module stage1_fullspec # overwrite module system: single import + as alias + qualified module name (lowered to plain symbols in the frontend)

import foo/baz as qux
import foo/bar as bar2
import foo/baz as qux2
import option
import result
import tables
import async_rt

trait Drawable:
    fn Draw(self: Self): int32

concept Addable:
    fn Add(self: Self, other: Self): Self

trait HasZero[T]:
    fn Zero(self: Self): T

fn Draw(self: int32): int32 =
    return self + 1

fn Add(self: int32, other: int32): int32 =
    return self + other

fn Zero(self: int32): int32 =
    return 0

fn Render(x: T): int32 =
    return Draw(x)

fn Sum(a: T, b: T): T =
    return Add(a, b)

fn UseZero(x: T): int32 =
    return Zero(x)

template Twice(x: int64): int64 =
    x + x

template Inc2(x: int64) =
    x = x + 1
    x = x + 1

macro TwiceM(x: int64): int64 =
    x + x

type
    Pair[A, B = int64] =
        first: A
        second: B

fn MakePair[A, B = int64](a: A, b: B): Pair[A, B] =
    return Pair[A, B](first: a, second: b)

type
    Duo[A, B = A] =
        left: A
        right: B

fn MakeDuo[A, B = A](x: A, y: B): Duo[A, B] =
    return Duo[A, B](left: x, right: y)

type
    OnlyInt32[T] where T is int32  =
        v: T

type
    Point =
        x: int32
        y: int32

    OpBox =
        v: int32

fn MakePoint(x: int32, y: int32): Point =
    return Point(x: x, y: y)

fn `+`(a: OpBox, b: OpBox): int32 =
    return a.v + b.v

fn `-`(a: OpBox, b: OpBox): int32 =
    return a.v - b.v

fn `*`(a: OpBox, b: OpBox): int32 =
    return a.v * b.v

fn `/`(a: OpBox, b: OpBox): int32 =
    return a.v / b.v

fn `==`(a: OpBox, b: OpBox): bool =
    return a.v == b.v

fn `<<`(a: OpBox, b: OpBox): int32 =
    return a.v + b.v * 100

fn `>>`(a: OpBox, b: OpBox): int32 =
    return a.v - b.v * 100

fn `%`(a: OpBox): int32 =
    return a.v + 7

fn `-`(a: OpBox): int32 =
    return 0 - a.v

fn add3(a: int64, b: int64 = 40, c: int64 = 2): int64(where) true =
    return a + b + c

fn WhereOk(x: T): int32(where) true && !false =
    x
    return 123

fn WhereIsInt32(x: T): int32(where) T is int32 =
    x
    return 7

fn ParsePos(x: int64): Result[int64] =
    if x >= 0:
        return Ok[int64](x)
    return Err[int64]("negative")

fn AddPos(a: int64, b: int64): Result[int64] =
    let x: int64 = ParsePos(a)?
    let y: int64 = ParsePos(b)?
    return Ok[int64](x + y)

var tupCalls: int64 = 0

fn MakeTup(): tuple[int64, int64] =
    tupCalls = tupCalls + 1
    let t: tuple[int64, int64] = (tupCalls, tupCalls)
    return t

var intCalls: int64 = 0

fn NextInt(): int64 =
    intCalls = intCalls + 1
    return intCalls

fn GetStr(): str =
    return "abcd"

fn MkVec(): int32[] =
    return [1, 2, 3]

fn MkSet(): set[int32] =
    return {1, 2, 3}

fn MkTbl(): Table[int64] =
    var t: Table[int64] = TableInit[int64](8)
    TablePut[int64](t, "foo", 100)
    TablePut[int64](t, "bar", 200)
    return t

async fn AsyncNoop(): int32 =
    return 7

fn testSeqAndString() =
    var ys: int32[] = [1, 2, 3]
    var sum: int64 = 0
    for v in ys:
        sum = sum + int64(v)
    assert(sum == 6, "for seq single pattern failed")

    var sum2: int64 = 0
    for i, v in ys:
        sum2 = sum2 + int64(v) + int64(i)
    assert(sum2 == 6 + 0 + 1 + 2, "for seq double pattern failed")

    var sumLit: int64 = 0
    for v in [1, 2, 3]:
        sumLit = sumLit + int64(v)
    assert(sumLit == 6, "for seq literal failed")

    assert(2 in ys, "in seq failed")
    assert(4 notin ys, "notin seq failed")
    assert(2 in (ys), "in seq (rhs) failed")
    assert(2 in MkVec(), "in seq call rhs failed")

    let s: str = "abcd"
    assert('b' in s, "in str(failed)")
    assert('x' notin s, "notin str(failed)")
    assert("bc" in s, "str(in) str(failed)")
    assert("zz" notin s, "str(notin) str(failed)")
    assert('b' in (s), "in str(rhs) failed")
    assert('b' in GetStr(), "in str(call) rhs failed")
    assert(2 in MkSet(), "set call rhs failed")

    var scnt: int64 = 0
    for ch in s:
        scnt = scnt + 1
    assert(scnt == 4, "for str(single) pattern failed")

    var scntLit: int64 = 0
    for ch in "abcd":
        scntLit = scntLit + 1
    assert(scntLit == 4, "for str(literal) failed")

    var scntSlice: int64 = 0
    for ch in s[1..< 3]:
        scntSlice = scntSlice + 1
    assert(scntSlice == 2, "for str(slice) failed")

    var isum: int64 = 0
    var firstOk: bool = false
    var lastOk: bool = false
    for i, ch in s:
        isum = isum + int64(i)
        if i == 0:
            firstOk = (ch == 'a')
        if i == 3:
            lastOk = (ch == 'd')
    assert(isum == 6, "for str(double) pattern idx sum failed")
    assert(firstOk && lastOk, "for str(double) pattern element failed")

    let sub1: str = s[1..< 3]
    assert(sub1 == "bc", "str(slice) ..< failed")
    let sub2: str = s[1..2]
    assert(sub2 == "bc", "str(slice) .. failed")

    let zs: int32[] = ys[1..< 3]
    assert(get[int32](zs, 0) == 2, "seq slicefirst element failed")
    assert(get[int32](zs, 1) == 3, "seq slicesecond element failed")

fn testSymbolOverload() =
    let a: OpBox = OpBox(v: 20)
    let b: OpBox = OpBox(v: 4)
    assert(a.v == 20, "symbol overload fixture a failed")
    assert(b.v == 4, "symbol overload fixture b failed")
    var condOk: bool = false
    if a.v != b.v:
        condOk = true
    assert(condOk, "symbol overload fixture cond failed")

fn testCasePatterns() =
    var hit: int32 = 0
    case (1, 2):
        of (1, 2):
            hit = 1
        of (1, _):
            hit = 2
        else:
            hit = 3
    assert(hit == 1, "case tuple pattern match failed")

    tupCalls = 0
    var hit2: int32 = 0
    case MakeTup():
        of (1, 1):
            hit2 = 1
        else:
            hit2 = 2
    assert(hit2 == 1, "case tuple pattern selector call match failed")
    assert(tupCalls == 1, "case tuple pattern selector call should not evaluate multiple times")

    var z: int64 = 10
    if z in 0..100:
        0

    case z:
        of 0 if true:
            0
        of 10:
            0
        else:
            0

    let w2: int64 = case z: of 0: 10 of _: 20
    assert(w2 == 20 || w2 == 10, "case wildcard result unexpected")

    var w3: int32 = 0
    case z:
        of _:
            w3 = 1
    assert(w3 == 1, "case wildcard statement branch failed")

    intCalls = 0
    var w4: int32 = 0
    case NextInt():
        of _:
            w4 = 1
    assert(w4 == 1, "case wildcard selector branch failed")
    assert(intCalls == 1, "case wildcard selector should evaluate once")

    var bindOut: int64 = 0
    case z:
        of v: int64:
            bindOut = v
    assert(bindOut == z, "case typed pattern binding failed")

    var bindGuard: int32 = 0
    case z:
        of v: int64 if v == 0:
            bindGuard = 1
        of v: int64:
            bindGuard = 2
    assert(bindGuard == 2, "case typed pattern + guard failed")

    let bindGuardExpr: int64 = case 11: of v: int64 if v == 11: 99 else: 0
    assert(bindGuardExpr == 99, "case expr typed pattern + guard failed")

    var mixHit0: int32 = 0
    case 0:
        of 0:
            mixHit0 = 1
        of 0, v: int64:
            mixHit0 = 2
    assert(mixHit0 == 1, "case mixed binding pattern: branch order wrong")

    var mixBind: int64 = 0
    case 1:
        of 0, v: int64:
            mixBind = v
        else:
            mixBind = 99
    assert(mixBind == 1, "case mixed binding pattern: binding unavailable or branch not hit")

    let mixExpr: int64 = case 1: of 0, v: int64: v + 10 else: 0
    assert(mixExpr == 11, "case expr mixed binding pattern failed")

    let mixGuardExpr: int64 = case 1: of 0, v: int64 if v == 2: 99 of v: int64: v else: 0
    assert(mixGuardExpr == 1, "case mixed binding pattern + guard failed")

fn testSeqPatterns() =
    let v: int32[] = [1, 2, 3]
    let [a, b, c] = v
    assert(a == 1 && b == 2 && c == 3, "seq pattern destructuring failed")

    var hit: int32 = 0
    case v:
        of [1, 2, 3]:
            hit = 1
        else:
            hit = 2
    assert(hit == 1, "case seq pattern match failed")

    var rangeHit: int32 = 0
    case 5:
        of 1..3:
            rangeHit = 1
        of 4..6:
            rangeHit = 2
        else:
            rangeHit = 3
    assert(rangeHit == 2, "case range pattern match failed")

    var setHit: int32 = 0
    case 2:
        of {1, 2, 3}:
            setHit = 1
        else:
            setHit = 2
    assert(setHit == 1, "case set pattern match failed")

fn testObjectPatterns() =
    let p: Point = Point(x: 3, y: 4)
    let Point(x: px, y: py) = p
    assert(px == 3 && py == 4, "object pattern destructuring failed")

    let Point(x: 3, y: py2) = p
    assert(py2 == 4, "object pattern literal failed")

    var hit: int32 = 0
    case p:
        of Point(x: 3, y: 4):
            hit = 1
        else:
            hit = 2
    assert(hit == 1, "case object pattern match failed")

fn testInLiteralContainers() =
    assert(2 in [1, 2, 3], "in seq literal failed")
    assert(4 notin [1, 2, 3], "notin seq literal failed")
    assert(2 in (1, 2, 3), "in tuple literal failed")
    assert(4 notin (1, 2, 3), "notin tuple literal failed")
    assert(2 in [1, 2, 3], "in bracket literal failed")
    assert(4 notin [1, 2, 3], "notin bracket literal failed")

fn testTables() =
    var tbl: Table[int64] = TableInit[int64](8)
    TablePut[int64](tbl, "foo", 100)
    TablePut[int64](tbl, "bar", 200)
    assert(TableHas[int64](tbl, "foo"), "TableHas failed")
    assert("foo" in tbl, "Table in failed")
    assert("missing" notin tbl, "Table notin failed")
    assert("foo" in (tbl), "Table in (rhs) failed")
    assert("missing" notin (tbl), "Table notin (rhs) failed")
    assert("foo" in MkTbl(), "Table in call rhs failed")
    assert("missing" notin MkTbl(), "Table notin call rhs failed")
    assert(TableGet[int64](tbl, "foo") == 100, "TableGet failed")
    assert(TableLen[int64](tbl) == 2, "TableLen failed")
    TablePut[int64](tbl, "foo", 101)
    assert(TableGet[int64](tbl, "foo") == 101, "TablePut overwrite failed")
    assert(TableLen[int64](tbl) == 2, "TablePut overwrite should not increase length")
    assert(TableGet[int64](tbl, "missing") == 0, "TableGet default value failed")
    TablePut[int64](tbl, "k1", 1)
    TablePut[int64](tbl, "k2", 2)
    TablePut[int64](tbl, "k3", 3)
    TablePut[int64](tbl, "k4", 4)
    TablePut[int64](tbl, "k5", 5)
    TablePut[int64](tbl, "k6", 6)
    assert(TableGet[int64](tbl, "k6") == 6, "Table resize failed")

    var cntKeys: int32 = 0
    var foundFoo: bool = false
    for k in tbl:
        cntKeys = cntKeys + 1
        if k == "foo":
            foundFoo = true
    assert(cntKeys == TableLen[int64](tbl), "for Table single pattern failed")
    assert(foundFoo, "for Table single pattern key failed")

    var sumVals2: int64 = 0
    var foundBar: bool = false
    for k, v in tbl:
        sumVals2 = sumVals2 + v
        if k == "bar":
            foundBar = true
    assert(foundBar, "for Table double pattern key failed")
    assert(sumVals2 == 322, "for Table double pattern value sum failed")

fn testImplicitDefaultInit() =
    let i: int32
    let b: bool
    let f: float64
    let s: str
    let p: Point
    assert(i == 0, "implicit default init int(failed)")
    assert(!b, "implicit default init bool(failed)")
    assert(f == 0.0, "implicit default init float failed")
    assert(s == "", "implicit default init str(failed)")
    assert(p.x == 0 && p.y == 0, "implicit default init object failed")

fn testSeqDefaultInit() =
    var lines: str[]
    assert(lines.len == 0, "implicit default init seq failed")
    lines.add "x"
    lines.reset
    assert(lines.len == 0, "seq reset failed")
    var pending: int32[]
    pending = [1, 2]
    assert(pending.len == 2, "seq assign literal failed")
    pending = []
    assert(pending.len == 0, "seq assign empty literal failed")

fn main(): int32 =
    # trait/concept constraints: minimal structural check on generic instantiation (Self -> concrete type)
    assert(Render[int32](41) == 42, "trait constraint check failed: Draw(self: Self) no implementation found")
    assert(Sum[int32](40, 2) == 42, "concept constraint check failed: Add(self: Self, other: Self) no implementation found")
    assert(UseZero[int32](5) == 0, "generic trait constraint check failed: HasZero[int32] Zero(self: Self): T no implementation found")

    let imported: int64 = bar2.BarValue() + qux.BazValue()
    let imported2: int64 = qux2.BazValue()
    assert(imported == 42, "import/from import/export/qualified-name lowering failed")
    assert(imported2 == 1, "from import syntax sugar failed")

    assert(await AsyncNoop() == 7, "async parse failed")
    testImplicitDefaultInit()
    testSeqDefaultInit()
    testSymbolOverload()

    var x: int64 = add3(c = 5, a = 1)
    assert(x == 46, "named argument reordering + default argument filling failed")

    assert(WhereOk[int32](0) == 123, "where constantevaluation failed")
    assert(WhereIsInt32[int32](0) == 7, "where type equalityevaluation failed")

    let oi: OnlyInt32[int32] = OnlyInt32[int32](v: 1)
    assert(oi.v == 1, "type where type equalityevaluation failed")

    # numeric literal: 0x/0b/0o and '_' separator (align with formal spec lexing)
    let nHex: int64 = 0x10
    let nBin: int64 = 0b1010
    let nOct: int64 = 0o10
    let nSep: int64 = 1_000_000
    assert(nHex == 16, "0x literal parse failed")
    assert(nBin == 10, "0b literal parse failed")
    assert(nOct == 8, "0o literal parse failed")
    assert(nSep == 1000000, "numeric '_' separatorparse failed")

    let f0: float64 = 1.25
    assert(f0 == 1.25, "float literal parse failed")
    let f1: float64 = f0 + 1.0
    assert(f1 == 2.25, "float addition failed")
    let f2: float64 = -f0
    assert(f2 == -1.25, "float negation failed")
    var fx: float64 = 1.0
    var fy: float64 = 2.0
    let f3: float64 = fx + fy
    assert(f3 == 3.0, "float variable addition failed")
    let f4: float64 = 1 + 2.0
    assert(f4 == 3.0, "int+float operation failed")
    let f5: float64 = (f0 * 2.0) / 5.0
    assert(f5 == 0.5, "float mul/div failed")

    # `+`: str(concat) (select by type)
    let s1: str = intToStr(int32(42))
    assert(s1 == "42", "system import strings failed")
    let s2: str = "ab" + "cd"
    assert(s2 == "abcd", "str(+ concat) failed")
    # string literal: escapes and r/f prefix (align with formal spec lexing/semantics)
    let sEsc1: str = "a\nb"
    assert(c_strlen(sEsc1) == int32(3), "str(\\n) escape decode failed (length should be 3)")
    let sRaw1: str = r"a\nb"
    assert(c_strlen(sRaw1) == int32(4), "raw str(should) preserve backslash(length should be 4)")
    assert(sRaw1 == "a\\nb", "raw str(r)\"\" semantic failed")
    assert(!(sEsc1 == sRaw1), "raw str(should) not parse escapes")
    assert(r"ab" == "ab", "raw prefix should not reach runtime string")
    assert(f"ab" == "ab", "f prefix should not reach runtime string")
    assert(c_strlen("\\") == int32(1), "backslash self-escape failed")
    assert("\x41" == "A", "str(\\xHH) escape failed")
    assert("\x22" == "\"", "str(\\x22) and \\\" mismatch")

    # tuple destructuring
    let (a, b) = (1, 2)
    assert(a + b == 3, "tuple destructuring failed: (a,b) != (1,2)")
    let (_, c) = (3, 4)
    assert(c == 4, "tuple destructuring failed: (_,c) != (3,4)")
    let ((p, q), r) = ((10, 20), 30)
    assert(p + q + r == 60, "tuple destructuring failed: nested destructuring incorrect")

    # named tuple element: syntax allowed, current impl ignores element names (fields by position)
    let (only) = (a: 1)
    assert(only == 1, "named single element tuple parse failed")
    let namedTv: tuple[a: int64, b: int64] = (a: 1, b: 2)
    let (na0, nb0): tuple[a: int64, b: int64] = namedTv
    assert(na0 + nb0 == 3, "named tuple literal/type failed")
    let (na, nb) = namedTv
    assert(na + nb == 3, "tuple destructuring RHS simple ref inference failed")

    let tv: tuple[int64, int64] = (1, 2)
    let (ta, tb): tuple[int64, int64] = tv
    assert(ta + tb == 3, "tuple value/type failed")

    tupCalls = 0
    let (tc, td) = MakeTup()
    assert(tc == 1 && td == 1, "tuple destructuring RHS call failed")
    assert(tupCalls == 1, "tuple destructuring RHS call should not evaluate multiple times")

    # routine literal (fn/iterator): hoist to module top-level and return function pointer
    let inc = fn (x: int64): int64 = x + 1
    assert(inc(41) == 42, "fn literal call failed")
    let inc2: fn (x: int64): int64 = fn (x: int64): int64 = x + 1
    assert(inc2(41) == 42, "fn type + fn literal failed")
    let fact = fn Fact(n: int64): int64 =
        if n <= 1:
            return 1
        return n * Fact(n - 1)
    assert(fact(5) == 120, "fn literal named recursion failed")
    let idIt = iterator (x: int64): int64 = x
    assert(idIt(7) == 7, "iterator literal failed")

    # generic routine literal: explicit instantiation / expected fn type instantiation
    let gid1: fn (x: int64): int64 = (fn [T](x: T): T = x)[int64]
    assert(gid1(7) == 7, "generic fn literal explicit instantiation failed")
    let gid2: fn (x: int64): int64 = fn [T](x: T): T = x
    assert(gid2(8) == 8, "generic fn literal expected-type instantiation failed")

    # set[T] + `{...}` (minimal impl: uint64(bitset))
    let ss: set[int32] = {1, 2, 3, 5}
    assert(2 in ss, "set in failed")
    assert(4 notin ss, "set notin failed")
    let ss2: set[int32] = {1..3}
    assert(1 in ss2 && 2 in ss2 && 3 in ss2, "set range `..` failed")
    let ss3: set[int32] = {1..< 4}
    assert(3 in ss3 && 4 notin ss3, "set range `..<` failed")
    assert(2 in {1, 2, 3}, "set literal in failed")

    testCasePatterns()

    testSeqPatterns()
    testObjectPatterns()
    testInLiteralContainers()

    testSeqAndString()

    # bit ops and shifts
    var bx: int32 = 7
    var by: int32 = (bx << 1) >> 1
    var bz: int32 = ((by + 3) | 8) ^ 1
    let bn: int32 = ~bz
    assert(bz == 11, "bit ops failed")
    assert(bn == -12, "bitnot failed")

    # literal pattern: allow match assertions in let/var/const bindings
    let 1 = 1
    let true = true
    let (1, lp): tuple[int32, int32] = (1, 2)
    assert(lp == 2, "literal tuple pattern binding failed")

    # default type parameters
    let p1: Pair[str] = Pair[str](first: "a", second: 7)
    assert(p1.second == 7, "default type parameter failed: Pair[str] not filled B=int64")
    let p2: Pair[str, int64] = Pair[str, int64](first: "b", second: 8)
    let p3: Pair[str] = p2
    assert(p3.second == 8, "default type parameter failed: Pair[str] and Pair[str,int64] incompatible")
    let p4: Pair[str] = MakePair[str]("c", 9)
    assert(c_strcmp(p4.first, "c") == 0 && p4.second == 9, "default type parameter failed: MakePair[str] not filled B=int64")
    let d1: Duo[int64] = Duo[int64](left: 1, right: 2)
    assert(d1.left + d1.right == 3, "default type parameter failed: Duo[int64] not filled B=A")
    let d2: Duo[int64, int64] = MakeDuo[int64](3, 4)
    let d3: Duo[int64] = d2
    assert(d3.left + d3.right == 7, "default type parameter failed: MakeDuo[int64] not filled B=A")

    # generic + object construction + template/macro expansion
    let tTwice: int64 = Twice(21)
    assert(tTwice == 42, "template expansion failed")
    let mTwice: int64 = TwiceM(21)
    assert(mTwice == 42, "macro expansion failed")
    var ti: int64 = 0
    Inc2(ti)
    assert(ti == 2, "template multi-statement body expansion failed")

    testTables()

    let o: Option[int64] = Some[int64](123)
    assert(IsSome[int64](o), "Option Some/IsSome failed")
    assert(Get[int64](o) == 123, "Option Get failed")
    let n: Option[int64] = None[int64]()
    assert(!IsSome[int64](n), "Option None/IsSome failed")

    # Result[T] + `?`: early-return error propagation in same-type return functions
    let okR: Result[int64] = AddPos(1, 2)
    assert(IsOk[int64](okR), "Result Ok failed")
    assert(Value[int64](okR) == 3, "Result Value failed")
    let badR: Result[int64] = AddPos(1, -1)
    assert(!IsOk[int64](badR), "Result `?` propagation failed")
    assert(Error[int64](badR) == "negative", "Result Error failed")

    echo "fullspec ok"
    return 0
