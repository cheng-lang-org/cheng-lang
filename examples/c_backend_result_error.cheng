import result

fn makeOk(value: int32): result.Result[int32] =
    var out: result.Result[int32]
    out.ok = true
    out.value = value
    out.err = result.ErrorOk()
    return out

fn makeErr(code: int32, msg: str): result.Result[int32] =
    var out: result.Result[int32]
    out.ok = false
    out.err = result.ErrorCode(code, msg)
    return out

fn parseNum(x: int32): result.Result[int32] =
    if x >= 0:
        return makeOk(x)
    return makeErr(42, "bad")

fn parsePlusOne(x: int32): result.Result[int32] =
    let n: int32 = parseNum(x)?
    return makeOk(n + 1)

fn main(): int32 =
    let ok: result.Result[int32] = parsePlusOne(1)
    if !ok.ok:
        panic(ok.err)
    let bad: result.Result[int32] = parsePlusOne(-1)
    if bad.ok:
        return 2
    let info: result.ErrorInfo = bad.err
    let code: int32 = result.ErrorCodeOf(info)
    let msg: str = result.ErrorMessage(info)
    let formatted: str = result.ErrorFormat(info)
    if void*(msg) == nil || void*(formatted) == nil:
        return 3
    if code == 42:
        return 0
    return 1
