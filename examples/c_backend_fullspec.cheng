type Kind = enum
    kA
    kB

type Payload =
    case kind: Kind
        of kA:
            a: int32
        of kB:
            b: int32

type Point =
    x: int32
    y: int32

type slice_int =
    ptr: void*
    len: int32

@importc("cheng_bounds_check")
fn boundsCheck(len: int32, idx: int32)
@importc("ptr_add")
fn ptrAdd(p: void*, offset: int32): void*
@importc("load_int32")
fn loadInt32(p: void*): int32

fn makePoint(x: int32, y: int32): Point =
    var p: Point
    p.x = x
    p.y = y
    return p

fn sumSlice(s: slice_int): int32 =
    var total: int32 = 0
    for i in 0..<s.len:
        boundsCheck(s.len, i)
        let offset: int32 = i * 4
        let p: void* = ptrAdd(s.ptr, offset)
        let v: int32 = loadInt32(p)
        total = total + v
    return total

fn main(): int32 =
    var payload: Payload
    payload.kind = kA
    payload.a = 4
    let point: Point = makePoint(2, 3)
    let xs: slice_int = [1, 2, 3]
    let total: int32 = sumSlice xs

    var acc: int32 = 0
    for i in 0..<4:
        acc = acc + i

    if total == 6 && payload.a == 4 && point.x + point.y == 5 && acc == 6:
        system.echo "fullspec ok"
        return 0
    return 1
