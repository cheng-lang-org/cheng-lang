import std/strutils

type
    JsonNodeKind = enum
        JNull
        JBool
        JInt
        JFloat
        JString
        JArray
        JObject

type
    JsonNode = ref
        kind: JsonNodeKind
        b: bool
        i: int64
        f: float64
        s: str
        a: JsonNode[]
        okeys: str[]
        ovalues: JsonNode[]
    JsonPair =
        key: str
        value: JsonNode

type
    JsonValue = JsonNode

const
    jkNull: JsonNodeKind = JNull
    jkBool: JsonNodeKind = JBool
    jkInt: JsonNodeKind = JInt
    jkFloat: JsonNodeKind = JFloat
    jkString: JsonNodeKind = JString
    jkArray: JsonNodeKind = JArray
    jkObject: JsonNodeKind = JObject

fn newJsonNode(kind: JsonNodeKind): JsonNode =
    var node: JsonNode
    new(node)
    node.kind = kind
    return node

fn newJNull(): JsonNode =
    newJsonNode(JNull)

fn newJBool(value: bool): JsonNode =
    var node = newJsonNode(JBool)
    node.b = value
    return node

fn newJInt(value: int64): JsonNode =
    var node = newJsonNode(JInt)
    node.i = value
    return node

fn newJFloat(value: float64): JsonNode =
    var node = newJsonNode(JFloat)
    node.f = value
    return node

fn newJString(value: str): JsonNode =
    var node = newJsonNode(JString)
    node.s = value
    return node

fn newJArray(): JsonNode =
    var node = newJsonNode(JArray)
    node.a = []
    return node

fn newJObject(): JsonNode =
    var node = newJsonNode(JObject)
    node.okeys = []
    node.ovalues = []
    return node

fn jsonNil(): JsonNode =
    newJNull()

fn jsonBool(value: bool): JsonNode =
    newJBool(value)

fn jsonNumber(value: float64): JsonNode =
    newJFloat(value)

fn jsonString(value: str): JsonNode =
    newJString(value)

fn jsonArray(items: JsonNode[]): JsonNode =
    let node = newJArray()
    for i in 0..<len(items):
        node.add(items[i])
    return node

fn jsonObject(pairs: JsonPair[]): JsonNode =
    let node = newJObject()
    for i in 0..<pairs.len:
        let pair = pairs[i]
        jsonSetField(node, pair.key, pair.value)
    return node

fn add(node: JsonNode, item: JsonNode) =
    if node == nil || node.kind != JArray:
        return
    node.a.add(item)

fn len(node: JsonNode): int =
    if node == nil:
        return 0
    case node.kind
    of JArray:
        return int(node.a.len)
    of JObject:
        return int(node.okeys.len)
    else:
        return 0

fn hasKey(node: JsonNode, key: str): bool =
    if node == nil || node.kind != JObject:
        return false
    for i in 0..<node.okeys.len:
        if (&node.okeys)[i] == key:
            return true
    return false

fn jsonGetField(node: JsonNode, key: str): JsonNode =
    if node == nil || node.kind != JObject:
        return jsonNil()
    for i in 0..<node.okeys.len:
        if (&node.okeys)[i] == key:
            return node.ovalues[i]
    return jsonNil()

fn jsonSetField(node: JsonNode, key: str, value: JsonNode) =
    if node == nil || node.kind != JObject:
        return
    for i in 0..<len(node.okeys):
        if (&node.okeys)[i] == key:
            (&node.ovalues)[i] = value
            return
    node.okeys.add(key)
    node.ovalues.add(value)

fn `[]`(node: JsonNode, key: str): JsonNode =
    return jsonGetField(node, key)

fn `[]=`(node: JsonNode, key: str, value: JsonNode) =
    jsonSetField(node, key, value)

fn getInt(node: JsonNode): int64 =
    if node == nil:
        return 0
    if node.kind == JInt:
        return node.i
    else:
        return 0

fn getBool(node: JsonNode): bool =
    if node == nil:
        return false
    if node.kind == JBool:
        return node.b
    else:
        return false

fn getFloat(node: JsonNode): float64 =
    if node == nil:
        return 0.0
    if node.kind == JFloat:
        return node.f
    elif node.kind == JInt:
        return float64(node.i)
    else:
        return 0.0

fn getStr(node: JsonNode): str =
    if node == nil:
        return ""
    if node.kind == JString:
        return node.s
    else:
        return ""

fn `%`(node: JsonNode): JsonNode =
    return node

fn `%`(value: str): JsonNode =
    newJString(value)

fn `%`(value: bool): JsonNode =
    newJBool(value)

fn `%`(value: int): JsonNode =
    newJInt(int64(value))

fn `%`(value: int32): JsonNode =
    newJInt(int64(value))

fn `%`(value: int64): JsonNode =
    newJInt(value)

fn `%`(value: float64): JsonNode =
    newJFloat(value)

fn toJsonNode(node: JsonNode): JsonNode =
    return node

fn toJsonValue(node: JsonNode): JsonNode =
    return node

fn toJsonValue(value: str): JsonNode =
    return `%` value

fn toJsonValue(value: bool): JsonNode =
    return `%` value

fn toJsonValue(value: int): JsonNode =
    return `%` value

fn toJsonValue(value: int32): JsonNode =
    return `%` value

fn toJsonValue(value: int64): JsonNode =
    return `%` value

fn toJsonValue(value: float64): JsonNode =
    return `%` value

fn toJsonValue(value: T[]): JsonNode =
    let node = newJArray()
    for item in value:
        node.add(toJsonValue(item))
    return node

fn escapeJsonString(value: str): str =
    var out = ""
    for i in 0..<len(value):
        let ch = value[i]
        if ch == '\\':
            out = out + "\\\\"
        elif ch == '"':
            out = out + "\\\""
        elif ch == '\n':
            out = out + "\\n"
        elif ch == '\r':
            out = out + "\\r"
        elif ch == '\t':
            out = out + "\\t"
        else:
            out = out + $ ch
    return out

fn pretty(node: JsonNode, indent: int): str =
    indent
    if node == nil:
        return "null"
    case node.kind
    of JNull:
        return "null"
    of JBool:
        return if node.b: "true" else: "false"
    of JInt:
        return $ node.i
    of JFloat:
        return $ node.f
    of JString:
        let escaped = escapeJsonString node.s
        var out = "\""
        out = out + escaped
        out = out + "\""
        return out
    of JArray:
        var out = "["
        for i in 0..<len(node.a):
            if i > 0:
                out = out + ","
            out = out + pretty(node.a[i], indent)
        out = out + "]"
        return out
    of JObject:
        var out = "{"
        for i in 0..<len(node.okeys):
            if i > 0:
                out = out + ","
            let keyText = escapeJsonString(node.okeys[i])
            let valueText = pretty(node.ovalues[i], indent)
            out = out + "\""
            out = out + keyText
            out = out + "\":"
            out = out + valueText
        out = out + "}"
        return out
    else:
        return "null"

fn pretty(node: JsonNode): str =
    pretty(node, 2)

fn toPretty(node: JsonNode, indent: int): str =
    pretty(node, indent)

fn toPretty(node: JsonNode): str =
    pretty(node, 2)
