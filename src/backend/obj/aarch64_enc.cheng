# Shared AArch64 instruction encoders used by object writers.
import std/result
import backend/machine/machine_types

fn a64RegNum(reg: MachineReg): int32 =
    let rv: int32 = int32(reg)
    case rv
    of 0, 9: return 0
    of 1, 10: return 1
    of 2, 11: return 2
    of 3, 12: return 3
    of 4, 13: return 4
    of 5, 14: return 5
    of 6, 15: return 6
    of 7, 16: return 7
    of 8, 17: return 8
    of 18: return 16
    of 19: return 17
    of 20: return 19
    of 21: return 29
    of 22: return 30
    of 23: return 31
    of 24: return 0
    of 25: return 1
    return 0

fn a64Is64(reg: MachineReg): bool =
    let rv: int32 = int32(reg)
    case rv
    of 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23:
        return true
    else:
        return false

fn a64EncAddImm(is64: bool, rd: int32, rn: int32, imm12: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x91000000) : uint32(0x11000000)
    return base | (uint32(imm12 & 0xFFF) << 10) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncSubImm(is64: bool, rd: int32, rn: int32, imm12: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xD1000000) : uint32(0x51000000)
    return base | (uint32(imm12 & 0xFFF) << 10) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncMovz(is64: bool, rd: int32, imm16: int32, hw: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xD2800000) : uint32(0x52800000)
    return base | (uint32(hw & 3) << 21) | (uint32(imm16 & 0xFFFF) << 5) | uint32(rd & 31)

fn a64EncMovk(is64: bool, rd: int32, imm16: int32, hw: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xF2800000) : uint32(0x72800000)
    return base | (uint32(hw & 3) << 21) | (uint32(imm16 & 0xFFFF) << 5) | uint32(rd & 31)

fn a64EncAdrp(rd: int32): uint32 =
    return uint32(0x90000000) | uint32(rd & 31)

fn a64EncAddReg(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x8B000000) : uint32(0x0B000000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncSubReg(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xCB000000) : uint32(0x4B000000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncAndReg(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x8A000000) : uint32(0x0A000000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncOrrReg(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xAA000000) : uint32(0x2A000000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncEorReg(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0xCA000000) : uint32(0x4A000000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncMul(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    # MUL is an alias of MADD with Ra = ZR.
    let base: uint32 = is64 ? uint32(0x9B007C00) : uint32(0x1B007C00)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncSdiv(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9AC00C00) : uint32(0x1AC00C00)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncUdiv(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9AC00800) : uint32(0x1AC00800)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncMsub(is64: bool, rd: int32, rn: int32, rm: int32, ra: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9B008000) : uint32(0x1B008000)
    return base | (uint32(rm & 31) << 16) | (uint32(ra & 31) << 10) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncSxtw(rd: int32, rn: int32): uint32 =
    # SXTW is an alias of SBFM Xd, Xn, #0, #31.
    return uint32(0x93407C00) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncLslv(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9AC02000) : uint32(0x1AC02000)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncLsrv(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9AC02400) : uint32(0x1AC02400)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncAsrv(is64: bool, rd: int32, rn: int32, rm: int32): uint32 =
    let base: uint32 = is64 ? uint32(0x9AC02800) : uint32(0x1AC02800)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncCmpReg(is64: bool, rn: int32, rm: int32): uint32 =
    # CMP is an alias of SUBS ZR, Rn, Rm.
    let base: uint32 = is64 ? uint32(0xEB00001F) : uint32(0x6B00001F)
    return base | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5)

fn a64CondCode(cond: MachineCond): uint32 =
    # See AArch64 condition codes: EQ=0, NE=1, HS=2, LO=3, MI=4, HI=8, LS=9, GE=10, LT=11, GT=12, LE=13.
    let cv: int32 = int32(cond)
    case cv
    of 0: return uint32(0)
    of 1: return uint32(1)
    of 10: return uint32(2)
    of 7: return uint32(3)
    of 2: return uint32(4)
    of 9: return uint32(8)
    of 8: return uint32(9)
    of 6: return uint32(10)
    of 3: return uint32(11)
    of 5: return uint32(12)
    of 4: return uint32(13)
    return uint32(0)

fn a64EncBImm(deltaWords: int64): Result[uint32] =
    # Unconditional branch immediate: 26-bit signed word offset.
    if deltaWords < -33554432 || deltaWords > 33554431:
        return Err[uint32]("aarch64_enc: b offset out of range")
    let imm26: uint32 = uint32(uint64(deltaWords) & uint64(0x03FFFFFF))
    return Ok[uint32](uint32(0x14000000) | imm26)

fn a64EncBCond(deltaWords: int64, cond: MachineCond): Result[uint32] =
    # Conditional branch immediate: 19-bit signed word offset.
    if deltaWords < -262144 || deltaWords > 262143:
        return Err[uint32]("aarch64_enc: b.cond offset out of range")
    let imm19: uint32 = uint32(uint64(deltaWords) & uint64(0x7FFFF))
    return Ok[uint32](uint32(0x54000000) | (imm19 << 5) | a64CondCode(cond))

fn a64EncBl(): uint32 =
    return uint32(0x94000000)

fn a64EncBlr(rn: int32): uint32 =
    return uint32(0xD63F0000) | (uint32(rn & 31) << 5)

fn a64EncRet(): uint32 =
    return uint32(0xD65F03C0)

fn a64EncFmovDx(rd: int32, rn: int32): uint32 =
    return uint32(0x9E670000) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFmovXd(rd: int32, rn: int32): uint32 =
    return uint32(0x9E660000) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFcmpD(rn: int32, rm: int32): uint32 =
    return uint32(0x1E602000) | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5)

fn a64EncFaddD(rd: int32, rn: int32, rm: int32): uint32 =
    return uint32(0x1E602800) | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFsubD(rd: int32, rn: int32, rm: int32): uint32 =
    return uint32(0x1E603800) | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFmulD(rd: int32, rn: int32, rm: int32): uint32 =
    return uint32(0x1E600800) | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFdivD(rd: int32, rn: int32, rm: int32): uint32 =
    return uint32(0x1E601800) | (uint32(rm & 31) << 16) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncFnegD(rd: int32, rn: int32): uint32 =
    return uint32(0x1E614000) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncScvtfDx(rd: int32, rn: int32): uint32 =
    return uint32(0x9E620000) | (uint32(rn & 31) << 5) | uint32(rd & 31)

fn a64EncSvc(imm16: int32): uint32 =
    return uint32(0xD4000001) | ((uint32(imm16) & uint32(0xFFFF)) << 5)

fn a64MovImmWordCount(is64: bool, imm: int64): int32 =
    var count: int32 = 1
    let v: uint64 = uint64(imm)
    for hw in 1..<(is64 ? 4 : 2):
        let part: uint64 = (v >> uint64(hw * 16)) & uint64(0xFFFF)
        if part != 0:
            count = count + 1
    return count

fn a64EncStrImm(is64: bool, rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    let scale: int64 = is64 ? int64(8) : int64(4)
    if offsetBytes < 0 || offsetBytes % scale != 0:
        return Err[uint32]("aarch64_enc: str offset not aligned")
    let imm12: int64 = offsetBytes / scale
    if imm12 < 0 || imm12 > 4095:
        return Err[uint32]("aarch64_enc: str offset out of range")
    let base: uint32 = is64 ? uint32(0xF9000000) : uint32(0xB9000000)
    return Ok[uint32](base | (uint32(imm12) << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncLdrImm(is64: bool, rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    let scale: int64 = is64 ? int64(8) : int64(4)
    if offsetBytes < 0 || offsetBytes % scale != 0:
        return Err[uint32]("aarch64_enc: ldr offset not aligned")
    let imm12: int64 = offsetBytes / scale
    if imm12 < 0 || imm12 > 4095:
        return Err[uint32]("aarch64_enc: ldr offset out of range")
    let base: uint32 = is64 ? uint32(0xF9400000) : uint32(0xB9400000)
    return Ok[uint32](base | (uint32(imm12) << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))


fn a64EncStrbImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0:
        return Err[uint32]("aarch64_enc: strb offset out of range")
    if offsetBytes > 4095:
        return Err[uint32]("aarch64_enc: strb offset out of range")
    let imm12: uint32 = uint32(offsetBytes)
    let base: uint32 = uint32(0x39000000)
    return Ok[uint32](base | (imm12 << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncLdrbImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0:
        return Err[uint32]("aarch64_enc: ldrb offset out of range")
    if offsetBytes > 4095:
        return Err[uint32]("aarch64_enc: ldrb offset out of range")
    let imm12: uint32 = uint32(offsetBytes)
    let base: uint32 = uint32(0x39400000)
    return Ok[uint32](base | (imm12 << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncLdrsbImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0:
        return Err[uint32]("aarch64_enc: ldrsb offset out of range")
    if offsetBytes > 4095:
        return Err[uint32]("aarch64_enc: ldrsb offset out of range")
    let imm12: uint32 = uint32(offsetBytes)
    let base: uint32 = uint32(0x39C00000)
    return Ok[uint32](base | (imm12 << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncStrhImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0 || offsetBytes % 2 != 0:
        return Err[uint32]("aarch64_enc: strh offset not aligned")
    let imm12: int64 = offsetBytes / 2
    if imm12 < 0 || imm12 > 4095:
        return Err[uint32]("aarch64_enc: strh offset out of range")
    let base: uint32 = uint32(0x79000000)
    return Ok[uint32](base | (uint32(imm12) << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncLdrhImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0 || offsetBytes % 2 != 0:
        return Err[uint32]("aarch64_enc: ldrh offset not aligned")
    let imm12: int64 = offsetBytes / 2
    if imm12 < 0 || imm12 > 4095:
        return Err[uint32]("aarch64_enc: ldrh offset out of range")
    let base: uint32 = uint32(0x79400000)
    return Ok[uint32](base | (uint32(imm12) << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))

fn a64EncLdrshImm(rt: int32, rn: int32, offsetBytes: int64): Result[uint32] =
    if offsetBytes < 0 || offsetBytes % 2 != 0:
        return Err[uint32]("aarch64_enc: ldrsh offset not aligned")
    let imm12: int64 = offsetBytes / 2
    if imm12 < 0 || imm12 > 4095:
        return Err[uint32]("aarch64_enc: ldrsh offset out of range")
    let base: uint32 = uint32(0x79C00000)
    return Ok[uint32](base | (uint32(imm12) << 10) | (uint32(rn & 31) << 5) | uint32(rt & 31))
