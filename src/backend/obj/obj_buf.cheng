# Shared byte-buffer helpers for object writers (ELF/Mach-O/COFF).
import std/seqs

fn bufAddU8(buf: var uint8[], v: uint8) =
    if buf == nil:
        return
    add(buf, v)

fn bufAlign(buf: var uint8[], align: uint64) =
    if buf == nil || align <= 1:
        return
    while uint64(buf.len) % align != 0:
        bufAddU8(buf, uint8(0))

fn bufU8(buf: var uint8[], v: uint8) =
    bufAddU8(buf, v)

fn bufU16(buf: var uint8[], v: uint16) =
    bufAddU8(buf, uint8(v & uint16(0xFF)))
    bufAddU8(buf, uint8((v >> 8) & uint16(0xFF)))

fn bufU32(buf: var uint8[], v: uint32) =
    bufU16(buf, uint16(v & uint32(0xFFFF)))
    bufU16(buf, uint16((v >> 16) & uint32(0xFFFF)))

fn bufU64(buf: var uint8[], v: uint64) =
    bufU32(buf, uint32(v & uint64(0xFFFFFFFF)))
    bufU32(buf, uint32((v >> 32) & uint64(0xFFFFFFFF)))

fn bufI64(buf: var uint8[], v: int64) =
    bufU64(buf, uint64(v))

fn bufU32At(buf: var uint8[], offset: int32, v: uint32) =
    if buf == nil:
        return
    if offset < 0 || offset + 4 > buf.len:
        return
    buf[offset + 0] = uint8(v & uint32(0xFF))
    buf[offset + 1] = uint8((v >> 8) & uint32(0xFF))
    buf[offset + 2] = uint8((v >> 16) & uint32(0xFF))
    buf[offset + 3] = uint8((v >> 24) & uint32(0xFF))

fn bufBytes(buf: var uint8[], data: uint8[]) =
    if buf == nil:
        return
    for i in 0..<data.len:
        bufAddU8(buf, data[i])

fn bufFixedStr(buf: var uint8[], s: str, size: int32) =
    if buf == nil:
        return
    var i: int32 = 0
    if s != nil:
        for __for_guard_i in 0..<size:
            if !(i < len(s) && i < size):
                break
            bufAddU8(buf, uint8(int32(int64(s[i]) & int64(0xFF))))
            i = i + 1
    for __for_guard_i in 0..<size:
        if !(i < size):
            break
        bufAddU8(buf, uint8(0))
        i = i + 1

fn bufFixedStr8(buf: var uint8[], s: str) =
    bufFixedStr(buf, s, 8)

fn bufStr0(buf: var uint8[], s: str) =
    if buf == nil:
        return
    if s != nil:
        for i in 0..<len(s):
            bufAddU8(buf, uint8(int32(int64(s[i]) & int64(0xFF))))
    bufAddU8(buf, uint8(0))

fn emitU32LE(buf: var uint8[], v: uint32) =
    bufU32(buf, v)
