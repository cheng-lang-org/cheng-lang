# ELF64 relocatable (.o) writer for AArch64 (MVP subset).
import std/seqs
import std/strings
import std/result
import backend/machine/machine_types
import backend/obj/obj_buf
import backend/obj/aarch64_enc

type
    ElfReloc = ref
        off: uint64
        sym: str
        rtype: uint32
        addend: int64

    ElfSym = ref
        name: str
        bind: uint8
        stType: uint8
        shndx: uint16
        value: uint64
        size: uint64
        nameOff: uint32

const
    ELFCLASS64: uint8 = 2
    ELFDATA2LSB: uint8 = 1
    EV_CURRENT: uint32 = 1
    ET_REL: uint16 = 1
    EM_AARCH64: uint16 = 183

    SHT_NULL: uint32 = 0
    SHT_PROGBITS: uint32 = 1
    SHT_SYMTAB: uint32 = 2
    SHT_STRTAB: uint32 = 3
    SHT_RELA: uint32 = 4
    SHT_NOBITS: uint32 = 8

    SHF_WRITE: uint64 = 0x1
    SHF_ALLOC: uint64 = 0x2
    SHF_EXECINSTR: uint64 = 0x4
    STB_LOCAL: uint8 = 0
    STB_GLOBAL: uint8 = 1

    STT_NOTYPE: uint8 = 0
    STT_OBJECT: uint8 = 1
    STT_FUNC: uint8 = 2
    STT_SECTION: uint8 = 3

    R_AARCH64_ADR_PREL_PG_HI21: uint32 = 275 # 0x113
    R_AARCH64_ADD_ABS_LO12_NC: uint32 = 277 # 0x115
    R_AARCH64_CALL26: uint32 = 283 # 0x11b

fn elf_findLabelOff(labels: str[], offs: int32[], label: str): Result[int32] =
    for i in 0..<labels.len:
        if ! (i < offs.len):
            break
        if (labels[i] == label):
            return Ok[int32](offs[i])
    return Err[int32]("elf_writer: missing label: " + label)

fn elf_strContains(hay: str, needle: str): bool =
    if hay == nil || needle == nil:
        return false
    let n: int32 = len(hay)
    let m: int32 = len(needle)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..n - m:
        for j in 0..<m:
            if !(hay[i + j] == needle[j]):
                break
        if j == m:
            return true
    return false

fn elf_targetIsDarwin(target: str): bool =
    if target == nil || len(target) == 0:
        return true
    return elf_strContains(target, "apple") || elf_strContains(target, "darwin") || elf_strContains(target, "ios")

fn elf_strCmp(a: str, b: str): int32 =
    if a == nil && b == nil:
        return 0
    if a == nil:
        return -1
    if b == nil:
        return 1
    let na: int32 = len(a)
    let nb: int32 = len(b)
    let n: int32 = na < nb ? na : nb
    for i in 0..<n:
        let ca: int32 = int32(int64(a[i]) & int64(0xFF))
        let cb: int32 = int32(int64(b[i]) & int64(0xFF))
        if ca < cb:
            return -1
        if ca > cb:
            return 1
    if na < nb:
        return -1
    if na > nb:
        return 1
    return 0

fn elf_seqContainsStr(items: str[], value: str): bool =
    for i in 0..<items.len:
        if (items[i] == value):
            return true
    return false

fn elfHexNibble(c: char): int32 =
    if c >= '0' && c <= '9':
        return int32(c) - int32('0')
    if c >= 'a' && c <= 'f':
        return 10 + int32(c) - int32('a')
    if c >= 'A' && c <= 'F':
        return 10 + int32(c) - int32('A')
    return -1

fn elfCanonicalCStringReloc(name: str): str =
    let _: str = name
    return ""


fn elfReadStrPtr(items: var str[], idx: int32): str =
    if items == nil:
        panic "elf_writer: nil seq pointer"
    return items[int(idx)]

fn elfWriteStrPtr(items: var str[], idx: int32, val: str) =
    if items == nil:
        panic "elf_writer: nil seq pointer"
    items[int(idx)] = val

fn elfAddStrPtr(items: var str[], value: str) =
    if items == nil:
        return
    add(items, value)

fn elfAddSymPtr(outSyms: var ElfSym[], s: ElfSym) =
    if outSyms == nil:
        return
    add(outSyms, s)

fn elf_seqAddUniqueStr(items: var str[], value: str) =
    if items == nil || value == nil || len(value) == 0:
        return
    if elf_seqContainsStr(items, value):
        return
    elfAddStrPtr(items, value)

fn elf_sortStringsStable(items: var str[]) =
    if items == nil:
        return
    for i in 1..<items.len:
        let key: str = elfReadStrPtr(items, i)
        var j: int32 = i - 1
        let __for_start_j = j
        for __for_rev_j in 0..(__for_start_j - (0)):
            j = __for_start_j - __for_rev_j
            if !(elf_strCmp(elfReadStrPtr(items, j), key) > 0):
                break
            elfWriteStrPtr(items, j + 1, elfReadStrPtr(items, j))
        elfWriteStrPtr(items, j + 1, key)

fn elf_alignUp(value: uint64, align: uint64): uint64 =
    if align == 0:
        return value
    let rem: uint64 = value % align
    if rem == 0:
        return value
    return value + (align - rem)

fn elfWriteShdr(out: var uint8[], nameOff: uint32, shType: uint32, flags: uint64,
                shOffset: uint64, shSize: uint64, link: uint32, info: uint32,
                addralign: uint64, entsize: uint64) =
    if out == nil:
        return
    bufU32(out, nameOff)
    bufU32(out, shType)
    bufU64(out, flags)
    bufU64(out, uint64(0)) # sh_addr
    bufU64(out, shOffset)
    bufU64(out, shSize)
    bufU32(out, link)
    bufU32(out, info)
    bufU64(out, addralign)
    bufU64(out, entsize)

fn elfAddSectionSym(outSyms: var ElfSym[], shndx: uint16) =
    var s: ElfSym
    new s
    s.name = ""
    s.bind = STB_LOCAL
    s.stType = STT_SECTION
    s.shndx = shndx
    s.value = 0
    s.size = 0
    s.nameOff = 0
    elfAddSymPtr(outSyms, s)

fn elfAddSym(outSyms: var ElfSym[], name: str, bind: uint8, stType: uint8,
             shndx: uint16, value: uint64, size: uint64) =
    var s: ElfSym
    new s
    s.name = name
    s.bind = bind
    s.stType = stType
    s.shndx = shndx
    s.value = value
    s.size = size
    s.nameOff = 0
    elfAddSymPtr(outSyms, s)

fn elfFindSymIndex(syms: ElfSym[], name: str): int32 =
    if name == nil:
        return -1
    for i in 0..<syms.len:
        let s: ElfSym = syms[i]
        if s != nil && (s.name == name):
            return i
    return -1

fn elfSeqAtMachineFunc(items: MachineFunc[], idx: int32): MachineFunc =
    return items[int(idx)]

fn elfSeqAtMachineCString(items: MachineCString[], idx: int32): MachineCString =
    return items[int(idx)]

fn elfSeqAtMachineGlobal(items: MachineGlobal[], idx: int32): MachineGlobal =
    return items[int(idx)]

fn elfSeqAtMachineInst(items: MachineInst[], idx: int32): MachineInst =
    return items[int(idx)]

fn elfModuleFuncAtRaw(mod: MachineModule, idx: int32): MachineFunc =
    if mod == nil:
        return nil
    return elfSeqAtMachineFunc(mod.funcs, idx)

fn elfModuleCStringAtRaw(mod: MachineModule, idx: int32): MachineCString =
    if mod == nil:
        return nil
    return elfSeqAtMachineCString(mod.cstrs, idx)

fn elfModuleGlobalAtRaw(mod: MachineModule, idx: int32): MachineGlobal =
    if mod == nil:
        return nil
    return elfSeqAtMachineGlobal(mod.globals, idx)

fn elfFuncInstAtRaw(func: MachineFunc, idx: int32): MachineInst =
    if func == nil:
        return nil
    return elfSeqAtMachineInst(func.insts, idx)

fn elfBuild(module: MachineModule): Result[uint8[]] =
    if module == nil:
        return Err[uint8[]]("elf_writer: nil module")
    let target: str = machineModuleTargetOf(module)
    if elf_targetIsDarwin(target):
        return Err[uint8[]]("elf_writer: darwin target not supported")
    let cstrCount: int32 = machineModuleCstrsLen(module)
    let globalCount: int32 = machineModuleGlobalsLen(module)
    let funcCount: int32 = machineModuleFuncsLen(module)

    # Sections (fixed indices):
    # 0: null
    # 1: .text
    # 2: .rodata
    # 3: .data
    # 4: .bss
    # 5: .rela.text
    # 6: .symtab
    # 7: .strtab
    # 8: .shstrtab

    var text: uint8[]
    var rodata: uint8[]
    var data: uint8[]
    var bssSize: uint64 = 0

    # Layout rodata (cstrings).
    var cSymOffs: uint64[]
    cSymOffs.len = int(cstrCount)
    var cSymLabels: str[]
    cSymLabels.len = int(cstrCount)
    for ci in 0..<cstrCount:
        let c: MachineCString = elfModuleCStringAtRaw(module, ci)
        let off: uint64 = uint64(rodata.len)
        cSymOffs[ci] = off
        cSymLabels[ci] = machineCStringLabelOf(c)
        bufStr0(&rodata, machineCStringValueOf(c))

    # Layout globals.
    var dataSymOffs: uint64[]
    dataSymOffs.len = int(globalCount)
    var bssSymOffs: uint64[]
    bssSymOffs.len = int(globalCount)
    var maxDataAlign: uint64 = 1
    var maxBssAlign: uint64 = 1
    for gi in 0..<globalCount:
        let g: MachineGlobal = elfModuleGlobalAtRaw(module, gi)
        let align: uint64 = uint64(1) << uint64(machineGlobalAlignPow2Of(g))
        if machineGlobalHasInit(g):
            if align > maxDataAlign:
                maxDataAlign = align
            bufAlign(&data, align)
            dataSymOffs[gi] = uint64(data.len)
            if machineGlobalSizeOf(g) == 4:
                bufU32(&data, uint32(int32(machineGlobalInitOf(g))))
            else:
                bufU64(&data, uint64(machineGlobalInitOf(g)))
        else:
            if align > maxBssAlign:
                maxBssAlign = align
            bssSize = elf_alignUp(bssSize, align)
            bssSymOffs[gi] = bssSize
            bssSize = bssSize + uint64(machineGlobalSizeOf(g))

    # Encode .text and collect relocations.
    var relocs: ElfReloc[]

    # Track function start offsets.
    var funcOffs: uint64[]
    funcOffs.len = int(funcCount)
    for fi in 0..<funcCount:
        bufAlign(text, 4)
        funcOffs[fi] = uint64(text.len)
        let f: MachineFunc = elfModuleFuncAtRaw(module, fi)
        let instCount: int32 = machineFuncInstsLen(f)

        # Pass 1: compute label offsets within this function (in bytes from func start).
        var labels: str[16]
        var labelOffs: int32[16]
        var scanOff: int32 = 0
        for si in 0..<instCount:
            let inst0: MachineInst = elfFuncInstAtRaw(f, si)
            if machineInstOpOf(inst0) == machineOpLabel:
                add(labels, machineInstLabelOf(inst0))
                add(labelOffs, scanOff)
                continue
            if machineInstOpOf(inst0) == machineOpMovImm:
                let wc: int32 = a64MovImmWordCount(a64Is64(machineInstRdOf(inst0)), machineInstImmOf(inst0))
                scanOff = scanOff + (wc * 4)
            else:
                scanOff = scanOff + 4

        var ii: int32 = 0
        var curOff: int32 = 0
        for __for_guard_ii in 0..<instCount:
            if !(ii < instCount):
                break
            let inst: MachineInst = elfFuncInstAtRaw(f, ii)
            if machineInstOpOf(inst) == machineOpLabel:
                ii = ii + 1
                continue
            let off: uint64 = uint64(text.len)
            var word: uint32 = 0
            if machineInstOpOf(inst) == machineOpSubSp:
                if machineInstImmOf(inst) < 0 || machineInstImmOf(inst) > 4095:
                    return Err[uint8[]]("elf_writer: sub sp immediate out of range")
                word = a64EncSubImm(true, 31, 31, int32(machineInstImmOf(inst)))
            elif machineInstOpOf(inst) == machineOpAddSp:
                if machineInstImmOf(inst) < 0 || machineInstImmOf(inst) > 4095:
                    return Err[uint8[]]("elf_writer: add sp immediate out of range")
                word = a64EncAddImm(true, 31, 31, int32(machineInstImmOf(inst)))
            elif machineInstOpOf(inst) == machineOpMovReg:
                let is64: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncAddImm(is64, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), 0)
            elif machineInstOpOf(inst) == machineOpMovImm:
                let is64: bool = a64Is64(machineInstRdOf(inst))
                let rd: int32 = a64RegNum(machineInstRdOf(inst))
                let v: uint64 = uint64(machineInstImmOf(inst))
                # Emit movz/movk chain (0..3 halfwords).
                word = a64EncMovz(is64, rd, int32(v & uint64(0xFFFF)), 0)
                emitU32LE(text, word)
                for hw in 1..<(is64 ? 4 : 2):
                    let part: uint64 = (v >> uint64(hw * 16)) & uint64(0xFFFF)
                    if part != 0:
                        let w2: uint32 = a64EncMovk(is64, rd, int32(part), hw)
                        emitU32LE(text, w2)
                ii = ii + 1
                curOff = curOff + (a64MovImmWordCount(is64, machineInstImmOf(inst)) * 4)
                continue
            elif machineInstOpOf(inst) == machineOpAdrp:
                word = a64EncAdrp(a64RegNum(machineInstRdOf(inst)))
                var r: ElfReloc
                new r
                r.off = off
                r.sym = machineInstLabelOf(inst)
                r.rtype = R_AARCH64_ADR_PREL_PG_HI21
                r.addend = 0
                add(relocs, r)
            elif machineInstOpOf(inst) == machineOpAddPageOff:
                word = a64EncAddImm(true, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), 0)
                var r2: ElfReloc
                new r2
                r2.off = off
                r2.sym = machineInstLabelOf(inst)
                r2.rtype = R_AARCH64_ADD_ABS_LO12_NC
                r2.addend = 0
                add(relocs, r2)
            elif machineInstOpOf(inst) == machineOpSxtw:
                word = a64EncSxtw(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpAdd:
                let is64a: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncAddReg(is64a, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpSub:
                let is64s2: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncSubReg(is64s2, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpMul:
                let is64m2: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncMul(is64m2, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpSdiv:
                let is64d: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncSdiv(is64d, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpUdiv:
                let is64d2: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncUdiv(is64d2, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpMsub:
                let is64ms: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncMsub(is64ms, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)), a64RegNum(machineInstRaOf(inst)))
            elif machineInstOpOf(inst) == machineOpAnd:
                let is64l: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncAndReg(is64l, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpOrr:
                let is64o: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncOrrReg(is64o, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpEor:
                let is64e: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncEorReg(is64e, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpLsl:
                let is64sh: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncLslv(is64sh, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpLsr:
                let is64sh2: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncLsrv(is64sh2, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpAsr:
                let is64sh3: bool = a64Is64(machineInstRdOf(inst))
                word = a64EncAsrv(is64sh3, a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpCmp:
                let is64c: bool = a64Is64(machineInstRnOf(inst))
                word = a64EncCmpReg(is64c, a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpBCond:
                let toffRes: Result[int32] = elf_findLabelOff(labels, labelOffs, machineInstLabelOf(inst))
                if !IsOk[int32](toffRes):
                    return ErrInfo[uint8[]](ErrorInfoOf[int32](toffRes))
                let targetOff: int32 = Value[int32](toffRes)
                let deltaBytes: int64 = int64(targetOff - curOff)
                if deltaBytes % 4 != 0:
                    return Err[uint8[]]("elf_writer: misaligned branch target")
                let encRes: Result[uint32] = a64EncBCond(deltaBytes / 4, machineInstCondOf(inst))
                if !IsOk[uint32](encRes):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes))
                word = Value[uint32](encRes)
            elif machineInstOpOf(inst) == machineOpB:
                let toffRes2: Result[int32] = elf_findLabelOff(labels, labelOffs, machineInstLabelOf(inst))
                if !IsOk[int32](toffRes2):
                    return ErrInfo[uint8[]](ErrorInfoOf[int32](toffRes2))
                let targetOff2: int32 = Value[int32](toffRes2)
                let deltaBytes2: int64 = int64(targetOff2 - curOff)
                if deltaBytes2 % 4 != 0:
                    return Err[uint8[]]("elf_writer: misaligned branch target")
                let encRes2: Result[uint32] = a64EncBImm(deltaBytes2 / 4)
                if !IsOk[uint32](encRes2):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes2))
                word = Value[uint32](encRes2)
            elif machineInstOpOf(inst) == machineOpStr:
                let is64s: bool = a64Is64(machineInstRdOf(inst))
                let encRes: Result[uint32] = a64EncStrImm(is64s, a64RegNum(machineInstRdOf(inst)),
                                                          a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if ! IsOk[uint32](encRes):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes))
                word = Value[uint32](encRes)
            elif machineInstOpOf(inst) == machineOpLdr:
                let is64l: bool = a64Is64(machineInstRdOf(inst))
                let encRes2: Result[uint32] = a64EncLdrImm(is64l, a64RegNum(machineInstRdOf(inst)),
                                                           a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if ! IsOk[uint32](encRes2):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes2))
                word = Value[uint32](encRes2)
            elif machineInstOpOf(inst) == machineOpStrb:
                let encRes3: Result[uint32] = a64EncStrbImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes3):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes3))
                word = Value[uint32](encRes3)
            elif machineInstOpOf(inst) == machineOpLdrb:
                let encRes4: Result[uint32] = a64EncLdrbImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes4):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes4))
                word = Value[uint32](encRes4)
            elif machineInstOpOf(inst) == machineOpLdrsb:
                let encRes5: Result[uint32] = a64EncLdrsbImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes5):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes5))
                word = Value[uint32](encRes5)
            elif machineInstOpOf(inst) == machineOpStrh:
                let encRes6: Result[uint32] = a64EncStrhImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes6):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes6))
                word = Value[uint32](encRes6)
            elif machineInstOpOf(inst) == machineOpLdrh:
                let encRes7: Result[uint32] = a64EncLdrhImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes7):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes7))
                word = Value[uint32](encRes7)
            elif machineInstOpOf(inst) == machineOpLdrsh:
                let encRes8: Result[uint32] = a64EncLdrshImm(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), machineInstImmOf(inst))
                if !IsOk[uint32](encRes8):
                    return ErrInfo[uint8[]](ErrorInfoOf[uint32](encRes8))
                word = Value[uint32](encRes8)
            elif machineInstOpOf(inst) == machineOpBl:
                word = a64EncBl()
                var r3: ElfReloc
                new r3
                r3.off = off
                r3.sym = machineInstLabelOf(inst)
                r3.rtype = R_AARCH64_CALL26
                r3.addend = 0
                add(relocs, r3)
            elif machineInstOpOf(inst) == machineOpBlr:
                word = a64EncBlr(a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpFmovDx:
                word = a64EncFmovDx(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpFmovXd:
                word = a64EncFmovXd(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpFcmpD:
                word = a64EncFcmpD(a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpFaddD:
                word = a64EncFaddD(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpFsubD:
                word = a64EncFsubD(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpFmulD:
                word = a64EncFmulD(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpFdivD:
                word = a64EncFdivD(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)), a64RegNum(machineInstRmOf(inst)))
            elif machineInstOpOf(inst) == machineOpFnegD:
                word = a64EncFnegD(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpScvtfDx:
                word = a64EncScvtfDx(a64RegNum(machineInstRdOf(inst)), a64RegNum(machineInstRnOf(inst)))
            elif machineInstOpOf(inst) == machineOpSvc:
                if machineInstImmOf(inst) < 0 || machineInstImmOf(inst) > 65535:
                    return Err[uint8[]]("elf_writer: svc immediate out of range")
                word = a64EncSvc(int32(machineInstImmOf(inst)))
            elif machineInstOpOf(inst) == machineOpRet:
                word = a64EncRet()
            else:
                return Err[uint8[]]("elf_writer: unsupported machine op (op=" + intToStr(int32(machineInstOpOf(inst))) + ")")
            emitU32LE(text, word)
            ii = ii + 1
            curOff = curOff + 4

    # Some stage0/seed paths keep L_cheng_str_* as reloc-only symbols.
    # Materialize zero-terminated placeholders in .rodata so linkers can
    # resolve these locals within the same object.
    var synthCstrNames: str[]
    var synthCstrOffs: uint64[]
    for ri in 0..<relocs.len:
        let rSynth: ElfReloc = relocs[ri]
        if rSynth == nil || rSynth.sym == nil || len(rSynth.sym) == 0:
            continue
        let canonical: str = elfCanonicalCStringReloc(rSynth.sym)
        if len(canonical) == 0:
            continue
        if elf_seqContainsStr(cSymLabels, canonical) || elf_seqContainsStr(synthCstrNames, canonical):
            continue
        let offSynth: uint64 = uint64(rodata.len)
        bufU8(&rodata, uint8(0))
        add(synthCstrNames, canonical)
        add(synthCstrOffs, offSynth)

    # Build symbol list.
    var syms: ElfSym[]
    # null
    elfAddSym(syms, "", STB_LOCAL, STT_NOTYPE, uint16(0), 0, 0)
    # section symbols
    elfAddSectionSym(syms, uint16(1))
    elfAddSectionSym(syms, uint16(2))
    elfAddSectionSym(syms, uint16(3))
    elfAddSectionSym(syms, uint16(4))

    # local rodata symbols
    for ci in 0..<cstrCount:
        let c2: MachineCString = elfModuleCStringAtRaw(module, ci)
        elfAddSym(syms, machineCStringLabelOf(c2), STB_LOCAL, STT_OBJECT, uint16(2),
                  cSymOffs[ci], 0)
    for si in 0..<synthCstrNames.len:
        elfAddSym(syms, synthCstrNames[si], STB_LOCAL, STT_OBJECT, uint16(2),
                  synthCstrOffs[si], 0)

    # globals: funcs
    for fi in 0..<funcCount:
        let f2: MachineFunc = elfModuleFuncAtRaw(module, fi)
        elfAddSym(syms, machineFuncNameOf(f2), STB_GLOBAL, STT_FUNC, uint16(1),
                  funcOffs[fi], 0)

    # globals: data/bss
    for gi in 0..<globalCount:
        let g2: MachineGlobal = elfModuleGlobalAtRaw(module, gi)
        if machineGlobalHasInit(g2):
            elfAddSym(syms, machineGlobalNameOf(g2), STB_GLOBAL, STT_OBJECT, uint16(3),
                      dataSymOffs[gi], uint64(machineGlobalSizeOf(g2)))
        else:
            elfAddSym(syms, machineGlobalNameOf(g2), STB_GLOBAL, STT_OBJECT, uint16(4),
                      bssSymOffs[gi], uint64(machineGlobalSizeOf(g2)))

    # undefined symbols referenced by relocations.
    var undefs: str[]
    for ri in 0..<relocs.len:
        let r0: ElfReloc = relocs[ri]
        if r0 != nil && r0.sym != nil && len(r0.sym) > 0:
            if elfFindSymIndex(syms, r0.sym) < 0:
                elf_seqAddUniqueStr(&undefs, r0.sym)
    elf_sortStringsStable(&undefs)
    for ri in 0..<undefs.len:
        elfAddSym(syms, undefs[ri], STB_GLOBAL, STT_NOTYPE, uint16(0), 0, 0)

    # Build .strtab (symbol names) and fill nameOff.
    var strtab: uint8[]
    add(strtab, uint8(0))
    for si in 0..<syms.len:
        let s3: ElfSym = syms[si]
        if s3 != nil:
            if s3.name != nil && len(s3.name) > 0:
                s3.nameOff = uint32(strtab.len)
                bufStr0(strtab, s3.name)
            else:
                s3.nameOff = 0
            syms[si] = s3

    # Count locals for symtab.sh_info (first global index).
    var localCount: uint32 = 0
    for si in 0..<syms.len:
        let s4: ElfSym = syms[si]
        if s4 != nil && s4.bind == STB_LOCAL:
            localCount = localCount + 1

    # Build .symtab
    var symtab: uint8[]
    for si in 0..<syms.len:
        let s5: ElfSym = syms[si]
        let info: uint8 = uint8((uint8(s5.bind) << 4) | uint8(s5.stType & uint8(0xF)))
        bufU32(&symtab, s5.nameOff)
        bufU8(&symtab, info)
        bufU8(&symtab, uint8(0))
        bufU16(&symtab, s5.shndx)
        bufU64(&symtab, s5.value)
        bufU64(&symtab, s5.size)

    # Build .rela.text
    var relaText: uint8[]
    ri = 0
    let __for_start_ri_1 = ri
    for __for_ri_1 in __for_start_ri_1..<relocs.len:
        ri = __for_ri_1
        let r4: ElfReloc = relocs[ri]
        let symIdx: int32 = elfFindSymIndex(syms, r4.sym)
        if symIdx < 0:
            return Err[uint8[]]("elf_writer: missing relocation symbol")
        let info2: uint64 = (uint64(uint32(symIdx)) << 32) | uint64(r4.rtype)
        bufU64(&relaText, r4.off)
        bufU64(&relaText, info2)
        bufI64(&relaText, r4.addend)
        ri = ri + 1

    # Build .shstrtab
    var shstrtab: uint8[]
    add(shstrtab, uint8(0))
    let sh_text: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".text")
    let sh_rodata: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".rodata")
    let sh_data: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".data")
    let sh_bss: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".bss")
    let sh_rela_text: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".rela.text")
    let sh_symtab: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".symtab")
    let sh_strtab: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".strtab")
    let sh_shstrtab: uint32 = uint32(shstrtab.len)
    bufStr0(&shstrtab, ".shstrtab")

    # Section offsets.
    var off: uint64 = 64
    let textOff: uint64 = elf_alignUp(off, 4)
    off = textOff + uint64(text.len)
    let rodataOff: uint64 = elf_alignUp(off, 1)
    off = rodataOff + uint64(rodata.len)
    let dataOff: uint64 = elf_alignUp(off, maxDataAlign)
    off = dataOff + uint64(data.len)
    let bssOff: uint64 = elf_alignUp(off, maxBssAlign)
    # NOBITS: does not advance file offset.
    let relaOff: uint64 = elf_alignUp(bssOff, 8)
    off = relaOff + uint64(relaText.len)
    let symOff: uint64 = elf_alignUp(off, 8)
    off = symOff + uint64(symtab.len)
    let strOff: uint64 = elf_alignUp(off, 1)
    off = strOff + uint64(strtab.len)
    let shstrOff: uint64 = elf_alignUp(off, 1)
    off = shstrOff + uint64(shstrtab.len)
    let shOff: uint64 = elf_alignUp(off, 8)

    # Build final file.
    var out: uint8[]

    # ELF header (64 bytes).
    bufU8(out, uint8(0x7F))
    bufU8(out, uint8('E'))
    bufU8(out, uint8('L'))
    bufU8(out, uint8('F'))
    bufU8(out, ELFCLASS64)
    bufU8(out, ELFDATA2LSB)
    bufU8(out, uint8(1)) # EI_VERSION
    bufU8(out, uint8(0)) # EI_OSABI
    bufU8(out, uint8(0)) # EI_ABIVERSION
    # padding (7)
    for pad in 0..<7:
        bufU8(out, uint8(0))
    bufU16(out, ET_REL)
    bufU16(out, EM_AARCH64)
    bufU32(out, EV_CURRENT)
    bufU64(out, uint64(0)) # e_entry
    bufU64(out, uint64(0)) # e_phoff
    bufU64(out, shOff)     # e_shoff
    bufU32(out, uint32(0)) # e_flags
    bufU16(out, uint16(64)) # e_ehsize
    bufU16(out, uint16(0))  # e_phentsize
    bufU16(out, uint16(0))  # e_phnum
    bufU16(out, uint16(64)) # e_shentsize
    bufU16(out, uint16(9))  # e_shnum
    bufU16(out, uint16(8))  # e_shstrndx

    # Sections data.
    bufAlign(out, 4)
    if uint64(out.len) != textOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.text)")
    bufBytes(out, text)

    bufAlign(out, 1)
    if uint64(out.len) != rodataOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.rodata)")
    bufBytes(out, rodata)

    bufAlign(out, maxDataAlign)
    if uint64(out.len) != dataOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.data)")
    bufBytes(out, data)

    # .bss: no bytes, but keep alignment point.
    bufAlign(out, maxBssAlign)
    if uint64(out.len) != bssOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.bss)")

    bufAlign(out, 8)
    if uint64(out.len) != relaOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.rela.text)")
    bufBytes(out, relaText)

    bufAlign(out, 8)
    if uint64(out.len) != symOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.symtab)")
    bufBytes(out, symtab)

    bufAlign(out, 1)
    if uint64(out.len) != strOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.strtab)")
    bufBytes(out, strtab)

    bufAlign(out, 1)
    if uint64(out.len) != shstrOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (.shstrtab)")
    bufBytes(out, shstrtab)

    bufAlign(out, 8)
    if uint64(out.len) != shOff:
        return Err[uint8[]]("elf_writer: internal offset mismatch (shoff)")

    # [0] null
    elfWriteShdr(out, uint32(0), SHT_NULL, uint64(0), uint64(0), uint64(0),
                 uint32(0), uint32(0), uint64(0), uint64(0))
    # [1] .text
    elfWriteShdr(out, sh_text, SHT_PROGBITS, SHF_ALLOC | SHF_EXECINSTR, textOff, uint64(text.len),
                 uint32(0), uint32(0), uint64(4), uint64(0))
    # [2] .rodata
    elfWriteShdr(out, sh_rodata, SHT_PROGBITS, SHF_ALLOC, rodataOff, uint64(rodata.len),
                 uint32(0), uint32(0), uint64(1), uint64(0))
    # [3] .data
    elfWriteShdr(out, sh_data, SHT_PROGBITS, SHF_ALLOC | SHF_WRITE, dataOff, uint64(data.len),
                 uint32(0), uint32(0), maxDataAlign, uint64(0))
    # [4] .bss
    elfWriteShdr(out, sh_bss, SHT_NOBITS, SHF_ALLOC | SHF_WRITE, bssOff, bssSize,
                 uint32(0), uint32(0), maxBssAlign, uint64(0))
    # [5] .rela.text (link=symtab, info=.text)
    elfWriteShdr(out, sh_rela_text, SHT_RELA, uint64(0), relaOff, uint64(relaText.len),
                 uint32(6), uint32(1), uint64(8), uint64(24))
    # [6] .symtab (link=strtab, info=local count)
    elfWriteShdr(out, sh_symtab, SHT_SYMTAB, uint64(0), symOff, uint64(symtab.len),
                 uint32(7), localCount, uint64(8), uint64(24))
    # [7] .strtab
    elfWriteShdr(out, sh_strtab, SHT_STRTAB, uint64(0), strOff, uint64(strtab.len),
                 uint32(0), uint32(0), uint64(1), uint64(0))
    # [8] .shstrtab
    elfWriteShdr(out, sh_shstrtab, SHT_STRTAB, uint64(0), shstrOff, uint64(shstrtab.len),
                 uint32(0), uint32(0), uint64(1), uint64(0))

    return Ok[uint8[]](out)

fn elfWriteAarch64RelocatableObj(module: MachineModule): Result[uint8[]] =
    if module != nil:
        memRetain(void*(module))
    return elfBuild(module)
