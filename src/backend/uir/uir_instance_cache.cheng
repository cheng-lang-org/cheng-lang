# UIR generic instance cache (phase-1): deterministic in-process cache key facade.
import std/hashmaps

type
    UirInstanceCache = ref
        seen: hashmaps.HashMapStrInt
        total: int32
        reused: int32
        specialized: int32
        dictCalls: int32

fn uirNewInstanceCache(): UirInstanceCache =
    let c: UirInstanceCache = UirInstanceCache()
    c.seen = hashmaps.hashMapStrIntInit(256)
    c.total = 0
    c.reused = 0
    c.specialized = 0
    c.dictCalls = 0
    return c

fn uirInstanceCacheTouch(c: UirInstanceCache, key: str, specialized: bool) =
    if c == nil || len(key) == 0:
        return
    var found: bool = false
    let old: int32 = hashmaps.hashMapStrIntGetEx(c.seen, key, found)
    if found && old > 0:
        c.reused = c.reused + 1
        return
    hashmaps.hashMapStrIntPut(c.seen, key, 1)
    c.total = c.total + 1
    if specialized:
        c.specialized = c.specialized + 1
    else:
        c.dictCalls = c.dictCalls + 1
