# UIR e-graph cost model (phase-2): deterministic objective scoring with explicit goals.
import std/strutils

fn uirEgraphCostLowerAscii(s: str): str =
    return strutils.toLowerAscii(s)

fn uirEGraphNormalizeGoal(goal: str): str =
    let s: str = uirEgraphCostLowerAscii(goal)
    if s == "latency":
        return "latency"
    if s == "size":
        return "size"
    return "balanced"

fn uirEGraphNodeWeight(goal: str): int32 =
    let target: str = uirEGraphNormalizeGoal(goal)
    if target == "latency":
        return 3
    if target == "size":
        return 8
    return 4

fn uirEGraphOpWeight(goal: str): int32 =
    let target: str = uirEGraphNormalizeGoal(goal)
    if target == "latency":
        return 5
    if target == "size":
        return 2
    return 3

fn uirEGraphIterWeight(goal: str): int32 =
    let _: str = uirEGraphNormalizeGoal(goal)
    return 1

fn uirEGraphGoalWeightSignature(goal: str): str =
    let target: str = uirEGraphNormalizeGoal(goal)
    return target + ".n" + intToStr(uirEGraphNodeWeight(target)) + "_o" + intToStr(uirEGraphOpWeight(target)) + "_i" + intToStr(uirEGraphIterWeight(target))

fn uirEGraphScore(goal: str, nodeCount: int32, opCost: int32, iterBudget: int32): int32 =
    let target: str = uirEGraphNormalizeGoal(goal)
    var n: int32 = nodeCount
    var o: int32 = opCost
    var b: int32 = iterBudget
    if n < 0:
        n = 0
    if o < 0:
        o = 0
    if b <= 0:
        b = 1
    let nodeWeight: int32 = uirEGraphNodeWeight(target)
    let opWeight: int32 = uirEGraphOpWeight(target)
    let iterWeight: int32 = uirEGraphIterWeight(target)
    # Goal-specific linear objective with explicit weights for audit/regression.
    return n * nodeWeight + o * opWeight + b * iterWeight

fn uirEGraphCostAccept(goal: str, oldScore: int32, newScore: int32, oldNodes: int32, newNodes: int32): bool =
    if oldScore < 0 || newScore < 0:
        return false
    if newScore < oldScore:
        return true
    if newScore > oldScore:
        return false
    let target: str = uirEGraphNormalizeGoal(goal)
    if target == "size":
        return newNodes <= oldNodes
    return newNodes <= oldNodes
