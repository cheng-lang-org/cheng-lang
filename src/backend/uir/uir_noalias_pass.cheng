# UIR no-alias preparation pass (phase-2):
# - conservative block-local load/store forwarding
# - conservative local mem2reg for resolved stack slots
# - NJVL-lite (unknown + kill-lite) optional mode
import backend/uir/uir_types
import backend/uir/uir_internal/uir_core_types
import std/os
import std/strings
import std/strutils

fn uirNoAliasLowerAscii(s: str): str =
    return strutils.toLowerAscii(s)

fn uirNoAliasParseBoolEnv(name: str, defaultValue: bool): bool =
    let raw: str = os.getEnvDefault(name, "")
    if len(raw) == 0:
        return defaultValue
    let s: str = uirNoAliasLowerAscii(raw)
    if s == "1" || s == "true" || s == "yes" || s == "on":
        return true
    if s == "0" || s == "false" || s == "no" || s == "off":
        return false
    return defaultValue

fn uirNoAliasInitExprSeq(n: int32): UirExpr[] =
    var out: UirExpr[]
    for _ in 0..<n:
        add(out, nil)
    return out

fn uirNoAliasInitBoolSeq(n: int32, value: bool): bool[] =
    var out: bool[]
    for _ in 0..<n:
        add(out, value)
    return out

fn uirNoAliasInitI32Seq(n: int32, value: int32): int32[] =
    var out: int32[]
    for _ in 0..<n:
        add(out, value)
    return out

fn uirNoAliasInvalidateKnown(knownValid: bool[]*) =
    if knownValid == nil:
        return
    for i in 0..<knownValid->len:
        knownValid[i] = false

fn uirNoAliasInvalidatePtrBase(ptrBase: int32[]*) =
    if ptrBase == nil:
        return
    for i in 0..<ptrBase->len:
        ptrBase[i] = -1

fn uirNoAliasDisablePromotable(promotable: bool[]*) =
    if promotable == nil:
        return
    for i in 0..<promotable->len:
        promotable[i] = false

fn uirNoAliasInvalidateAll(knownValid: bool[]*, ptrBase: int32[]*, promotable: bool[]*) =
    uirNoAliasInvalidateKnown(knownValid)
    uirNoAliasInvalidatePtrBase(ptrBase)
    uirNoAliasDisablePromotable(promotable)

fn uirNoAliasIsObjSlot(func: UirCoreFunc, slot: int32): bool =
    if func == nil || slot < 0:
        return false
    for i in 0..<func.objLocals.len:
        let ol: UirObjLocal = func.objLocals[i]
        if ol.slot == slot:
            return true
    return false

fn uirNoAliasEnsureName(name: str, slot: int32): str =
    if len(name) > 0:
        return name
    return "__na_l" + intToStr(slot)

fn uirNoAliasResolveAddrBaseSlot(addrExpr: UirExpr, ptrBase: int32[]): int32 =
    if addrExpr == nil:
        return -1
    let k: UirExprKind = uirExprKindOf(addrExpr)
    if k == meAddr:
        return uirExprLocalIndexOf(addrExpr)
    if k == meLocal:
        let slot: int32 = uirExprLocalIndexOf(addrExpr)
        if slot >= 0 && slot < ptrBase.len:
            return ptrBase[slot]
        return -1
    if k == meCast:
        return uirNoAliasResolveAddrBaseSlot(uirExprCastExprOf(addrExpr), ptrBase)
    return -1

fn uirNoAliasExprStable(expr: UirExpr): bool =
    if expr == nil:
        return false
    let k: UirExprKind = uirExprKindOf(expr)
    if k == meConstI64 || k == meLocal || k == meAddr || k == meGlobalAddr:
        return true
    if k == meCall || k == meLoad:
        return false
    if k == meCast:
        return uirNoAliasExprStable(uirExprCastExprOf(expr))
    if k == meBin || k == meCmp:
        return uirNoAliasExprStable(uirExprLhsOf(expr)) &&
               uirNoAliasExprStable(uirExprRhsOf(expr))
    return false

fn uirNoAliasExprHasCall(expr: UirExpr): bool =
    if expr == nil:
        return false
    let k: UirExprKind = uirExprKindOf(expr)
    if k == meCall:
        return true
    if k == meCast:
        return uirNoAliasExprHasCall(uirExprCastExprOf(expr))
    if k == meBin || k == meCmp:
        return uirNoAliasExprHasCall(uirExprLhsOf(expr)) ||
               uirNoAliasExprHasCall(uirExprRhsOf(expr))
    if k == meLoad:
        return uirNoAliasExprHasCall(uirExprAddrExprOf(expr))
    if k == meLocal || k == meAddr || k == meConstI64 || k == meGlobalAddr:
        return false
    for i in 0..<uirExprArgsLen(expr):
        if uirNoAliasExprHasCall(uirExprArgAt(expr, i)):
            return true
    return false

fn uirNoAliasExprMayClobber(expr: UirExpr): bool =
    return uirNoAliasExprHasCall(expr)

fn uirNoAliasExprHasLoadFromBase(expr: UirExpr, baseSlot: int32, ptrBase: int32[]): bool =
    if expr == nil:
        return false
    let k: UirExprKind = uirExprKindOf(expr)
    if k == meLoad:
        let loadBase: int32 = uirNoAliasResolveAddrBaseSlot(uirExprAddrExprOf(expr), ptrBase)
        if loadBase == baseSlot:
            return true
        return uirNoAliasExprHasLoadFromBase(uirExprAddrExprOf(expr), baseSlot, ptrBase)
    if k == meCast:
        return uirNoAliasExprHasLoadFromBase(uirExprCastExprOf(expr), baseSlot, ptrBase)
    if k == meBin || k == meCmp:
        return uirNoAliasExprHasLoadFromBase(uirExprLhsOf(expr), baseSlot, ptrBase) ||
               uirNoAliasExprHasLoadFromBase(uirExprRhsOf(expr), baseSlot, ptrBase)
    if k == meCall:
        for i in 0..<uirExprArgsLen(expr):
            if uirNoAliasExprHasLoadFromBase(uirExprArgAt(expr, i), baseSlot, ptrBase):
                return true
    return false

fn uirNoAliasHasFutureLoad(blk: UirCoreBlock, startIdx: int32, baseSlot: int32, ptrBase: int32[]): bool =
    if blk == nil || startIdx < 0:
        return false
    for si in startIdx..<blk.stmts.len:
        let st: UirCoreStmt = blk.stmts[si]
        if uirNoAliasExprHasLoadFromBase(st.expr, baseSlot, ptrBase):
            return true
        if st.kind == msStore && uirNoAliasExprHasLoadFromBase(st.addrExpr, baseSlot, ptrBase):
            return true
    if blk.term.kind == mtRet:
        return uirNoAliasExprHasLoadFromBase(blk.term.retExpr, baseSlot, ptrBase)
    if blk.term.kind == mtCbr:
        return uirNoAliasExprHasLoadFromBase(blk.term.condExpr, baseSlot, ptrBase)
    return false

fn uirNoAliasExprMarkUses(expr: UirExpr, marks: bool[]*) =
    if expr == nil || marks == nil:
        return
    let k: UirExprKind = uirExprKindOf(expr)
    if k == meLocal:
        let slot: int32 = uirExprLocalIndexOf(expr)
        if slot >= 0 && slot < marks->len:
            marks[slot] = true
        return
    if k == meBin || k == meCmp:
        uirNoAliasExprMarkUses(uirExprLhsOf(expr), marks)
        uirNoAliasExprMarkUses(uirExprRhsOf(expr), marks)
        return
    if k == meCast:
        uirNoAliasExprMarkUses(uirExprCastExprOf(expr), marks)
        return
    if k == meLoad:
        uirNoAliasExprMarkUses(uirExprAddrExprOf(expr), marks)
        return
    if k == meCall:
        for i in 0..<uirExprArgsLen(expr):
            uirNoAliasExprMarkUses(uirExprArgAt(expr, i), marks)
        return

fn uirNoAliasBuildLastUse(blk: UirCoreBlock, localCount: int32): int32[] =
    var lastUse: int32[] = uirNoAliasInitI32Seq(localCount, -1)
    if blk == nil || localCount <= 0:
        return lastUse
    var marks: bool[] = uirNoAliasInitBoolSeq(localCount, false)
    for si in 0..<blk.stmts.len:
        for i in 0..<localCount:
            marks[i] = false
        uirNoAliasExprMarkUses(blk.stmts[si].expr, &marks)
        uirNoAliasExprMarkUses(blk.stmts[si].addrExpr, &marks)
        for i in 0..<localCount:
            if marks[i]:
                lastUse[i] = si
    let termMark: int32 = blk.stmts.len
    for i in 0..<localCount:
        marks[i] = false
    if blk.term.kind == mtRet:
        uirNoAliasExprMarkUses(blk.term.retExpr, &marks)
    elif blk.term.kind == mtCbr:
        uirNoAliasExprMarkUses(blk.term.condExpr, &marks)
    for i in 0..<localCount:
        if marks[i]:
            lastUse[i] = termMark
    return lastUse

fn uirNoAliasApplyKillLite(stepIdx: int32,
                           lastUse: int32[],
                           knownValid: bool[]*,
                           ptrBase: int32[]*,
                           killEvents: int32*) =
    if knownValid == nil || ptrBase == nil:
        return
    for i in 0..<lastUse.len:
        if lastUse[i] != stepIdx:
            continue
        var touched: bool = false
        if i < knownValid->len && knownValid[i]:
            knownValid[i] = false
            touched = true
        if i < ptrBase->len && ptrBase[i] != -1:
            ptrBase[i] = -1
            touched = true
        if touched && killEvents != nil:
            *killEvents = *killEvents + 1

fn uirNoAliasExprCollectResolvedBases(expr: UirExpr,
                                      ptrBase: int32[],
                                      resolved: bool[]*,
                                      unknownCount: int32*) =
    if expr == nil || resolved == nil:
        return
    let k: UirExprKind = uirExprKindOf(expr)
    if k == meAddr:
        let slot: int32 = uirExprLocalIndexOf(expr)
        if slot >= 0 && slot < resolved->len:
            resolved[slot] = true
        elif unknownCount != nil:
            *unknownCount = *unknownCount + 1
        return
    if k == meLocal:
        let slot: int32 = uirExprLocalIndexOf(expr)
        if slot >= 0 && slot < ptrBase.len:
            let base: int32 = ptrBase[slot]
            if base >= 0 && base < resolved->len:
                resolved[base] = true
            elif unknownCount != nil:
                *unknownCount = *unknownCount + 1
        elif unknownCount != nil:
            *unknownCount = *unknownCount + 1
        return
    if k == meCast:
        uirNoAliasExprCollectResolvedBases(uirExprCastExprOf(expr), ptrBase, resolved, unknownCount)
        return
    if k == meLoad:
        uirNoAliasExprCollectResolvedBases(uirExprAddrExprOf(expr), ptrBase, resolved, unknownCount)
        return
    if k == meBin || k == meCmp:
        uirNoAliasExprCollectResolvedBases(uirExprLhsOf(expr), ptrBase, resolved, unknownCount)
        uirNoAliasExprCollectResolvedBases(uirExprRhsOf(expr), ptrBase, resolved, unknownCount)
        return
    if k == meCall:
        if unknownCount != nil:
            *unknownCount = *unknownCount + 1
        for i in 0..<uirExprArgsLen(expr):
            uirNoAliasExprCollectResolvedBases(uirExprArgAt(expr, i), ptrBase, resolved, unknownCount)
        return

fn uirNoAliasApplyExprClobber(expr: UirExpr,
                              njvlLite: bool,
                              ptrBase: int32[],
                              knownValid: bool[]*,
                              promotable: bool[]*,
                              unknownSlotClobbers: int32*,
                              unknownGlobalClobbers: int32*) =
    if !uirNoAliasExprMayClobber(expr):
        return
    if knownValid == nil || promotable == nil:
        return
    if !njvlLite:
        uirNoAliasInvalidateAll(knownValid, &ptrBase, promotable)
        return

    var resolved: bool[] = uirNoAliasInitBoolSeq(knownValid->len, false)
    var unknownCount: int32 = 0
    uirNoAliasExprCollectResolvedBases(expr, ptrBase, &resolved, &unknownCount)

    var resolvedCount: int32 = 0
    for i in 0..<resolved.len:
        if resolved[i]:
            resolvedCount = resolvedCount + 1
            knownValid[i] = false
            if i < ptrBase.len:
                ptrBase[i] = -1

    if unknownCount > 0 && unknownSlotClobbers != nil:
        *unknownSlotClobbers = *unknownSlotClobbers + unknownCount

    if resolvedCount <= 0 || unknownCount > 0:
        if unknownGlobalClobbers != nil:
            *unknownGlobalClobbers = *unknownGlobalClobbers + 1
        uirNoAliasInvalidateAll(knownValid, &ptrBase, promotable)

fn uirNoAliasRewriteExpr(expr: UirExpr,
                         ptrBase: int32[],
                         knownVals: UirExpr[],
                         knownValid: bool[],
                         promotable: bool[],
                         changed: bool*,
                         forwardedLoads: int32*,
                         mem2regLoads: int32*,
                         proofBackedChanges: int32*,
                         proofBacked: bool): UirExpr =
    if expr == nil:
        return nil
    var cur: UirCoreExpr = expr
    let k: UirExprKind = uirExprKindOf(cur)
    if k == meBin || k == meCmp:
        cur.lhs = uirNoAliasRewriteExpr(cur.lhs, ptrBase, knownVals, knownValid, promotable,
                                        changed, forwardedLoads, mem2regLoads,
                                        proofBackedChanges, proofBacked)
        cur.rhs = uirNoAliasRewriteExpr(cur.rhs, ptrBase, knownVals, knownValid, promotable,
                                        changed, forwardedLoads, mem2regLoads,
                                        proofBackedChanges, proofBacked)
        return cur
    if k == meCall:
        for i in 0..<cur.args.len:
            cur.args[i] = uirNoAliasRewriteExpr(cur.args[i], ptrBase, knownVals, knownValid, promotable,
                                                changed, forwardedLoads, mem2regLoads,
                                                proofBackedChanges, proofBacked)
        return cur
    if k == meCast:
        cur.castExpr = uirNoAliasRewriteExpr(cur.castExpr, ptrBase, knownVals, knownValid, promotable,
                                             changed, forwardedLoads, mem2regLoads,
                                             proofBackedChanges, proofBacked)
        return cur
    if k == meLoad:
        cur.addrExpr = uirNoAliasRewriteExpr(cur.addrExpr, ptrBase, knownVals, knownValid, promotable,
                                             changed, forwardedLoads, mem2regLoads,
                                             proofBackedChanges, proofBacked)
        let baseSlot: int32 = uirNoAliasResolveAddrBaseSlot(cur.addrExpr, ptrBase)
        if baseSlot >= 0 && baseSlot < knownValid.len:
            if knownValid[baseSlot] && knownVals[baseSlot] != nil:
                if changed != nil:
                    *changed = true
                if forwardedLoads != nil:
                    *forwardedLoads = *forwardedLoads + 1
                if proofBacked && proofBackedChanges != nil:
                    *proofBackedChanges = *proofBackedChanges + 1
                return knownVals[baseSlot]
            if baseSlot < promotable.len && promotable[baseSlot]:
                if changed != nil:
                    *changed = true
                if mem2regLoads != nil:
                    *mem2regLoads = *mem2regLoads + 1
                if proofBacked && proofBackedChanges != nil:
                    *proofBackedChanges = *proofBackedChanges + 1
                return uirCoreLocal(baseSlot)
        return cur
    return cur

fn uirNoAliasRunFunc(func: UirCoreFunc,
                     changedAny: bool*,
                     forwardedLoads: int32*,
                     mem2regLoads: int32*,
                     mem2regStores: int32*,
                     proofBackedChanges: int32*,
                     proofBacked: bool,
                     njvlLite: bool,
                     unknownSlotClobbers: int32*,
                     unknownGlobalClobbers: int32*,
                     killEvents: int32*): bool =
    if func == nil || func.isExtern:
        return false
    let localCount: int32 = func.localTypes.len
    if localCount <= 0:
        return false

    var funcChanged: bool = false
    for bi in 0..<func.blocks.len:
        let blkView: UirLowerBlock = func.blocks[bi]
        if blkView == nil:
            continue
        let blk: UirCoreBlock = blkView
        var ptrBase: int32[] = uirNoAliasInitI32Seq(localCount, -1)
        var knownVals: UirExpr[] = uirNoAliasInitExprSeq(localCount)
        var knownValid: bool[] = uirNoAliasInitBoolSeq(localCount, false)
        var promotable: bool[] = uirNoAliasInitBoolSeq(localCount, true)
        let lastUse: int32[] = uirNoAliasBuildLastUse(blk, localCount)
        for si0 in 0..<localCount:
            if uirNoAliasIsObjSlot(func, si0):
                promotable[si0] = false

        for si in 0..<blk.stmts.len:
            var st: UirCoreStmt = blk.stmts[si]
            if st.kind == msLet || st.kind == msVar || st.kind == msAssign:
                st.expr = uirNoAliasRewriteExpr(st.expr, ptrBase, knownVals, knownValid, promotable,
                                                &funcChanged, forwardedLoads, mem2regLoads,
                                                proofBackedChanges, proofBacked)
                if st.slot >= 0 && st.slot < localCount:
                    knownValid[st.slot] = false
                    if uirNoAliasExprStable(st.expr):
                        knownVals[st.slot] = st.expr
                        knownValid[st.slot] = true
                    let aliasBase: int32 = uirNoAliasResolveAddrBaseSlot(st.expr, ptrBase)
                    if aliasBase >= 0 && aliasBase < localCount:
                        ptrBase[st.slot] = aliasBase
                    else:
                        ptrBase[st.slot] = -1
                blk.stmts[si] = st
                uirNoAliasApplyExprClobber(st.expr, njvlLite, ptrBase, &knownValid, &promotable,
                                           unknownSlotClobbers, unknownGlobalClobbers)
            elif st.kind == msParam:
                if st.slot >= 0 && st.slot < localCount:
                    knownValid[st.slot] = false
                    ptrBase[st.slot] = -1
            elif st.kind == msStore:
                st.addrExpr = uirNoAliasRewriteExpr(st.addrExpr, ptrBase, knownVals, knownValid, promotable,
                                                    &funcChanged, forwardedLoads, mem2regLoads,
                                                    proofBackedChanges, proofBacked)
                st.expr = uirNoAliasRewriteExpr(st.expr, ptrBase, knownVals, knownValid, promotable,
                                                &funcChanged, forwardedLoads, mem2regLoads,
                                                proofBackedChanges, proofBacked)
                let baseSlot: int32 = uirNoAliasResolveAddrBaseSlot(st.addrExpr, ptrBase)
                if baseSlot >= 0 && baseSlot < localCount && promotable[baseSlot]:
                    let futureLoad: bool = uirNoAliasHasFutureLoad(blk, si + 1, baseSlot, ptrBase)
                    if futureLoad:
                        st.kind = msAssign
                        st.name = uirNoAliasEnsureName(st.name, baseSlot)
                        st.slot = baseSlot
                        st.addrExpr = nil
                        if uirNoAliasExprStable(st.expr):
                            knownVals[baseSlot] = st.expr
                            knownValid[baseSlot] = true
                        else:
                            knownValid[baseSlot] = false
                        if mem2regStores != nil:
                            *mem2regStores = *mem2regStores + 1
                        if proofBacked && proofBackedChanges != nil:
                            *proofBackedChanges = *proofBackedChanges + 1
                        funcChanged = true
                    elif uirNoAliasExprStable(st.expr):
                        knownVals[baseSlot] = st.expr
                        knownValid[baseSlot] = true
                    else:
                        knownValid[baseSlot] = false
                else:
                    if baseSlot >= 0 && baseSlot < localCount:
                        knownValid[baseSlot] = false
                    else:
                        if unknownSlotClobbers != nil:
                            *unknownSlotClobbers = *unknownSlotClobbers + 1
                        if unknownGlobalClobbers != nil:
                            *unknownGlobalClobbers = *unknownGlobalClobbers + 1
                        uirNoAliasInvalidateAll(&knownValid, &ptrBase, &promotable)
                blk.stmts[si] = st
                uirNoAliasApplyExprClobber(st.expr, njvlLite, ptrBase, &knownValid, &promotable,
                                           unknownSlotClobbers, unknownGlobalClobbers)
                uirNoAliasApplyExprClobber(st.addrExpr, njvlLite, ptrBase, &knownValid, &promotable,
                                           unknownSlotClobbers, unknownGlobalClobbers)
            else:
                st.expr = uirNoAliasRewriteExpr(st.expr, ptrBase, knownVals, knownValid, promotable,
                                                &funcChanged, forwardedLoads, mem2regLoads,
                                                proofBackedChanges, proofBacked)
                blk.stmts[si] = st
                uirNoAliasApplyExprClobber(st.expr, njvlLite, ptrBase, &knownValid, &promotable,
                                           unknownSlotClobbers, unknownGlobalClobbers)

            if njvlLite:
                uirNoAliasApplyKillLite(si, lastUse, &knownValid, &ptrBase, killEvents)

        if blk.term.kind == mtRet && blk.term.retExpr != nil:
            blk.term.retExpr = uirNoAliasRewriteExpr(blk.term.retExpr, ptrBase, knownVals, knownValid, promotable,
                                                     &funcChanged, forwardedLoads, mem2regLoads,
                                                     proofBackedChanges, proofBacked)
            uirNoAliasApplyExprClobber(blk.term.retExpr, njvlLite, ptrBase, &knownValid, &promotable,
                                       unknownSlotClobbers, unknownGlobalClobbers)
        elif blk.term.kind == mtCbr && blk.term.condExpr != nil:
            blk.term.condExpr = uirNoAliasRewriteExpr(blk.term.condExpr, ptrBase, knownVals, knownValid, promotable,
                                                      &funcChanged, forwardedLoads, mem2regLoads,
                                                      proofBackedChanges, proofBacked)
            uirNoAliasApplyExprClobber(blk.term.condExpr, njvlLite, ptrBase, &knownValid, &promotable,
                                       unknownSlotClobbers, unknownGlobalClobbers)

        if njvlLite:
            uirNoAliasApplyKillLite(blk.stmts.len, lastUse, &knownValid, &ptrBase, killEvents)

    if funcChanged && changedAny != nil:
        *changedAny = true
    return funcChanged

fn uirNoAliasEmitReport(forwardedLoads: int32, mem2regLoads: int32, mem2regStores: int32,
                        changedFuncs: int32, proofBackedChanges: int32,
                        proofCheckedFuncs: int32, proofSkippedFuncs: int32,
                        proofRequired: bool,
                        njvlLite: bool,
                        unknownSlotClobbers: int32,
                        unknownGlobalClobbers: int32,
                        killEvents: int32) =
    let f: os.File = os.get_stderr()
    os.write(f, "noalias_report\tforward_loads=")
    os.write(f, intToStr(forwardedLoads))
    os.write(f, "\tmem2reg_loads=")
    os.write(f, intToStr(mem2regLoads))
    os.write(f, "\tmem2reg_stores=")
    os.write(f, intToStr(mem2regStores))
    os.write(f, "\tchanged_funcs=")
    os.write(f, intToStr(changedFuncs))
    os.write(f, "\tproof_backed_changes=")
    os.write(f, intToStr(proofBackedChanges))
    os.write(f, "\tproof_checked_funcs=")
    os.write(f, intToStr(proofCheckedFuncs))
    os.write(f, "\tproof_skipped_funcs=")
    os.write(f, intToStr(proofSkippedFuncs))
    os.write(f, "\tproof_required=")
    os.write(f, intToStr(proofRequired ? 1 : 0))
    os.write(f, "\tnjvl_lite=")
    os.write(f, intToStr(njvlLite ? 1 : 0))
    os.write(f, "\tunknown_slot_clobbers=")
    os.write(f, intToStr(unknownSlotClobbers))
    os.write(f, "\tunknown_global_clobbers=")
    os.write(f, intToStr(unknownGlobalClobbers))
    os.write(f, "\tkill_events=")
    os.write(f, intToStr(killEvents))
    os.writeLine(f, "")
    os.c_fflush f

fn uirRunNoAliasPrep(module: UirModule, requireProof: bool): bool =
    if module == nil:
        return false
    let njvlLite: bool = uirNoAliasParseBoolEnv("UIR_NOALIAS_NJVL_LITE", true)
    var changedAny: bool = false
    var forwardedLoads: int32 = 0
    var mem2regLoads: int32 = 0
    var mem2regStores: int32 = 0
    var changedFuncs: int32 = 0
    var proofBackedChanges: int32 = 0
    var proofCheckedFuncs: int32 = 0
    var proofSkippedFuncs: int32 = 0
    var unknownSlotClobbers: int32 = 0
    var unknownGlobalClobbers: int32 = 0
    var killEvents: int32 = 0
    for fi in 0..<uirModuleFuncsLen(module):
        let funcView: UirFunc = uirModuleFuncAt(module, fi)
        if funcView == nil || uirFuncIsExtern(funcView):
            continue
        let func: UirCoreFunc = funcView
        let proofBacked: bool = func.highUirChecked && func.lowUirLowered
        if proofBacked:
            proofCheckedFuncs = proofCheckedFuncs + 1
        elif requireProof:
            proofSkippedFuncs = proofSkippedFuncs + 1
            continue
        if uirNoAliasRunFunc(func, &changedAny, &forwardedLoads, &mem2regLoads, &mem2regStores,
                             &proofBackedChanges, proofBacked, njvlLite,
                             &unknownSlotClobbers, &unknownGlobalClobbers, &killEvents):
            changedFuncs = changedFuncs + 1
    uirNoAliasEmitReport(forwardedLoads, mem2regLoads, mem2regStores, changedFuncs,
                         proofBackedChanges, proofCheckedFuncs, proofSkippedFuncs, requireProof,
                         njvlLite, unknownSlotClobbers, unknownGlobalClobbers, killEvents)
    return changedAny
