# UIR core builder import/package resolver helpers (split from uir_core_builder).
import std/os
import std/result
import std/strutils
import stage1/ast
import stage1/frontend_lib

fn resolverStripSpaces(s: str): str =
    if s == nil:
        return ""
    return strutils.strip(s)

fn strHasSuffix(s: str, suffix: str): bool =
    if s == nil || suffix == nil:
        return false
    let n: int32 = len(s)
    let m: int32 = len(suffix)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[n - m + i] != suffix[i]:
            return false
    return true

fn strHasPrefix(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    let n: int32 = len(s)
    let m: int32 = len(prefix)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[i] != prefix[i]:
            return false
    return true

fn strStripPrefix(s: str, prefix: str): str =
    if s == nil || prefix == nil:
        return ""
    let n: int32 = len(s)
    let m: int32 = len(prefix)
    if m == 0:
        return s
    if n < m:
        return ""
    for i in 0..<m:
        if s[i] != prefix[i]:
            return ""
    return str(ptr_add(void*(s), m))

fn indexOfChar(s: str, ch: char): int32 =
    if len(s) == 0:
        return -1
    for i in 0..<len(s):
        if s[i] == ch:
            return i
    return -1

fn indexOfCharFrom(s: str, ch: char, start0: int32): int32 =
    if len(s) == 0:
        return -1
    var start: int32 = start0
    if start < 0:
        start = 0
    let n: int32 = len(s)
    if start >= n:
        return -1
    for i in start..<n:
        if s[i] == ch:
            return i
    return -1

fn resolverSliceRange(s: str, start0: int32, end0: int32): str =
    if s == nil:
        return ""
    let n: int32 = len(s)
    if n <= 0:
        return ""
    var start: int32 = start0
    var endIdx: int32 = end0
    if start < 0:
        start = 0
    if endIdx >= n:
        endIdx = n - 1
    if start > endIdx:
        return ""
    let outLen: int32 = endIdx - start + 1
    let buf: void* = alloc(outLen + 1)
    if buf == nil:
        return ""
    for i in 0..<outLen:
        let dst: void* = ptr_add(buf, i)
        let pch: char* = char*(dst)
        *pch = s[start + i]
    setMem(ptr_add(buf, outLen), 0, 1)
    return str(buf)

fn parseQuotedValue(line: str): str =
    if line == nil:
        return ""
    if len(line) <= 0:
        return ""
    let first: int32 = indexOfCharFrom(line, '"', 0)
    if first >= 0:
        let second: int32 = indexOfCharFrom(line, '"', first + 1)
        if second > first:
            return resolverSliceRange(line, first + 1, second - 1)
    return ""

fn importPathDropChengPrefix(path: str): str =
    if len(path) == 0:
        return ""
    if strHasPrefix(path, "cheng/"):
        if len(path) <= 6:
            return ""
        return strStripPrefix(path, "cheng/")
    return path

fn packageNameFromRest(rest: str): str =
    let normalized: str = importPathDropChengPrefix(rest)
    if normalized == nil:
        return ""
    if len(normalized) == 0:
        return ""
    let slash: int32 = indexOfChar(normalized, '/')
    if slash <= 0:
        return ""
    # Avoid os.sliceStr in this hot path.
    let nameLen: int32 = slash
    let buf: void* = alloc(nameLen + 1)
    if buf == nil:
        return ""
    for i in 0..<nameLen:
        let dst: void* = ptr_add(buf, i)
        let pch: char* = char*(dst)
        *pch = normalized[i]
    setMem(ptr_add(buf, nameLen), 0, 1)
    let pkgName: str = str(buf)
    if pkgName == "std":
        return ""
    if pkgName == "core":
        return ""
    if pkgName == "system":
        return ""
    if pkgName == "ide":
        return ""
    if pkgName == "gui":
        return ""
    return pkgName

fn packageIdFromRest(rest: str): str =
    let name: str = packageNameFromRest(rest)
    if len(name) == 0:
        return ""
    if (name == "stdlib"):
        return ""
    return "pkg://cheng/" + name

fn packageIdFromManifest(manifestPath: str): str =
    if len(manifestPath) == 0:
        return ""
    if !frontend_lib.stage1_fileExists(manifestPath):
        return ""
    let content: str = frontend_lib.stage1_readFile(manifestPath)
    if len(content) == 0:
        return ""
    let contentLen: int32 = len(content)
    let key: str = "package_id"
    let keyLen: int32 = len(key)
    var start: int32 = 0
    for i in 0..contentLen:
        if i == contentLen || content[i] == '\n':
            if i > start:
                let line: str = resolverSliceRange(content, start, i - 1)
                let trimmed: str = resolverStripSpaces(line)
                if strHasPrefix(trimmed, key):
                    let trimmedLen: int32 = len(trimmed)
                    if trimmedLen == keyLen || trimmed[keyLen] == '=' || trimmed[keyLen] == ':' || trimmed[keyLen] == ' ':
                        let value: str = parseQuotedValue(trimmed)
                        if len(value) > 0:
                            return value
            start = i + 1
    return ""

fn packageIdMatches(manifestPath: str, expected: str): bool =
    if len(expected) == 0:
        return true
    let got: str = packageIdFromManifest manifestPath
    if len(got) == 0:
        return false
    return (got == expected)

fn pkgRootsFromEnv(): str[] =
    var out: str[]
    let single: str = os.getEnvDefault("PKG_ROOT", "")
    if len(single) > 0:
        let trimmedSingle: str = resolverStripSpaces(single)
        if len(trimmedSingle) > 0:
            add(out, trimmedSingle)
    let raw: str = os.getEnvDefault("PKG_ROOTS", "")
    if len(raw) > 0:
        let rawLen: int32 = len(raw)
        var hasCommaOrSemi: bool = false
        for k in 0..<rawLen:
            let c0: char = raw[k]
            if c0 == ',' || c0 == ';':
                hasCommaOrSemi = true
                break
        let useColon: bool = !hasCommaOrSemi
        var start: int32 = 0
        for i in 0..rawLen:
            if i == rawLen || raw[i] == ',' || raw[i] == ';' || (useColon && raw[i] == ':'):
                if i > start:
                    let part: str = resolverSliceRange(raw, start, i - 1)
                    let trimmed: str = resolverStripSpaces(part)
                    if len(trimmed) > 0:
                        add(out, trimmed)
                start = i + 1
    if out.len == 0:
        let home: str = os.getEnvDefault("HOME", "")
        if len(home) > 0:
            add(out, os.joinPath(home, ".cheng-packages"))
    return out

fn resolvePkgCandidate(base: str): str =
    if len(base) == 0:
        return ""
    var full: str = base
    if ! strHasSuffix(full, ".cheng"):
        full = full + ".cheng"
    if frontend_lib.stage1_fileExists(full):
        return full
    return ""

fn resolvePkgInRoot(pkgRoot: str, relInPkg: str, relForPkgRoot: str): str =
    if len(pkgRoot) == 0:
        return ""

    if len(relInPkg) > 0:
        var candidate: str = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "src"), relInPkg))
        if len(candidate) > 0:
            return candidate
        candidate = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "cheng"), relInPkg))
        if len(candidate) > 0:
            return candidate
        candidate = resolvePkgCandidate(os.joinPath(pkgRoot, relInPkg))
        if len(candidate) > 0:
            return candidate

    if len(relForPkgRoot) > 0:
        var legacy: str = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "src"), relForPkgRoot))
        if len(legacy) > 0:
            return legacy
        legacy = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "cheng"), relForPkgRoot))
        if len(legacy) > 0:
            return legacy
        legacy = resolvePkgCandidate(os.joinPath(pkgRoot, relForPkgRoot))
        if len(legacy) > 0:
            return legacy
    return ""

fn resolvePkgImport(root: str, rest: str): str =
    if len(root) == 0 || len(rest) == 0:
        return ""
    let expectedPkgId: str = packageIdFromRest(rest)
    let importPkgName: str = packageNameFromRest(rest)
    var relForPkgRoot: str = importPathDropChengPrefix(rest)
    if len(relForPkgRoot) == 0:
        relForPkgRoot = rest

    let manifest: str = os.joinPath(root, "cheng-package.toml")
    if frontend_lib.stage1_fileExists(manifest):
        if !packageIdMatches(manifest, expectedPkgId):
            return ""
        var relInPkg: str = relForPkgRoot
        if len(expectedPkgId) > 0 && len(importPkgName) > 0:
            let prefix: str = importPkgName + "/"
            if len(relInPkg) > len(prefix) && strHasPrefix(relInPkg, prefix):
                relInPkg = resolverSliceRange(relInPkg, len(prefix), len(relInPkg) - 1)
        return resolvePkgInRoot(root, relInPkg, relForPkgRoot)

    if len(expectedPkgId) > 0:
        if len(importPkgName) == 0:
            return ""
        let prefixedRoot: str = os.joinPath(root, "cheng-" + importPkgName)
        let prefixedManifest: str = os.joinPath(prefixedRoot, "cheng-package.toml")
        if frontend_lib.stage1_fileExists(prefixedManifest) && packageIdMatches(prefixedManifest, expectedPkgId):
            var relInPkgPref: str = relForPkgRoot
            let prefixPref: str = importPkgName + "/"
            if len(relInPkgPref) > len(prefixPref) && strHasPrefix(relInPkgPref, prefixPref):
                relInPkgPref = resolverSliceRange(relInPkgPref, len(prefixPref), len(relInPkgPref) - 1)
            let resolvedPref: str = resolvePkgInRoot(prefixedRoot, relInPkgPref, relForPkgRoot)
            if len(resolvedPref) > 0:
                return resolvedPref
        let plainRoot: str = os.joinPath(root, importPkgName)
        let plainManifest: str = os.joinPath(plainRoot, "cheng-package.toml")
        if frontend_lib.stage1_fileExists(plainManifest) && packageIdMatches(plainManifest, expectedPkgId):
            var relInPkgPlain: str = relForPkgRoot
            let prefixPlain: str = importPkgName + "/"
            if len(relInPkgPlain) > len(prefixPlain) && strHasPrefix(relInPkgPlain, prefixPlain):
                relInPkgPlain = resolverSliceRange(relInPkgPlain, len(prefixPlain), len(relInPkgPlain) - 1)
            let resolvedPlain: str = resolvePkgInRoot(plainRoot, relInPkgPlain, relForPkgRoot)
            if len(resolvedPlain) > 0:
                return resolvedPlain
        return ""

    let slash: int32 = indexOfChar(rest, '/')
    if slash > 0 && slash < len(rest) - 1:
        let pkgName: str = resolverSliceRange(rest, 0, slash - 1)
        let rel: str = resolverSliceRange(rest, slash + 1, len(rest) - 1)
        let pkgRoot: str = os.joinPath(root, pkgName)
        return resolvePkgInRoot(pkgRoot, rel, rest)
    return ""
