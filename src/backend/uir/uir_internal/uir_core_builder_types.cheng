# Shared builder-local types split from uir_core_builder.
import std/result
import std/hashmaps
import std/hashsets
import stage1/ast
import backend/uir/uir_internal/uir_core_types

type
    LocalEnv = ref
        names: str[]
        types: UirCoreType[]
        typeKeys: str[]
        callTargets: str[]
        active: bool[]
        scopeMarks: int32[]
        nameIndex: hashmaps.HashMapStrInt
        prevSlots: int32[]
    DeferFrame = ref
        bodies: Node[]
    LoopContext = ref
        breakLabel: str
        continueLabel: str
        deferDepth: int32
    BlockBuilder = ref
        env: LocalEnv
        module: UirCoreModule
        func: UirCoreFunc
        currentLabel: str
        currentStmts: UirCoreStmt[]
        labelCounter: int32
        objCursor: int32
        loopStack: LoopContext[]
        deferStack: DeferFrame[]

    DotAccess =
        addr: UirCoreExpr
        fieldTy: UirCoreType
        # Non-empty only when fieldTy == mtVoid (composite/inlined object field).
        objTypeName: str

    UirCorePhaseContractStats =
        highCheckedFuncs: int32
        highFallbackFuncs: int32
        highUnmappedFuncs: int32
        highNoProofFuncs: int32

    UirCoreGlobalInit = ref
        name: str
        ty: UirCoreType
        objTypeName: str
        initNode: Node
        filePath: str
        seqFixedElemType: Node
        seqFixedCapExpr: Node

    UirCoreBuildCtx = ref
        foundMain: bool
        traceEnabled: bool
        traceFnCount: int32
        traceGlobalCount: int32
        overloadedFnBases: hashsets.HashSetStr
        globalInits: UirCoreGlobalInit[]

fn Ok_DotAccess(value: DotAccess): Result[DotAccess] =
    var out: Result[DotAccess]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_DotAccess(err: str): Result[DotAccess] =
    var out: Result[DotAccess]
    out.ok = false
    out.err = ErrorNew(err)
    return out
