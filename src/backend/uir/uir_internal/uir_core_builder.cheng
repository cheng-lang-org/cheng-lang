# MIR builder from Stage1 AST (MVP subset).
import std/os
import std/result
import std/strings
import std/seqs
import std/system
import std/hashmaps
import std/hashsets
import cheng/stage1/lexer
import cheng/stage1/parser
import cheng/stage1/ast
import cheng/stage1/frontend_lib
import cheng/stage1/type_syntax_lowering
import cheng/stage1/semantics
import cheng/stage1/monomorphize
import cheng/stage1/c_profile_lowering
import cheng/stage1/ownership
import cheng/stage1/diagnostics
import cheng/backend/uir/uir_internal/uir_core_types

@importc("cheng_parse_f64_bits")
fn cheng_parse_f64_bits(s: str): int64

@importc("cheng_i64_to_f64_bits")
fn cheng_i64_to_f64_bits(x: int64): int64

@importc("cheng_u64_to_f64_bits")
fn cheng_u64_to_f64_bits(x: uint64): int64

@importc("cheng_f64_bits_to_i64")
fn cheng_f64_bits_to_i64(bits: int64): int64

@importc("cheng_f64_bits_to_u64")
fn cheng_f64_bits_to_u64(bits: int64): uint64

@importc("cheng_f32_bits_to_f64_bits")
fn cheng_f32_bits_to_f64_bits(bits: int32): int64

@importc("cheng_f64_bits_to_f32_bits")
fn cheng_f64_bits_to_f32_bits(bits: int64): int32

@importc("cheng_f32_bits_to_i64")
fn cheng_f32_bits_to_i64(bits: int32): int64

@importc("cheng_f32_bits_to_u64")
fn cheng_f32_bits_to_u64(bits: int32): uint64

type
    LocalEnv = ref
        names: str[]
        types: UirCoreType[]
        typeKeys: str[]
        callTargets: str[]
        active: bool[]
        scopeMarks: int32[]
        nameIndex: hashmaps.HashMapStrInt
        prevSlots: int32[]
    DeferFrame = ref
        bodies: Node[]
    LoopContext = ref
        breakLabel: str
        continueLabel: str
        deferDepth: int32
    BlockBuilder = ref
        env: LocalEnv
        module: UirCoreModule
        func: UirCoreFunc
        currentLabel: str
        currentStmts: UirCoreStmt[]
        labelCounter: int32
        objCursor: int32
        loopStack: LoopContext[]
        deferStack: DeferFrame[]

    DotAccess =
        addr: UirCoreExpr
        fieldTy: UirCoreType
        # Non-empty only when fieldTy == mtVoid (composite/inlined object field).
        objTypeName: str

    UirCorePhaseContractStats =
        highCheckedFuncs: int32
        highFallbackFuncs: int32
        highUnmappedFuncs: int32
        highNoProofFuncs: int32

fn Ok_DotAccess(value: DotAccess): Result[DotAccess] =
    var out: Result[DotAccess]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_DotAccess(err: str): Result[DotAccess] =
    var out: Result[DotAccess]
    out.ok = false
    out.err = ErrorNew(err)
    return out

var
    uirCoreGlobalObjTypeIndex: hashmaps.HashMapStrInt
    uirCoreGlobalObjTypeNames: str[]
    uirCoreGlobalObjTypeReady: bool = false
    uirCoreGlobalTypeKeyIndex: hashmaps.HashMapStrInt
    uirCoreGlobalTypeKeyNames: str[]
    uirCoreGlobalTypeKeyReady: bool = false
    uirCoreInlineObjFieldTypeIndex: hashmaps.HashMapStrInt
    uirCoreInlineObjFieldTypeNames: str[]
    uirCoreInlineObjFieldTypeReady: bool = false
    uirCoreObjFieldTypeKeyIndex: hashmaps.HashMapStrInt
    uirCoreObjFieldTypeKeyNames: str[]
    uirCoreObjFieldTypeKeyReady: bool = false
    uirCoreTupleFieldIndex: hashmaps.HashMapStrInt
    uirCoreTupleFieldIndexReady: bool = false
    uirCoreObjAliasIndex: hashmaps.HashMapStrInt
    uirCoreObjAliasNames: str[]
    uirCoreObjAliasReady: bool = false
    uirCoreDupFnBases: hashsets.HashSetStr
    uirCoreDupFnBasesReady: bool = false
    uirCoreDupGlobalNames: hashsets.HashSetStr
    uirCoreDupGlobalNamesReady: bool = false
    uirCoreCalleeCandidates: hashmaps.HashMapStrSeqInt
    uirCoreCalleeCandidatesReady: bool = false

    uirCore_funcIndex_cache_module: UirCoreModule
    uirCore_funcIndex_cache: hashmaps.HashMapStrInt
    uirCore_funcIndex_cache_len: int32
    uirCore_funcIndex_cache_ready: bool = false

    uirCore_globalIndex_cache_module: UirCoreModule
    uirCore_globalIndex_cache: hashmaps.HashMapStrInt
    uirCore_globalIndex_cache_len: int32
    uirCore_globalIndex_cache_ready: bool = false

var
    uirCorePluginEnableCached: int32 = -1
    uirCorePluginPathsCached: str[]
    uirCorePluginPathsCachedReady: bool = false
    uirCorePluginMeteringCached: str = nil

fn backendSkipGlobalInit(): bool =
    return envIsTrue "BACKEND_SKIP_GLOBAL_INIT"

fn backendAllowNoMainByEmit(): bool =
    let emitMode: str = lowerAscii(backendStripSpaces(os.getEnvDefault("BACKEND_EMIT", "")))
    if emitMode == "obj" || emitMode == "object" || emitMode == "o":
        return true
    let outPath: str = backendStripSpaces(os.getEnvDefault("BACKEND_OUTPUT", ""))
    if outPath != nil && len(outPath) >= 2 && outPath[len(outPath) - 2] == '.' && outPath[len(outPath) - 1] == 'o':
        return true
    if outPath != nil && len(outPath) >= 4 &&
       outPath[len(outPath) - 4] == '.' &&
       (outPath[len(outPath) - 3] == 'o' || outPath[len(outPath) - 3] == 'O') &&
       (outPath[len(outPath) - 2] == 'b' || outPath[len(outPath) - 2] == 'B') &&
       (outPath[len(outPath) - 1] == 'j' || outPath[len(outPath) - 1] == 'J'):
        return true
    return false

fn uirCorePluginEnabled(): bool =
    if uirCorePluginEnableCached >= 0:
        return uirCorePluginEnableCached == 1
    let raw: str = backendStripSpaces(getEnv "PLUGIN_ENABLE")
    if raw == nil || len(raw) == 0 || raw == "1" || raw == "true" || raw == "yes":
        uirCorePluginEnableCached = 1
        return true
    if raw == "0" || raw == "false" || raw == "no":
        uirCorePluginEnableCached = 0
        return false
    uirCorePluginEnableCached = 1
    return true

fn uirCorePluginPathsFromEnv(): str[] =
    if uirCorePluginPathsCachedReady:
        return uirCorePluginPathsCached
    var out: str[]
    let legacy: str = getEnv "PLUGIN_PATH"
    if legacy != nil && len(legacy) > 0:
        let legacyTrimmed: str = backendStripSpaces(legacy)
        if len(legacyTrimmed) > 0:
            add(out, legacyTrimmed)
    let raw: str = getEnv "PLUGIN_PATHS"
    if raw != nil && len(raw) > 0:
        var hasCommaOrSemi: bool = false
        for ki in 0..<len(raw):
            let ck: char = raw[ki]
            if ck == ',' || ck == ';':
                hasCommaOrSemi = true
                break
        let useColon: bool = !hasCommaOrSemi
        var start: int32 = 0
        for i in 0..len(raw):
            let c: char = (i < len(raw)) ? raw[i] : char(0)
            if i == len(raw) || c == ',' || c == ';' || (useColon && c == ':'):
                if i > start:
                    let part: str = os.sliceStr(raw, start, i - 1)
                    let trimmed: str = backendStripSpaces(part)
                    if len(trimmed) > 0:
                        add(out, trimmed)
                start = i + 1
    uirCorePluginPathsCached = out
    uirCorePluginPathsCachedReady = true
    return out

fn uirCorePluginMeteringId(): str =
    let cached: str = uirCorePluginMeteringCached
    if cached != nil:
        return cached
    let raw: str = getEnv "METERING_PLUGIN"
    if raw == nil:
        return ""
    let trimmed: str = backendStripSpaces(raw)
    uirCorePluginMeteringCached = trimmed
    return trimmed

fn uirCoreResolvePluginImportCandidate(candidate: str): str =
    if candidate == nil || len(candidate) == 0:
        return ""
    if frontend_lib.stage1_fileExists(candidate):
        return candidate
    var withExt: str = candidate
    if !strHasSuffix(withExt, ".cheng"):
        withExt = candidate + ".cheng"
    if frontend_lib.stage1_fileExists(withExt):
        return withExt
    return ""

fn uirCoreResolvePluginImportPath(path: str): str =
    if !uirCorePluginEnabled():
        return ""
    if path == nil || len(path) == 0:
        return ""
    if !strHasPrefix(path, "cheng/web/") && !strHasPrefix(path, "cheng/decentralized/"):
        return ""
    let roots: str[] = uirCorePluginPathsFromEnv()
    if roots.len == 0:
        return ""
    let relPath: str = importPathDropChengPrefix(path)
    for i in 0..<roots.len:
        let root: str = roots[i]
        if root == nil || len(root) == 0:
            continue
        let c0: str = os.joinPath(root, path)
        let h0: str = uirCoreResolvePluginImportCandidate(c0)
        if len(h0) > 0:
            return h0
        let c1: str = os.joinPath(root, "src", path)
        let h1: str = uirCoreResolvePluginImportCandidate(c1)
        if len(h1) > 0:
            return h1
        let c2: str = os.joinPath(root, "cheng", path)
        let h2: str = uirCoreResolvePluginImportCandidate(c2)
        if len(h2) > 0:
            return h2
        let c3: str = os.joinPath(root, relPath)
        let h3: str = uirCoreResolvePluginImportCandidate(c3)
        if len(h3) > 0:
            return h3
        let c4: str = os.joinPath(root, "src", relPath)
        let h4: str = uirCoreResolvePluginImportCandidate(c4)
        if len(h4) > 0:
            return h4
        let c5: str = os.joinPath(root, "cheng", relPath)
        let h5: str = uirCoreResolvePluginImportCandidate(c5)
        if len(h5) > 0:
            return h5
    return ""

fn uirCoreApplyAstPluginHooks(filePath: str, root: Node): Node =
    if root == nil:
        return root
    if !uirCorePluginEnabled():
        return root
    return root

fn uirCoreApplyMirPluginHooks(filePath: str, root: Node): Node =
    if root == nil:
        return root
    if !uirCorePluginEnabled():
        return root
    return root

fn uirCoreApplyUirPluginHooks(filePath: str, mod: UirCoreModule) =
    if !uirCorePluginEnabled():
        return
    if mod == nil:
        return
    return

fn uirCoreIsOne(raw: str): bool =
    return raw != nil && len(raw) == 1 && raw[0] == char('1')

fn uirCoreParseInt32(raw: str, defaultValue: int32): int32 =
    if raw == nil || len(raw) == 0:
        return defaultValue
    let n: int32 = len(raw)
    var i: int32 = 0
    var neg: bool = false
    if raw[0] == '-':
        neg = true
        i = 1
    if i >= n:
        return defaultValue
    var v: int64 = 0
    for __for_guard_i in 0..<n:
        if !(i < n):
            break
        let c: char = raw[i]
        if c < '0' || c > '9':
            return defaultValue
        v = v * 10 + int64(int32(c) - int32('0'))
        i = i + 1
    if neg:
        v = -v
    return int32(v)

fn uirCoreGenericSpecBudget(): int32 =
    let raw: str = backendStripSpaces(getEnv "GENERIC_SPEC_BUDGET")
    if raw == nil || len(raw) == 0:
        return 0
    let parsed: int32 = uirCoreParseInt32(raw, 0)
    return parsed

fn uirCoreGenericModeNormalized(): str =
    let raw0: str = lowerAscii(backendStripSpaces(getEnv "GENERIC_MODE"))
    if raw0 == nil || len(raw0) == 0:
        return "dict"
    return raw0

fn uirCoreBorrowIrNormalized(): str =
    let raw0: str = lowerAscii(backendStripSpaces(getEnv "BORROW_IR"))
    if raw0 == nil || len(raw0) == 0:
        return "mir"
    return raw0

fn uirCoreGenericLoweringNormalized(): str =
    let raw0: str = lowerAscii(backendStripSpaces(getEnv "GENERIC_LOWERING"))
    if raw0 == nil || len(raw0) == 0:
        return "mir_hybrid"
    return raw0

fn uirCoreBorrowIrSupported(mode: str): bool =
    return mode == "mir" || mode == "stage1"

fn uirCoreGenericLoweringSupported(mode: str): bool =
    return mode == "mir_hybrid" || mode == "mir_dict"

fn uirCoreDictHelperClosureEnabled(): bool =
    let mode: str = uirCoreGenericModeNormalized()
    return mode == "dict" || mode == "dictionary"

fn uirCoreShouldSkipMonoPass(): bool =
    let mode: str = uirCoreGenericModeNormalized()
    if mode == "dict" || mode == "dictionary":
        # Dict mode keeps mono off by default for compile-time stability.
        # Local env can opt back into mono for debug/bring-up.
        let forceMonoDict: bool = envIsTrue "STAGE1_FORCE_MONO_DICT"
        var skipDict: bool = true
        if forceMonoDict:
            skipDict = false
        if os.getEnvDefault("BACKEND_DEBUG_STAGE1_PIPE", "") == "1":
            let f: os.File = os.get_stderr()
            os.writeLine(f, "[backend] stage1: skip_mono mode=" + mode +
                         " skip_dict=" + (skipDict ? "1" : "0"))
            os.c_fflush f
        return skipDict
    if mode == "hybrid":
        let budget: int32 = uirCoreGenericSpecBudget()
        let forceMonoHybrid: bool = envIsTrue "STAGE1_FORCE_MONO_HYBRID"
        # Budget <= 0 keeps a dict-like fast path; >0 allows controlled
        # mono re-entry for small/explicitly budgeted instantiations.
        let skipDict: bool = !forceMonoHybrid && budget <= 0
        if os.getEnvDefault("BACKEND_DEBUG_STAGE1_PIPE", "") == "1":
            let f: os.File = os.get_stderr()
            os.writeLine(f, "[backend] stage1: skip_mono mode=" + mode +
                         " budget=" + intToStr(budget) +
                         " skip=" + (skipDict ? "1" : "0"))
            os.c_fflush f
        return skipDict
    return false

fn uirCoreIsOrcMode(mm: str): bool =
    return mm != nil && len(mm) == 3 &&
           mm[0] == char('o') && mm[1] == char('r') && mm[2] == char('c')

fn uirCoreEnsurePolicyDiag(diags: var Diagnostic[], filePath: str, msg: str) =
    if hasError(diags):
        return
    var d: Diagnostic
    d.severity = svError
    d.filename = filePath
    d.line = 1
    d.col = 1
    d.message = msg
    add(diags, d)

fn uirCoreFileLikelyHasPointerSyntax(path: str): bool =
    if path == nil || len(path) == 0:
        return false
    let content: str = stage1_readFile(path)
    if content == nil || len(content) == 0:
        return false
    if strContains(content, "ptr_add(") || strContains(content, "load_ptr(") || strContains(content, "store_ptr("):
        return true
    if strContains(content, "alloc(") || strContains(content, "dealloc("):
        return true
    if strContains(content, "ptr[") || strContains(content, "ref["):
        return true
    var colonSeen: bool = false
    var sawAssign: bool = false
    for i in 0..<len(content):
        let ch: char = content[i]
        if ch == '\n' || ch == '\r':
            colonSeen = false
            sawAssign = false
            continue
        if ch == ':':
            colonSeen = true
            sawAssign = false
            continue
        if ch == '=':
            sawAssign = true
            continue
        if ch == '*' && colonSeen && !sawAssign:
            return true
    return false

fn uirCoreHasDefaultSpawnCall(content: str): bool =
    if content == nil || len(content) < 6:
        return false
    let n: int32 = len(content)
    for i in 0..(n - 6):
        if content[i] == 's' &&
           content[i + 1] == 'p' &&
           content[i + 2] == 'a' &&
           content[i + 3] == 'w' &&
           content[i + 4] == 'n' &&
           content[i + 5] == '(':
            if i > 0:
                let prev: char = content[i - 1]
                if prev == '.' || prev == '_' ||
                   (prev >= 'a' && prev <= 'z') ||
                   (prev >= 'A' && prev <= 'Z') ||
                   (prev >= '0' && prev <= '9'):
                    continue
            return true
    return false

fn uirCoreFileLikelyUsesRawSpawn(path: str): bool =
    if path == nil || len(path) == 0:
        return false
    let content: str = stage1_readFile(path)
    if content == nil || len(content) == 0:
        return false
    if !uirCoreHasDefaultSpawnCall(content):
        return false
    if strContains(content, "void*") || strContains(content, "void *"):
        return true
    if strContains(content, "fn_ptr") || strContains(content, "fnPtr"):
        return true
    return false

fn uirCorePathLooksStdModule(path: str): bool =
    if path == nil || len(path) == 0:
        return false
    if strContains(path, "src/std/") || strContains(path, "src\\std\\"):
        return true
    return false

fn uirCoreStdNoPointerEnabled(): bool =
    let stdNoPtrEnv: str = getEnv "STAGE1_STD_NO_POINTERS"
    if uirCoreIsOne(stdNoPtrEnv):
        return true
    if stdNoPtrEnv == "0":
        return false
    let abiEnv: str = getEnv "ABI"
    return abiEnv == "v2_noptr"

fn uirCoreStage1StdNoPointerPrecheck(root: Node, inPath: str, diags: var Diagnostic[]): bool =
    if !uirCoreStdNoPointerEnabled():
        return false
    var ctx: SemCtx
    initSemCtxInPlace(ctx)
    ctx.diags = diags
    ctx.filename = inPath
    var hits: int32 = semCheckStdNoPointerPolicy(ctx, root)
    # Heuristic fallback must honor std policy exemptions; otherwise internal
    # bridge modules (explicitly exempt) are rejected in strict bootstrap.
    if hits <= 0 &&
       uirCorePathLooksStdModule(inPath) &&
       !semIsStdPointerPolicyExempt(inPath) &&
       uirCoreFileLikelyHasPointerSyntax(inPath):
        hits = 1
    diags = ctx.diags
    if hits > 0:
        uirCoreEnsurePolicyDiag(diags, inPath, "std policy: pointer types are forbidden in standard library")
    return hits > 0

fn uirCoreStage1NoPointerNonCAbiPrecheck(root: Node, inPath: str, diags: var Diagnostic[]): bool =
    let nonCAbiNoPtrEnv: str = getEnv "STAGE1_NO_POINTERS_NON_C_ABI"
    if !uirCoreIsOne(nonCAbiNoPtrEnv):
        return false
    var ctx: SemCtx
    initSemCtxInPlace(ctx)
    ctx.diags = diags
    ctx.filename = inPath
    var hits: int32 = semCheckNoPointerNonCAbiPolicy(ctx, root)
    # Heuristic fallback must use the same scope gate as semantic checks.
    # Otherwise compiler-internal modules are flagged even when
    # STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0.
    if hits <= 0 &&
       semPointerPolicyShouldCheckNonCAbi(inPath) &&
       uirCoreFileLikelyHasPointerSyntax(inPath):
        hits = 1
    diags = ctx.diags
    if hits > 0:
        uirCoreEnsurePolicyDiag(diags, inPath, "no-pointer policy: pointer types are forbidden outside C ABI modules")
    return hits > 0

fn uirCoreCalleeCandidatesReset() =
    uirCoreCalleeCandidates = hashmaps.hashMapStrSeqIntInit(2048)
    uirCoreCalleeCandidatesReady = true

fn uirCoreCalleeCandidatesGet(mod: UirCoreModule, baseName: str): int32[] =
    var out: int32[]
    if mod == nil || baseName == nil || len(baseName) == 0:
        return out
    if !uirCoreCalleeCandidatesReady:
        uirCoreCalleeCandidatesReset()
    var found: bool = false
    let cached: int32[] = hashmaps.hashMapStrSeqIntGet(uirCoreCalleeCandidates, baseName, &found)
    if found:
        if cached.len > 0:
            let meta: int32 = cached[cached.len - 1]
            if meta < 0:
                let cachedLen: int32 = -1 - meta
                if cachedLen == mod.funcs.len:
                    return cached
        # Cache entry missing/stale metadata: rebuild.

    out.cap = 8
    let baseSym: str = backendSanitizeLinkName(baseName)
    let overloadPrefix: str = baseSym + uirCoreFuncSigMarker()
    let dupPrefix: str = baseSym + "__cheng_mod_"
    let instPrefix: str = baseSym + "_"
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        if f == nil || f.name == nil:
            continue
        if (f.name == baseName) ||
           uirCoreStrStartsWith(f.name, overloadPrefix) ||
           uirCoreStrStartsWith(f.name, dupPrefix):
            add(out, i)
            continue
        if uirCoreStrStartsWith(f.name, instPrefix):
            # Avoid double-counting "__cheng_sig_" / "__cheng_mod_" candidates; both start with `baseSym + "_"`.
            if uirCoreStrStartsWith(f.name, overloadPrefix) || uirCoreStrStartsWith(f.name, dupPrefix):
                continue
            # Skip names that start with a second underscore (e.g. `echo__cheng_sig_*`).
            if len(f.name) > len(instPrefix) && f.name[len(instPrefix)] == '_':
                continue
            add(out, i)

    # Cache version marker (negative sentinel): -1 - mod.funcs.len
    add(out, -1 - mod.funcs.len)
    hashmaps.hashMapStrSeqIntPutSeq(&uirCoreCalleeCandidates, baseName, out)
    return out

type
    UirCoreProfileState = ref
        enabled: bool
        startNs: int64
        lastNs: int64

fn uirCoreProfileInit(): UirCoreProfileState =
    let enabled: bool = envIsTrue "UIR_PROFILE"
    if !enabled:
        return nil
    var p: UirCoreProfileState
    new p
    p.enabled = true
    p.startNs = cheng_monotime_ns()
    p.lastNs = p.startNs
    return p

fn uirCoreProfileStep(p: UirCoreProfileState, name: str) =
    if p == nil || !p.enabled:
        return
    let now: int64 = cheng_monotime_ns()
    let stepMs: int64 = (now - p.lastNs) / 1000000
    let totalMs: int64 = (now - p.startNs) / 1000000
    p.lastNs = now
    # Write directly to stderr to avoid fork-buffer duplication.
    let f: os.File = os.get_stderr()
    os.write(f, "uir_profile\t")
    os.write(f, name)
    os.write(f, "\tstep_ms=")
    os.write(f, int64ToStr(stepMs))
    os.write(f, "\ttotal_ms=")
    os.writeLine(f, int64ToStr(totalMs))
    os.c_fflush f

fn uirCoreGlobalObjTypesReset() =
    uirCoreGlobalObjTypeIndex = hashmaps.hashMapStrIntInit(256)
    uirCoreGlobalObjTypeNames.len = 0
    uirCoreGlobalObjTypeNames.cap = 128
    uirCoreGlobalObjTypeReady = true

fn uirCoreGlobalTypeKeysReset() =
    uirCoreGlobalTypeKeyIndex = hashmaps.hashMapStrIntInit(256)
    uirCoreGlobalTypeKeyNames.len = 0
    uirCoreGlobalTypeKeyNames.cap = 128
    uirCoreGlobalTypeKeyReady = true

fn uirCoreInlineObjFieldTypesReset() =
    uirCoreInlineObjFieldTypeIndex = hashmaps.hashMapStrIntInit(512)
    uirCoreInlineObjFieldTypeNames.len = 0
    uirCoreInlineObjFieldTypeNames.cap = 256
    uirCoreInlineObjFieldTypeReady = true

fn uirCoreObjFieldTypeKeysReset() =
    uirCoreObjFieldTypeKeyIndex = hashmaps.hashMapStrIntInit(1024)
    uirCoreObjFieldTypeKeyNames.len = 0
    uirCoreObjFieldTypeKeyNames.cap = 512
    uirCoreObjFieldTypeKeyReady = true

fn uirCoreTupleFieldIndicesReset() =
    uirCoreTupleFieldIndex = hashmaps.hashMapStrIntInit(1024)
    uirCoreTupleFieldIndexReady = true

fn uirCoreObjAliasesReset() =
    uirCoreObjAliasIndex = hashmaps.hashMapStrIntInit(512)
    uirCoreObjAliasNames.len = 0
    uirCoreObjAliasNames.cap = 256
    uirCoreObjAliasReady = true

fn uirCoreHashMapStrIntGetCompat(m: hashmaps.HashMapStrInt, key: str, found: var bool): int32 =
    if key == nil || len(key) == 0 || m.mask == 0:
        found = false
        return -1
    if m.states.len <= 0 || m.keys.len <= 0 || m.vals.len <= 0:
        found = false
        return -1
    var mask: int32 = int32(m.mask)
    if mask < 0:
        found = false
        return -1
    if mask >= m.states.len || mask >= m.keys.len || mask >= m.vals.len:
        let cap0: int32 = m.states.len
        if m.keys.len < cap0 || m.vals.len < cap0:
            found = false
            return -1
        mask = cap0 - 1
    if mask < 0:
        found = false
        return -1
    var probe: int32 = int32(hashmaps.hashMapHash64StrMeta(key) & uint64(mask))
    var scanned: int32 = 0
    let __for_start_scanned_compat = scanned
    for __for_scanned_compat in __for_start_scanned_compat..mask:
        scanned = __for_scanned_compat
        let st: uint8 = m.states[probe]
        if st == uint8(0):
            found = false
            return -1
        if hashmaps.hashMapStrEq(m.keys[probe], key):
            found = true
            return m.vals[probe]
        probe = (probe + 1) & mask
        scanned = scanned + 1
    found = false
    return -1

fn uirCoreOwnershipEngineNormalized(): str =
    let raw: str = lowerAscii(backendStripSpaces(getEnv "STAGE1_OWNERSHIP_ENGINE"))
    if raw == nil || len(raw) == 0:
        return "scan"
    if raw == "legacy":
        return "legacy"
    if raw == "scan":
        return "scan"
    return "scan"

fn uirCoreOwnershipProofNodeWeight(kind: NodeKind): int32 =
    if kind == nkAsgn || kind == nkFastAsgn || kind == nkCall ||
       kind == nkReturn || kind == nkYield ||
       kind == nkDerefExpr || kind == nkHiddenDeref || kind == nkDotExpr || kind == nkBracketExpr:
        return 2
    if kind == nkVar || kind == nkLet || kind == nkFor || kind == nkWhile ||
       kind == nkIf || kind == nkWhen || kind == nkCase || kind == nkStmtList || kind == nkBlock:
        return 1
    return 0

fn uirCoreOwnershipProofCount(n: Node): int32 =
    if n == nil:
        return 0
    var total: int32 = uirCoreOwnershipProofNodeWeight(n.kind)
    for i in 0..<kidCount(n):
        total = total + uirCoreOwnershipProofCount(kid(n, i))
    return total

fn uirCoreFuncSyntheticByName(funcName: str): bool =
    if funcName == nil || len(funcName) == 0:
        return true
    if uirCoreStrStartsWith(funcName, "__cheng_"):
        return true
    if uirCoreStrIndexOf(funcName, "__cheng_mod_") >= 0:
        return true
    if uirCoreStrIndexOf(funcName, uirCoreFuncSigMarker()) >= 0:
        return true
    return false

fn uirCoreFuncOwnershipProofScore(func: UirCoreFunc): int32 =
    if func == nil || func.isExtern:
        return 0
    if func.blocks.len <= 0:
        return 0
    var score: int32 = 0
    for bi in 0..<func.blocks.len:
        let blk: UirCoreBlock = func.blocks[bi]
        if blk == nil:
            continue
        score = score + blk.stmts.len
        if blk.term.kind == mtRet && blk.term.retExpr != nil:
            score = score + 1
        elif blk.term.kind == mtCbr && blk.term.condExpr != nil:
            score = score + 1
    return score

fn uirCoreApplyOwnershipPhaseContract(module: UirCoreModule, skipOwnership: bool, borrowIrMode: str): UirCorePhaseContractStats =
    var st: UirCorePhaseContractStats
    if module == nil:
        return st
    let skipReason: str = skipOwnership ? (borrowIrMode == "mir" ? "mir_borrow_skipped" : "ownership_skipped") : ""
    for i in 0..<module.funcs.len:
        let f: UirCoreFunc = module.funcs[i]
        if f == nil || f.isExtern:
            continue
        var highChecked: bool = false
        var fallbackReason: str = ""
        if skipOwnership:
            fallbackReason = skipReason
        else:
            let proofCount: int32 = uirCoreFuncOwnershipProofScore(f)
            if proofCount > 0 && !uirCoreFuncSyntheticByName(f.name):
                highChecked = true
            elif proofCount == 0:
                fallbackReason = "high_uir_ownership_no_proof"
                st.highNoProofFuncs = st.highNoProofFuncs + 1
            else:
                fallbackReason = "high_uir_ownership_synthetic"
                st.highUnmappedFuncs = st.highUnmappedFuncs + 1
        if highChecked:
            st.highCheckedFuncs = st.highCheckedFuncs + 1
        else:
            st.highFallbackFuncs = st.highFallbackFuncs + 1
        uirCoreFuncSetPhaseContract(f, uirCorePhaseLowTag(), highChecked, true, fallbackReason)
    return st

fn uirCoreInlineObjFieldTypePut(parentType: str, fieldName: str, objTypeName: str) =
    if parentType == nil || len(parentType) == 0 || fieldName == nil || len(fieldName) == 0 || objTypeName == nil || len(objTypeName) == 0:
        return
    if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && parentType == "ProtoBuffer" && fieldName == "out":
        echo("[backend] debugOverloadDot: put inline field parent='ProtoBuffer' field='out' objType='" + objTypeName + "'")
    if !uirCoreInlineObjFieldTypeReady:
        uirCoreInlineObjFieldTypesReset()
    let key: str = parentType + "::" + fieldName
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreInlineObjFieldTypeIndex, key, found)
    if idx >= 0 && idx < uirCoreInlineObjFieldTypeNames.len:
        mbWriteStr(uirCoreInlineObjFieldTypeNames, idx, objTypeName)
        return
    if found:
        if idx >= 0 && idx < uirCoreInlineObjFieldTypeNames.len:
            mbWriteStr(uirCoreInlineObjFieldTypeNames, idx, objTypeName)
        return
    let newIdx: int32 = uirCoreInlineObjFieldTypeNames.len
    add(uirCoreInlineObjFieldTypeNames, objTypeName)
    hashmaps.hashMapStrIntPut(uirCoreInlineObjFieldTypeIndex, key, newIdx)

fn uirCoreInlineObjFieldTypeGet(parentType: str, fieldName: str): str =
    if parentType == nil || len(parentType) == 0 || fieldName == nil || len(fieldName) == 0 || !uirCoreInlineObjFieldTypeReady:
        return ""
    let key: str = parentType + "::" + fieldName
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreInlineObjFieldTypeIndex, key, found)
    if idx < 0 || idx >= uirCoreInlineObjFieldTypeNames.len:
        return ""
    return get_string(uirCoreInlineObjFieldTypeNames, idx)

fn uirCoreObjFieldTypeKeyPut(parentType: str, fieldName: str, fieldTypeKey: str) =
    if parentType == nil || len(parentType) == 0 || fieldName == nil || len(fieldName) == 0 || fieldTypeKey == nil || len(fieldTypeKey) == 0:
        return
    if !uirCoreObjFieldTypeKeyReady:
        uirCoreObjFieldTypeKeysReset()
    let key: str = parentType + "::" + fieldName
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreObjFieldTypeKeyIndex, key, found)
    if idx >= 0 && idx < uirCoreObjFieldTypeKeyNames.len:
        mbWriteStr(uirCoreObjFieldTypeKeyNames, idx, fieldTypeKey)
        return
    if found:
        if idx >= 0 && idx < uirCoreObjFieldTypeKeyNames.len:
            mbWriteStr(uirCoreObjFieldTypeKeyNames, idx, fieldTypeKey)
        return
    let newIdx: int32 = uirCoreObjFieldTypeKeyNames.len
    add(uirCoreObjFieldTypeKeyNames, fieldTypeKey)
    hashmaps.hashMapStrIntPut(uirCoreObjFieldTypeKeyIndex, key, newIdx)

fn uirCoreObjFieldTypeKeyGet(parentType: str, fieldName: str): str =
    if parentType == nil || len(parentType) == 0 || fieldName == nil || len(fieldName) == 0 || !uirCoreObjFieldTypeKeyReady:
        return ""
    let key: str = parentType + "::" + fieldName
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreObjFieldTypeKeyIndex, key, found)
    if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && parentType == "ProtoBuffer" && fieldName == "out":
        let foundCompat: bool = idx >= 0
        echo("[backend] debugOverloadDot: keyGetCompat key='" + key + "' found=" + (foundCompat ? "1" : "0") +
             " idx=" + intToStr(idx) + " namesLen=" + intToStr(uirCoreObjFieldTypeKeyNames.len))
    if idx < 0 || idx >= uirCoreObjFieldTypeKeyNames.len:
        return ""
    return get_string(uirCoreObjFieldTypeKeyNames, idx)

fn uirCoreTupleFieldIndexPut(tupleKey: str, fieldName: str, idx0: int32) =
    if tupleKey == nil || len(tupleKey) == 0 || fieldName == nil || len(fieldName) == 0 || idx0 < 0:
        return
    if !uirCoreTupleFieldIndexReady:
        uirCoreTupleFieldIndicesReset()
    let key: str = tupleKey + "::" + fieldName
    var found: bool = false
    let existing: int32 = uirCoreHashMapStrIntGetCompat(uirCoreTupleFieldIndex, key, found)
    if existing >= 0:
        # Structural tuple types may share the same key without field labels. If a label maps to
        # different indices, treat it as ambiguous.
        if existing != idx0 && existing != -2:
            hashmaps.hashMapStrIntPut(uirCoreTupleFieldIndex, key, -2)
        return
    hashmaps.hashMapStrIntPut(uirCoreTupleFieldIndex, key, idx0)

fn uirCoreTupleFieldIndexGet(tupleKey: str, fieldName: str): int32 =
    if tupleKey == nil || len(tupleKey) == 0 || fieldName == nil || len(fieldName) == 0 || !uirCoreTupleFieldIndexReady:
        return -1
    let key: str = tupleKey + "::" + fieldName
    var found: bool = false
    let v: int32 = uirCoreHashMapStrIntGetCompat(uirCoreTupleFieldIndex, key, found)
    if v < 0:
        return -1
    return v

fn uirCoreGlobalObjTypePut(name: str, objTypeName: str) =
    if name == nil || len(name) == 0 || objTypeName == nil || len(objTypeName) == 0:
        return
    if !uirCoreGlobalObjTypeReady:
        uirCoreGlobalObjTypesReset()
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreGlobalObjTypeIndex, name, found)
    if idx >= 0 && idx < uirCoreGlobalObjTypeNames.len:
        mbWriteStr(uirCoreGlobalObjTypeNames, idx, objTypeName)
        return
    if found:
        if idx >= 0 && idx < uirCoreGlobalObjTypeNames.len:
            mbWriteStr(uirCoreGlobalObjTypeNames, idx, objTypeName)
        return
    let newIdx: int32 = uirCoreGlobalObjTypeNames.len
    add(uirCoreGlobalObjTypeNames, objTypeName)
    hashmaps.hashMapStrIntPut(uirCoreGlobalObjTypeIndex, name, newIdx)

fn uirCoreGlobalObjTypeGet(name: str): str =
    if name == nil || len(name) == 0 || !uirCoreGlobalObjTypeReady:
        return ""
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreGlobalObjTypeIndex, name, found)
    if idx < 0 || idx >= uirCoreGlobalObjTypeNames.len:
        return ""
    return get_string(uirCoreGlobalObjTypeNames, idx)

fn uirCoreGlobalTypeKeyPut(name: str, typeKey0: str) =
    if name == nil || len(name) == 0 || typeKey0 == nil || len(typeKey0) == 0:
        return
    if !uirCoreGlobalTypeKeyReady:
        uirCoreGlobalTypeKeysReset()
    let typeKey: str = backendStripSpaces(typeKey0)
    if typeKey == nil || len(typeKey) == 0:
        return
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreGlobalTypeKeyIndex, name, found)
    if idx >= 0 && idx < uirCoreGlobalTypeKeyNames.len:
        mbWriteStr(uirCoreGlobalTypeKeyNames, idx, typeKey)
        return
    if found:
        if idx >= 0 && idx < uirCoreGlobalTypeKeyNames.len:
            mbWriteStr(uirCoreGlobalTypeKeyNames, idx, typeKey)
        return
    let newIdx: int32 = uirCoreGlobalTypeKeyNames.len
    add(uirCoreGlobalTypeKeyNames, typeKey)
    hashmaps.hashMapStrIntPut(uirCoreGlobalTypeKeyIndex, name, newIdx)

fn uirCoreGlobalTypeKeyGet(name: str): str =
    if name == nil || len(name) == 0 || !uirCoreGlobalTypeKeyReady:
        return ""
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreGlobalTypeKeyIndex, name, found)
    if idx < 0 || idx >= uirCoreGlobalTypeKeyNames.len:
        return ""
    return get_string(uirCoreGlobalTypeKeyNames, idx)

fn uirCoreObjAliasPut(aliasName0: str, targetName0: str) =
    if aliasName0 == nil || len(aliasName0) == 0 || targetName0 == nil || len(targetName0) == 0:
        return
    if !uirCoreObjAliasReady:
        uirCoreObjAliasesReset()
    let aliasName: str = backendStripSpaces(aliasName0)
    let targetName: str = backendStripSpaces(targetName0)
    if aliasName == nil || len(aliasName) == 0 || targetName == nil || len(targetName) == 0:
        return
    if (aliasName == targetName):
        return
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreObjAliasIndex, aliasName, found)
    if idx >= 0 && idx < uirCoreObjAliasNames.len:
        mbWriteStr(uirCoreObjAliasNames, idx, targetName)
        return
    if found:
        if idx >= 0 && idx < uirCoreObjAliasNames.len:
            mbWriteStr(uirCoreObjAliasNames, idx, targetName)
        return
    let newIdx: int32 = uirCoreObjAliasNames.len
    add(uirCoreObjAliasNames, targetName)
    hashmaps.hashMapStrIntPut(uirCoreObjAliasIndex, aliasName, newIdx)

fn uirCoreObjAliasGet(aliasName0: str): str =
    if aliasName0 == nil || len(aliasName0) == 0 || !uirCoreObjAliasReady:
        return ""
    let aliasName: str = backendStripSpaces(aliasName0)
    if aliasName == nil || len(aliasName) == 0:
        return ""
    var found: bool = false
    let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCoreObjAliasIndex, aliasName, found)
    if idx < 0 || idx >= uirCoreObjAliasNames.len:
        return ""
    return get_string(uirCoreObjAliasNames, idx)

fn uirCoreObjAliasCanon(name0: str): str =
    if name0 == nil || len(name0) == 0:
        return ""
    if !uirCoreObjAliasReady:
        return name0
    var cur: str = name0
    for i in 0..<8:
        let next: str = uirCoreObjAliasGet(cur)
        if next == nil || len(next) == 0 || (next == cur):
            return cur
        cur = next
    return cur

fn uirCoreObjLayoutName(module: UirCoreModule, name0: str): str =
    if name0 == nil || len(name0) == 0:
        return ""
    let name: str = name0
    if module != nil:
        if uirCoreStrStartsWith(name, "seq_") && uirCoreHasObjType(module, "seq"):
            return "seq"
        if uirCoreStrStartsWith(name, "seq_fixed_") && uirCoreHasObjType(module, "seq"):
            return "seq"
        if uirCoreStrStartsWith(name, "Table_") && uirCoreHasObjType(module, "Table"):
            return "Table"
    return name

fn uirCoreModuleIdForFile(filePath0: str): str =
    let filePath: str = (filePath0 != nil) ? filePath0 : ""
    if len(filePath) == 0:
        return "0000000000000000"
    return uirCoreU64ToHex(uirCoreFnv1a64(filePath))

fn uirCoreDupFnBasesReset() =
    uirCoreDupFnBases = hashsets.hashSetStrInit(256)
    uirCoreDupFnBasesReady = true

fn uirCoreDupFnBasesHas(baseName: str): bool =
    if !uirCoreDupFnBasesReady:
        return false
    if baseName == nil || len(baseName) == 0:
        return false
    return hashsets.hashSetStrHas(uirCoreDupFnBases, baseName)

fn uirCoreMaybeMangleDupFnBase(baseName0: str, originFile0: str): str =
    let baseName: str = (baseName0 != nil) ? baseName0 : ""
    if len(baseName) == 0:
        return ""
    if (baseName == "main"):
        return baseName
    if !uirCoreDupFnBasesHas(baseName):
        return baseName
    let originFile: str = (originFile0 != nil) ? originFile0 : ""
    return baseName + "__cheng_mod_" + uirCoreModuleIdForFile(originFile)

fn uirCoreCollectGenericParamNames(generics: Node): str[] =
    var out: str[4]
    if generics == nil || generics.kind == nkEmpty:
        return out
    for i in 0..<kidCount(generics):
        let n0: Node = kid(generics, i)
        if n0 == nil || n0.kind == nkEmpty:
            continue
        var nameNode: Node = nil
        if n0.kind == nkIdentDefs && kidCount(n0) > 0:
            nameNode = kid(n0, 0)
        elif n0.kind == nkIdent || n0.kind == nkSymbol:
            nameNode = n0
        elif kidCount(n0) > 0:
            nameNode = kid(n0, 0)
        if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
            let nm: str = backendStripSpaces(plainName(nameNode))
            if nm != nil && len(nm) > 0:
                add(out, nm)
    return out

fn uirCoreTypeNodeHasGenericParam(typeNode0: Node, genericNames: str[]): bool =
    if typeNode0 == nil || genericNames.len == 0:
        return false
    var stack: Node[16]
    add(stack, typeNode0)
    while stack.len > 0:
        let n: Node = stack[stack.len - 1]
        stack.len = stack.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkIdent || n.kind == nkSymbol:
            let nm: str = backendStripSpaces(plainName(n))
            if nm != nil && len(nm) > 0:
                for gi in 0..<genericNames.len:
                    if (nm == genericNames[gi]):
                        return true
        for ki in 0..<kidCount(n):
            add(stack, kid(n, ki))
    return false

fn uirCoreFuncSigHasUnresolvedGenerics(fnNode: Node): bool =
    if fnNode == nil || kidCount(fnNode) <= 4:
        return false
    let genNode: Node = kid(fnNode, 4)
    if genNode == nil || genNode.kind == nkEmpty || kidCount(genNode) == 0:
        return false
    let genNames: str[] = uirCoreCollectGenericParamNames(genNode)
    if genNames.len == 0:
        return false
    let retNode: Node = (kidCount(fnNode) > 2) ? kid(fnNode, 2) : nil
    if retNode != nil && retNode.kind != nkEmpty:
        if uirCoreTypeNodeHasGenericParam(retNode, genNames):
            return true
    let paramsNode: Node = (kidCount(fnNode) > 1) ? kid(fnNode, 1) : nil
    if paramsNode != nil && paramsNode.kind == nkFormalParams:
        for pi in 0..<kidCount(paramsNode):
            let defs: Node = kid(paramsNode, pi)
            if defs != nil && defs.kind == nkIdentDefs && kidCount(defs) > 1:
                let tn: Node = kid(defs, 1)
                if tn != nil && tn.kind != nkEmpty:
                    if uirCoreTypeNodeHasGenericParam(tn, genNames):
                        return true
    return false

fn uirCoreComputeDuplicateFnBases(root: Node, overloaded: hashsets.HashSetStr* = nil): hashsets.HashSetStr =
    var dup: hashsets.HashSetStr = hashsets.hashSetStrInit(256)
    if root == nil:
        return dup
    var seenNames: str[]
    var seenCounts: int32[]
    var queue: Node[]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
            continue
        if n.kind != nkFnDecl && n.kind != nkIteratorDecl:
            continue
        if kidCount(n) > 3:
            let body: Node = kid(n, 3)
            # Forward decls (no body, no importc) should not count as duplicates.
            if body == nil || body.kind == nkEmpty:
                continue
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            continue
        let nameNode: Node = kid(n, 0)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let rawName: str = backendStripSpaces(plainName(nameNode))
        if rawName == nil || len(rawName) == 0 || (rawName == "main"):
            continue
        if overloaded != nil && hashsets.hashSetStrHas(*overloaded, rawName):
            continue
        var idx: int32 = -1
        for ci in 0..<seenNames.len:
            if seenNames[ci] == rawName:
                idx = ci
                break
        if idx < 0:
            add(seenNames, rawName)
            add(seenCounts, 1)
        else:
            let next: int32 = seenCounts[idx] + 1
            seenCounts[idx] = next
            if next > 1:
                hashsets.hashSetStrAdd(dup, rawName)
    return dup

fn uirCoreDupGlobalNamesReset() =
    uirCoreDupGlobalNames = hashsets.hashSetStrInit(256)
    uirCoreDupGlobalNamesReady = true

fn uirCoreDupGlobalNamesHas(baseName: str): bool =
    if !uirCoreDupGlobalNamesReady:
        return false
    if baseName == nil || len(baseName) == 0:
        return false
    return hashsets.hashSetStrHas(uirCoreDupGlobalNames, baseName)

fn uirCoreMaybeMangleDupGlobalName(baseName0: str, originFile0: str): str =
    let baseName: str = (baseName0 != nil) ? baseName0 : ""
    if len(baseName) == 0:
        return ""
    if !uirCoreDupGlobalNamesHas(baseName):
        return baseName
    let originFile: str = (originFile0 != nil) ? originFile0 : ""
    return baseName + "__cheng_mod_" + uirCoreModuleIdForFile(originFile)

fn uirCoreComputeDuplicateGlobalNames(root: Node): hashsets.HashSetStr =
    var dup: hashsets.HashSetStr = hashsets.hashSetStrInit(256)
    if root == nil:
        return dup
    var seenNames: str[]
    var seenCounts: int32[]
    var queue: Node[]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
            continue
        if n.kind != nkVar && n.kind != nkLet && n.kind != nkConst:
            continue
        var pat: Node = nil
        if kidCount(n) > 0:
            pat = kid(n, 0)
        var nameNode: Node = pat
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let rawName: str = backendStripSpaces(plainName(nameNode))
        if rawName == nil || len(rawName) == 0:
            continue
        var idx: int32 = -1
        for ci in 0..<seenNames.len:
            if seenNames[ci] == rawName:
                idx = ci
                break
        if idx < 0:
            add(seenNames, rawName)
            add(seenCounts, 1)
        else:
            let next: int32 = seenCounts[idx] + 1
            seenCounts[idx] = next
            if next > 1:
                hashsets.hashSetStrAdd(dup, rawName)
    return dup

fn blockBuilderNew(env: LocalEnv, module: UirCoreModule, func: UirCoreFunc): BlockBuilder =
    var b: BlockBuilder
    new b
    b.env = env
    b.module = module
    b.func = func
    b.currentLabel = "entry"
    b.currentStmts = []
    b.labelCounter = 0
    b.objCursor = 0
    b.loopStack = []
    b.deferStack = []
    return b

fn blockBuilderNextLabel(b: BlockBuilder, prefix: str): str =
    let id: int32 = b.labelCounter
    b.labelCounter = b.labelCounter + 1
    return prefix + intToStr(id)

fn blockBuilderStart(b: BlockBuilder, label: str) =
    b.currentLabel = label
    b.currentStmts = []

fn blockBuilderFinish(b: BlockBuilder, term: UirCoreTerm) =
    # Copy stmt buffer so finished blocks don't alias the builder's scratch seq.
    # (Without this, later appends can realloc/free the shared buffer.)
    var stmtsCopy: UirCoreStmt[]
    if b.currentStmts.len > 0:
        stmtsCopy.cap = b.currentStmts.len
        for si in 0..<b.currentStmts.len:
            add(stmtsCopy, b.currentStmts[si])
    let blk: UirCoreBlock = uirCoreBlockWithStmts(b.currentLabel, stmtsCopy, term)
    let dbgFunc: UirCoreFunc = b.func
    let dbgName: str = (dbgFunc != nil) ? dbgFunc.name : ""
    if (os.getEnvDefault("BACKEND_DEBUG_MIR_FINISH", "") == dbgName):
        let curLen: int32 = b.currentStmts.len
        let blkLen: int32 = blk.stmts.len
        echo("[backend] dbgFinish: fn=" + dbgName + " label=" + b.currentLabel +
             " cur.len=" + intToStr(curLen) + " blk.len=" + intToStr(blkLen))
        if curLen > 0:
            let s0: UirCoreStmt = b.currentStmts[0]
            echo("[backend] dbgFinish: cur0.kind=" + intToStr(int32(s0.kind)) +
                 " slot=" + intToStr(s0.slot))
        if blkLen > 0:
            let s1: UirCoreStmt = blk.stmts[0]
            echo("[backend] dbgFinish: blk0.kind=" + intToStr(int32(s1.kind)) +
                 " slot=" + intToStr(s1.slot))
    uirCoreAddBlock(b.func, blk)
    b.currentLabel = ""
    b.currentStmts = []

fn blockBuilderPushLoop(b: BlockBuilder, breakLabel: str, continueLabel: str) =
    var ctx: LoopContext
    new ctx
    ctx.breakLabel = breakLabel
    ctx.continueLabel = continueLabel
    ctx.deferDepth = b.deferStack.len
    add(b.loopStack, ctx)

fn blockBuilderPopLoop(b: BlockBuilder): LoopContext =
    if b.loopStack.len == 0:
        return nil
    let idx: int32 = b.loopStack.len - 1
    let ctx: LoopContext = b.loopStack[idx]
    b.loopStack.len = idx
    return ctx

fn blockBuilderPeekLoop(b: BlockBuilder): LoopContext =
    if b.loopStack.len == 0:
        return nil
    return b.loopStack[b.loopStack.len - 1]

fn blockBuilderPushDefer(b: BlockBuilder) =
    if b == nil:
        return
    var frame: DeferFrame
    new frame
    frame.bodies = []
    add(b.deferStack, frame)

fn blockBuilderPopDefer(b: BlockBuilder): DeferFrame =
    if b == nil || b.deferStack.len == 0:
        return nil
    let idx: int32 = b.deferStack.len - 1
    let frame: DeferFrame = b.deferStack[idx]
    b.deferStack.len = idx
    return frame

fn blockBuilderPeekDefer(b: BlockBuilder): DeferFrame =
    if b == nil || b.deferStack.len == 0:
        return nil
    return b.deferStack[b.deferStack.len - 1]

fn emitDeferFrames(b: BlockBuilder, frames: DeferFrame[]): Result[bool] =
    if frames.buffer == nil || frames.len == 0:
        return Ok[bool](false)
    for fi in 0..<frames.len:
        let frame: DeferFrame = frames[fi]
        if frame != nil && frame.bodies.buffer != nil:
            let __for_start_bi = frame.bodies.len - 1
            for __for_rev_bi in 0..(__for_start_bi - (0)):
                let bi = __for_start_bi - __for_rev_bi
                let body: Node = frame.bodies[bi]
                if body == nil || body.kind != nkStmtList:
                    return Err[bool]("uirCore_builder: invalid defer body")
                let bodyRes: Result[bool] = lowerStmtList(b, body)
                if !IsOk[bool](bodyRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](bodyRes))
                if Value[bool](bodyRes):
                    return Err[bool]("uirCore_builder: defer body terminated")
    return Ok[bool](false)

fn blockBuilderEmitDefers(b: BlockBuilder, minDepth: int32): Result[bool] =
    if b == nil:
        return Ok[bool](false)
    var md: int32 = minDepth
    if md < 0:
        md = 0
    if md >= b.deferStack.len:
        return Ok[bool](false)
    var frames: DeferFrame[]
    let __for_start_i = b.deferStack.len - 1
    for __for_rev_i in 0..(__for_start_i - (md)):
        let i = __for_start_i - __for_rev_i
        add(frames, b.deferStack[i])
    return emitDeferFrames(b, frames)

fn blockBuilderNextTemp(b: BlockBuilder, prefix: str): str =
    return blockBuilderNextLabel(b, prefix)

fn isControlExpr(n: Node): bool =
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node == nil:
        return false
    if node.kind == nkIf:
        return true
    if node.kind == nkCase:
        return true
    if node.kind == nkInfix && kidCount(node) >= 3:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        if op == "&&" || op == "||":
            return true
    return false

fn isImplicitReturnExpr(n: Node): bool =
    if n == nil:
        return false
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node == nil:
        return false
    case node.kind
    of nkCall, nkInfix, nkPrefix, nkPostfix, nkDotExpr, nkBracketExpr,
       nkCurlyExpr, nkTupleLit, nkSeqLit, nkTableLit,
       nkIdent, nkSymbol,
       nkIntLit, nkFloatLit, nkStrLit, nkCharLit, nkBoolLit, nkNilLit:
        return true
    return false

fn uirCoreAddStrPtr(items: str[]*, value: str) =
    if items == nil:
        return
    add(items, value)

fn mbWrite[T](seqInst: var T[], idx: int32, val: T) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteBool(seqInst: var bool[], idx: int32, val: bool) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteStr(seqInst: var str[], idx: int32, val: str) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteObjLocal(seqInst: var UirCoreObjLocal[], idx: int32, val: UirCoreObjLocal) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteObjType(seqInst: var UirCoreObjType[], idx: int32, val: UirCoreObjType) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteGlobal(seqInst: var UirCoreGlobal[], idx: int32, val: UirCoreGlobal) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn mbWriteFunc(seqInst: var UirCoreFunc[], idx: int32, val: UirCoreFunc) =
    if idx < 0 || idx >= seqInst.len:
        panic "uirCore_builder: seq index out of bounds"
    seqInst[idx] = val

fn localEnvNew(): LocalEnv =
    var env: LocalEnv
    new env
    env.names = []
    env.types = []
    env.typeKeys = []
    env.callTargets = []
    env.active = []
    env.scopeMarks = []
    env.nameIndex = hashmaps.hashMapStrIntInit(64)
    env.prevSlots = []
    return env

fn localEnvPushScope(env: LocalEnv) =
    if env == nil:
        return
    add(env.scopeMarks, env.names.len)

fn localEnvPopScope(env: LocalEnv) =
    if env == nil || env.scopeMarks.len == 0:
        return
    let mark: int32 = env.scopeMarks[env.scopeMarks.len - 1]
    env.scopeMarks.len = env.scopeMarks.len - 1
    if mark < 0:
        return
    let __for_start_slot = env.names.len - 1
    for __for_rev_slot in 0..(__for_start_slot - (mark)):
        let slot = __for_start_slot - __for_rev_slot
        if slot >= 0 && slot < env.names.len && slot < env.prevSlots.len:
            let nm: str = env.names[slot]
            let prev: int32 = env.prevSlots[slot]
            let restore: int32 = (prev >= 0) ? (prev + 1) : 0
            hashmaps.hashMapStrIntPut(env.nameIndex, nm, restore)
    for i in mark..<env.active.len:
        mbWriteBool(env.active, i, false)

fn localIndex(env: LocalEnv, name: str): int32 =
    if env == nil:
        return -1
    if name == nil || len(name) == 0:
        return -1
    let query: str = backendStripSpacesMaybe(name)
    if query == nil || len(query) == 0:
        return -1
    let idxPlus1: int32 = hashmaps.hashMapStrIntGet(env.nameIndex, query)
    if idxPlus1 <= 0:
        return -1
    let idx: int32 = idxPlus1 - 1
    if env.active.len == env.names.len && idx < env.active.len && !env.active[idx]:
        return -1
    return idx

fn localAdd(env: LocalEnv, name: str, ty: UirCoreType): int32 =
    if env == nil:
        return -1
    let nm: str = backendStripSpaces(name)
    if (getEnv "BACKEND_DEBUG_LET" == "1") && (nm == "snapRes"):
        let mark: int32 = (env.scopeMarks.len > 0) ? env.scopeMarks[env.scopeMarks.len - 1] : -1
        echo("[backend] debugLocalAdd: name='snapRes' slot=" + intToStr(env.names.len) +
             " scopeMarks=" + intToStr(env.scopeMarks.len) + " topMark=" + intToStr(mark))
    trackLexString void*(nm)
    let prevPlus1: int32 = hashmaps.hashMapStrIntGet(env.nameIndex, nm)
    let prevSlot: int32 = (prevPlus1 > 0) ? (prevPlus1 - 1) : -1
    add(env.names, nm)
    add(env.types, ty)
    add(env.typeKeys, "")
    add(env.callTargets, "")
    add(env.active, true)
    add(env.prevSlots, prevSlot)
    hashmaps.hashMapStrIntPut(env.nameIndex, nm, env.names.len)
    return env.names.len - 1

fn localType(env: LocalEnv, idx: int32): UirCoreType =
    if env == nil || idx < 0 || idx >= env.types.len:
        return uirCoreTypeI32()
    return env.types[idx]

fn localTypeKey(env: LocalEnv, idx: int32): str =
    if env == nil || idx < 0 || idx >= env.typeKeys.len:
        return ""
    return env.typeKeys[idx]

fn localCallTarget(env: LocalEnv, idx: int32): str =
    if env == nil || idx < 0 || idx >= env.callTargets.len:
        return ""
    return env.callTargets[idx]

fn localSetTypeKey(env: LocalEnv, idx: int32, key: str) =
    if env == nil || key == nil || len(key) == 0:
        return
    if idx < 0 || idx >= env.typeKeys.len:
        return
    trackLexString void*(key)
    mbWriteStr(env.typeKeys, idx, key)

fn localSetCallTarget(env: LocalEnv, idx: int32, target: str) =
    if env == nil || target == nil || len(target) == 0:
        return
    if idx < 0 || idx >= env.callTargets.len:
        return
    trackLexString void*(target)
    mbWriteStr(env.callTargets, idx, target)

fn alignUpPow2(value: int32, alignPow2: int32): int32 =
    if alignPow2 <= 0:
        return value
    let align: int32 = 1 << alignPow2
    let rem: int32 = value % align
    if rem == 0:
        return value
    return value + (align - rem)

fn funcFindObjLocal(func: UirCoreFunc, slot: int32): int32 =
    if func == nil:
        return -1
    for i in 0..<func.objLocals.len:
        let ol: UirCoreObjLocal = func.objLocals[i]
        if ol.slot == slot:
            return i
    return -1

fn funcObjTypeName(func: UirCoreFunc, slot: int32): str =
    let idx: int32 = funcFindObjLocal(func, slot)
    if idx < 0:
        return ""
    let ol: UirCoreObjLocal = func.objLocals[idx]
    return ol.objTypeName

fn funcObjTypeKey(func: UirCoreFunc, slot: int32): str =
    let idx: int32 = funcFindObjLocal(func, slot)
    if idx < 0:
        return ""
    let ol: UirCoreObjLocal = func.objLocals[idx]
    if ol.typeKey != nil && len(ol.typeKey) > 0:
        return ol.typeKey
    return ol.objTypeName

fn funcSetObjTypeKey(func: UirCoreFunc, slot: int32, typeKey: str) =
    if func == nil || typeKey == nil || len(typeKey) == 0:
        return
    let idx: int32 = funcFindObjLocal(func, slot)
    if idx < 0:
        return
    var ol: UirCoreObjLocal = func.objLocals[idx]
    ol.typeKey = typeKey
    mbWriteObjLocal(func.objLocals, idx, ol)

fn typeNodeObjTypeName(module: UirCoreModule, typeNode: Node): str =
    if module == nil || typeNode == nil:
        return ""
    if typeNode.kind == nkVarTy && kidCount(typeNode) > 0:
        return typeNodeObjTypeName(module, kid(typeNode, 0))
    if (typeNode.kind == nkRefTy || typeNode.kind == nkPtrTy) && kidCount(typeNode) > 0:
        return typeNodeObjTypeName(module, kid(typeNode, 0))
    if typeNode.kind == nkDotExpr && kidCount(typeNode) > 1:
        return typeNodeObjTypeName(module, kid(typeNode, 1))
    if typeNode.kind == nkTupleTy:
        let key: str = typeKey(typeNode)
        # Record tuple field labels (if any) so `t.foo` can resolve to `fN` fields.
        if len(key) > 0:
            for ti in 0..<kidCount(typeNode):
                let elemNode0: Node = kid(typeNode, ti)
                var elemTypeNode0: Node = elemNode0
                var fieldLabel0: str = ""
                if elemNode0 != nil && elemNode0.kind == nkIdentDefs:
                    if kidCount(elemNode0) > 0:
                        let nameNode0: Node = kid(elemNode0, 0)
                        if nameNode0 != nil && (nameNode0.kind == nkIdent || nameNode0.kind == nkSymbol):
                            fieldLabel0 = backendStripSpaces(plainName(nameNode0))
                    if kidCount(elemNode0) > 1:
                        elemTypeNode0 = kid(elemNode0, 1)
                var elemTypeKey0: str = ""
                if elemTypeNode0 != nil && elemTypeNode0.kind == nkDotExpr && kidCount(elemTypeNode0) > 1:
                    elemTypeKey0 = typeKey(kid(elemTypeNode0, 1))
                else:
                    elemTypeKey0 = typeKey(elemTypeNode0)
                if len(elemTypeKey0) == 0 && elemTypeNode0 != nil:
                    elemTypeKey0 = backendStripSpaces(plainName(elemTypeNode0))
                let fName0: str = "f" + intToStr(ti)
                if len(elemTypeKey0) > 0:
                    uirCoreObjFieldTypeKeyPut(key, fName0, elemTypeKey0)
                    if len(fieldLabel0) > 0:
                        uirCoreObjFieldTypeKeyPut(key, fieldLabel0, elemTypeKey0)
                if len(fieldLabel0) > 0:
                    uirCoreTupleFieldIndexPut(key, fieldLabel0, ti)
        if len(key) > 0 && ! uirCoreHasObjType(module, key):
            var fields: UirCoreObjField[]
            var offset: int32 = 0
            var maxAlignPow2: int32 = 0
            for i in 0..<kidCount(typeNode):
                let elemNode: Node = kid(typeNode, i)
                var elemTypeNode: Node = elemNode
                if elemNode != nil && elemNode.kind == nkIdentDefs && kidCount(elemNode) > 1:
                    elemTypeNode = kid(elemNode, 1)
                if elemTypeNode == nil || elemTypeNode.kind == nkEmpty:
                    return ""
                let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(module, elemTypeNode)
                let fieldSize: int32 = uirCoreTypeSize(elemTy)
                if fieldSize <= 0:
                    return ""
                let alignPow2: int32 = uirCoreTypeAlignPow2(elemTy)
                if alignPow2 > maxAlignPow2:
                    maxAlignPow2 = alignPow2
                offset = alignUpPow2(offset, alignPow2)
                var f: UirCoreObjField
                f.name = "f" + intToStr(i)
                f.ty = elemTy
                f.offset = offset
                add(fields, f)
                offset = offset + fieldSize
            var ot: UirCoreObjType
            ot.name = key
            ot.alignPow2 = maxAlignPow2
            ot.size = alignUpPow2(offset, maxAlignPow2)
            ot.fields = fields
            uirCoreAddObjType(module, ot)
        if len(key) > 0 && uirCoreHasObjType(module, key):
            return key
        return ""
    if typeNode.kind == nkIdent || typeNode.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(typeNode))
        if uirCoreHasObjType(module, nm):
            return nm
        let canon: str = uirCoreObjAliasCanon(nm)
        if canon != nil && len(canon) > 0 && !(canon == nm) && uirCoreHasObjType(module, canon):
            return canon
        # Seq instantiations often appear as flattened idents (e.g. `seq_str`).
        # They share the builtin `seq` layout.
        if uirCoreStrStartsWith(nm, "seq_") && uirCoreHasObjType(module, "seq"):
            return "seq"
        if uirCoreStrStartsWith(nm, "seq_fixed_") && uirCoreHasObjType(module, "seq"):
            return "seq"
        # stdlib `tables.Table[V]` has a stable layout; instantiations share builtin `Table`.
        if uirCoreStrStartsWith(nm, "Table_") && uirCoreHasObjType(module, "Table"):
            return "Table"
        if uirCoreStrStartsWith(nm, "SeqUninit_") && ensureSeqUninitObjType(module, nm):
            return nm
        if uirCoreStrStartsWith(nm, "Option_") && ensureOptionObjType(module, nm):
            return nm
        if uirCoreStrStartsWith(nm, "Result_") && ensureResultObjType(module, nm):
            return nm
        if uirCoreStrStartsWith(nm, "__cheng_tables_Entry_"):
            if ensureTablesEntryObjType(module, nm):
                return nm
        return ""
    if typeNode.kind == nkBracketExpr && kidCount(typeNode) > 0:
        let base: Node = kid(typeNode, 0)
        if base != nil:
            let nm3: str = backendStripSpaces(plainName(base))
            if (nm3 == "seq") && uirCoreHasObjType(module, "seq"):
                return "seq"
            if (nm3 == "seq_fixed") && uirCoreHasObjType(module, "seq"):
                return "seq"
            if (nm3 == "Table") && uirCoreHasObjType(module, "Table"):
                return "Table"
            var instArgs: Node[4]
            for ai in 1..<kidCount(typeNode):
                let a: Node = kid(typeNode, ai)
                if a != nil && a.kind != nkEmpty:
                    add(instArgs, a)
            if instArgs.len > 0:
                let instName: str = mangleInstance(nm3, instArgs)
                if (nm3 == "array"):
                    if ensureArrayObjTypeFromTypeExpr(module, typeNode, instName):
                        return instName
                if (nm3 == "SeqUninit") && ensureSeqUninitObjType(module, instName):
                    return instName
                if (nm3 == "Option") && ensureOptionObjType(module, instName):
                    return instName
                if (nm3 == "Result") && ensureResultObjType(module, instName):
                    return instName
                if uirCoreHasObjType(module, instName):
                    return instName
                if (nm3 == "__cheng_tables_Entry") && ensureTablesEntryObjType(module, instName):
                    return instName
                # Default type parameters: stage1 may canonicalize to a longer instantiated name.
                # If there's exactly one object type with this prefix, use it.
                let prefix: str = instName + "_"
                var foundName: str = ""
                var foundCount: int32 = 0
                for oi in 0..<module.objTypes.len:
                    let ot: UirCoreObjType = module.objTypes[oi]
                    if ot.name != nil && uirCoreStrStartsWith(ot.name, prefix):
                        foundName = ot.name
                        foundCount = foundCount + 1
                        if foundCount > 1:
                            break
                if foundCount == 1 && len(foundName) > 0 && uirCoreHasObjType(module, foundName):
                    return foundName
    return ""

fn typeNodeIsObjValue(module: UirCoreModule, typeNode: Node): bool =
    if module == nil || typeNode == nil:
        return false
    if typeNode.kind == nkVarTy && kidCount(typeNode) > 0:
        return typeNodeIsObjValue(module, kid(typeNode, 0))
    if typeNode.kind == nkDotExpr && kidCount(typeNode) > 1:
        return typeNodeIsObjValue(module, kid(typeNode, 1))
    if typeNode.kind == nkTupleTy:
        let nm: str = typeNodeObjTypeName(module, typeNode)
        return len(nm) > 0
    if typeNode.kind == nkIdent || typeNode.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(typeNode))
        if uirCoreHasObjType(module, nm):
            # Ref-like types are represented as pointer aliases + object layout.
            let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, nm)
            if aliasTy.kind != mtVoid:
                return false
            if typeNode != nil && typeNode.typeCacheValid && typeNode.typeCache != nil:
                let tc: Node = typeNode.typeCache
                if tc.kind == nkRefTy || tc.kind == nkPtrTy:
                    return false
            return true
        if uirCoreStrStartsWith(nm, "seq_") && uirCoreHasObjType(module, "seq"):
            return true
        if uirCoreStrStartsWith(nm, "seq_fixed_") && uirCoreHasObjType(module, "seq"):
            return true
        if uirCoreStrStartsWith(nm, "Table_") && uirCoreHasObjType(module, "Table"):
            return true
        if uirCoreStrStartsWith(nm, "SeqUninit_") && ensureSeqUninitObjType(module, nm):
            return true
        if uirCoreStrStartsWith(nm, "Option_") && ensureOptionObjType(module, nm):
            return true
        if uirCoreStrStartsWith(nm, "Result_") && ensureResultObjType(module, nm):
            return true
        if uirCoreStrStartsWith(nm, "__cheng_tables_Entry_"):
            return ensureTablesEntryObjType(module, nm)
        return false
    if typeNode.kind == nkBracketExpr && kidCount(typeNode) > 0:
        let base: Node = kid(typeNode, 0)
        if base != nil:
            let nm2: str = backendStripSpaces(plainName(base))
            if (nm2 == "seq") && uirCoreHasObjType(module, "seq"):
                return true
            if (nm2 == "seq_fixed") && uirCoreHasObjType(module, "seq"):
                return true
            if (nm2 == "Table") && uirCoreHasObjType(module, "Table"):
                return true
            var instArgs: Node[4]
            for ai in 1..<kidCount(typeNode):
                let a: Node = kid(typeNode, ai)
                if a != nil && a.kind != nkEmpty:
                    add(instArgs, a)
            if instArgs.len > 0:
                let instName: str = mangleInstance(nm2, instArgs)
                if (nm2 == "array") && ensureArrayObjTypeFromTypeExpr(module, typeNode, instName):
                    return true
                if (nm2 == "SeqUninit") && ensureSeqUninitObjType(module, instName):
                    return true
                if (nm2 == "Option") && ensureOptionObjType(module, instName):
                    return true
                if (nm2 == "Result") && ensureResultObjType(module, instName):
                    return true
                if uirCoreHasObjType(module, instName):
                    return true
                if (nm2 == "__cheng_tables_Entry") && ensureTablesEntryObjType(module, instName):
                    return true
                return false
    return false

fn ensureBuiltinObjTypes(module: UirCoreModule) =
    if module == nil:
        return
    if ! uirCoreHasObjType(module, "seq"):
        var fields: UirCoreObjField[]
        var f0: UirCoreObjField
        f0.name = "len"
        f0.ty = uirCoreTypeI32()
        f0.offset = 0
        add(fields, f0)
        var f1: UirCoreObjField
        f1.name = "cap"
        f1.ty = uirCoreTypeI32()
        f1.offset = 4
        add(fields, f1)
        var f2: UirCoreObjField
        f2.name = "buffer"
        f2.ty = uirCoreTypeI64()
        f2.offset = 8
        add(fields, f2)
        var ot: UirCoreObjType
        ot.name = "seq"
        ot.size = 16
        ot.alignPow2 = 3
        ot.fields = fields
        uirCoreAddObjType(module, ot)
    if ! uirCoreHasObjType(module, "Table"):
        # stdlib `tables.Table[V]` (generic) has a stable layout independent of V:
        #   keys: seq[str]      (inlined as keys.len/cap/buffer)
        #   vals: seq[V]        (inlined as vals.len/cap/buffer)
        #   states: seq[uint8]  (inlined as states.len/cap/buffer)
        #   len: int32
        var fields2: UirCoreObjField[]
        var f0: UirCoreObjField
        f0.name = "keys.len"
        f0.ty = uirCoreTypeI32()
        f0.offset = 0
        add(fields2, f0)
        var f1: UirCoreObjField
        f1.name = "keys.cap"
        f1.ty = uirCoreTypeI32()
        f1.offset = 4
        add(fields2, f1)
        var f2: UirCoreObjField
        f2.name = "keys.buffer"
        f2.ty = uirCoreTypeI64()
        f2.offset = 8
        add(fields2, f2)
        var f3: UirCoreObjField
        f3.name = "vals.len"
        f3.ty = uirCoreTypeI32()
        f3.offset = 16
        add(fields2, f3)
        var f4: UirCoreObjField
        f4.name = "vals.cap"
        f4.ty = uirCoreTypeI32()
        f4.offset = 20
        add(fields2, f4)
        var f5: UirCoreObjField
        f5.name = "vals.buffer"
        f5.ty = uirCoreTypeI64()
        f5.offset = 24
        add(fields2, f5)
        var f6: UirCoreObjField
        f6.name = "states.len"
        f6.ty = uirCoreTypeI32()
        f6.offset = 32
        add(fields2, f6)
        var f7: UirCoreObjField
        f7.name = "states.cap"
        f7.ty = uirCoreTypeI32()
        f7.offset = 36
        add(fields2, f7)
        var f8: UirCoreObjField
        f8.name = "states.buffer"
        f8.ty = uirCoreTypeI64()
        f8.offset = 40
        add(fields2, f8)
        var f9: UirCoreObjField
        f9.name = "len"
        f9.ty = uirCoreTypeI32()
        f9.offset = 48
        add(fields2, f9)
        var ot2: UirCoreObjType
        ot2.name = "Table"
        ot2.size = 56
        ot2.alignPow2 = 3
        ot2.fields = fields2
        uirCoreAddObjType(module, ot2)

fn ensureTablesEntryObjType(module: UirCoreModule, entryName: str): bool =
    if module == nil || entryName == nil || len(entryName) == 0:
        return false
    if uirCoreHasObjType(module, entryName):
        return true
    let prefix: str = "__cheng_tables_Entry_"
    if ! uirCoreStrStartsWith(entryName, prefix):
        return false
    let valKey: str = str(ptr_add(void*(entryName), len(prefix)))
    if valKey == nil || len(valKey) == 0:
        return false
    # Entry layout: `{ key: str, val: V }`
    let pos: SourcePos = zeroPos()
    let valTypeNode: Node = newIdent(valKey, pos)
    let valTy: UirCoreType = uirCoreTypeFromNodeWithModule(module, valTypeNode)
    let valSize: int32 = uirCoreTypeSize(valTy)
    if valSize <= 0:
        return false
    let valAlignPow2: int32 = uirCoreTypeAlignPow2(valTy)
    var fields: UirCoreObjField[]
    var f0: UirCoreObjField
    f0.name = "key"
    f0.ty = uirCoreTypeI64()
    f0.offset = 0
    add(fields, f0)
    var offset: int32 = 8
    offset = alignUpPow2(offset, valAlignPow2)
    var f1: UirCoreObjField
    f1.name = "val"
    f1.ty = valTy
    f1.offset = offset
    add(fields, f1)
    var maxAlignPow2: int32 = 3
    if valAlignPow2 > maxAlignPow2:
        maxAlignPow2 = valAlignPow2
    let size: int32 = alignUpPow2(offset + valSize, maxAlignPow2)
    var ot: UirCoreObjType
    ot.name = entryName
    ot.alignPow2 = maxAlignPow2
    ot.size = size
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn ensureOptionObjType(module: UirCoreModule, optionName: str): bool =
    if module == nil || optionName == nil || len(optionName) == 0:
        return false
    if uirCoreHasObjType(module, optionName):
        return true
    let prefix: str = "Option_"
    if !uirCoreStrStartsWith(optionName, prefix):
        return false
    let valKey: str = str(ptr_add(void*(optionName), len(prefix)))
    if valKey == nil || len(valKey) == 0:
        return false
    var hasObjVal: bool = uirCoreHasObjType(module, valKey)
    if !hasObjVal:
        let valCanon0: str = uirCoreObjAliasCanon(valKey)
        if valCanon0 != nil && len(valCanon0) > 0 && uirCoreHasObjType(module, valCanon0):
            hasObjVal = true
    if !isBuiltinTypeName(valKey) && !hasObjVal:
        let aliasTyCheck: UirCoreType = uirCoreTryGetTypeAlias(module, valKey)
        if aliasTyCheck.kind == mtVoid:
            return false
    var fields: UirCoreObjField[]
    var f0: UirCoreObjField
    f0.name = "has"
    f0.ty = uirCoreTypeU8()
    f0.offset = 0
    add(fields, f0)
    var maxAlignPow2: int32 = 0
    var offset: int32 = 1
    if uirCoreHasObjType(module, valKey):
        let inner: UirCoreObjType = uirCoreGetObjType(module, valKey)
        if inner.size <= 0 || inner.fields.len == 0:
            return false
        let alignPow2: int32 = inner.alignPow2
        if alignPow2 > maxAlignPow2:
            maxAlignPow2 = alignPow2
        offset = alignUpPow2(offset, alignPow2)
        for fi in 0..<inner.fields.len:
            let innerF: UirCoreObjField = inner.fields[fi]
            var f: UirCoreObjField
            f.name = "value." + innerF.name
            f.ty = innerF.ty
            f.offset = offset + innerF.offset
            add(fields, f)
        offset = offset + inner.size
        uirCoreInlineObjFieldTypePut(optionName, "value", valKey)
    else:
        let pos: SourcePos = zeroPos()
        let valTypeNode: Node = newIdent(valKey, pos)
        let valTy: UirCoreType = uirCoreTypeFromNodeWithModule(module, valTypeNode)
        let valSize: int32 = uirCoreTypeSize(valTy)
        if valSize <= 0:
            return false
        let valAlignPow2: int32 = uirCoreTypeAlignPow2(valTy)
        if valAlignPow2 > maxAlignPow2:
            maxAlignPow2 = valAlignPow2
        offset = alignUpPow2(offset, valAlignPow2)
        var f1: UirCoreObjField
        f1.name = "value"
        f1.ty = valTy
        f1.offset = offset
        add(fields, f1)
        offset = offset + valSize
    var ot: UirCoreObjType
    ot.name = optionName
    ot.alignPow2 = maxAlignPow2
    ot.size = alignUpPow2(offset, maxAlignPow2)
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn ensureResultObjType(module: UirCoreModule, resultName: str): bool =
    if module == nil || resultName == nil || len(resultName) == 0:
        return false
    if uirCoreHasObjType(module, resultName):
        return true
    let prefix: str = "Result_"
    if !uirCoreStrStartsWith(resultName, prefix):
        return false
    let valKey: str = str(ptr_add(void*(resultName), len(prefix)))
    if valKey == nil || len(valKey) == 0:
        return false
    var hasObjVal: bool = uirCoreHasObjType(module, valKey)
    if !hasObjVal:
        let valCanon0: str = uirCoreObjAliasCanon(valKey)
        if valCanon0 != nil && len(valCanon0) > 0 && uirCoreHasObjType(module, valCanon0):
            hasObjVal = true

    var errObjName: str = "ErrorInfo"
    if !uirCoreHasObjType(module, errObjName):
        let errCanon: str = uirCoreObjAliasCanon(errObjName)
        if errCanon != nil && len(errCanon) > 0 && uirCoreHasObjType(module, errCanon):
            errObjName = errCanon
    if !uirCoreHasObjType(module, errObjName):
        return false
    let errObj: UirCoreObjType = uirCoreGetObjType(module, errObjName)
    if errObj.size <= 0 || errObj.fields.len == 0:
        return false

    var fields: UirCoreObjField[]
    var maxAlignPow2: int32 = 0
    var offset: int32 = 0

    var f0: UirCoreObjField
    f0.name = "ok"
    f0.ty = uirCoreTypeU8()
    f0.offset = 0
    add(fields, f0)
    let okAlign: int32 = uirCoreTypeAlignPow2(f0.ty)
    if okAlign > maxAlignPow2:
        maxAlignPow2 = okAlign
    offset = 1

    var valObjName: str = ""
    if hasObjVal && uirCoreHasObjType(module, valKey):
        valObjName = valKey
    elif hasObjVal:
        let valCanon: str = uirCoreObjAliasCanon(valKey)
        if valCanon != nil && len(valCanon) > 0 && uirCoreHasObjType(module, valCanon):
            valObjName = valCanon
    let valAliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, valKey)
    let inlineValObj: bool = valObjName != nil && len(valObjName) > 0 && valAliasTy.kind == mtVoid
    uirCoreObjFieldTypeKeyPut(resultName, "value", valKey)
    if inlineValObj:
        let inner: UirCoreObjType = uirCoreGetObjType(module, valObjName)
        if inner.size <= 0 || inner.fields.len == 0:
            return false
        let alignPow2: int32 = inner.alignPow2
        if alignPow2 > maxAlignPow2:
            maxAlignPow2 = alignPow2
        offset = alignUpPow2(offset, alignPow2)
        for fi in 0..<inner.fields.len:
            let innerF: UirCoreObjField = inner.fields[fi]
            var f: UirCoreObjField
            f.name = "value." + innerF.name
            f.ty = innerF.ty
            f.offset = offset + innerF.offset
            add(fields, f)
        offset = offset + inner.size
        uirCoreInlineObjFieldTypePut(resultName, "value", valObjName)
    else:
        var valTy: UirCoreType
        if valAliasTy.kind != mtVoid:
            valTy = valAliasTy
        else:
            valTy = uirCoreTypeFromTypeKeyName(valKey)
        let valSize: int32 = uirCoreTypeSize(valTy)
        if valSize <= 0:
            return false
        let valAlignPow2: int32 = uirCoreTypeAlignPow2(valTy)
        if valAlignPow2 > maxAlignPow2:
            maxAlignPow2 = valAlignPow2
        offset = alignUpPow2(offset, valAlignPow2)
        var f1: UirCoreObjField
        f1.name = "value"
        f1.ty = valTy
        f1.offset = offset
        add(fields, f1)
        offset = offset + valSize

    uirCoreObjFieldTypeKeyPut(resultName, "err", errObjName)
    let errAlignPow2: int32 = errObj.alignPow2
    if errAlignPow2 > maxAlignPow2:
        maxAlignPow2 = errAlignPow2
    offset = alignUpPow2(offset, errAlignPow2)
    for ei in 0..<errObj.fields.len:
        let errF: UirCoreObjField = errObj.fields[ei]
        var ef: UirCoreObjField
        ef.name = "err." + errF.name
        ef.ty = errF.ty
        ef.offset = offset + errF.offset
        add(fields, ef)
    offset = offset + errObj.size
    uirCoreInlineObjFieldTypePut(resultName, "err", errObjName)

    var ot: UirCoreObjType
    ot.name = resultName
    ot.alignPow2 = maxAlignPow2
    ot.size = alignUpPow2(offset, maxAlignPow2)
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn tryResolveArrayCount(module: UirCoreModule, n0: Node): int32 =
    if module == nil || n0 == nil:
        return -1
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return -1
    if n.kind == nkIntLit:
        return int32(n.intVal)
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(n))
        let gi: int32 = moduleGlobalIndex(module, nm)
        if gi >= 0:
            let g: UirCoreGlobal = module.globals[gi]
            if g.hasInit:
                return int32(g.init)
    return -1

fn ensureArrayObjTypeFromElemKey(module: UirCoreModule, arrName: str, elemKey0: str, count: int32): bool =
    if module == nil || arrName == nil || len(arrName) == 0 || elemKey0 == nil || len(elemKey0) == 0 || count <= 0:
        return false
    if uirCoreHasObjType(module, arrName):
        return true
    let elemKey: str = backendStripSpaces(elemKey0)
    if elemKey == nil || len(elemKey) == 0:
        return false
    let elemObjName: str = uirCoreObjTypeFromTypeKey(module, elemKey)
    var elemTy: UirCoreType = uirCoreTypeFromTypeKeyName(elemKey)
    if elemObjName != nil && len(elemObjName) > 0:
        if !uirCoreHasObjType(module, elemObjName):
            return false
        elemTy = uirCoreTypeI64()
    else:
        let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, elemKey)
        if !isBuiltinTypeName(elemKey) && aliasTy.kind == mtVoid:
            return false
        if aliasTy.kind != mtVoid:
            elemTy = aliasTy
    let elemSize: int32 = uirCoreTypeSize(elemTy)
    if elemSize <= 0:
        return false
    let elemAlignPow2: int32 = uirCoreTypeAlignPow2(elemTy)
    let stride: int32 = alignUpPow2(elemSize, elemAlignPow2)
    if stride <= 0:
        return false
    var fields: UirCoreObjField[]
    var off: int32 = 0
    for i in 0..<count:
        var f: UirCoreObjField
        f.name = "e" + intToStr(i)
        f.ty = elemTy
        f.offset = off
        add(fields, f)
        off = off + stride
    var ot: UirCoreObjType
    ot.name = arrName
    ot.alignPow2 = elemAlignPow2
    ot.size = alignUpPow2(off, elemAlignPow2)
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn ensureSeqUninitObjType(module: UirCoreModule, seqName0: str): bool =
    if module == nil || seqName0 == nil || len(seqName0) == 0:
        return false
    let seqName: str = backendStripSpaces(seqName0)
    if seqName == nil || len(seqName) == 0 || !uirCoreStrStartsWith(seqName, "SeqUninit_"):
        return false
    if uirCoreHasObjType(module, seqName):
        return true
    let elemKey: str = str(ptr_add(void*(seqName), 10))
    if elemKey == nil || len(elemKey) == 0:
        return false
    let seqCap: int32 = 256
    let itemsObjName: str = "array_" + intToStr(seqCap) + "_" + elemKey
    if !ensureArrayObjTypeFromElemKey(module, itemsObjName, elemKey, seqCap):
        return false
    let itemsObj: UirCoreObjType = uirCoreGetObjType(module, itemsObjName)
    if itemsObj.name == nil || len(itemsObj.name) == 0 || itemsObj.size <= 0:
        return false

    var fields: UirCoreObjField[]
    var maxAlignPow2: int32 = 0

    let countTy: UirCoreType = uirCoreTypeI32()
    let countAlignPow2: int32 = uirCoreTypeAlignPow2(countTy)
    var countField: UirCoreObjField
    countField.name = "count"
    countField.ty = countTy
    countField.offset = 0
    add(fields, countField)
    uirCoreObjFieldTypeKeyPut(seqName, "count", "int32")
    if countAlignPow2 > maxAlignPow2:
        maxAlignPow2 = countAlignPow2

    let itemsAlignPow2: int32 = itemsObj.alignPow2
    if itemsAlignPow2 > maxAlignPow2:
        maxAlignPow2 = itemsAlignPow2
    let itemsBaseOff: int32 = alignUpPow2(4, itemsAlignPow2)
    for fi in 0..<itemsObj.fields.len:
        let innerF: UirCoreObjField = itemsObj.fields[fi]
        var f: UirCoreObjField
        f.name = "items." + innerF.name
        f.ty = innerF.ty
        f.offset = itemsBaseOff + innerF.offset
        add(fields, f)
    uirCoreObjFieldTypeKeyPut(seqName, "items", itemsObjName)
    uirCoreInlineObjFieldTypePut(seqName, "items", itemsObjName)

    var ot: UirCoreObjType
    ot.name = seqName
    ot.alignPow2 = maxAlignPow2
    ot.size = alignUpPow2(itemsBaseOff + itemsObj.size, maxAlignPow2)
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn ensureArrayObjTypeFromTypeExpr(module: UirCoreModule, arrType: Node, arrName: str): bool =
    if module == nil || arrType == nil || arrName == nil || len(arrName) == 0:
        return false
    if uirCoreHasObjType(module, arrName):
        return true
    if arrType.kind != nkBracketExpr || kidCount(arrType) < 3:
        return false
    let base: Node = kid(arrType, 0)
    if base == nil || (base.kind != nkIdent && base.kind != nkSymbol):
        return false
    let baseName: str = backendStripSpaces(plainName(base))
    if !(baseName == "array"):
        return false
    let arg1: Node = kid(arrType, 1)
    let arg2: Node = kid(arrType, 2)
    if arg1 == nil || arg2 == nil || arg1.kind == nkEmpty || arg2.kind == nkEmpty:
        return false

    let c1: int32 = tryResolveArrayCount(module, arg1)
    let c2: int32 = tryResolveArrayCount(module, arg2)
    var count: int32 = -1
    var elemTypeNode: Node = nil
    if c1 > 0 && c2 <= 0:
        count = c1
        elemTypeNode = arg2
    elif c2 > 0 && c1 <= 0:
        count = c2
        elemTypeNode = arg1
    elif c1 > 0 && c2 > 0:
        # Ambiguous; prefer `array[Count, ElemType]`.
        count = c1
        elemTypeNode = arg2
    if count <= 0 || elemTypeNode == nil || elemTypeNode.kind == nkEmpty:
        return false

    # If element type isn't resolved yet, defer array layout creation so we don't
    # lock in an incorrect element representation (e.g. unknown object types default to i32).
    if elemTypeNode.kind == nkIdent || elemTypeNode.kind == nkSymbol:
        let elemName: str = backendStripSpaces(plainName(elemTypeNode))
        if len(elemName) > 0 && !isBuiltinTypeName(elemName):
            if !uirCoreHasObjType(module, elemName):
                let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, elemName)
                if aliasTy.kind == mtVoid:
                    return false

    var elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(module, elemTypeNode)
    let elemObjName: str = typeNodeObjTypeName(module, elemTypeNode)
    if len(elemObjName) > 0 && typeNodeIsObjValue(module, elemTypeNode):
        elemTy = uirCoreTypeI64()
    let elemSize: int32 = uirCoreTypeSize(elemTy)
    if elemSize <= 0:
        return false
    let elemAlignPow2: int32 = uirCoreTypeAlignPow2(elemTy)
    let stride: int32 = alignUpPow2(elemSize, elemAlignPow2)
    if stride <= 0:
        return false
    var fields: UirCoreObjField[]
    var off: int32 = 0
    for i in 0..<count:
        var f: UirCoreObjField
        f.name = "e" + intToStr(i)
        f.ty = elemTy
        f.offset = off
        add(fields, f)
        off = off + stride
    var ot: UirCoreObjType
    ot.name = arrName
    ot.alignPow2 = elemAlignPow2
    ot.size = alignUpPow2(off, elemAlignPow2)
    ot.fields = fields
    uirCoreAddObjType(module, ot)
    return true

fn uirCoreCallCalleeName(callNode: Node): str =
    if callNode == nil || callNode.kind != nkCall || kidCount(callNode) == 0:
        return ""
    let callee: Node = kid(callNode, 0)
    if callee == nil:
        return ""
    if callee.kind == nkIdent || callee.kind == nkSymbol:
        return backendStripSpaces(plainName(callee))
    if callee.kind == nkDotExpr && kidCount(callee) > 1:
        let member: Node = kid(callee, 1)
        if member != nil && (member.kind == nkIdent || member.kind == nkSymbol):
            return backendStripSpaces(plainName(member))
        if member != nil && member.kind == nkBracketExpr && kidCount(member) > 0:
            let base2: Node = kid(member, 0)
            if base2 != nil && (base2.kind == nkIdent || base2.kind == nkSymbol):
                return backendStripSpaces(plainName(base2))
    if callee.kind == nkBracketExpr && kidCount(callee) > 0:
        let base: Node = kid(callee, 0)
        if base != nil && (base.kind == nkIdent || base.kind == nkSymbol):
            return backendStripSpaces(plainName(base))
    return ""

fn uirCoreNodeIsTypeArgInCallNoEnv(module: UirCoreModule, n: Node): bool =
    if module == nil || n == nil:
        return false
    case n.kind
    of nkPtrTy, nkRefTy, nkVarTy, nkFnTy, nkTupleTy, nkSetTy, nkBracketExpr:
        return true
    of nkIdent, nkSymbol:
        let nm: str = backendStripSpaces(plainName(n))
        if nm == nil || len(nm) == 0:
            return false
        if isBuiltinTypeName(nm):
            return true
        return uirCoreFindTypeAlias(module, nm) >= 0 || uirCoreFindObjType(module, nm) >= 0
    return false

fn uirCoreCallNameForReachability(module: UirCoreModule, callNode: Node): str =
    if callNode == nil || callNode.kind != nkCall || kidCount(callNode) == 0:
        return ""
    let callee: Node = kid(callNode, 0)
    if callee == nil:
        return ""
    var name: str = ""
    var typeArgs: Node[4]
    if callee.kind == nkIdent || callee.kind == nkSymbol:
        name = backendStripSpaces(plainName(callee))
    elif callee.kind == nkBracketExpr && kidCount(callee) > 0:
        let base: Node = kid(callee, 0)
        name = backendStripSpaces(plainName(base))
        for ti in 1..<kidCount(callee):
            let t: Node = kid(callee, ti)
            if t != nil && t.kind != nkEmpty:
                add(typeArgs, t)
    elif callee.kind == nkDotExpr && kidCount(callee) > 1:
        let member: Node = kid(callee, 1)
        if member != nil && member.kind == nkBracketExpr && kidCount(member) > 0:
            let base2: Node = kid(member, 0)
            name = backendStripSpaces(plainName(base2))
            for ti2 in 1..<kidCount(member):
                let t2: Node = kid(member, ti2)
                if t2 != nil && t2.kind != nkEmpty:
                    add(typeArgs, t2)
        else:
            name = backendStripSpaces(plainName(member))

    if name == nil || len(name) == 0:
        return ""
    if module != nil && typeArgs.len > 0:
        return mangleInstance(name, typeArgs)
    return name

fn uirCoreCollectCallsDeep(module: UirCoreModule, n: Node, out: str[]*) =
    if n == nil || out == nil:
        return
    if n.kind == nkComprehension:
        # Comprehensions lower to a loop that appends via `add`.
        uirCoreAddStrPtr(out, "add")
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(n))
        if len(nm) > 0:
            uirCoreAddStrPtr(out, nm)
    if n.kind == nkBracketExpr && kidCount(n) == 2:
        # Bracket syntax can target user-defined `[]` / `[]=` operators, which may be pruned by
        # reachability if we only follow explicit `nkCall` nodes.
        uirCoreAddStrPtr(out, "[]")
    if (n.kind == nkAsgn || n.kind == nkFastAsgn) && kidCount(n) >= 2:
        let lhs0: Node = kid(n, 0)
        if lhs0 != nil && lhs0.kind == nkBracketExpr && kidCount(lhs0) == 2:
            uirCoreAddStrPtr(out, "[]=")
        elif lhs0 != nil && (lhs0.kind == nkIdent || lhs0.kind == nkSymbol):
            # Simple assignments can target user-defined `=` operators.
            uirCoreAddStrPtr(out, "=")
    if n.kind == nkCall:
        let name: str = uirCoreCallNameForReachability(module, n)
        if len(name) > 0:
            uirCoreAddStrPtr(out, name)
        if (name == "__addr") && kidCount(n) >= 2:
            var arg0: Node = kid(n, 1)
            if arg0 != nil && arg0.kind == nkCallArg && kidCount(arg0) > 1:
                arg0 = kid(arg0, 1)
            if arg0 != nil && (arg0.kind == nkIdent || arg0.kind == nkSymbol):
                let target: str = backendStripSpaces(plainName(arg0))
                if len(target) > 0:
                    uirCoreAddStrPtr(out, target)
    for i in 0..<kidCount(n):
        uirCoreCollectCallsDeep(module, kid(n, i), out)

fn uirCoreIndexFnDecls(root: Node, outMap: hashmaps.HashMapStrSeqInt*, outNodes: Node[]*) =
    if root == nil || outMap == nil || outNodes == nil:
        return
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            uirCoreIndexFnDecls(n, outMap, outNodes)
            continue
        if (n.kind == nkFnDecl || n.kind == nkIteratorDecl) && kidCount(n) > 0:
            let nameNode: Node = kid(n, 0)
            if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                let nm: str = backendStripSpaces(plainName(nameNode))
                let idx: int32 = outNodes->len
                add(outNodes, n)
                hashmaps.hashMapStrSeqIntAdd(outMap, nm, idx)
                let sigOff: int32 = uirCoreStrIndexOf(nm, uirCoreFuncSigMarker())
                if sigOff > 0:
                    let base: str = uirCoreStrTake(nm, sigOff)
                    if base != nil && len(base) > 0 && !(base == nm):
                        hashmaps.hashMapStrSeqIntAdd(outMap, base, idx)
                let modOff: int32 = uirCoreStrIndexOf(nm, "__cheng_mod_")
                if modOff > 0:
                    let base2: str = uirCoreStrTake(nm, modOff)
                    if base2 != nil && len(base2) > 0 && !(base2 == nm):
                        hashmaps.hashMapStrSeqIntAdd(outMap, base2, idx)

fn uirCoreReachDeclIdxs(index: hashmaps.HashMapStrSeqInt, nodes: Node[], name: str, foundOut: bool* = nil): int32[] =
    var found: bool = false
    let idxs: int32[] = hashmaps.hashMapStrSeqIntGet(index, name, &found)
    if found && idxs.len > 0:
        if foundOut != nil:
            *foundOut = true
        return idxs
    var out: int32[]
    for i in 0..<nodes.len:
        let declNode: Node = nodes[i]
        if declNode == nil || kidCount(declNode) <= 0:
            continue
        let declNameNode: Node = kid(declNode, 0)
        if declNameNode == nil || (declNameNode.kind != nkIdent && declNameNode.kind != nkSymbol):
            continue
        let declName: str = backendStripSpaces(plainName(declNameNode))
        if declName == name:
            add(out, i)
    if foundOut != nil:
        *foundOut = out.len > 0
    return out

fn uirCoreComputeReachableFns(module: UirCoreModule, root: Node): hashsets.HashSetStr =
    let rootKids0: int32 = kidCount(root)
    let rootKids: int32 = (rootKids0 > 0) ? rootKids0 : 1
    let workCap: int32 = rootKids * 2 + 256
    var index: hashmaps.HashMapStrSeqInt = hashmaps.hashMapStrSeqIntInit(workCap)
    var nodes: Node[workCap]
    uirCoreIndexFnDecls(root, &index, &nodes)

    var reachable: hashsets.HashSetStr = hashsets.hashSetStrInit(workCap)
    var queue: str[]
    queue.cap = workCap
    hashsets.hashSetStrAdd(reachable, "main")
    add(queue, "main")

    # Global initializers run before `main`, so their callees must be treated as reachable even
    # if they are not referenced from the function call graph rooted at `main`.
    var initWork: Node[]
    initWork.cap = workCap
    add(initWork, root)
    while initWork.len > 0:
        let n: Node = initWork[initWork.len - 1]
        initWork.len = initWork.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkFnDecl || n.kind == nkIteratorDecl:
            continue
        if n.kind == nkLet || n.kind == nkVar || n.kind == nkConst:
            var callees: str[64]
            uirCoreCollectCallsDeep(module, n, &callees)
            for ci in 0..<callees.len:
                let nm: str = callees[ci]
                var inProgram: bool = false
                let calleeIdxs: int32[] = uirCoreReachDeclIdxs(index, nodes, nm, &inProgram)
                if inProgram && calleeIdxs.len > 0:
                    for ki in 0..<calleeIdxs.len:
                        let k: int32 = calleeIdxs[ki]
                        if k >= 0 && k < nodes.len:
                            let declNode: Node = nodes[k]
                            let declNameNode: Node = (declNode != nil && kidCount(declNode) > 0) ? kid(declNode, 0) : nil
                            if declNameNode != nil && (declNameNode.kind == nkIdent || declNameNode.kind == nkSymbol):
                                let declName: str = backendStripSpaces(plainName(declNameNode))
                                if len(declName) > 0 && !hashsets.hashSetStrHas(reachable, declName):
                                    hashsets.hashSetStrAdd(reachable, declName)
                                    add(queue, declName)
        for i in 0..<kidCount(n):
            add(initWork, kid(n, i))

    for qi in 0..<queue.len:
        let cur: str = queue[qi]
        var found: bool = false
        let idxs: int32[] = hashmaps.hashMapStrSeqIntGet(index, cur, &found)
        if !found || idxs.len == 0:
            continue
        for ni in 0..<idxs.len:
            let idx: int32 = idxs[ni]
            if idx < 0 || idx >= nodes.len:
                continue
            let fnNode: Node = nodes[idx]
            var callees: str[64]
            uirCoreCollectCallsDeep(module, fnNode, &callees)
            for ci in 0..<callees.len:
                let nm: str = callees[ci]
                var inProgram: bool = false
                let calleeIdxs: int32[] = uirCoreReachDeclIdxs(index, nodes, nm, &inProgram)
                if inProgram && calleeIdxs.len > 0:
                    for ki in 0..<calleeIdxs.len:
                        let k: int32 = calleeIdxs[ki]
                        if k >= 0 && k < nodes.len:
                            let declNode: Node = nodes[k]
                            let declNameNode: Node = (declNode != nil && kidCount(declNode) > 0) ? kid(declNode, 0) : nil
                            if declNameNode != nil && (declNameNode.kind == nkIdent || declNameNode.kind == nkSymbol):
                                let declName: str = backendStripSpaces(plainName(declNameNode))
                                if len(declName) > 0 && !hashsets.hashSetStrHas(reachable, declName):
                                    hashsets.hashSetStrAdd(reachable, declName)
                                    add(queue, declName)
    return reachable

fn uirCoreFuncSigMarker(): str =
    return "__cheng_sig_"

fn uirCoreFuncSigInput(retKey0: str, paramKeys: str[]): str =
    var retKey: str = retKey0
    if retKey == nil:
        retKey = ""
    var out: str = retKey + "|"
    for i in 0..<paramKeys.len:
        let pk0: str = paramKeys[i]
        let pk: str = (pk0 != nil) ? pk0 : ""
        out = out + pk + ";"
    return out

fn uirCoreFuncSigId(retKey: str, paramKeys: str[]): str =
    return uirCoreU64ToHex(uirCoreFnv1a64(uirCoreFuncSigInput(retKey, paramKeys)))

fn uirCoreMangleOverloadName(baseSym: str, retKey: str, paramKeys: str[]): str =
    return baseSym + uirCoreFuncSigMarker() + uirCoreFuncSigId(retKey, paramKeys)

fn uirCoreComputeOverloadedFnBases(root: Node): hashsets.HashSetStr =
    # Stage1 monomorphize may emit multiple functions with the same base name (e.g. `len`)
    # but different signatures. The MIR module requires globally-unique function symbols,
    # so we precompute which base names are overloaded.
    var overloaded: hashsets.HashSetStr = hashsets.hashSetStrInit(256)
    var seenNames: str[]
    var firstSigs: str[]

    var queue: Node[256]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
            continue
        if (n.kind != nkFnDecl && n.kind != nkIteratorDecl) || kidCount(n) == 0:
            continue
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            continue
        let nameNode: Node = kid(n, 0)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let rawName: str = backendStripSpaces(plainName(nameNode))
        let baseId: str = rawName
        if baseId == nil || len(baseId) == 0:
            continue

        let paramsNode: Node = kid(n, 1)
        var paramKeys: str[]
        if paramsNode != nil && paramsNode.kind == nkFormalParams:
            for pi in 0..<kidCount(paramsNode):
                let defs: Node = kid(paramsNode, pi)
                if defs != nil && defs.kind == nkIdentDefs && kidCount(defs) > 1:
                    let tn: Node = kid(defs, 1)
                    let pk: str = (tn != nil) ? typeKey(tn) : ""
                    add(paramKeys, pk)

        let retNode: Node = kid(n, 2)
        var retKey: str = ""
        if retNode != nil && retNode.kind != nkEmpty:
            retKey = typeKey(retNode)
        let sigId: str = uirCoreFuncSigId(retKey, paramKeys)

        var prevIdx: int32 = -1
        for si in 0..<seenNames.len:
            if seenNames[si] == baseId:
                prevIdx = si
                break
        if prevIdx < 0:
            add(seenNames, baseId)
            add(firstSigs, sigId)
            continue
        if prevIdx < firstSigs.len:
            let prevSig: str = firstSigs[prevIdx]
            if !(prevSig == sigId):
                hashsets.hashSetStrAdd(overloaded, baseId)
    return overloaded

fn uirCoreMaybeEnqueueMissingRoutine(mod: UirCoreModule, declIndex: hashmaps.HashMapStrInt,
                                 seen: hashsets.HashSetStr*, queue: str[]*, name0: str) =
    if mod == nil || seen == nil || queue == nil || name0 == nil || len(name0) == 0:
        return
    trackLexString void*(name0)
    var foundDecl: bool = false
    let _declIdx: int32 = uirCoreHashMapStrIntGetCompat(declIndex, name0, foundDecl)
    if !foundDecl || _declIdx < 0:
        return
    if moduleHasFunc(mod, name0):
        return
    if hashsets.hashSetStrHas(*seen, name0):
        return
    hashsets.hashSetStrAdd(seen, name0)
    add(queue, name0)

fn uirCoreMaybeEnqueueFromExpr(mod: UirCoreModule, declIndex: hashmaps.HashMapStrInt,
                           seen: hashsets.HashSetStr*, queue: str[]*, e: UirCoreExpr) =
    if e == nil:
        return
    case e.kind
    of meCall:
        uirCoreMaybeEnqueueMissingRoutine(mod, declIndex, seen, queue, e.callee)
        for i in 0..<e.args.len:
            uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, e.args[i])
    of meGlobalAddr:
        uirCoreMaybeEnqueueMissingRoutine(mod, declIndex, seen, queue, e.globalName)
    of meBin, meCmp:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, e.lhs)
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, e.rhs)
    of meCast:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, e.castExpr)
    of meLoad:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, e.addrExpr)
    else:
        return

fn uirCoreMaybeEnqueueFromStmt(mod: UirCoreModule, declIndex: hashmaps.HashMapStrInt,
                           seen: hashsets.HashSetStr*, queue: str[]*, s: UirCoreStmt) =
    if s.expr != nil:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, s.expr)
    if s.addrExpr != nil:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, s.addrExpr)

fn uirCoreMaybeEnqueueFromTerm(mod: UirCoreModule, declIndex: hashmaps.HashMapStrInt,
                           seen: hashsets.HashSetStr*, queue: str[]*, t: UirCoreTerm) =
    if t.kind == mtRet:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, t.retExpr)
    elif t.kind == mtCbr:
        uirCoreMaybeEnqueueFromExpr(mod, declIndex, seen, queue, t.condExpr)

fn uirCoreMaybeEnqueueFromFunc(mod: UirCoreModule, declIndex: hashmaps.HashMapStrInt,
                           seen: hashsets.HashSetStr*, queue: str[]*, f: UirCoreFunc) =
    if f == nil:
        return
    for bi in 0..<f.blocks.len:
        let blk: UirCoreBlock = f.blocks[bi]
        if blk != nil:
            for si in 0..<blk.stmts.len:
                let stmt: UirCoreStmt = blk.stmts[si]
                uirCoreMaybeEnqueueFromStmt(mod, declIndex, seen, queue, stmt)
            uirCoreMaybeEnqueueFromTerm(mod, declIndex, seen, queue, blk.term)

fn uirCoreIndexFnDeclsMangled(root: Node, overloaded: hashsets.HashSetStr*,
                          outMap: hashmaps.HashMapStrInt*, outNodes: Node[]*) =
    if root == nil || outMap == nil || outNodes == nil:
        return
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            uirCoreIndexFnDeclsMangled(n, overloaded, outMap, outNodes)
            continue
        if n.kind != nkFnDecl && n.kind != nkIteratorDecl:
            continue
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            continue
        let nameNode: Node = kid(n, 0)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let rawName: str = backendStripSpaces(plainName(nameNode))
        let fp: str = (n.strVal != nil && len(n.strVal) > 0) ? n.strVal : (root.strVal != nil ? root.strVal : "")
        let symName: str = uirCoreMaybeMangleDupFnBase(rawName, fp)
        let baseSym: str = backendSanitizeLinkName(symName)

        let paramsNode: Node = kid(n, 1)
        var paramKeys: str[]
        if paramsNode != nil && paramsNode.kind == nkFormalParams:
            for pi in 0..<kidCount(paramsNode):
                let defs: Node = kid(paramsNode, pi)
                if defs != nil && defs.kind == nkIdentDefs && kidCount(defs) > 1:
                    let tn: Node = kid(defs, 1)
                    let pk: str = (tn != nil) ? typeKey(tn) : ""
                    add(paramKeys, pk)

        let retNode: Node = kid(n, 2)
        var retKey: str = ""
        if retNode != nil && retNode.kind != nkEmpty:
            retKey = typeKey(retNode)

        var name: str = symName
        if rawName != nil && !(rawName == "main") && overloaded != nil && hashsets.hashSetStrHas(*overloaded, rawName):
            name = uirCoreMangleOverloadName(baseSym, retKey, paramKeys)

        let idx: int32 = outNodes->len
        add(outNodes, n)
        hashmaps.hashMapStrIntPut(outMap, name, idx)

fn uirCoreBuildMissingRoutinesFromUir(mod: UirCoreModule, root: Node, overloaded: hashsets.HashSetStr* = nil): Result[bool] =
    if mod == nil || root == nil:
        return Ok[bool](false)
    var declIndex: hashmaps.HashMapStrInt = hashmaps.hashMapStrIntInit(1024)
    var declNodes: Node[512]
    uirCoreIndexFnDeclsMangled(root, overloaded, &declIndex, &declNodes)

    var existingFuncs: hashsets.HashSetStr = hashsets.hashSetStrInit(mod.funcs.len * 2 + 8)
    for fi0 in 0..<mod.funcs.len:
        let f0: UirCoreFunc = mod.funcs[fi0]
        if f0 != nil && f0.name != nil && len(f0.name) > 0:
            hashsets.hashSetStrAdd(existingFuncs, f0.name)

    var seen: hashsets.HashSetStr = hashsets.hashSetStrInit(256)
    var queue: str[256]
    for fi in 0..<mod.funcs.len:
        let f0: UirCoreFunc = mod.funcs[fi]
        uirCoreMaybeEnqueueFromFunc(mod, declIndex, &seen, &queue, f0)

    var builtAny: bool = false
    for qi in 0..<queue.len:
        let nm: str = queue[qi]
        if nm == nil || len(nm) == 0:
            continue
        if hashsets.hashSetStrHas(existingFuncs, nm):
            continue
        var found: bool = false
        let idx: int32 = uirCoreHashMapStrIntGetCompat(declIndex, nm, found)
        if !found || idx < 0 || idx >= declNodes.len:
            continue
        let n: Node = declNodes[idx]
        if n == nil:
            continue
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            continue
        let fp: str = (n.strVal != nil && len(n.strVal) > 0) ? n.strVal : (root.strVal != nil ? root.strVal : "")
        let fRes: Result[UirCoreFunc] = uirCoreBuildFunc(mod, n, fp, overloaded)
        if ! IsOk[UirCoreFunc](fRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreFunc](fRes))
        let f: UirCoreFunc = Value[UirCoreFunc](fRes)
        if f == nil:
            continue
        if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
           uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
            var sameFile: bool = false
            for di in 0..<mod.funcs.len:
                let ex: UirCoreFunc = mod.funcs[di]
                if ex != nil && (ex.name == f.name) && (ex.originFile == f.originFile):
                    sameFile = true
                    break
            if sameFile:
                continue
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name)
        uirCoreAddFunc(mod, f)
        hashsets.hashSetStrAdd(existingFuncs, f.name)
        builtAny = true
        uirCoreMaybeEnqueueFromFunc(mod, declIndex, &seen, &queue, f)
    return Ok[bool](builtAny)

fn nodeIsTypeArgInCall(b: BlockBuilder, n: Node): bool =
    if b == nil || n == nil:
        return false
    case n.kind
    of nkPtrTy, nkRefTy, nkVarTy, nkFnTy, nkTupleTy, nkSetTy, nkBracketExpr:
        return true
    of nkIdent, nkSymbol:
        let nm: str = backendStripSpaces(plainName(n))
        if localIndex(b.env, nm) >= 0:
            return false
        if moduleGlobalIndex(b.module, nm) >= 0:
            return false
        if nm == "int8" || nm == "uint8" || nm == "i8" || nm == "u8" ||
           nm == "int16" || nm == "uint16" || nm == "i16" || nm == "u16" ||
           nm == "int32" || nm == "uint32" || nm == "i32" || nm == "u32" ||
           nm == "int64" || nm == "uint64" || nm == "i64" || nm == "u64" ||
           nm == "int" || nm == "uint" ||
           nm == "float32" || nm == "float64" || nm == "float" ||
           nm == "bool" || nm == "char" || nm == "str" || nm == "void" || nm == "cstring":
            return true
        return uirCoreFindTypeAlias(b.module, nm) >= 0 || uirCoreFindObjType(b.module, nm) >= 0
    return false

fn uirCoreTypeKindName(t: UirCoreType): str =
    if t.kind == mtVoid:
        return "void"
    if t.kind == mtF64:
        return "f64"
    if t.kind == mtF32:
        return "f32"
    if t.kind == mtI64:
        return t.isUnsigned ? "u64" : "i64"
    if t.kind == mtI32:
        return t.isUnsigned ? "u32" : "i32"
    if t.kind == mtI16:
        return t.isUnsigned ? "u16" : "i16"
    if t.kind == mtI8:
        return t.isUnsigned ? "u8" : "i8"
    return "i32"

fn backendStripSpaces(s: str): str =
    if s == nil:
        return ""
    let n: int32 = len s
    if n == 0:
        return ""
    var hasWs: bool = false
    for i in 0..<n:
        let c: char = s[i]
        if c == ' ' || c == '\t' || c == '\n' || c == '\r':
            hasWs = true
            break
    if !hasWs:
        return s
    let p: void* = alloc(n + 1)
    var outIdx: int32 = 0
    for i in 0..<n:
        let c: char = s[i]
        if c != ' ' && c != '\t' && c != '\n' && c != '\r':
            let dst: void* = ptr_add(p, outIdx)
            var pc: char* = char*(dst)
            *pc = c
            outIdx = outIdx + 1
    setMem(ptr_add(p, outIdx), 0, 1)
    trackLexString p
    return str(p)

fn backendStripSpacesMaybe(s: str): str =
    return backendStripSpaces(s)

fn backendIsSafeLinkName(name: str): bool =
    if name == nil:
        return false
    let n: int32 = len(name)
    if n == 0:
        return false
    let c0: char = name[0]
    let v0: int32 = int32(int64(c0) & 0xFF)
    if ! ((v0 >= 65 && v0 <= 90) || (v0 >= 97 && v0 <= 122) || v0 == 95):
        return false
    for i in 0..<n:
        let c: char = name[i]
        let v: int32 = int32(int64(c) & 0xFF)
        if (v >= 65 && v <= 90) || (v >= 97 && v <= 122) ||
           (v >= 48 && v <= 57) || v == 95:
            continue
        return false
    return true

fn backendHexDigitLower(v: int32): char =
    if v < 10:
        return char(int8(48 + v))
    return char(int8(97 + (v - 10)))

fn backendHexByteLower(v: int32): str =
    let hi: int32 = (v / 16) & 15
    let lo: int32 = v & 15
    return charToStr(backendHexDigitLower(hi)) + charToStr(backendHexDigitLower(lo))

fn backendSanitizeLinkName(raw: str): str =
    if raw == nil:
        return ""
    let name: str = backendStripSpaces(raw)
    if backendIsSafeLinkName(name):
        return name
    if name == nil:
        return "__cheng_anon"
    let nameLen: int32 = len(name)
    if nameLen == 0:
        return "__cheng_anon"
    var out: str = "__cheng_sym"
    for i in 0..<nameLen:
        let c: char = name[i]
        let v: int32 = int32(int64(c) & 0xFF)
        out = out + "_" + backendHexByteLower(v)
    return out

fn uirCoreStrStartsWith(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    var i: int32 = 0
    while true:
        let pc: char = prefix[i]
        if pc == char(0):
            return true
        let sc: char = s[i]
        if sc == char(0):
            return false
        if sc != pc:
            return false
        i = i + 1

fn uirCoreStripLeadingUnderscores(raw: str): str =
    if raw == nil:
        return ""
    let n: int32 = len(raw)
    if n <= 0:
        return ""
    var i: int32 = 0
    while i < n && raw[i] == '_':
        i = i + 1
    if i <= 0:
        return raw
    if i >= n:
        return ""
    return str(ptr_add(void*(raw), i))

fn uirCoreInferCtorSuffixFromTypeCache(b: BlockBuilder, callNode: Node, objPrefix: str): str =
    if b == nil || b.module == nil || callNode == nil || objPrefix == nil || len(objPrefix) == 0:
        return ""
    if callNode.typeCacheValid && callNode.typeCache != nil:
        let tc: Node = callNode.typeCache
        let objName0: str = typeNodeObjTypeName(b.module, tc)
        if objName0 != nil && uirCoreStrStartsWith(objName0, objPrefix):
            let suffix0: str = str(ptr_add(void*(objName0), len(objPrefix)))
            if suffix0 != nil && len(suffix0) > 0:
                return suffix0
        let key0: str = typeKey(tc)
        if key0 != nil && uirCoreStrStartsWith(key0, objPrefix):
            let suffix1: str = str(ptr_add(void*(key0), len(objPrefix)))
            if suffix1 != nil && len(suffix1) > 0:
                return suffix1
    return ""

fn uirCoreTypeKeyStripIterWrappers(typeKey0: str): str =
    var key: str = backendStripSpaces(typeKey0)
    if key == nil:
        return ""
    while true:
        if uirCoreStrStartsWith(key, "ref_"):
            key = str(ptr_add(void*(key), 4))
            continue
        if uirCoreStrStartsWith(key, "var_ref_"):
            key = str(ptr_add(void*(key), 8))
            continue
        if uirCoreStrStartsWith(key, "var_"):
            key = str(ptr_add(void*(key), 4))
            continue
        if uirCoreStrStartsWith(key, "ptr_"):
            key = str(ptr_add(void*(key), 4))
            continue
        break
    return key

fn uirCoreTypeKeyFromNodeLoose(typeNode0: Node): str =
    var typeNode: Node = typeNode0
    while typeNode != nil && typeNode.kind == nkPar && kidCount(typeNode) > 0:
        typeNode = kid(typeNode, 0)
    if typeNode == nil:
        return ""
    if typeNode.kind == nkDotExpr && kidCount(typeNode) > 1:
        let rhs: Node = kid(typeNode, 1)
        let rhsKey: str = uirCoreTypeKeyFromNodeLoose(rhs)
        if rhsKey != nil && len(rhsKey) > 0:
            return rhsKey
    let key: str = backendStripSpaces(typeKey(typeNode))
    if key != nil && len(key) > 0 && !(key == "node"):
        return key
    let nm: str = backendStripSpaces(plainName(typeNode))
    if nm != nil && len(nm) > 0:
        return nm
    return ""

fn uirCoreTypeKeyBaseName(typeKey0: str): str =
    let key: str = backendStripSpaces(typeKey0)
    if key == nil || len(key) == 0:
        return ""
    let __for_start_i = len(key) - 1
    for __for_rev_i in 0..(__for_start_i - (0)):
        let i = __for_start_i - __for_rev_i
        if key[i] == '.':
            return str(ptr_add(void*(key), i + 1))
    return key

fn uirCoreTypeKeyIsTableIter(typeKey0: str): bool =
    let key: str = uirCoreTypeKeyBaseName(uirCoreTypeKeyStripIterWrappers(typeKey0))
    return (key == "Table") || uirCoreStrStartsWith(key, "Table_")

fn uirCoreTypeKeyTableValKey(typeKey0: str): str =
    let key: str = uirCoreTypeKeyBaseName(uirCoreTypeKeyStripIterWrappers(typeKey0))
    if uirCoreStrStartsWith(key, "Table_"):
        return str(ptr_add(void*(key), 6))
    return ""

fn uirCoreHashMapIterFlavorFromTypeKey(typeKey0: str): int32 =
    let key: str = uirCoreTypeKeyBaseName(uirCoreTypeKeyStripIterWrappers(typeKey0))
    if (key == "HashMapStrInt"):
        return 1
    if (key == "HashMapStrSeqInt"):
        return 2
    if (key == "HashMapPtrInt"):
        return 3
    let __for_start_i = len(key) - 1
    for __for_rev_i in 0..(__for_start_i - (0)):
        let i = __for_start_i - __for_rev_i
        if key[i] == '_':
            let suffix: str = str(ptr_add(void*(key), i + 1))
            if (suffix == "HashMapStrInt"):
                return 1
            if (suffix == "HashMapStrSeqInt"):
                return 2
            if (suffix == "HashMapPtrInt"):
                return 3
    return 0

fn uirCoreStrIndexOf(s: str, sub: str): int32 =
    if s == nil || sub == nil:
        return -1
    let n: int32 = len(s)
    let m: int32 = len(sub)
    if m == 0:
        return 0
    if m > n:
        return -1
    for i in 0..n - m:
        for j in 0..<m:
            if !(s[i + j] == sub[j]):
                break
        if j == m:
            return i
    return -1

fn uirCoreStrTake(s: str, count: int32): str =
    if s == nil || count <= 0:
        return ""
    let n: int32 = len(s)
    var k: int32 = count
    if k > n:
        k = n
    let p: void* = alloc(k + 1)
    if k > 0:
        copyMem(p, s, k)
    setMem(ptr_add(p, k), 0, 1)
    trackLexString p
    return str(p)

fn backendOpName(n: Node): str =
    if n == nil:
        return ""
    return backendStripSpaces(n.ident)

fn uirCoreIntBitsDefault32(): int32 =
    # Backend MVP supports INTBITS=32/64 only.
    let raw: str = backendStripSpaces(os.getEnv("INTBITS"))
    if (raw == "64"):
        return 64
    return 32

fn uirCoreTypeFromNode(n: Node): UirCoreType =
    if n == nil || n.kind == nkEmpty:
        return uirCoreTypeI32()
    if n.kind == nkPtrTy || n.kind == nkRefTy || n.kind == nkFnTy || n.kind == nkSetTy || n.kind == nkVarTy || n.kind == nkTupleTy:
        return uirCoreTypeI64()
    # Stage1 often stores token idents with surrounding spaces.
    let name: str = backendStripSpaces(plainName(n))
    if name == "void":
        return uirCoreTypeVoid()
    if name == "tuple" || uirCoreStrStartsWith(name, "tuple_"):
        return uirCoreTypeI64()
    if name == "float64" || name == "float":
        return uirCoreTypeF64()
    if name == "float32":
        return uirCoreTypeF32()
    if name == "bool":
        return uirCoreTypeU8()
    if name == "char":
        return uirCoreTypeU8()
    if name == "int8" || name == "i8":
        return uirCoreTypeI8()
    if name == "uint8" || name == "u8":
        return uirCoreTypeU8()
    if name == "int16" || name == "i16":
        return uirCoreTypeI16()
    if name == "uint16" || name == "u16":
        return uirCoreTypeU16()
    if name == "int" || name == "NI":
        let bits: int32 = uirCoreIntBitsDefault32()
        if bits == 64:
            return uirCoreTypeI64()
        return uirCoreTypeI32()
    if name == "uint" || name == "NU":
        let bits2: int32 = uirCoreIntBitsDefault32()
        if bits2 == 64:
            return uirCoreTypeU64()
        return uirCoreTypeU32()
    if name == "int64" || name == "i64":
        return uirCoreTypeI64()
    if name == "uint64" || name == "u64":
        return uirCoreTypeU64()
    if name == "int32" || name == "i32":
        return uirCoreTypeI32()
    if name == "uint32" || name == "u32":
        return uirCoreTypeU32()
    if uirCoreStrStartsWith(name, "set_"):
        return uirCoreTypeU64()
    if uirCoreStrStartsWith(name, "seq_"):
        return uirCoreTypeI64()
    if name == "str" || name == "string" || name == "cstring" || name == "void*" || name == "ptr":
        return uirCoreTypeI64()
    return uirCoreTypeI32()

fn uirCoreTypeFromTypeKeyName(key0: str): UirCoreType =
    if key0 == nil || len(key0) == 0:
        return uirCoreTypeI64()
    let key: str = backendStripSpaces(key0)
    if key == "void":
        return uirCoreTypeVoid()
    if key == "float64" || key == "float":
        return uirCoreTypeF64()
    if key == "float32":
        return uirCoreTypeF32()
    if key == "bool" || key == "char":
        return uirCoreTypeU8()
    if key == "int8" || key == "i8":
        return uirCoreTypeI8()
    if key == "uint8" || key == "u8":
        return uirCoreTypeU8()
    if key == "int16" || key == "i16":
        return uirCoreTypeI16()
    if key == "uint16" || key == "u16":
        return uirCoreTypeU16()
    if key == "int32" || key == "i32":
        return uirCoreTypeI32()
    if key == "uint32" || key == "u32":
        return uirCoreTypeU32()
    if key == "int64" || key == "i64":
        return uirCoreTypeI64()
    if key == "uint64" || key == "u64":
        return uirCoreTypeU64()
    if key == "int" || key == "NI":
        let bits: int32 = uirCoreIntBitsDefault32()
        return (bits == 64) ? uirCoreTypeI64() : uirCoreTypeI32()
    if key == "uint" || key == "NU":
        let bits2: int32 = uirCoreIntBitsDefault32()
        return (bits2 == 64) ? uirCoreTypeU64() : uirCoreTypeU32()
    if key == "str" || key == "string" || key == "cstring" || key == "void*" || key == "ptr":
        return uirCoreTypeI64()
    if uirCoreStrStartsWith(key, "ptr_") || uirCoreStrStartsWith(key, "ref_") || uirCoreStrStartsWith(key, "fn_"):
        return uirCoreTypeI64()
    if uirCoreStrStartsWith(key, "seq_") || uirCoreStrStartsWith(key, "seq_fixed_") || uirCoreStrStartsWith(key, "Table_"):
        return uirCoreTypeI64()
    if uirCoreStrStartsWith(key, "set_"):
        return uirCoreTypeU64()
    return uirCoreTypeI64()

fn uirCoreLooksLikeTypeParamName(name0: str): bool =
    let name: str = backendStripSpaces(name0)
    if name == nil || len(name) != 1:
        return false
    let c: char = name[0]
    return c >= 'A' && c <= 'Z'

fn uirCoreSizeOfTypeNode(module: UirCoreModule, typeNode: Node): Result[int32] =
    if typeNode == nil || typeNode.kind == nkEmpty:
        return Err[int32]("uirCore_builder: sizeof expects a type/expression")
    if typeNode.kind == nkPtrTy || typeNode.kind == nkRefTy || typeNode.kind == nkFnTy || typeNode.kind == nkVarTy:
        return Ok[int32](8)
    if typeNode.kind == nkTupleTy:
        let nm: str = typeNodeObjTypeName(module, typeNode)
        if len(nm) > 0 && module != nil && uirCoreHasObjType(module, nm):
            let ot: UirCoreObjType = uirCoreGetObjType(module, nm)
            return Ok[int32](ot.size)
        return Err[int32]("uirCore_builder: sizeof unknown tuple type")
    if typeNode.kind == nkIdent || typeNode.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(typeNode))
        if nm == "bool" || nm == "char" || nm == "int8" || nm == "uint8" || nm == "i8" || nm == "u8":
            return Ok[int32](1)
        if nm == "int16" || nm == "uint16" || nm == "i16" || nm == "u16":
            return Ok[int32](2)
        if nm == "int32" || nm == "uint32" || nm == "i32" || nm == "u32" || nm == "float32":
            return Ok[int32](4)
        if nm == "int" || nm == "uint" || nm == "NI" || nm == "NU":
            let bits: int32 = uirCoreIntBitsDefault32()
            if bits == 64:
                return Ok[int32](8)
            return Ok[int32](4)
        if nm == "int64" || nm == "uint64" || nm == "i64" || nm == "u64" || nm == "float64":
            return Ok[int32](8)
        if nm == "str" || nm == "string" || nm == "cstring" || nm == "void*" || nm == "ptr":
            return Ok[int32](8)
        if uirCoreStrStartsWith(nm, "ptr_") || uirCoreStrStartsWith(nm, "ref_") || uirCoreStrStartsWith(nm, "fn_"):
            return Ok[int32](8)
        if uirCoreStrStartsWith(nm, "seq_") || uirCoreStrStartsWith(nm, "seq_fixed_") || uirCoreStrStartsWith(nm, "Table_"):
            return Ok[int32](8)
        if uirCoreStrStartsWith(nm, "set_"):
            return Ok[int32](8)
        if nm == "void":
            return Ok[int32](0)
        if module != nil:
            let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, nm)
            if aliasTy.kind == mtF64:
                return Ok[int32](8)
            if aliasTy.kind == mtF32:
                return Ok[int32](4)
            if aliasTy.kind == mtI64:
                return Ok[int32](8)
            if aliasTy.kind == mtI32:
                return Ok[int32](4)
            if aliasTy.kind == mtI16:
                return Ok[int32](2)
            if aliasTy.kind == mtI8:
                return Ok[int32](1)
        if module != nil && uirCoreHasObjType(module, nm):
            let ot2: UirCoreObjType = uirCoreGetObjType(module, nm)
            return Ok[int32](ot2.size)
        # Skip-mono gate compiles keep some generic helpers uninstantiated.
        # Treat single-letter generic params (`T`/`V`/`K`) as pointer-sized.
        if uirCoreShouldSkipMonoPass() && uirCoreLooksLikeTypeParamName(nm):
            return Ok[int32](8)
        if getEnv("BACKEND_SIZEOF_UNKNOWN_FALLBACK") == "1":
            return Ok[int32](8)
        let line2: str = intToStr(typeNode.pos.line)
        let col2: str = intToStr(typeNode.pos.col)
        return Err[int32]("uirCore_builder: sizeof unknown type '" + nm + "' @" + line2 + ":" + col2)
    if typeNode.kind == nkBracketExpr && kidCount(typeNode) > 0:
        let base: Node = kid(typeNode, 0)
        if base != nil && (base.kind == nkIdent || base.kind == nkSymbol):
            let nm2: str = backendStripSpaces(plainName(base))
            if nm2 == "seq" && module != nil && uirCoreHasObjType(module, "seq"):
                let ot3: UirCoreObjType = uirCoreGetObjType(module, "seq")
                return Ok[int32](ot3.size)
            if module != nil && uirCoreHasObjType(module, nm2):
                let ot4: UirCoreObjType = uirCoreGetObjType(module, nm2)
                return Ok[int32](ot4.size)
            var instArgs: Node[4]
            for ai in 1..<kidCount(typeNode):
                let a: Node = kid(typeNode, ai)
                if a != nil && a.kind != nkEmpty:
                    add(instArgs, a)
            if instArgs.len > 0:
                let instName: str = mangleInstance(nm2, instArgs)
                if module != nil && uirCoreHasObjType(module, instName):
                    let ot5: UirCoreObjType = uirCoreGetObjType(module, instName)
                    return Ok[int32](ot5.size)
    let k: str = intToStr(int32(typeNode.kind))
    let line: str = intToStr(typeNode.pos.line)
    let col: str = intToStr(typeNode.pos.col)
    return Err[int32]("uirCore_builder: sizeof unsupported type (nk#" + k + " @" + line + ":" + col + ")")

fn uirCoreTypeFromNodeWithModule(module: UirCoreModule, n: Node): UirCoreType =
    let ty: UirCoreType = uirCoreTypeFromNode(n)
    if module == nil || n == nil:
        return ty
    if n.kind == nkIdent || n.kind == nkSymbol:
        let name: str = backendStripSpaces(plainName(n))
        let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(module, name)
        if aliasTy.kind != mtVoid:
            return aliasTy
    return ty

fn inferExprType(env: LocalEnv, n: Node, fallback: UirCoreType): UirCoreType =
    if n == nil:
        return fallback
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node == nil:
        return fallback
    if node.kind == nkStrLit:
        return uirCoreTypeI64()
    if node.kind == nkFloatLit:
        return uirCoreTypeF64()
    if node.kind == nkCharLit:
        return uirCoreTypeU8()
    if node.kind == nkBoolLit:
        return uirCoreTypeU8()
    if node.kind == nkIdent || node.kind == nkSymbol:
        let idx: int32 = localIndex(env, plainName(node))
        if idx >= 0:
            return localType(env, idx)
        return fallback
    if node.kind == nkCall && kidCount(node) > 0:
        let calleeNode: Node = kid(node, 0)
        let name: str = backendStripSpaces(plainName(calleeNode))
        if name == "__addr":
            return uirCoreTypeI64()
        if name == "uint64" || name == "u64":
            return uirCoreTypeU64()
        if name == "int64" || name == "i64":
            return uirCoreTypeI64()
        if name == "uint32" || name == "u32":
            return uirCoreTypeU32()
        if name == "int32" || name == "i32":
            return uirCoreTypeI32()
        return fallback
    if node.kind == nkPrefix && kidCount(node) > 1:
        return inferExprType(env, kid(node, 1), fallback)
    if node.kind == nkInfix && kidCount(node) >= 3:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        let lt: UirCoreType = inferExprType(env, kid(node, 1), fallback)
        let rt: UirCoreType = inferExprType(env, kid(node, 2), fallback)
        if op == "<<" || op == ">>":
            return lt
        if lt.kind == mtF64 || rt.kind == mtF64:
            return uirCoreTypeF64()
        if lt.kind == mtF32 || rt.kind == mtF32:
            return uirCoreTypeF32()
        if lt.kind == mtI64 || rt.kind == mtI64:
            var out: UirCoreType = uirCoreTypeI64()
            out.isUnsigned = (lt.kind == mtI64 && lt.isUnsigned) || (rt.kind == mtI64 && rt.isUnsigned)
            return out
        var out2: UirCoreType = uirCoreTypeI32()
        out2.isUnsigned = lt.isUnsigned || rt.isUnsigned
        return out2
    return fallback

fn uirCore_buildGlobalIndexCache(module: UirCoreModule) =
    if module == nil:
        uirCore_globalIndex_cache_module = nil
        uirCore_globalIndex_cache_ready = false
        uirCore_globalIndex_cache_len = 0
        return
    uirCore_globalIndex_cache_module = module
    uirCore_globalIndex_cache = hashmaps.hashMapStrIntInit(module.globals.len * 2 + 8)
    for i in 0..<module.globals.len:
        let g: UirCoreGlobal = module.globals[i]
        if g.name != nil && len(g.name) > 0:
            hashmaps.hashMapStrIntPut(uirCore_globalIndex_cache, g.name, i)
    uirCore_globalIndex_cache_len = module.globals.len
    uirCore_globalIndex_cache_ready = true

fn uirCore_ensureGlobalIndexCache(module: UirCoreModule) =
    if module == nil:
        uirCore_globalIndex_cache_module = nil
        uirCore_globalIndex_cache_ready = false
        uirCore_globalIndex_cache_len = 0
        return
    if module.globals.len < 32:
        return
    if uirCore_globalIndex_cache_module != module || !uirCore_globalIndex_cache_ready:
        uirCore_buildGlobalIndexCache(module)
        return
    if uirCore_globalIndex_cache_len > module.globals.len:
        uirCore_buildGlobalIndexCache(module)
        return
    if uirCore_globalIndex_cache_len < module.globals.len:
        for i in uirCore_globalIndex_cache_len..<module.globals.len:
            let g: UirCoreGlobal = module.globals[i]
            if g.name != nil && len(g.name) > 0:
                hashmaps.hashMapStrIntPut(uirCore_globalIndex_cache, g.name, i)
        uirCore_globalIndex_cache_len = module.globals.len

fn moduleGlobalIndex(module: UirCoreModule, name: str): int32 =
    if module == nil || name == nil:
        return -1
    if module.globals.len >= 32:
        uirCore_ensureGlobalIndexCache(module)
        if uirCore_globalIndex_cache_ready && uirCore_globalIndex_cache_module == module:
            var found: bool = false
            let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCore_globalIndex_cache, name, found)
            if found && idx >= 0 && idx < module.globals.len:
                let g0: UirCoreGlobal = module.globals[idx]
                if (g0.name == name):
                    return idx
    for i in 0..<module.globals.len:
        let g: UirCoreGlobal = module.globals[i]
        if (g.name == name):
            if uirCore_globalIndex_cache_ready && uirCore_globalIndex_cache_module == module:
                hashmaps.hashMapStrIntPut(uirCore_globalIndex_cache, name, i)
            return i
    return -1

fn moduleGlobalType(module: UirCoreModule, name: str, fallback: UirCoreType): UirCoreType =
    let idx: int32 = moduleGlobalIndex(module, name)
    if idx < 0:
        return fallback
    let g: UirCoreGlobal = module.globals[idx]
    return g.ty

fn inferExprTypeWithGlobals(env: LocalEnv, module: UirCoreModule, func: UirCoreFunc, n: Node, fallback: UirCoreType): UirCoreType =
    if n == nil:
        return fallback
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node == nil:
        return fallback
    if node.kind == nkStrLit:
        return uirCoreTypeI64()
    if node.kind == nkFloatLit:
        return uirCoreTypeF64()
    if node.kind == nkCall:
        let name: str = uirCoreCallNameForReachability(module, node)
        if name != nil && len(name) > 0 && module != nil:
            let exact: UirCoreFunc = moduleFindFunc(module, name)
            if exact != nil:
                return exact.retType
            let unique: UirCoreFunc = moduleFindFuncByBaseUnique(module, name)
            if unique != nil:
                return unique.retType
    if node.kind == nkDotExpr && kidCount(node) > 1:
        let base: Node = kid(node, 0)
        let field: Node = kid(node, 1)
        if base != nil && (base.kind == nkIdent || base.kind == nkSymbol) &&
           field != nil && (field.kind == nkIdent || field.kind == nkSymbol):
            let baseName: str = plainName(base)
            let slot: int32 = localIndex(env, baseName)
            if slot >= 0:
                let objTypeName: str = funcObjTypeName(func, slot)
                if len(objTypeName) > 0:
                    let ot: UirCoreObjType = uirCoreGetObjType(module, objTypeName)
                    let fieldName: str = backendStripSpaces(plainName(field))
                    for fi in 0..<ot.fields.len:
                        let f: UirCoreObjField = ot.fields[fi]
                        if (f.name == fieldName):
                            return f.ty
        return fallback
    if node.kind == nkIdent || node.kind == nkSymbol:
        let name: str = plainName(node)
        let idx: int32 = localIndex(env, name)
        if idx >= 0:
            return localType(env, idx)
        let gidx: int32 = moduleGlobalIndex(module, name)
        if gidx >= 0:
            let g2: UirCoreGlobal = module.globals[gidx]
            return g2.ty
        if moduleHasFuncByBase(module, name):
            return uirCoreTypeI64()
        return fallback
    return inferExprType(env, node, fallback)

fn isAddrCall(n: Node): bool =
    if n == nil || n.kind != nkCall || kidCount(n) == 0:
        return false
    let calleeNode: Node = kid(n, 0)
    let name: str = backendStripSpaces(plainName(calleeNode))
    return name == "__addr"

fn funcSetObjLocal(func: UirCoreFunc, slot: int32, objTypeName: str, frameOff: int32) =
    if func == nil || objTypeName == nil || len(objTypeName) == 0:
        return
    let idx: int32 = funcFindObjLocal(func, slot)
    var ol: UirCoreObjLocal
    ol.slot = slot
    ol.objTypeName = objTypeName
    ol.typeKey = objTypeName
    ol.frameOff = frameOff
    if idx >= 0:
        mbWriteObjLocal(func.objLocals, idx, ol)
        return
    add(func.objLocals, ol)

fn allocObjValueLocal(b: BlockBuilder, slot: int32, objTypeName: str): Result[bool] =
    if b == nil || b.module == nil || b.func == nil:
        return Err[bool]("uirCore_builder: object alloc missing builder/module")
    if (getEnv "BACKEND_DEBUG_OBJLOCAL" == "1") && (objTypeName == "Node"):
        let bf0: UirCoreFunc = b.func
        echo("[backend] debug: allocObjValueLocal Node slot=" + intToStr(slot) +
             " fn=" + bf0.name + " file=" + bf0.originFile)
    let idx: int32 = uirCoreFindObjType(b.module, objTypeName)
    if idx < 0:
        return Err[bool]("uirCore_builder: unknown object type")
    let mod: UirCoreModule = b.module
    let ot: UirCoreObjType = mod.objTypes[idx]
    if ot.size <= 0:
        return Err[bool]("uirCore_builder: invalid object size")
    let off: int32 = alignUpPow2(b.objCursor, ot.alignPow2)
    b.objCursor = off + ot.size
    let fref: UirCoreFunc = b.func
    if b.objCursor > fref.objFrameSize:
        fref.objFrameSize = b.objCursor
    funcSetObjLocal(b.func, slot, objTypeName, off)
    return Ok[bool](true)

fn emitObjDefaultInit(b: BlockBuilder, slot: int32, objTypeName: str): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: object init missing builder/module")
    let idx: int32 = uirCoreFindObjType(b.module, objTypeName)
    if idx < 0:
        return Err[bool]("uirCore_builder: unknown object type")
    let mod: UirCoreModule = b.module
    let ot: UirCoreObjType = mod.objTypes[idx]
    for fi in 0..<ot.fields.len:
        let f: UirCoreObjField = ot.fields[fi]
        let basePtr: UirCoreExpr = uirCoreLocal(slot)
        var addr: UirCoreExpr = basePtr
        if f.offset != 0:
            addr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(f.offset)))
        add(b.currentStmts, uirCoreStmtStore(addr, uirCoreConstI64(0), f.ty))
    let seqFixedRes: Result[bool] = emitObjInlineSeqFixedReserveInitToPtr(b, uirCoreLocal(slot), objTypeName, ot)
    if !IsOk[bool](seqFixedRes):
        return ErrInfo[bool](ErrorInfoOf[bool](seqFixedRes))
    return Ok[bool](false)

type
    SeqFixedInit =
        elemType: Node
        capExpr: Node

fn seqFixedParseCapDigits(raw0: str): int32 =
    let raw: str = backendStripSpaces(raw0)
    if raw == nil || len(raw) == 0:
        return -1
    var cap: int32 = 0
    for i in 0..<len(raw):
        let c: char = raw[i]
        if c < '0' || c > '9':
            return -1
        cap = cap * 10 + int32(c) - int32('0')
    return cap

fn seqFixedInitInfoFromTypeKey(typeKey0: str): SeqFixedInit =
    var out: SeqFixedInit
    let typeKey: str = backendStripSpaces(typeKey0)
    if typeKey == nil || len(typeKey) == 0 || !uirCoreStrStartsWith(typeKey, "seq_fixed_"):
        return out
    let tail: str = str(ptr_add(void*(typeKey), 10))
    if tail == nil || len(tail) == 0:
        return out
    var split: int32 = -1
    let __for_start_i = len(tail) - 1
    for __for_rev_i in 0..(__for_start_i - (0)):
        let i = __for_start_i - __for_rev_i
        if tail[i] == '_':
            split = i
            break
    if split <= 0 || split >= len(tail) - 1:
        return out
    let elemKey: str = uirCoreStrTake(tail, split)
    let capTok: str = str(ptr_add(void*(tail), split + 1))
    if elemKey == nil || len(elemKey) == 0 || capTok == nil || len(capTok) == 0:
        return out
    let pos: SourcePos = zeroPos()
    out.elemType = newIdent(elemKey, pos)
    let capDigits: int32 = seqFixedParseCapDigits(capTok)
    if capDigits > 0:
        out.capExpr = newIntLit(int64(capDigits), pos)
    else:
        out.capExpr = newIdent(capTok, pos)
    return out

fn emitObjInlineSeqFixedReserveInitToPtr(b: BlockBuilder, dstBasePtr: UirCoreExpr, objTypeName: str, ot: UirCoreObjType): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: object inline seq_fixed init missing builder/module")
    var seenBases: str[]
    for fi in 0..<ot.fields.len:
        let f: UirCoreObjField = ot.fields[fi]
        let dotAt: int32 = uirCoreStrIndexOf(f.name, ".")
        if dotAt <= 0:
            continue
        let baseName: str = uirCoreStrTake(f.name, dotAt)
        if baseName == nil || len(baseName) == 0:
            continue
        var seen: bool = false
        for si in 0..<seenBases.len:
            if seenBases[si] == baseName:
                seen = true
                break
        if seen:
            continue
        add(seenBases, baseName)

        let typeKey: str = backendStripSpaces(uirCoreObjFieldTypeKeyGet(objTypeName, baseName))
        if (getEnv "BACKEND_DEBUG_SEQFIXED_INIT" == "1") && objTypeName == "PeerAttributes":
            echo("[backend] debugSeqFixedInit: obj=" + objTypeName +
                 " base=" + baseName + " key='" + typeKey + "'")
        let sfi: SeqFixedInit = seqFixedInitInfoFromTypeKey(typeKey)
        if sfi.elemType == nil || sfi.capExpr == nil:
            continue

        var baseOff: int32 = -1
        let lenField: str = baseName + ".len"
        for ofi in 0..<ot.fields.len:
            let of: UirCoreObjField = ot.fields[ofi]
            if of.name == lenField:
                baseOff = of.offset
                break
        if baseOff < 0:
            continue

        var seqBase: UirCoreExpr = dstBasePtr
        if baseOff != 0:
            seqBase = uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(baseOff)))
        let seqInitRes: Result[bool] = emitSeqFixedReserveInitToPtr(b, seqBase, sfi)
        if !IsOk[bool](seqInitRes):
            if (getEnv "BACKEND_DEBUG_SEQFIXED_INIT" == "1"):
                echo("[backend] debugSeqFixedInit: skip obj=" + objTypeName +
                     " base=" + baseName + " reason='emitSeqFixedReserveInitToPtr failed'")
            continue
    return Ok[bool](false)

fn seqFixedInitInfo(typeNode0: Node): SeqFixedInit =
    var out: SeqFixedInit
    if typeNode0 == nil:
        return out
    var t: Node = typeNode0
    while t != nil && t.kind == nkPar && kidCount(t) > 0:
        t = kid(t, 0)
    while t != nil && t.kind == nkVarTy && kidCount(t) > 0:
        t = kid(t, 0)
        while t != nil && t.kind == nkPar && kidCount(t) > 0:
            t = kid(t, 0)
    if t != nil && t.kind == nkDotExpr && kidCount(t) > 1:
        t = kid(t, 1)
    if t == nil || t.kind != nkBracketExpr || kidCount(t) < 3:
        return out
    let base: Node = kid(t, 0)
    if base == nil || (base.kind != nkIdent && base.kind != nkSymbol):
        return out
    let nm: str = backendStripSpaces(plainName(base))
    if !(nm == "seq_fixed"):
        return out
    out.elemType = kid(t, 1)
    out.capExpr = kid(t, 2)
    return out

fn emitSeqFixedReserveInitToPtr(b: BlockBuilder, dstBasePtr: UirCoreExpr, info: SeqFixedInit): Result[bool] =
    if b == nil || b.module == nil || b.func == nil:
        return Err[bool]("uirCore_builder: seq_fixed init missing builder/module")
    # Stage0 compatibility: avoid chained dot access through a ref-typed field.
    let elemTypeNode: Node = info.elemType
    let capExprNode: Node = info.capExpr
    if elemTypeNode == nil || capExprNode == nil || capExprNode.kind == nkEmpty:
        return Ok[bool](false)
    # IMPORTANT: element type may be an object type (e.g. `T[]` -> `seq[T]`),
    # so we must compute its byte size via the type-node sizeof logic rather
    # than scalar `uirCoreTypeSize`.
    let elemSizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
    if !IsOk[int32](elemSizeRes):
        return ErrInfo[bool](ErrorInfoOf[int32](elemSizeRes))
    let elemSize: int32 = Value[int32](elemSizeRes)
    if elemSize <= 0:
        return Err[bool]("uirCore_builder: seq_fixed init unknown elem size")

    let capRes0: Result[UirCoreExpr] = lowerExprValue(b, capExprNode, uirCoreTypeI32())
    if !IsOk[UirCoreExpr](capRes0):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](capRes0))
    let capTmp: str = blockBuilderNextTemp(b, "__seq_fixed_cap")
    let capSlot: int32 = localAdd(b.env, capTmp, uirCoreTypeI32())
    uirCoreSetLocalType(b.func, capSlot, uirCoreTypeI32())
    add(b.currentStmts, uirCoreStmtLet(capTmp, capSlot, Value[UirCoreExpr](capRes0)))
    let capVal: UirCoreExpr = uirCoreLocal(capSlot)

    let reserveLabel: str = blockBuilderNextLabel(b, "seq_fixed_reserve")
    let joinLabel: str = blockBuilderNextLabel(b, "seq_fixed_join")
    let cond: UirCoreExpr = uirCoreCmp(mcGt, capVal, uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(cond, reserveLabel, joinLabel))

    blockBuilderStart(b, reserveLabel)
    # cap field: offset 4 (i32)
    let capAddr: UirCoreExpr = uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(4))
    add(b.currentStmts, uirCoreStmtStore(capAddr, capVal, uirCoreTypeI32()))

    let capI64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), capVal)
    let bytes: UirCoreExpr = uirCoreBin(mbMul, capI64, uirCoreConstI64(int64(elemSize)))

    var reallocArgs: UirCoreExpr[]
    add(reallocArgs, uirCoreConstI64(0))
    add(reallocArgs, bytes)
    let bufTmp: str = blockBuilderNextTemp(b, "__seq_fixed_buf")
    let bufSlot: int32 = localAdd(b.env, bufTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, bufSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(bufTmp, bufSlot, uirCoreCall("realloc", reallocArgs)))
    let bufVal: UirCoreExpr = uirCoreLocal(bufSlot)

    # buffer field: offset 8 (i64)
    let bufAddr: UirCoreExpr = uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(8))
    add(b.currentStmts, uirCoreStmtStore(bufAddr, bufVal, uirCoreTypeI64()))

    let zeroLabel: str = blockBuilderNextLabel(b, "seq_fixed_zero")
    let bufOk: UirCoreExpr = uirCoreCmp(mcNe, bufVal, uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(bufOk, zeroLabel, joinLabel))

    blockBuilderStart(b, zeroLabel)
    var zeroArgs: UirCoreExpr[]
    add(zeroArgs, bufVal)
    add(zeroArgs, bytes)
    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("zeroMem", zeroArgs)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, joinLabel)
    return Ok[bool](false)

fn emitObjDefaultInitPtrs(b: BlockBuilder, dstBasePtr: UirCoreExpr, objTypeName: str): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: object init missing builder/module")
    let idx: int32 = uirCoreFindObjType(b.module, objTypeName)
    if idx < 0:
        return Err[bool]("uirCore_builder: unknown object type")
    let mod: UirCoreModule = b.module
    let ot: UirCoreObjType = mod.objTypes[idx]
    for fi in 0..<ot.fields.len:
        let f: UirCoreObjField = ot.fields[fi]
        var addr: UirCoreExpr = dstBasePtr
        if f.offset != 0:
            addr = uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(f.offset)))
        add(b.currentStmts, uirCoreStmtStore(addr, uirCoreConstI64(0), f.ty))
    let seqFixedRes: Result[bool] = emitObjInlineSeqFixedReserveInitToPtr(b, dstBasePtr, objTypeName, ot)
    if !IsOk[bool](seqFixedRes):
        return ErrInfo[bool](ErrorInfoOf[bool](seqFixedRes))
    return Ok[bool](false)

fn emitObjCopyPtrs(b: BlockBuilder, dstBasePtr: UirCoreExpr, objTypeName: str, srcBasePtr: UirCoreExpr): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: object copy missing builder/module")
    let idx: int32 = uirCoreFindObjType(b.module, objTypeName)
    if idx < 0:
        return Err[bool]("uirCore_builder: unknown object type")
    let mod: UirCoreModule = b.module
    let ot: UirCoreObjType = mod.objTypes[idx]
    for fi in 0..<ot.fields.len:
        let f: UirCoreObjField = ot.fields[fi]
        var dstAddr: UirCoreExpr = dstBasePtr
        var srcAddr: UirCoreExpr = srcBasePtr
        if f.offset != 0:
            let off: UirCoreExpr = uirCoreConstI64(int64(f.offset))
            dstAddr = uirCoreBin(mbAdd, dstBasePtr, off)
            srcAddr = uirCoreBin(mbAdd, srcBasePtr, off)
        let val: UirCoreExpr = uirCoreLoad(srcAddr, f.ty)
        add(b.currentStmts, uirCoreStmtStore(dstAddr, val, f.ty))
    return Ok[bool](false)

fn emitObjCopy(b: BlockBuilder, dstSlot: int32, objTypeName: str, srcSlot: int32): Result[bool] =
    let dstBasePtr: UirCoreExpr = uirCoreLocal(dstSlot)
    let srcBasePtr: UirCoreExpr = uirCoreLocal(srcSlot)
    return emitObjCopyPtrs(b, dstBasePtr, objTypeName, srcBasePtr)

fn emitTupleLitToPtr(b: BlockBuilder, dstBasePtr: UirCoreExpr, objTypeName: str, lit: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: tuple store missing builder/module")
    if lit == nil || lit.kind != nkTupleLit:
        return Err[bool]("uirCore_builder: invalid tuple literal")
    if objTypeName == nil || len(objTypeName) == 0 || ! uirCoreHasObjType(b.module, objTypeName):
        return Err[bool]("uirCore_builder: unknown tuple type")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objTypeName)
    for i in 0..<kidCount(lit):
        var elemNode: Node = kid(lit, i)
        if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
            elemNode = kid(elemNode, 1)
        let fieldName: str = "f" + intToStr(i)
        var found: bool = false
        for fi in 0..<ot.fields.len:
            let f: UirCoreObjField = ot.fields[fi]
            if (f.name == fieldName):
                found = true
                let valRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, f.ty)
                if ! IsOk[UirCoreExpr](valRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
                var addr: UirCoreExpr = dstBasePtr
                if f.offset != 0:
                    addr = uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(f.offset)))
                add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), f.ty))
                break
        if ! found:
            return Err[bool]("uirCore_builder: tuple store field missing")
    return Ok[bool](false)

fn emitSeqLitToPtr(b: BlockBuilder, dstBasePtr: UirCoreExpr, seqTypeKey: str, lit: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: seq store missing builder/module")
    if lit == nil || lit.kind != nkSeqLit:
        return Err[bool]("uirCore_builder: invalid seq literal")
    if seqTypeKey == nil || len(seqTypeKey) == 0:
        return Err[bool]("uirCore_builder: seq store missing type key")
    if ! uirCoreStrStartsWith(seqTypeKey, "seq_"):
        return Err[bool]("uirCore_builder: seq store unsupported type key")

    let elemKey: str = str(ptr_add(void*(seqTypeKey), 4))
    let elemTypeNode: Node = newIdent(elemKey, lit.pos)
    let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
    if ! IsOk[int32](sizeRes):
        return ErrInfo[bool](ErrorInfoOf[int32](sizeRes))
    let elemSize: int32 = Value[int32](sizeRes)
    let elemUirTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)

    let count: int32 = kidCount(lit)
    let seqObj: str = "seq"
    let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, seqObj)
    var lenOff: int32 = -1
    var capOff: int32 = -1
    var bufOff: int32 = -1
    for fi in 0..<seqOt.fields.len:
        let f: UirCoreObjField = seqOt.fields[fi]
        if (f.name == "len"):
            lenOff = f.offset
        elif (f.name == "cap"):
            capOff = f.offset
        elif (f.name == "buffer"):
            bufOff = f.offset
    if lenOff < 0 || capOff < 0 || bufOff < 0:
        return Err[bool]("uirCore_builder: seq layout mismatch")

    let lenAddr: UirCoreExpr = (lenOff == 0) ? dstBasePtr : uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(lenOff)))
    let capAddr: UirCoreExpr = (capOff == 0) ? dstBasePtr : uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(capOff)))
    let bufAddr: UirCoreExpr = (bufOff == 0) ? dstBasePtr : uirCoreBin(mbAdd, dstBasePtr, uirCoreConstI64(int64(bufOff)))
    add(b.currentStmts, uirCoreStmtStore(lenAddr, uirCoreConstI64(int64(count)), uirCoreTypeI32()))
    add(b.currentStmts, uirCoreStmtStore(capAddr, uirCoreConstI64(int64(count)), uirCoreTypeI32()))

    var bufPtr: UirCoreExpr = uirCoreConstI64(0)
    if count > 0 && elemSize > 0:
        let bytes: int64 = int64(count) * int64(elemSize)
        var allocArgs: UirCoreExpr[]
        add(allocArgs, uirCoreConstI64(bytes))
        let allocCall: UirCoreExpr = uirCoreCall("alloc", allocArgs)
        let bufName: str = blockBuilderNextTemp(b, "__seq_buf")
        let bufSlot: int32 = localAdd(b.env, bufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, bufSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(bufName, bufSlot, allocCall))
        bufPtr = uirCoreLocal(bufSlot)
    add(b.currentStmts, uirCoreStmtStore(bufAddr, bufPtr, uirCoreTypeI64()))

    if count > 0 && elemSize > 0:
        for i in 0..<count:
            var elemNode: Node = kid(lit, i)
            if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
                elemNode = kid(elemNode, 1)
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, elemUirTy)
            if ! IsOk[UirCoreExpr](valRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
            let off: int64 = int64(i) * int64(elemSize)
            let addr: UirCoreExpr = (off == 0) ? bufPtr : uirCoreBin(mbAdd, bufPtr, uirCoreConstI64(off))
            add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), elemUirTy))

    return Ok[bool](false)

fn emitSeqComprehensionToPtr(b: BlockBuilder, dstName: str, dstBasePtr: UirCoreExpr, seqTypeKey: str, comp0: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: comprehension store missing builder/module")
    if dstBasePtr == nil:
        return Err[bool]("uirCore_builder: comprehension store missing dst ptr")
    if seqTypeKey == nil || len(seqTypeKey) == 0 || !uirCoreStrStartsWith(seqTypeKey, "seq_"):
        return Err[bool]("uirCore_builder: comprehension store expects seq type key")
    if comp0 == nil:
        return Err[bool]("uirCore_builder: invalid comprehension")
    var comp: Node = comp0
    while comp != nil && comp.kind == nkPar && kidCount(comp) > 0:
        comp = kid(comp, 0)
    if comp == nil || comp.kind != nkComprehension:
        return Err[bool]("uirCore_builder: invalid comprehension")

    # Initialize destination as an empty seq.
    var emptyLit: Node = newNode(nkSeqLit, comp.pos)
    let initRes: Result[bool] = emitSeqLitToPtr(b, dstBasePtr, seqTypeKey, emptyLit)
    if !IsOk[bool](initRes):
        return ErrInfo[bool](ErrorInfoOf[bool](initRes))

    # Decode comprehension layout:
    # kid0=pattern, kid1=iterExpr, kid2=cond (nkEmpty when absent), kid3=bodyExpr
    var pat: Node = nil
    var iterExpr: Node = nil
    var cond: Node = nil
    var body: Node = nil
    if kidCount(comp) > 0:
        pat = kid(comp, 0)
    if kidCount(comp) > 1:
        iterExpr = kid(comp, 1)
    if kidCount(comp) == 3:
        body = kid(comp, 2)
    elif kidCount(comp) > 3:
        cond = kid(comp, 2)
        body = kid(comp, 3)
    if iterExpr == nil:
        return Err[bool]("uirCore_builder: comprehension missing iterator")

    # Build: add(__addr(dstName), body)
    var addrCall: Node = newNode(nkCall, comp.pos)
    addrCall.callStyle = CallStyleParen
    addSon(addrCall, newIdent("__addr", comp.pos))
    addSon(addrCall, newIdent(dstName, comp.pos))

    var addCall: Node = newNode(nkCall, comp.pos)
    addCall.callStyle = CallStyleParen
    addSon(addCall, newIdent("add", comp.pos))
    addSon(addCall, addrCall)
    if body != nil:
        addSon(addCall, body)
    else:
        addSon(addCall, newNode(nkEmpty, comp.pos))

    var loopBody: Node = newNode(nkStmtList, comp.pos)
    if cond != nil && cond.kind != nkEmpty:
        var thenList: Node = newNode(nkStmtList, comp.pos)
        addSon(thenList, addCall)
        var ifNode: Node = newNode(nkIf, comp.pos)
        addSon(ifNode, cond)
        addSon(ifNode, thenList)
        addSon(loopBody, ifNode)
    else:
        addSon(loopBody, addCall)

    var forNode: Node = newNode(nkFor, comp.pos)
    if pat != nil:
        addSon(forNode, pat)
    else:
        addSon(forNode, newIdent("_", comp.pos))
    addSon(forNode, iterExpr)
    addSon(forNode, loopBody)
    return lowerForStmt(b, forNode)

fn inferInlineObjFieldTypeName(module: UirCoreModule, parent: UirCoreObjType, fieldName: str, baseOff: int32): str =
    # Match a nested/inlined field by layout against known object types.
    # Example: `Table.keys.*`/`Table.vals.*`/`Table.states.*` matches
    # builtin `seq` (len/cap/buffer) at baseOff.
    if module == nil || fieldName == nil || len(fieldName) == 0 || baseOff < 0:
        return ""
    let mapped: str = uirCoreInlineObjFieldTypeGet(parent.name, fieldName)
    if len(mapped) > 0:
        if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && parent.name == "ProtoBuffer" && fieldName == "out":
            echo("[backend] debugOverloadDot: inferInline mapped parent='ProtoBuffer' field='out' mapped='" + mapped + "'")
        return mapped
    # Prefer declared field type keys over structural matching to avoid
    # aliasing to an unrelated object type with the same flattened layout.
    let declaredKey: str = uirCoreObjFieldTypeKeyGet(parent.name, fieldName)
    if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && parent.name == "ProtoBuffer" && fieldName == "out":
        let lookupKeyDbg: str = parent.name + "::" + fieldName
        var scanFound: bool = false
        if uirCoreObjFieldTypeKeyIndex.keys.len > 0:
            for si in 0..<uirCoreObjFieldTypeKeyIndex.keys.len:
                if uirCoreObjFieldTypeKeyIndex.states[si] != uint8(1):
                    continue
                let kk: str = uirCoreObjFieldTypeKeyIndex.keys[si]
                if kk == lookupKeyDbg:
                    scanFound = true
                    let vi: int32 = uirCoreObjFieldTypeKeyIndex.vals[si]
                    var vv: str = ""
                    if vi >= 0 && vi < uirCoreObjFieldTypeKeyNames.len:
                        vv = get_string(uirCoreObjFieldTypeKeyNames, vi)
                    echo("[backend] debugOverloadDot: scan fieldKeyMap key='" + lookupKeyDbg + "' slot=" +
                         intToStr(si) + " valIdx=" + intToStr(vi) + " val='" + vv + "'")
                    break
        if !scanFound:
            echo("[backend] debugOverloadDot: scan fieldKeyMap key='" + lookupKeyDbg + "' missing")
        echo("[backend] debugOverloadDot: lookupKey len=" + intToStr(len(lookupKeyDbg)) +
             " parentLen=" + intToStr(len(parent.name)) + " fieldLen=" + intToStr(len(fieldName)))
        echo("[backend] debugOverloadDot: inferInline declaredKey parent='ProtoBuffer' field='out' key='" + declaredKey + "'")
    if declaredKey != nil && len(declaredKey) > 0:
        let declaredObj: str = uirCoreObjTypeFromTypeKey(module, declaredKey)
        if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && parent.name == "ProtoBuffer" && fieldName == "out":
            echo("[backend] debugOverloadDot: inferInline declaredObj parent='ProtoBuffer' field='out' obj='" + declaredObj + "'")
        if declaredObj != nil && len(declaredObj) > 0:
            uirCoreInlineObjFieldTypePut(parent.name, fieldName, declaredObj)
            return declaredObj
    let prefix: str = fieldName + "."
    for ti in 0..<module.objTypes.len:
        let cand: UirCoreObjType = module.objTypes[ti]
        if cand.name == nil || len(cand.name) == 0 || cand.fields.len == 0:
            continue
        var ok: bool = true
        for ci in 0..<cand.fields.len:
            let cf: UirCoreObjField = cand.fields[ci]
            let wantName: str = prefix + cf.name
            let wantOff: int32 = baseOff + cf.offset
            var found: bool = false
            for pi in 0..<parent.fields.len:
                let pf: UirCoreObjField = parent.fields[pi]
                if (pf.name == wantName) && pf.offset == wantOff && pf.ty.kind == cf.ty.kind:
                    found = true
                    break
            if !found:
                ok = false
                break
        if ok:
            return cand.name
    return ""

fn uirCoreObjTypeFromTypeKey(module: UirCoreModule, typeKey0: str): str =
    if module == nil || typeKey0 == nil || len(typeKey0) == 0:
        return ""
    var key: str = uirCoreTypeKeyStripIterWrappers(typeKey0)
    if key == nil || len(key) == 0:
        return ""
    let canon: str = uirCoreObjAliasCanon(key)
    if canon != nil && len(canon) > 0:
        key = canon
    if uirCoreHasObjType(module, key):
        return key
    if uirCoreStrStartsWith(key, "Option_") && ensureOptionObjType(module, key):
        return key
    if uirCoreStrStartsWith(key, "Result_") && ensureResultObjType(module, key):
        return key
    if uirCoreStrStartsWith(key, "__cheng_tables_Entry_") && ensureTablesEntryObjType(module, key):
        return key
    let layout0: str = uirCorePtrBaseObjTypeName(module, key)
    if layout0 != nil && len(layout0) > 0:
        return layout0
    let base: str = uirCoreTypeKeyBaseName(key)
    if base != nil && len(base) > 0 && !(base == key):
        var baseName: str = base
        let baseCanon: str = uirCoreObjAliasCanon(baseName)
        if baseCanon != nil && len(baseCanon) > 0:
            baseName = baseCanon
        if uirCoreHasObjType(module, baseName):
            return baseName
        if uirCoreStrStartsWith(baseName, "Option_") && ensureOptionObjType(module, baseName):
            return baseName
        if uirCoreStrStartsWith(baseName, "Result_") && ensureResultObjType(module, baseName):
            return baseName
        if uirCoreStrStartsWith(baseName, "__cheng_tables_Entry_") && ensureTablesEntryObjType(module, baseName):
            return baseName
        let layout1: str = uirCorePtrBaseObjTypeName(module, baseName)
        if layout1 != nil && len(layout1) > 0:
            return layout1
    return ""

fn uirCoreInferValueCallInnerKey(b: BlockBuilder, callNode: Node): str =
    if b == nil || callNode == nil || callNode.kind != nkCall || kidCount(callNode) <= 1:
        return ""
    let dbgValueInner: bool = (getEnv "BACKEND_DEBUG_VALUE_CALLSITE" == "1")
    let calleeName0: str = uirCoreCallCalleeName(callNode)
    let valueLikeCall0: bool = (calleeName0 == "Value") ||
        uirCoreStrStartsWith(calleeName0, "Value_") ||
        uirCoreStrStartsWith(calleeName0, "Value__")
    if dbgValueInner:
        let line0: str = intToStr(callNode.pos.line)
        let col0: str = intToStr(callNode.pos.col)
        echo("[backend] debugValueInner: callee='" + calleeName0 + "' valueLike=" +
             (valueLikeCall0 ? "1" : "0") + " @" + line0 + ":" + col0)
    # Relaxed fallback: some stage1 paths keep callee names qualified/mangled.
    # For unary calls whose first arg is `Result_*`, still recover the inner value key.
    if !valueLikeCall0 && kidCount(callNode) != 2:
        return ""
    var arg0: Node = kid(callNode, 1)
    if arg0 != nil && arg0.kind == nkCallArg && kidCount(arg0) > 1:
        arg0 = kid(arg0, 1)
    var argKey0: str = caseInferExprTypeKey(b, arg0)
    if argKey0 == nil || len(argKey0) == 0:
        argKey0 = uirCoreInferNodeTypeKeyForOverload(b, arg0)
    if (argKey0 == nil || len(argKey0) == 0) && arg0 != nil &&
       arg0.typeCacheValid && arg0.typeCache != nil:
        argKey0 = typeKey(arg0.typeCache)
        if argKey0 == nil || len(argKey0) == 0:
            argKey0 = uirCoreTypeKeyFromNodeLoose(arg0.typeCache)
    if (argKey0 == nil || len(argKey0) == 0) && arg0 != nil && (arg0.kind == nkIdent || arg0.kind == nkSymbol):
        let nm0: str = backendStripSpaces(plainName(arg0))
        let slot0: int32 = localIndex(b.env, nm0)
        if slot0 >= 0:
            argKey0 = localTypeKey(b.env, slot0)
        if (argKey0 == nil || len(argKey0) == 0) && b.module != nil:
            argKey0 = uirCoreGlobalTypeKeyByBaseUnique(b.module, nm0)
    if argKey0 != nil && len(argKey0) > 0:
        if uirCoreStrStartsWith(argKey0, "var_ref_"):
            argKey0 = str(ptr_add(void*(argKey0), 8))
        elif uirCoreStrStartsWith(argKey0, "var_"):
            argKey0 = str(ptr_add(void*(argKey0), 4))
        if uirCoreStrStartsWith(argKey0, "ref_"):
            argKey0 = str(ptr_add(void*(argKey0), 4))
        if uirCoreStrStartsWith(argKey0, "ptr_"):
            argKey0 = str(ptr_add(void*(argKey0), 4))
    if argKey0 != nil && uirCoreStrStartsWith(argKey0, "Result_"):
        let valKey0: str = str(ptr_add(void*(argKey0), 7))
        if dbgValueInner:
            echo("[backend] debugValueInner: argKey='" + argKey0 + "' valKey='" + valKey0 + "'")
        if valKey0 != nil && len(valKey0) > 0:
            return valKey0
    if b.module != nil && argKey0 != nil && len(argKey0) > 0:
        let objName0: str = uirCoreObjTypeFromTypeKey(b.module, argKey0)
        if objName0 != nil && len(objName0) > 0:
            let valueKey0: str = uirCoreObjFieldTypeKeyGet(objName0, "value")
            if valueKey0 != nil && len(valueKey0) > 0:
                return valueKey0
    return ""

fn uirCoreResolveGlobalObjTypeName(b: BlockBuilder, baseName0: str): str =
    if b == nil || b.module == nil || baseName0 == nil || len(baseName0) == 0:
        return ""
    let mod0: UirCoreModule = b.module
    let debugDot: bool = (getEnv "BACKEND_DEBUG_DOT" == "1")
    let baseName: str = backendStripSpaces(baseName0)
    if baseName == nil || len(baseName) == 0:
        return ""
    let obj0: str = uirCoreGlobalObjTypeGet(baseName)
    if obj0 != nil && len(obj0) > 0:
        return obj0
    let key0: str = uirCoreGlobalTypeKeyGet(baseName)
    let obj1: str = uirCoreObjTypeFromTypeKey(mod0, key0)
    if obj1 != nil && len(obj1) > 0:
        return obj1
    let gi0: int32 = moduleGlobalIndex(mod0, baseName)
    if debugDot:
        echo("[backend] debugDot: globalObjProbe base='" + baseName + "' obj0='" + obj0 +
             "' key0='" + key0 + "' obj1='" + obj1 + "' gi0=" + intToStr(gi0))
    let globals0: UirCoreGlobal[] = mod0.globals
    if gi0 >= 0 && gi0 < globals0.len:
        let g0: UirCoreGlobal = globals0[gi0]
        let gObj0: str = uirCoreGlobalObjTypeGet(g0.name)
        if gObj0 != nil && len(gObj0) > 0:
            return gObj0
        let gKey0: str = uirCoreGlobalTypeKeyGet(g0.name)
        let gObj1: str = uirCoreObjTypeFromTypeKey(mod0, gKey0)
        if debugDot:
            echo("[backend] debugDot: globalObjProbe exact g.name='" + g0.name +
                 "' gObj0='" + gObj0 + "' gKey0='" + gKey0 + "' gObj1='" + gObj1 +
                 "' g.origin='" + g0.originFile + "' g.ty=nk#" + intToStr(int32(g0.ty.kind)) + "'")
        if gObj1 != nil && len(gObj1) > 0:
            return gObj1
    if b.func != nil && uirCoreDupGlobalNamesHas(baseName):
        let f0: UirCoreFunc = b.func
        let sym0: str = uirCoreMaybeMangleDupGlobalName(baseName, f0.originFile)
        if debugDot:
            echo("[backend] debugDot: globalObjProbe dup base='" + baseName + "' sym0='" + sym0 + "'")
        if sym0 != nil && len(sym0) > 0 && !(sym0 == baseName):
            let mObj0: str = uirCoreGlobalObjTypeGet(sym0)
            if mObj0 != nil && len(mObj0) > 0:
                return mObj0
            let mKey0: str = uirCoreGlobalTypeKeyGet(sym0)
            let mObj1: str = uirCoreObjTypeFromTypeKey(mod0, mKey0)
            if debugDot:
                echo("[backend] debugDot: globalObjProbe dup sym0='" + sym0 +
                     "' mObj0='" + mObj0 + "' mKey0='" + mKey0 + "' mObj1='" + mObj1 + "'")
            if mObj1 != nil && len(mObj1) > 0:
                return mObj1
            let mGi0: int32 = moduleGlobalIndex(mod0, sym0)
            if mGi0 >= 0 && mGi0 < globals0.len:
                let mg0: UirCoreGlobal = globals0[mGi0]
                let mgObj0: str = uirCoreGlobalObjTypeGet(mg0.name)
                if mgObj0 != nil && len(mgObj0) > 0:
                    return mgObj0
                let mgKey0: str = uirCoreGlobalTypeKeyGet(mg0.name)
                let mgObj1: str = uirCoreObjTypeFromTypeKey(mod0, mgKey0)
                if debugDot:
                    echo("[backend] debugDot: globalObjProbe dup-index mg.name='" + mg0.name +
                         "' mgObj0='" + mgObj0 + "' mgKey0='" + mgKey0 + "' mgObj1='" + mgObj1 + "'")
                if mgObj1 != nil && len(mgObj1) > 0:
                    return mgObj1
    let uniqGi: int32 = moduleFindGlobalIndexByBaseUnique(mod0, baseName)
    if uniqGi >= 0 && uniqGi < globals0.len:
        let ug: UirCoreGlobal = globals0[uniqGi]
        let uObj0: str = uirCoreGlobalObjTypeGet(ug.name)
        if uObj0 != nil && len(uObj0) > 0:
            return uObj0
        let uKey0: str = uirCoreGlobalTypeKeyGet(ug.name)
        let uObj1: str = uirCoreObjTypeFromTypeKey(mod0, uKey0)
        if uObj1 != nil && len(uObj1) > 0:
            return uObj1
    let uniqKey: str = uirCoreGlobalTypeKeyByBaseUnique(mod0, baseName)
    let uniqObj: str = uirCoreObjTypeFromTypeKey(mod0, uniqKey)
    if debugDot:
        echo("[backend] debugDot: globalObjProbe uniq base='" + baseName +
             "' uniqGi=" + intToStr(uniqGi) + " uniqKey='" + uniqKey + "' uniqObj='" + uniqObj + "'")
    if uniqObj != nil && len(uniqObj) > 0:
        return uniqObj
    return ""

fn lowerDotAccess(b: BlockBuilder, dotNode: Node): Result[DotAccess] =
    if b == nil || dotNode == nil || dotNode.kind != nkDotExpr || kidCount(dotNode) < 2:
        return Err[DotAccess]("uirCore_builder: invalid dot expr")
    let debugDot: bool = (getEnv "BACKEND_DEBUG_DOT" == "1")
    var base: Node = kid(dotNode, 0)
    let field: Node = kid(dotNode, 1)
    while base != nil && base.kind == nkPar && kidCount(base) > 0:
        base = kid(base, 0)
    if field == nil || (field.kind != nkIdent && field.kind != nkSymbol):
        return Err[DotAccess]("uirCore_builder: dot field expects identifier")
    var basePtrRes: Result[UirCoreExpr]
    var baseName: str = ""
    var objTypeName: str = ""
    if base != nil && (base.kind == nkIdent || base.kind == nkSymbol):
        baseName = backendStripSpaces(plainName(base))
        let slot: int32 = localIndex(b.env, baseName)
        if slot >= 0:
            objTypeName = funcObjTypeName(b.func, slot)
            if len(objTypeName) > 0:
                basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
            else:
                # Stage0/early stage1 pipelines may lack typeCache on locals; fall back to local type keys.
                var key: str = localTypeKey(b.env, slot)
                if uirCoreStrStartsWith(key, "ref_"):
                    key = str(ptr_add(void*(key), 4))
                elif uirCoreStrStartsWith(key, "var_ref_"):
                    key = str(ptr_add(void*(key), 8))
                elif uirCoreStrStartsWith(key, "var_"):
                    key = str(ptr_add(void*(key), 4))
                if key != nil && len(key) > 0:
                    let objFromKey0: str = uirCoreObjTypeFromTypeKey(b.module, key)
                    if objFromKey0 != nil && len(objFromKey0) > 0:
                        objTypeName = objFromKey0
                        basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                    let canon: str = uirCoreObjAliasCanon(key)
                    if canon != nil && len(canon) > 0:
                        key = canon
                    if uirCoreHasObjType(b.module, key):
                        objTypeName = key
                        basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                    elif uirCoreStrStartsWith(key, "ptr_"):
                        var innerKey: str = str(ptr_add(void*(key), 4))
                        let innerCanon: str = uirCoreObjAliasCanon(innerKey)
                        if innerCanon != nil && len(innerCanon) > 0:
                            innerKey = innerCanon
                        if innerKey != nil && len(innerKey) > 0:
                            if uirCoreHasObjType(b.module, innerKey):
                                objTypeName = innerKey
                                basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                            elif uirCoreStrStartsWith(innerKey, "seq_") && uirCoreHasObjType(b.module, "seq"):
                                objTypeName = "seq"
                                basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                            elif uirCoreStrStartsWith(innerKey, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                                objTypeName = "seq"
                                basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                            elif uirCoreStrStartsWith(innerKey, "Table_") && uirCoreHasObjType(b.module, "Table"):
                                objTypeName = "Table"
                                basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                    elif uirCoreStrStartsWith(key, "seq_") && uirCoreHasObjType(b.module, "seq"):
                        objTypeName = "seq"
                        basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                    elif uirCoreStrStartsWith(key, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                        objTypeName = "seq"
                        basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
                    elif uirCoreStrStartsWith(key, "Table_") && uirCoreHasObjType(b.module, "Table"):
                        objTypeName = "Table"
                        basePtrRes = Ok[UirCoreExpr](uirCoreLocal(slot))
    if len(objTypeName) == 0:
        if base != nil && base.kind == nkBracketExpr && kidCount(base) == 2:
            let base0: Node = kid(base, 0)
            if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
                var t0: Node = base0.typeCache
                while t0 != nil && t0.kind == nkPar && kidCount(t0) > 0:
                    t0 = kid(t0, 0)
                if t0 != nil && t0.kind == nkVarTy && kidCount(t0) > 0:
                    t0 = kid(t0, 0)
                if t0 != nil && (t0.kind == nkRefTy || t0.kind == nkPtrTy) && kidCount(t0) > 0:
                    t0 = kid(t0, 0)
                if t0 != nil && t0.kind == nkBracketExpr && kidCount(t0) > 0:
                    let tyBase: Node = kid(t0, 0)
                    if tyBase != nil && (tyBase.kind == nkIdent || tyBase.kind == nkSymbol):
                        let tyName: str = backendStripSpaces(plainName(tyBase))
                        if (tyName == "array") && kidCount(t0) >= 3:
                            let arg1: Node = kid(t0, 1)
                            let arg2: Node = kid(t0, 2)
                            let c1: int32 = tryResolveArrayCount(b.module, arg1)
                            let c2: int32 = tryResolveArrayCount(b.module, arg2)
                            var elemTypeNode: Node = nil
                            if c1 > 0 && c2 <= 0:
                                elemTypeNode = arg2
                            elif c2 > 0 && c1 <= 0:
                                elemTypeNode = arg1
                            elif c1 > 0 && c2 > 0:
                                # Ambiguous; prefer `array[Count, ElemType]`.
                                elemTypeNode = arg2
                            if elemTypeNode != nil && elemTypeNode.kind != nkEmpty:
                                objTypeName = typeNodeObjTypeName(b.module, elemTypeNode)
                        elif (tyName == "seq") && kidCount(t0) >= 2:
                            let elemTypeNode2: Node = kid(t0, 1)
                            if elemTypeNode2 != nil && elemTypeNode2.kind != nkEmpty:
                                objTypeName = typeNodeObjTypeName(b.module, elemTypeNode2)
                        elif (tyName == "seq_fixed") && kidCount(t0) >= 2:
                            let elemTypeNode3: Node = kid(t0, 1)
                            if elemTypeNode3 != nil && elemTypeNode3.kind != nkEmpty:
                                objTypeName = typeNodeObjTypeName(b.module, elemTypeNode3)
            if len(objTypeName) == 0:
                var key0: str = ""
                if base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                    let slot0Name: str = backendStripSpaces(plainName(base0))
                    let slot0: int32 = localIndex(b.env, slot0Name)
                    if slot0 >= 0:
                        key0 = localTypeKey(b.env, slot0)
                if key0 == nil || len(key0) == 0:
                    key0 = exprTypeKeyShallow(b, base0)
                if (key0 == nil || len(key0) == 0) && base0 != nil && base0.kind == nkDotExpr:
                    let da0Res: Result[DotAccess] = lowerDotAccess(b, base0)
                    if IsOk[DotAccess](da0Res):
                        let da0: DotAccess = Value[DotAccess](da0Res)
                        if da0.fieldTy.kind == mtVoid && da0.objTypeName != nil && len(da0.objTypeName) > 0:
                            key0 = da0.objTypeName
                if (key0 == nil || len(key0) == 0) && base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                    let base0Name: str = backendStripSpaces(plainName(base0))
                    let gObj0: str = uirCoreResolveGlobalObjTypeName(b, base0Name)
                    if len(gObj0) > 0:
                        key0 = gObj0
                if base0 != nil && key0 != nil && len(key0) > 0 && (key0 == "seq" || key0 == "Table"):
                    let refinedKey: str = caseInferExprTypeKey(b, base0)
                    if refinedKey != nil && len(refinedKey) > 0 && !(refinedKey == key0):
                        key0 = refinedKey
                if len(objTypeName) == 0 && base0 != nil && base0.kind == nkDotExpr && kidCount(base0) > 1 &&
                   key0 != nil && len(key0) > 0 && (key0 == "seq" || key0 == "Table"):
                    let parentNode0: Node = kid(base0, 0)
                    let memberNode0: Node = kid(base0, 1)
                    let memberName0: str = backendStripSpaces(plainName(memberNode0))
                    var parentKey0: str = caseInferExprTypeKey(b, parentNode0)
                    if parentKey0 != nil && len(parentKey0) > 0:
                        if uirCoreStrStartsWith(parentKey0, "ref_"):
                            parentKey0 = str(ptr_add(void*(parentKey0), 4))
                        elif uirCoreStrStartsWith(parentKey0, "var_ref_"):
                            parentKey0 = str(ptr_add(void*(parentKey0), 8))
                        elif uirCoreStrStartsWith(parentKey0, "var_"):
                            parentKey0 = str(ptr_add(void*(parentKey0), 4))
                        if uirCoreStrStartsWith(parentKey0, "ptr_"):
                            parentKey0 = str(ptr_add(void*(parentKey0), 4))
                    var parentObj0: str = uirCoreObjTypeFromTypeKey(b.module, parentKey0)
                    if len(parentObj0) == 0 && parentNode0 != nil && (parentNode0.kind == nkIdent || parentNode0.kind == nkSymbol):
                        let parentName0: str = backendStripSpaces(plainName(parentNode0))
                        parentObj0 = uirCoreResolveGlobalObjTypeName(b, parentName0)
                    if len(parentObj0) > 0 && memberName0 != nil && len(memberName0) > 0:
                        let fieldKey1: str = backendStripSpaces(uirCoreObjFieldTypeKeyGet(parentObj0, memberName0))
                        if fieldKey1 != nil && len(fieldKey1) > 0:
                            key0 = fieldKey1
                if key0 != nil && len(key0) > 0:
                    var key: str = key0
                    if uirCoreStrStartsWith(key, "ref_"):
                        key = str(ptr_add(void*(key), 4))
                    elif uirCoreStrStartsWith(key, "var_ref_"):
                        key = str(ptr_add(void*(key), 8))
                    elif uirCoreStrStartsWith(key, "var_"):
                        key = str(ptr_add(void*(key), 4))
                    if uirCoreStrStartsWith(key, "ptr_"):
                        key = str(ptr_add(void*(key), 4))
                    if key != nil && len(key) > 0:
                        let keyCanon0: str = uirCoreObjAliasCanon(key)
                        if keyCanon0 != nil && len(keyCanon0) > 0:
                            key = keyCanon0
                        if uirCoreHasObjType(b.module, key):
                            objTypeName = key
                        if uirCoreStrStartsWith(key, "seq_"):
                            var elemKey: str = str(ptr_add(void*(key), 4))
                            if elemKey != nil && len(elemKey) > 0:
                                if uirCoreStrStartsWith(elemKey, "var_ref_"):
                                    elemKey = str(ptr_add(void*(elemKey), 8))
                                elif uirCoreStrStartsWith(elemKey, "var_"):
                                    elemKey = str(ptr_add(void*(elemKey), 4))
                                if uirCoreStrStartsWith(elemKey, "ref_") || uirCoreStrStartsWith(elemKey, "ptr_"):
                                    elemKey = str(ptr_add(void*(elemKey), 4))
                                if uirCoreHasObjType(b.module, elemKey):
                                    objTypeName = elemKey
                                elif uirCoreStrStartsWith(elemKey, "seq_") && uirCoreHasObjType(b.module, "seq"):
                                    objTypeName = "seq"
                                elif uirCoreStrStartsWith(elemKey, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                                    objTypeName = "seq"
                                elif uirCoreStrStartsWith(elemKey, "Table_") && uirCoreHasObjType(b.module, "Table"):
                                    objTypeName = "Table"
                        elif uirCoreStrStartsWith(key, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                            objTypeName = "seq"
                        elif uirCoreStrStartsWith(key, "Table_") && uirCoreHasObjType(b.module, "Table"):
                            objTypeName = "Table"
                        elif uirCoreStrStartsWith(key, "array_") && b.module != nil:
                            for i0 in 6..<len(key):
                                if key[i0] == '_':
                                    let suffix: str = str(ptr_add(void*(key), i0 + 1))
                                    if suffix != nil && len(suffix) > 0:
                                        if uirCoreHasObjType(b.module, suffix):
                                            objTypeName = suffix
                                            break
                                        elif uirCoreStrStartsWith(suffix, "seq_") && uirCoreHasObjType(b.module, "seq"):
                                            objTypeName = "seq"
                                            break
                                        elif uirCoreStrStartsWith(suffix, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                                            objTypeName = "seq"
                                            break
                                        elif uirCoreStrStartsWith(suffix, "Table_") && uirCoreHasObjType(b.module, "Table"):
                                            objTypeName = "Table"
                                            break
                if debugDot && len(objTypeName) == 0:
                    var bKind: int32 = -1
                    if base0 != nil:
                        bKind = int32(base0.kind)
                    let lineD: str = intToStr(dotNode.pos.line)
                    let colD: str = intToStr(dotNode.pos.col)
                    echo("[backend] debugDot: bracket-dot missing objTypeName key0='" + key0 +
                        "' base0Kind=nk#" + intToStr(bKind) + " @" + lineD + ":" + colD)
        if baseName != nil && len(baseName) > 0:
            let gObj: str = uirCoreResolveGlobalObjTypeName(b, baseName)
            if len(gObj) > 0:
                objTypeName = gObj
        if base != nil && base.kind == nkDotExpr:
            let da0Res: Result[DotAccess] = lowerDotAccess(b, base)
            if IsOk[DotAccess](da0Res):
                let da0: DotAccess = Value[DotAccess](da0Res)
                if da0.fieldTy.kind == mtVoid:
                    if len(da0.objTypeName) > 0:
                        objTypeName = da0.objTypeName
                    basePtrRes = Ok[UirCoreExpr](da0.addr)
        if base != nil && base.typeCacheValid && base.typeCache != nil:
            objTypeName = typeNodeObjTypeName(b.module, base.typeCache)
        if len(objTypeName) == 0 && base != nil && base.kind == nkCall && b.module != nil:
            let callName: str = uirCoreCallNameForReachability(b.module, base)
            if debugDot:
                echo("[backend] debugDot: call-dot callName='" + callName + "'")
            if callName != nil && len(callName) > 0:
                var callee0: UirCoreFunc = moduleFindFunc(b.module, callName)
                if callee0 == nil:
                    callee0 = moduleFindFuncByBaseUnique(b.module, callName)
                if callee0 != nil && callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                    var key: str = callee0.retTypeKey
                    if uirCoreStrStartsWith(key, "ref_"):
                        key = str(ptr_add(void*(key), 4))
                    elif uirCoreStrStartsWith(key, "var_ref_"):
                        key = str(ptr_add(void*(key), 8))
                    elif uirCoreStrStartsWith(key, "var_"):
                        key = str(ptr_add(void*(key), 4))
                    if uirCoreStrStartsWith(key, "ptr_"):
                        key = str(ptr_add(void*(key), 4))
                    objTypeName = uirCorePtrBaseObjTypeName(b.module, key)
                    if debugDot:
                        echo("[backend] debugDot: call-dot callee retTypeKey='" + callee0.retTypeKey +
                             "' objTypeFromRet='" + objTypeName + "'")
            if len(objTypeName) == 0 && kidCount(base) > 1:
                let valKey0: str = uirCoreInferValueCallInnerKey(b, base)
                if debugDot:
                    echo("[backend] debugDot: call-dot valKey='" + valKey0 + "'")
                if valKey0 != nil && len(valKey0) > 0:
                    objTypeName = uirCoreObjTypeFromTypeKey(b.module, valKey0)
                    if debugDot:
                        echo("[backend] debugDot: call-dot objTypeFromVal='" + objTypeName + "'")
            if len(objTypeName) == 0:
                let callKey2: str = caseInferExprTypeKey(b, base)
                if debugDot:
                    echo("[backend] debugDot: call-dot callExprKey='" + callKey2 + "'")
                if callKey2 != nil && len(callKey2) > 0:
                    objTypeName = uirCoreObjTypeFromTypeKey(b.module, callKey2)
                    if debugDot:
                        echo("[backend] debugDot: call-dot objTypeFromExprKey='" + objTypeName + "'")
        if len(objTypeName) == 0 && base != nil && (base.kind == nkHiddenDeref || base.kind == nkDerefExpr) &&
           kidCount(base) > 0:
            let inner: Node = kid(base, 0)
            if inner != nil && inner.typeCacheValid && inner.typeCache != nil:
                objTypeName = typeNodeObjTypeName(b.module, inner.typeCache)
            elif inner != nil && (inner.kind == nkIdent || inner.kind == nkSymbol):
                let slot2: int32 = localIndex(b.env, plainName(inner))
                if slot2 >= 0:
                    objTypeName = funcObjTypeName(b.func, slot2)
                    if len(objTypeName) == 0:
                        var key2: str = localTypeKey(b.env, slot2)
                        if uirCoreStrStartsWith(key2, "ref_"):
                            key2 = str(ptr_add(void*(key2), 4))
                        elif uirCoreStrStartsWith(key2, "var_ref_"):
                            key2 = str(ptr_add(void*(key2), 8))
                        if uirCoreStrStartsWith(key2, "ptr_"):
                            let innerKey2: str = str(ptr_add(void*(key2), 4))
                            if innerKey2 != nil && len(innerKey2) > 0:
                                if uirCoreHasObjType(b.module, innerKey2):
                                    objTypeName = innerKey2
                                elif uirCoreStrStartsWith(innerKey2, "seq_") && uirCoreHasObjType(b.module, "seq"):
                                    objTypeName = "seq"
                                elif uirCoreStrStartsWith(innerKey2, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                                    objTypeName = "seq"
                                elif uirCoreStrStartsWith(innerKey2, "Table_") && uirCoreHasObjType(b.module, "Table"):
                                    objTypeName = "Table"
            if len(objTypeName) == 0 && inner != nil && b.module != nil:
                var key3: str = backendStripSpaces(exprTypeKeyShallow(b, inner))
                if uirCoreStrStartsWith(key3, "ref_"):
                    key3 = str(ptr_add(void*(key3), 4))
                elif uirCoreStrStartsWith(key3, "var_ref_"):
                    key3 = str(ptr_add(void*(key3), 8))
                elif uirCoreStrStartsWith(key3, "var_"):
                    key3 = str(ptr_add(void*(key3), 4))
                if uirCoreStrStartsWith(key3, "ptr_"):
                    key3 = str(ptr_add(void*(key3), 4))
                key3 = uirCoreObjAliasCanon(key3)
                objTypeName = uirCorePtrBaseObjTypeName(b.module, key3)
        basePtrRes = lowerExprValue(b, base, uirCoreTypeI64())
    if len(objTypeName) == 0 || ! IsOk[UirCoreExpr](basePtrRes):
        var fnName: str = ""
        var fp: str = ""
        if b != nil && b.func != nil:
            let f0: UirCoreFunc = b.func
            fnName = f0.name
            fp = f0.originFile
        if debugDot:
            var bKind2: int32 = -1
            if base != nil:
                bKind2 = int32(base.kind)
            let okPtr: bool = IsOk[UirCoreExpr](basePtrRes)
            let okPtrStr: str = okPtr ? "1" : "0"
            let modNil: str = (b == nil || b.module == nil) ? "1" : "0"
            echo("[backend] debugDot: dotFail objTypeName='" + objTypeName + "' baseKind=nk#" +
                intToStr(bKind2) + " basePtrOk=" + okPtrStr + " moduleNil=" + modNil)
            if baseName != nil && len(baseName) > 0 && b != nil && b.env != nil:
                let dbgSlot: int32 = localIndex(b.env, baseName)
                var dbgMsg: str = "[backend] debugDot: baseName='" + baseName + "' slot=" + intToStr(dbgSlot)
                if dbgSlot >= 0 && b.func != nil:
                    let fObj: str = funcObjTypeName(b.func, dbgSlot)
                    let fKey: str = funcObjTypeKey(b.func, dbgSlot)
                    let lKey: str = localTypeKey(b.env, dbgSlot)
                    var lKey0: str = lKey
                    if uirCoreStrStartsWith(lKey0, "ref_"):
                        lKey0 = str(ptr_add(void*(lKey0), 4))
                    elif uirCoreStrStartsWith(lKey0, "var_ref_"):
                        lKey0 = str(ptr_add(void*(lKey0), 8))
                    elif uirCoreStrStartsWith(lKey0, "var_"):
                        lKey0 = str(ptr_add(void*(lKey0), 4))
                    dbgMsg = dbgMsg + " funcObjTypeName='" + fObj + "' funcObjTypeKey='" + fKey +
                        "' localTypeKey='" + lKey + "' localTypeKeyStrip='" + lKey0 + "'"
                    let hasObj: bool = lKey0 != nil && len(lKey0) > 0 && uirCoreHasObjType(b.module, lKey0)
                    dbgMsg = dbgMsg + " hasObj=" + (hasObj ? "1" : "0")
                    if !hasObj && b.module != nil && lKey0 != nil && len(lKey0) > 0:
                        let modDbg: UirCoreModule = b.module
                        let objsDbg: UirCoreObjType[] = modDbg.objTypes
                        let pref0: str = lKey0 + "_"
                        var shown0: int32 = 0
                        for oi0 in 0..<objsDbg.len:
                            let ot0: UirCoreObjType = objsDbg[oi0]
                            if ot0.name == nil || len(ot0.name) == 0:
                                continue
                            if ot0.name == lKey0 || uirCoreStrStartsWith(ot0.name, pref0):
                                echo("[backend] debugDot: localKeyCandidate key='" + lKey0 +
                                     "' cand='" + ot0.name + "'")
                                shown0 = shown0 + 1
                                if shown0 >= 6:
                                    break
                echo dbgMsg
                let altName: str = baseName + "Res"
                let altSlot: int32 = localIndex(b.env, altName)
                if altSlot >= 0:
                    let altKey: str = localTypeKey(b.env, altSlot)
                    echo("[backend] debugDot: altName='" + altName + "' slot=" + intToStr(altSlot) +
                         " localTypeKey='" + altKey + "'")
            if base != nil && base.typeCacheValid && base.typeCache != nil:
                let tc: Node = base.typeCache
                let tcKind2: str = intToStr(int32(tc.kind))
                let tcName: str = backendStripSpaces(plainName(tc))
                let tcKey: str = typeKey(tc)
                let tcObj: str = typeNodeObjTypeName(b.module, tc)
                echo("[backend] debugDot: base.typeCache kind=nk#" + tcKind2 + " name='" + tcName +
                    "' key='" + tcKey + "' objTypeName='" + tcObj + "'")
            if !okPtr:
                echo("[backend] debugDot: dotFail basePtrErr=" + Error(basePtrRes))
        let line: str = intToStr(dotNode.pos.line)
        let col: str = intToStr(dotNode.pos.col)
        let msg: str = "uirCore_builder: dot base is not an object/ref: " + baseName +
                       " (fn=" + fnName + " " + fp + ":" + line + ":" + col + ")"
        return Err[DotAccess](msg)
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objTypeName)
    if ot.name == nil || len(ot.name) == 0:
        return Err[DotAccess]("uirCore_builder: unknown object type")
    var fieldName: str = backendStripSpaces(plainName(field))
    if fieldName == "data" && ot.name == "seq":
        fieldName = "buffer"
    for fi in 0..<ot.fields.len:
        let f: UirCoreObjField = ot.fields[fi]
        if (f.name == fieldName):
            let basePtr: UirCoreExpr = Value[UirCoreExpr](basePtrRes)
            var addr: UirCoreExpr = basePtr
            if f.offset != 0:
                addr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(f.offset)))
            var da: DotAccess
            da.addr = addr
            da.fieldTy = f.ty
            da.objTypeName = ""
            return Ok[DotAccess](da)
    if ((objTypeName == "tuple") || uirCoreStrStartsWith(objTypeName, "tuple_")):
        var ti: int32 = uirCoreTupleFieldIndexGet(objTypeName, fieldName)
        if ti < 0 && base != nil && base.typeCacheValid && base.typeCache != nil:
            var tc: Node = base.typeCache
            while tc != nil && tc.kind == nkPar && kidCount(tc) > 0:
                tc = kid(tc, 0)
            if tc != nil && tc.kind == nkVarTy && kidCount(tc) > 0:
                tc = kid(tc, 0)
            if tc != nil && (tc.kind == nkRefTy || tc.kind == nkPtrTy) && kidCount(tc) > 0:
                tc = kid(tc, 0)
            if tc != nil && tc.kind == nkTupleTy:
                for tj in 0..<kidCount(tc):
                    let elem: Node = kid(tc, tj)
                    if elem != nil && elem.kind == nkIdentDefs && kidCount(elem) > 0:
                        let nameNode: Node = kid(elem, 0)
                        if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                            let lbl: str = backendStripSpaces(plainName(nameNode))
                            if len(lbl) > 0 && (lbl == fieldName):
                                ti = tj
                                uirCoreTupleFieldIndexPut(objTypeName, fieldName, tj)
                                break
        if ti == -2:
            return Err[DotAccess]("uirCore_builder: ambiguous tuple field '" + fieldName + "' for type '" + objTypeName + "'")
        if ti >= 0:
            let altFieldName: str = "f" + intToStr(ti)
            for fi2 in 0..<ot.fields.len:
                let f2: UirCoreObjField = ot.fields[fi2]
                if (f2.name == altFieldName):
                    let basePtr2: UirCoreExpr = Value[UirCoreExpr](basePtrRes)
                    var addr2: UirCoreExpr = basePtr2
                    if f2.offset != 0:
                        addr2 = uirCoreBin(mbAdd, basePtr2, uirCoreConstI64(int64(f2.offset)))
                    var da2: DotAccess
                    da2.addr = addr2
                    da2.fieldTy = f2.ty
                    da2.objTypeName = ""
                    return Ok[DotAccess](da2)
    let prefix: str = fieldName + "."
    var baseOff: int32 = -1
    for fj in 0..<ot.fields.len:
        let f2: UirCoreObjField = ot.fields[fj]
        if uirCoreStrStartsWith(f2.name, prefix):
            if baseOff < 0 || f2.offset < baseOff:
                baseOff = f2.offset
    if baseOff >= 0:
        let basePtr: UirCoreExpr = Value[UirCoreExpr](basePtrRes)
        var addr: UirCoreExpr = basePtr
        if baseOff != 0:
            addr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(baseOff)))
        var da: DotAccess
        da.addr = addr
        # Composite (inlined) object field: treat as an address-only value.
        da.fieldTy = uirCoreTypeVoid()
        da.objTypeName = inferInlineObjFieldTypeName(b.module, ot, fieldName, baseOff)
        return Ok[DotAccess](da)
    var fnName2: str = ""
    var fp2: str = ""
    if b != nil && b.func != nil:
        let f1: UirCoreFunc = b.func
        fnName2 = f1.name
        fp2 = f1.originFile
    let line2: str = intToStr(dotNode.pos.line)
    let col2: str = intToStr(dotNode.pos.col)
    let msg2: str = "uirCore_builder: unknown object field '" + fieldName + "' for type '" + objTypeName +
                    "' (fn=" + fnName2 + " " + fp2 + ":" + line2 + ":" + col2 + ")"
    return Err[DotAccess](msg2)

fn lowerCallWithLeadingArg(b: BlockBuilder, callNode: Node, lead: UirCoreExpr): Result[UirCoreExpr] =
    if b == nil || callNode == nil || callNode.kind != nkCall || kidCount(callNode) == 0:
        return Err[UirCoreExpr]("uirCore_builder: expected call")
    let calleeNode: Node = kid(callNode, 0)
    if calleeNode == nil:
        return Err[UirCoreExpr]("uirCore_builder: call expects callee")
    var name: str = ""
    var typeArgs: Node[]
    if calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
        let base: Node = kid(calleeNode, 0)
        name = backendStripSpaces(plainName(base))
        for ti in 1..<kidCount(calleeNode):
            let t: Node = kid(calleeNode, ti)
            if t != nil && t.kind != nkEmpty:
                add(typeArgs, t)
    elif calleeNode.kind == nkDotExpr && kidCount(calleeNode) > 1:
        let member: Node = kid(calleeNode, 1)
        if member != nil && member.kind == nkBracketExpr && kidCount(member) > 0:
            let base2: Node = kid(member, 0)
            name = backendStripSpaces(plainName(base2))
            for ti2 in 1..<kidCount(member):
                let t2: Node = kid(member, ti2)
                if t2 != nil && t2.kind != nkEmpty:
                    add(typeArgs, t2)
        else:
            name = backendStripSpaces(plainName(member))
    else:
        if calleeNode.kind != nkIdent && calleeNode.kind != nkSymbol:
            var fnName: str = ""
            var fp: str = ""
            if b.func != nil:
                let f0: UirCoreFunc = b.func
                fnName = f0.name
                fp = f0.originFile
            let line: str = intToStr(callNode.pos.line)
            let col: str = intToStr(callNode.pos.col)
            let k: str = intToStr(int32(calleeNode.kind))
            return Err[UirCoreExpr]("uirCore_builder: call expects identifier callee (kind=nk#" + k +
                                " fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")
        name = backendStripSpaces(plainName(calleeNode))
    let localCalleeIdx: int32 = localIndex(b.env, name)
    if localCalleeIdx >= 0:
        let target: str = localCallTarget(b.env, localCalleeIdx)
        if target != nil && len(target) > 0:
            name = target

    var valueNodes: Node[]
    for ai in 1..<kidCount(callNode):
        let raw: Node = kid(callNode, ai)
        add(valueNodes, raw)

    if name == "Value" && valueNodes.len == 1 && b.module != nil:
        var srcNode0: Node = valueNodes[0]
        if srcNode0 != nil && srcNode0.kind == nkCallArg:
            if kidCount(srcNode0) > 1:
                srcNode0 = kid(srcNode0, 1)
            elif kidCount(srcNode0) > 0:
                srcNode0 = kid(srcNode0, 0)
        if srcNode0 != nil:
            let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, srcNode0, uirCoreTypeI64())
            if IsOk[UirCoreExpr](srcRes0):
                var srcPtr0: UirCoreExpr = Value[UirCoreExpr](srcRes0)
                var srcKey0: str = uirCoreInferNodeTypeKeyForOverload(b, srcNode0)
                if uirCoreStrStartsWith(srcKey0, "ref_"):
                    srcKey0 = str(ptr_add(void*(srcKey0), 4))
                elif uirCoreStrStartsWith(srcKey0, "var_ref_"):
                    srcKey0 = str(ptr_add(void*(srcKey0), 8))
                elif uirCoreStrStartsWith(srcKey0, "var_"):
                    srcKey0 = str(ptr_add(void*(srcKey0), 4))
                if uirCoreStrStartsWith(srcKey0, "ptr_"):
                    srcKey0 = str(ptr_add(void*(srcKey0), 4))
                var valueOff0: int32 = -1
                let srcObj0: str = uirCoreObjTypeFromTypeKey(b.module, srcKey0)
                if srcObj0 != nil && len(srcObj0) > 0 && uirCoreHasObjType(b.module, srcObj0):
                    let srcOt0: UirCoreObjType = uirCoreGetObjType(b.module, srcObj0)
                    for sfi in 0..<srcOt0.fields.len:
                        let sf0: UirCoreObjField = srcOt0.fields[sfi]
                        if (sf0.name == "value") || uirCoreStrStartsWith(sf0.name, "value."):
                            if valueOff0 < 0 || sf0.offset < valueOff0:
                                valueOff0 = sf0.offset
                if valueOff0 < 0 && uirCoreStrStartsWith(srcKey0, "Result_"):
                    valueOff0 = 0
                if valueOff0 > 0:
                    srcPtr0 = uirCoreBin(mbAdd, srcPtr0, uirCoreConstI64(int64(valueOff0)))
                var dstObj0: str = ""
                if callNode.typeCacheValid && callNode.typeCache != nil:
                    dstObj0 = typeNodeObjTypeName(b.module, callNode.typeCache)
                if (dstObj0 == nil || len(dstObj0) == 0) && b != nil && b.func != nil &&
                   lead != nil && lead.kind == meLocal:
                    let leadSlot0: int32 = lead.localIndex
                    if leadSlot0 >= 0 && funcFindObjLocal(b.func, leadSlot0) >= 0:
                        dstObj0 = funcObjTypeName(b.func, leadSlot0)
                if dstObj0 != nil && len(dstObj0) > 0:
                    let copyRes0: Result[bool] = emitObjCopyPtrs(b, lead, dstObj0, srcPtr0)
                    if !IsOk[bool](copyRes0):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes0))
                    if getEnv "BACKEND_DEBUG_VALUE_LOWER" == "1":
                        var fnDbg1: str = ""
                        if b != nil && b.func != nil:
                            let fDbg1: UirCoreFunc = b.func
                            fnDbg1 = fDbg1.name
                        echo("[backend] debugValueLower: fn=" + fnDbg1 + " dstObj=" + dstObj0)
                    return Ok[UirCoreExpr](lead)

    if name == "ErrorInfoOf" && valueNodes.len == 1 && b.module != nil:
        var srcNode1: Node = valueNodes[0]
        if srcNode1 != nil && srcNode1.kind == nkCallArg:
            if kidCount(srcNode1) > 1:
                srcNode1 = kid(srcNode1, 1)
            elif kidCount(srcNode1) > 0:
                srcNode1 = kid(srcNode1, 0)
        if srcNode1 != nil:
            let srcRes1: Result[UirCoreExpr] = lowerExprValue(b, srcNode1, uirCoreTypeI64())
            if IsOk[UirCoreExpr](srcRes1):
                var srcPtr1: UirCoreExpr = Value[UirCoreExpr](srcRes1)
                var srcKey1: str = uirCoreInferNodeTypeKeyForOverload(b, srcNode1)
                if uirCoreStrStartsWith(srcKey1, "ref_"):
                    srcKey1 = str(ptr_add(void*(srcKey1), 4))
                elif uirCoreStrStartsWith(srcKey1, "var_ref_"):
                    srcKey1 = str(ptr_add(void*(srcKey1), 8))
                elif uirCoreStrStartsWith(srcKey1, "var_"):
                    srcKey1 = str(ptr_add(void*(srcKey1), 4))
                if uirCoreStrStartsWith(srcKey1, "ptr_"):
                    srcKey1 = str(ptr_add(void*(srcKey1), 4))
                var errOff1: int32 = -1
                let srcObj1: str = uirCoreObjTypeFromTypeKey(b.module, srcKey1)
                if srcObj1 != nil && len(srcObj1) > 0 && uirCoreHasObjType(b.module, srcObj1):
                    let srcOt1: UirCoreObjType = uirCoreGetObjType(b.module, srcObj1)
                    for sfi1 in 0..<srcOt1.fields.len:
                        let sf1: UirCoreObjField = srcOt1.fields[sfi1]
                        if (sf1.name == "err") || uirCoreStrStartsWith(sf1.name, "err."):
                            if errOff1 < 0 || sf1.offset < errOff1:
                                errOff1 = sf1.offset
                if errOff1 > 0:
                    srcPtr1 = uirCoreBin(mbAdd, srcPtr1, uirCoreConstI64(int64(errOff1)))
                var dstObj1: str = ""
                if callNode.typeCacheValid && callNode.typeCache != nil:
                    dstObj1 = typeNodeObjTypeName(b.module, callNode.typeCache)
                if (dstObj1 == nil || len(dstObj1) == 0) && b != nil && b.func != nil &&
                   lead != nil && lead.kind == meLocal:
                    let leadSlot1: int32 = lead.localIndex
                    if leadSlot1 >= 0 && funcFindObjLocal(b.func, leadSlot1) >= 0:
                        dstObj1 = funcObjTypeName(b.func, leadSlot1)
                if (dstObj1 == nil || len(dstObj1) == 0) && uirCoreHasObjType(b.module, "ErrorInfo"):
                    dstObj1 = "ErrorInfo"
                if dstObj1 != nil && len(dstObj1) > 0:
                    let copyRes1: Result[bool] = emitObjCopyPtrs(b, lead, dstObj1, srcPtr1)
                    if !IsOk[bool](copyRes1):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes1))
                    return Ok[UirCoreExpr](lead)

    var callName: str = name
    if typeArgs.len > 0:
        callName = mangleInstance(name, typeArgs)
    let helperCallNameL: str = uirCoreStripLeadingUnderscores(callName)

    if uirCoreDictHelperClosureEnabled() && b.module != nil:
        if kidCount(callNode) == 2:
            var ctorKindL: int32 = 0
            var resultSuffixL: str = ""
            if uirCoreStrStartsWith(helperCallNameL, "Ok_"):
                ctorKindL = 1
                resultSuffixL = str(ptr_add(void*(helperCallNameL), 3))
            elif uirCoreStrStartsWith(helperCallNameL, "Err_"):
                ctorKindL = 2
                resultSuffixL = str(ptr_add(void*(helperCallNameL), 4))
            elif uirCoreStrStartsWith(helperCallNameL, "ErrInfo_"):
                ctorKindL = 3
                resultSuffixL = str(ptr_add(void*(helperCallNameL), 8))
            if ctorKindL <= 0:
                if helperCallNameL == "Ok":
                    ctorKindL = 1
                elif helperCallNameL == "Err":
                    ctorKindL = 2
                elif helperCallNameL == "ErrInfo":
                    ctorKindL = 3
                if ctorKindL > 0:
                    resultSuffixL = uirCoreInferCtorSuffixFromTypeCache(b, callNode, "Result_")
            if ctorKindL > 0 && resultSuffixL != nil && len(resultSuffixL) > 0:
                let resultObjNameL: str = "Result_" + resultSuffixL
                if !uirCoreHasObjType(b.module, resultObjNameL):
                    let _ensResultL: bool = ensureResultObjType(b.module, resultObjNameL)
                if uirCoreHasObjType(b.module, resultObjNameL):
                    var payloadNodeL: Node = kid(callNode, 1)
                    if payloadNodeL != nil && payloadNodeL.kind == nkCallArg:
                        if kidCount(payloadNodeL) > 1:
                            payloadNodeL = kid(payloadNodeL, 1)
                        elif kidCount(payloadNodeL) > 0:
                            payloadNodeL = kid(payloadNodeL, 0)
                    var payloadExprL: Node = payloadNodeL
                    if ctorKindL == 2:
                        var errCtorL: Node = newNode(nkCall, callNode.pos)
                        addSon(errCtorL, newIdent("ErrorInfo", callNode.pos))
                        var errCodeArgL: Node = newNode(nkCallArg, callNode.pos)
                        addSon(errCodeArgL, newIdent("code", callNode.pos))
                        addSon(errCodeArgL, newIntLit(0, callNode.pos))
                        addSon(errCtorL, errCodeArgL)
                        var errMsgArgL: Node = newNode(nkCallArg, callNode.pos)
                        addSon(errMsgArgL, newIdent("msg", callNode.pos))
                        addSon(errMsgArgL, payloadNodeL)
                        addSon(errCtorL, errMsgArgL)
                        payloadExprL = errCtorL

                    var ctorCallL: Node = newNode(nkCall, callNode.pos)
                    addSon(ctorCallL, newIdent(resultObjNameL, callNode.pos))
                    var okArgL: Node = newNode(nkCallArg, callNode.pos)
                    addSon(okArgL, newIdent("ok", callNode.pos))
                    if ctorKindL == 1:
                        addSon(okArgL, newBoolLit(true, callNode.pos))
                    else:
                        addSon(okArgL, newBoolLit(false, callNode.pos))
                    addSon(ctorCallL, okArgL)
                    var payloadArgL: Node = newNode(nkCallArg, callNode.pos)
                    if ctorKindL == 1:
                        addSon(payloadArgL, newIdent("value", callNode.pos))
                    else:
                        addSon(payloadArgL, newIdent("err", callNode.pos))
                    addSon(payloadArgL, payloadExprL)
                    addSon(ctorCallL, payloadArgL)
                    let ctorResL: Result[UirCoreExpr] = lowerObjConstructorCall(b, ctorCallL, resultObjNameL)
                    if !IsOk[UirCoreExpr](ctorResL):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](ctorResL))
                    let copyResL: Result[bool] = emitObjCopyPtrs(b, lead, resultObjNameL, Value[UirCoreExpr](ctorResL))
                    if !IsOk[bool](copyResL):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyResL))
                    return Ok[UirCoreExpr](lead)

        var optionCtorKindL: int32 = 0
        var optionSuffixL: str = ""
        if kidCount(callNode) == 2 && uirCoreStrStartsWith(helperCallNameL, "Some_"):
            optionCtorKindL = 1
            optionSuffixL = str(ptr_add(void*(helperCallNameL), 5))
        elif kidCount(callNode) == 1 && uirCoreStrStartsWith(helperCallNameL, "None_"):
            optionCtorKindL = 2
            optionSuffixL = str(ptr_add(void*(helperCallNameL), 5))
        if optionCtorKindL <= 0:
            if kidCount(callNode) == 2 && helperCallNameL == "Some":
                optionCtorKindL = 1
                optionSuffixL = uirCoreInferCtorSuffixFromTypeCache(b, callNode, "Option_")
            elif kidCount(callNode) == 1 && helperCallNameL == "None":
                optionCtorKindL = 2
                optionSuffixL = uirCoreInferCtorSuffixFromTypeCache(b, callNode, "Option_")
        if optionCtorKindL > 0 && optionSuffixL != nil && len(optionSuffixL) > 0:
            let optionObjNameL: str = "Option_" + optionSuffixL
            if !uirCoreHasObjType(b.module, optionObjNameL):
                let _ensOptionL: bool = ensureOptionObjType(b.module, optionObjNameL)
            if uirCoreHasObjType(b.module, optionObjNameL):
                var ctorCallOptL: Node = newNode(nkCall, callNode.pos)
                addSon(ctorCallOptL, newIdent(optionObjNameL, callNode.pos))
                var hasArgOptL: Node = newNode(nkCallArg, callNode.pos)
                addSon(hasArgOptL, newIdent("has", callNode.pos))
                addSon(hasArgOptL, newBoolLit(optionCtorKindL == 1, callNode.pos))
                addSon(ctorCallOptL, hasArgOptL)
                if optionCtorKindL == 1:
                    var payloadNodeOptL: Node = kid(callNode, 1)
                    if payloadNodeOptL != nil && payloadNodeOptL.kind == nkCallArg:
                        if kidCount(payloadNodeOptL) > 1:
                            payloadNodeOptL = kid(payloadNodeOptL, 1)
                        elif kidCount(payloadNodeOptL) > 0:
                            payloadNodeOptL = kid(payloadNodeOptL, 0)
                    var payloadArgOptL: Node = newNode(nkCallArg, callNode.pos)
                    addSon(payloadArgOptL, newIdent("value", callNode.pos))
                    addSon(payloadArgOptL, payloadNodeOptL)
                    addSon(ctorCallOptL, payloadArgOptL)
                let ctorResOptL: Result[UirCoreExpr] = lowerObjConstructorCall(b, ctorCallOptL, optionObjNameL)
                if !IsOk[UirCoreExpr](ctorResOptL):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](ctorResOptL))
                let copyResOptL: Result[bool] = emitObjCopyPtrs(b, lead, optionObjNameL, Value[UirCoreExpr](ctorResOptL))
                if !IsOk[bool](copyResOptL):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyResOptL))
                return Ok[UirCoreExpr](lead)

    if b.module != nil && uirCoreHasObjType(b.module, callName):
        var hasNamedArgs: bool = false
        for ni in 0..<valueNodes.len:
            let an: Node = valueNodes[ni]
            if an != nil && an.kind == nkCallArg:
                hasNamedArgs = true
                break

        if hasNamedArgs:
            let initRes: Result[bool] = emitObjDefaultInitPtrs(b, lead, callName)
            if !IsOk[bool](initRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))
            let ot: UirCoreObjType = uirCoreGetObjType(b.module, callName)
            for vi in 0..<valueNodes.len:
                let arg0: Node = valueNodes[vi]
                if arg0 == nil || arg0.kind != nkCallArg || kidCount(arg0) < 2:
                    return Err[UirCoreExpr]("uirCore_builder: object constructor expects named args")
                let keyNode: Node = kid(arg0, 0)
                let valNode: Node = kid(arg0, 1)
                if keyNode == nil || (keyNode.kind != nkIdent && keyNode.kind != nkSymbol):
                    return Err[UirCoreExpr]("uirCore_builder: object constructor field expects identifier")
                let fieldName: str = backendStripSpaces(plainName(keyNode))

                var found: bool = false
                var field: UirCoreObjField
                for fi in 0..<ot.fields.len:
                    let f: UirCoreObjField = ot.fields[fi]
                    if (f.name == fieldName):
                        field = f
                        found = true
                        break
                if found:
                    var addr: UirCoreExpr = lead
                    if field.offset != 0:
                        addr = uirCoreBin(mbAdd, lead, uirCoreConstI64(int64(field.offset)))
                    let valRes: Result[UirCoreExpr] = lowerExprValue(b, valNode, field.ty)
                    if !IsOk[UirCoreExpr](valRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
                    add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), field.ty))
                    continue

                let prefix: str = fieldName + "."
                var hasPrefix: bool = false
                var minOff: int32 = 2147483647
                for fi2 in 0..<ot.fields.len:
                    let f2: UirCoreObjField = ot.fields[fi2]
                    if uirCoreStrStartsWith(f2.name, prefix):
                        hasPrefix = true
                        if f2.offset < minOff:
                            minOff = f2.offset
                if !hasPrefix:
                    let line: str = intToStr(keyNode.pos.line)
                    let col: str = intToStr(keyNode.pos.col)
                    return Err[UirCoreExpr]("uirCore_builder: unknown object constructor field: " + fieldName +
                                        " (" + callName + " @" + line + ":" + col + ")")

                var dstAddr: UirCoreExpr = lead
                if minOff != 0:
                    dstAddr = uirCoreBin(mbAdd, lead, uirCoreConstI64(int64(minOff)))

                var objNm: str = inferInlineObjFieldTypeName(b.module, ot, fieldName, minOff)
                if len(objNm) == 0 && valNode != nil && valNode.typeCacheValid && valNode.typeCache != nil:
                    objNm = typeNodeObjTypeName(b.module, valNode.typeCache)
                if len(objNm) == 0 && valNode != nil && (valNode.kind == nkIdent || valNode.kind == nkSymbol):
                    let srcSlot: int32 = localIndex(b.env, plainName(valNode))
                    if srcSlot >= 0:
                        objNm = funcObjTypeName(b.func, srcSlot)
                if len(objNm) == 0 && valNode != nil && b != nil && b.module != nil:
                    let key3: str = caseInferExprTypeKey(b, valNode)
                    if key3 != nil && len(key3) > 0:
                        let tn3: Node = newIdent(key3, valNode.pos)
                        objNm = typeNodeObjTypeName(b.module, tn3)
                    if (getEnv "BACKEND_DEBUG_NESTED_CTOR" == "1") && (callName == "GossipsubContext") && (fieldName == "params"):
                        let canon3: str = uirCoreObjAliasCanon(key3)
                        let canonOk: str = (canon3 != nil && len(canon3) > 0) ? canon3 : ""
                        echo("[backend] debugNestedCtorLead: ctor=" + callName + " field=" + fieldName +
                             " key3='" + key3 + "' canon='" + canonOk + "' objNm='" + objNm + "'" +
                             " aliasReady=" + (uirCoreObjAliasReady ? "1" : "0"))
                if len(objNm) == 0:
                    let line3: str = (valNode != nil) ? intToStr(valNode.pos.line) : "0"
                    let col3: str = (valNode != nil) ? intToStr(valNode.pos.col) : "0"
                    let k3: str = (valNode != nil) ? intToStr(int32(valNode.kind)) : "0"
                    var fnName3: str = ""
                    var fp3: str = ""
                    if b != nil && b.func != nil:
                        let f3: UirCoreFunc = b.func
                        fnName3 = f3.name
                        fp3 = f3.originFile
                    return Err[UirCoreExpr]("uirCore_builder: object constructor nested field expects object value" +
                                        " (ctor=" + callName + " field=" + fieldName + " valKind=nk#" + k3 +
                                        " fn=" + fnName3 + " " + fp3 + ":" + line3 + ":" + col3 + ")")

                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, valNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes))
                let copyRes: Result[bool] = emitObjCopyPtrs(b, dstAddr, objNm, Value[UirCoreExpr](srcRes))
                if !IsOk[bool](copyRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes))
            return Ok[UirCoreExpr](lead)

        let ot2: UirCoreObjType = uirCoreGetObjType(b.module, callName)
        let argCount: int32 = valueNodes.len
        if argCount == 0:
            let initRes2: Result[bool] = emitObjDefaultInitPtrs(b, lead, callName)
            if !IsOk[bool](initRes2):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes2))
            return Ok[UirCoreExpr](lead)
        if argCount == ot2.fields.len + 1:
            return lowerObjConstructorCallPositional(b, callNode, callName)
        if argCount > ot2.fields.len:
            let line0: str = intToStr(callNode.pos.line)
            let col0: str = intToStr(callNode.pos.col)
            var fnName0: str = ""
            var fp0: str = ""
            if b != nil && b.func != nil:
                let bf0: UirCoreFunc = b.func
                fnName0 = bf0.name
                fp0 = bf0.originFile
            return Err[UirCoreExpr]("uirCore_builder: object constructor '" + callName + "' expects all fields" +
                                " (argc=" + intToStr(argCount) + " fields=" + intToStr(ot2.fields.len) +
                                " fn=" + fnName0 + " " + fp0 + ":" + line0 + ":" + col0 + ")")

        # If the object layout inlines nested object fields (e.g. `value.len/value.cap/value.buffer`),
        # stage1 may still call the constructor positionally using the top-level field list
        # (e.g. `Option[T](has, value)`). Support this by mapping args to top-level fields and
        # copying composite fields as a group.
        var groupNames: str[]
        groupNames.cap = 8
        var groupIsComposite: bool[]
        groupIsComposite.cap = 8
        var groupOffsets: int32[]
        groupOffsets.cap = 8
        var groupTypes: UirCoreType[]
        groupTypes.cap = 8
        var groupObjNames: str[]
        groupObjNames.cap = 8
        var fiG: int32 = 0
        for __for_guard_fiG in 0..<ot2.fields.len:
            if !(fiG < ot2.fields.len):
                break
            let fG: UirCoreObjField = ot2.fields[fiG]
            let nmG: str = fG.name
            let dotAt: int32 = uirCoreStrIndexOf(nmG, ".")
            if dotAt > 0:
                let group: str = uirCoreStrTake(nmG, dotAt)
                let prefix: str = group + "."
                var minOff: int32 = 2147483647
                for fjG in fiG..<ot2.fields.len:
                    let f2G: UirCoreObjField = ot2.fields[fjG]
                    if !uirCoreStrStartsWith(f2G.name, prefix):
                        break
                    if f2G.offset < minOff:
                        minOff = f2G.offset
                if minOff == 2147483647:
                    minOff = fG.offset
                add(groupNames, group)
                add(groupIsComposite, true)
                add(groupOffsets, minOff)
                var voidTy: UirCoreType
                voidTy.kind = mtVoid
                add(groupTypes, voidTy)
                let objNmG: str = inferInlineObjFieldTypeName(b.module, ot2, group, minOff)
                add(groupObjNames, objNmG)
                fiG = fjG
                continue
            add(groupNames, nmG)
            add(groupIsComposite, false)
            add(groupOffsets, fG.offset)
            add(groupTypes, fG.ty)
            add(groupObjNames, "")
            fiG = fiG + 1

        let initRes2: Result[bool] = emitObjDefaultInitPtrs(b, lead, callName)
        if !IsOk[bool](initRes2):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes2))
        if groupNames.len > 0 && groupNames.len < ot2.fields.len && argCount <= groupNames.len:
            for gi in 0..<argCount:
                let isComposite: bool = groupIsComposite[gi]
                let off: int32 = groupOffsets[gi]
                var dstAddr: UirCoreExpr = lead
                if off != 0:
                    dstAddr = uirCoreBin(mbAdd, lead, uirCoreConstI64(int64(off)))
                var argNode: Node = valueNodes[gi]
                if argNode != nil && argNode.kind == nkCallArg:
                    if kidCount(argNode) > 1:
                        argNode = kid(argNode, 1)
                    elif kidCount(argNode) > 0:
                        argNode = kid(argNode, 0)
                if !isComposite:
                    let tyG: UirCoreType = groupTypes[gi]
                    let valResG: Result[UirCoreExpr] = lowerExprValue(b, argNode, tyG)
                    if !IsOk[UirCoreExpr](valResG):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valResG))
                    add(b.currentStmts, uirCoreStmtStore(dstAddr, Value[UirCoreExpr](valResG), tyG))
                    continue

                var objNm0: str = groupObjNames[gi]
                if len(objNm0) == 0 && argNode != nil && argNode.typeCacheValid && argNode.typeCache != nil:
                    objNm0 = typeNodeObjTypeName(b.module, argNode.typeCache)
                if len(objNm0) == 0 && argNode != nil && (argNode.kind == nkIdent || argNode.kind == nkSymbol):
                    let srcSlot0: int32 = localIndex(b.env, plainName(argNode))
                    if srcSlot0 >= 0:
                        objNm0 = funcObjTypeName(b.func, srcSlot0)
                if len(objNm0) == 0 && argNode != nil && b != nil && b.module != nil:
                    let key0: str = caseInferExprTypeKey(b, argNode)
                    if key0 != nil && len(key0) > 0:
                        let tn0: Node = newIdent(key0, argNode.pos)
                        objNm0 = typeNodeObjTypeName(b.module, tn0)
                if len(objNm0) == 0:
                    return Err[UirCoreExpr]("uirCore_builder: object constructor nested field expects object value" +
                                        " (ctor=" + callName + " field=" + groupNames[gi] + ")")
                let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, argNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes0))
                let copyRes0: Result[bool] = emitObjCopyPtrs(b, dstAddr, objNm0, Value[UirCoreExpr](srcRes0))
                if !IsOk[bool](copyRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes0))
            return Ok[UirCoreExpr](lead)

        for fi3 in 0..<argCount:
            let f3: UirCoreObjField = ot2.fields[fi3]
            var valNode2: Node = valueNodes[fi3]
            if valNode2 != nil && valNode2.kind == nkCallArg:
                if kidCount(valNode2) > 1:
                    valNode2 = kid(valNode2, 1)
                elif kidCount(valNode2) > 0:
                    valNode2 = kid(valNode2, 0)
            let valRes2: Result[UirCoreExpr] = lowerExprValue(b, valNode2, f3.ty)
            if !IsOk[UirCoreExpr](valRes2):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes2))
            var addr2: UirCoreExpr = lead
            if f3.offset != 0:
                addr2 = uirCoreBin(mbAdd, lead, uirCoreConstI64(int64(f3.offset)))
            add(b.currentStmts, uirCoreStmtStore(addr2, Value[UirCoreExpr](valRes2), f3.ty))
        return Ok[UirCoreExpr](lead)

    var argNodes: Node[]
    for vi2 in 0..<valueNodes.len:
        var argNode2: Node = valueNodes[vi2]
        if argNode2 != nil && argNode2.kind == nkCallArg:
            if kidCount(argNode2) > 1:
                argNode2 = kid(argNode2, 1)
            elif kidCount(argNode2) > 0:
                argNode2 = kid(argNode2, 0)
        add(argNodes, argNode2)

    # Some stage1 paths can rewrite `base[idx]` into `[](base, idx)`.
    # Even when this call is (incorrectly) seen as an object-return call, seq subscripting
    # should still lower via builtin bracket handling.
    if name == "[]" && typeArgs.len == 0 && argNodes.len == 2:
        var baseKeyBr: str = uirCoreInferNodeTypeKeyForOverload(b, argNodes[0])
        if uirCoreStrStartsWith(baseKeyBr, "var_ref_"):
            baseKeyBr = str(ptr_add(void*(baseKeyBr), 8))
        elif uirCoreStrStartsWith(baseKeyBr, "var_") || uirCoreStrStartsWith(baseKeyBr, "ref_"):
            baseKeyBr = str(ptr_add(void*(baseKeyBr), 4))
        if uirCoreStrStartsWith(baseKeyBr, "ptr_"):
            baseKeyBr = str(ptr_add(void*(baseKeyBr), 4))
        if uirCoreStrStartsWith(baseKeyBr, "seq_") || uirCoreStrStartsWith(baseKeyBr, "seq_fixed_"):
            let brNode: Node = newNode(nkBracketExpr, callNode.pos)
            brNode.typeCacheValid = callNode.typeCacheValid
            brNode.typeCache = callNode.typeCache
            addSon(brNode, argNodes[0])
            addSon(brNode, argNodes[1])
            return lowerExprValue(b, brNode, uirCoreTypeI64())

    # builtin: TableInit[V](cap?) -> Table[V]
    # Stage1 C codegen treats TableInit as an intrinsic struct literal; implement
    # the same behavior here to avoid relying on a monomorphized helper function.
    if b.module != nil && ((name == "TableInit") || uirCoreStrStartsWith(callName, "TableInit_")):
        let retKeyHint: str = uirCoreInferCallRetKeyHint(callNode)
        if (retKeyHint != nil && uirCoreStrStartsWith(retKeyHint, "Table_")) && uirCoreHasObjType(b.module, "Table"):
            var capNode: Node = nil
            if argNodes.len > 0:
                capNode = argNodes[0]
            var capExpr: UirCoreExpr = uirCoreConstI64(64)
            if capNode != nil && capNode.kind != nkEmpty:
                let capRes: Result[UirCoreExpr] = lowerExprValue(b, capNode, uirCoreTypeI32())
                if ! IsOk[UirCoreExpr](capRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](capRes))
                capExpr = Value[UirCoreExpr](capRes)

            var initName: str = "__cheng_tables_initSlots"
            let initFn: UirCoreFunc = moduleFindFuncByBaseUnique(b.module, initName)
            if initFn != nil:
                initName = initFn.name

            var initArgs: UirCoreExpr[]
            add(initArgs, lead)
            add(initArgs, capExpr)
            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(initName, initArgs)))

            let ot: UirCoreObjType = uirCoreGetObjType(b.module, "Table")
            var lenOff: int32 = 16
            for fi in 0..<ot.fields.len:
                let f: UirCoreObjField = ot.fields[fi]
                if (f.name == "len"):
                    lenOff = f.offset
                    break
            var lenAddr: UirCoreExpr = lead
            if lenOff != 0:
                lenAddr = uirCoreBin(mbAdd, lead, uirCoreConstI64(int64(lenOff)))
            add(b.currentStmts, uirCoreStmtStore(lenAddr, uirCoreConstI64(0), uirCoreTypeI32()))
            return Ok[UirCoreExpr](lead)

    # If the callee is a function pointer (e.g. `handlerFn(req)` or `svc.handler(req)`), lower as an indirect call.
    # This path is primarily used for object-return calls where the implicit leading arg is `__ret`.
    if b != nil && b.env != nil && b.module != nil:
        var fnPtrExpr: UirCoreExpr = nil

        if calleeNode != nil && (calleeNode.kind == nkIdent || calleeNode.kind == nkSymbol) && localCalleeIdx >= 0:
            let target2: str = localCallTarget(b.env, localCalleeIdx)
            if target2 == nil || len(target2) == 0:
                let calleeTy0: UirCoreType = localType(b.env, localCalleeIdx)
                if calleeTy0.kind == mtI64:
                    fnPtrExpr = uirCoreLocal(localCalleeIdx)

        if fnPtrExpr == nil && calleeNode != nil:
            var calleeCore: Node = calleeNode
            while calleeCore != nil && calleeCore.kind == nkPar && kidCount(calleeCore) > 0:
                calleeCore = kid(calleeCore, 0)

            if calleeCore != nil && calleeCore.kind == nkDotExpr && kidCount(calleeCore) > 1:
                let base0: Node = kid(calleeCore, 0)
                let member0: Node = kid(calleeCore, 1)
                if member0 != nil && (member0.kind == nkIdent || member0.kind == nkSymbol):
                    let fieldName0: str = backendStripSpaces(plainName(member0))
                    var baseKey0: str = caseInferExprTypeKey(b, base0)
                    if uirCoreStrStartsWith(baseKey0, "ref_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    elif uirCoreStrStartsWith(baseKey0, "var_ref_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 8))
                    elif uirCoreStrStartsWith(baseKey0, "var_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    if baseKey0 != nil && len(baseKey0) > 0:
                        let canon0: str = uirCoreObjAliasCanon(baseKey0)
                        if canon0 != nil && len(canon0) > 0:
                            baseKey0 = canon0
                    if uirCoreStrStartsWith(baseKey0, "ptr_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    if baseKey0 != nil && len(baseKey0) > 0 && b.module != nil && uirCoreHasObjType(b.module, baseKey0):
                        let ot0: UirCoreObjType = uirCoreGetObjType(b.module, baseKey0)
                        var hasField0: bool = false
                        for fi0 in 0..<ot0.fields.len:
                            let f0: UirCoreObjField = ot0.fields[fi0]
                            if (f0.name == fieldName0):
                                hasField0 = true
                                break
                        if hasField0:
                            let fnPtrRes0: Result[UirCoreExpr] = lowerExprValue(b, calleeNode, uirCoreTypeI64())
                            if !IsOk[UirCoreExpr](fnPtrRes0):
                                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](fnPtrRes0))
                            fnPtrExpr = Value[UirCoreExpr](fnPtrRes0)
            elif calleeCore != nil && calleeCore.kind != nkIdent && calleeCore.kind != nkSymbol:
                var calleeKey1: str = caseInferExprTypeKey(b, calleeCore)
                if uirCoreStrStartsWith(calleeKey1, "ref_"):
                    calleeKey1 = str(ptr_add(void*(calleeKey1), 4))
                elif uirCoreStrStartsWith(calleeKey1, "var_ref_"):
                    calleeKey1 = str(ptr_add(void*(calleeKey1), 8))
                elif uirCoreStrStartsWith(calleeKey1, "var_"):
                    calleeKey1 = str(ptr_add(void*(calleeKey1), 4))
                if uirCoreStrStartsWith(calleeKey1, "ptr_"):
                    calleeKey1 = str(ptr_add(void*(calleeKey1), 4))
                if uirCoreStrStartsWith(calleeKey1, "fn") || uirCoreStrStartsWith(calleeKey1, "fn_"):
                    let fnPtrRes: Result[UirCoreExpr] = lowerExprValue(b, calleeCore, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](fnPtrRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](fnPtrRes))
                    fnPtrExpr = Value[UirCoreExpr](fnPtrRes)

        if fnPtrExpr != nil:
            var indArgs: UirCoreExpr[]
            add(indArgs, fnPtrExpr)
            add(indArgs, lead)
            for xi0 in 0..<argNodes.len:
                let argNode3: Node = argNodes[xi0]
                let argRes0: Result[UirCoreExpr] = lowerExprValue(b, argNode3, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](argRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes0))
                add(indArgs, Value[UirCoreExpr](argRes0))
            let indName0: str = "__cheng_call_indirect_" + intToStr(indArgs.len - 1)
            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(indName0, indArgs)))
            return Ok[UirCoreExpr](lead)

    var calleeFunc: UirCoreFunc = nil
    var callInternal: str = callName
    let mod2: UirCoreModule = b.module
    if mod2 != nil:
        let hint: str = uirCoreInferCallRetKeyHint(callNode)
        let cand: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, hint)
        if cand != nil:
            calleeFunc = cand
            callInternal = cand.name
        elif moduleHasFuncByBase(mod2, callName):
            let calleeRes: Result[UirCoreFunc] = uirCoreResolveCalleeFunc(b, callNode, callName, argNodes)
            if !IsOk[UirCoreFunc](calleeRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreFunc](calleeRes))
            calleeFunc = Value[UirCoreFunc](calleeRes)
            callInternal = calleeFunc.name

    var args: UirCoreExpr[]
    add(args, lead)
    var paramStart: int32 = 0
    if calleeFunc != nil && calleeFunc.params.len > 0:
        let pFirst: UirCoreParam = calleeFunc.params[0]
        if (pFirst.name == "__ret"):
            paramStart = 1
    for vi3 in 0..<argNodes.len:
        let argNode3: Node = argNodes[vi3]
        var wantVarAddr: bool = false
        let pi3: int32 = paramStart + vi3
        if calleeFunc != nil && pi3 >= 0 && pi3 < calleeFunc.params.len:
            let p0: UirCoreParam = calleeFunc.params[pi3]
            if uirCoreStrStartsWith(p0.typeKey, "var_"):
                let baseKey: str = str(ptr_add(void*(p0.typeKey), 4))
                if baseKey == nil || len(baseKey) == 0 || mod2 == nil:
                    wantVarAddr = true
                elif uirCoreHasObjType(mod2, baseKey):
                    # Ref-like types have an object layout but are represented as pointer aliases.
                    # `var RefType` expects a pointer-to-pointer (i.e. take the slot address).
                    let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(mod2, baseKey)
                    wantVarAddr = aliasTy0.kind != mtVoid
                elif uirCoreStrStartsWith(baseKey, "seq_") && uirCoreHasObjType(mod2, "seq"):
                    wantVarAddr = false
                else:
                    wantVarAddr = true
            elif (p0.typeKey == "var"):
                wantVarAddr = true
        if wantVarAddr:
            let addrRes: Result[UirCoreExpr] = lowerVarArgAddr(b, argNode3)
            if !IsOk[UirCoreExpr](addrRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](addrRes))
            add(args, Value[UirCoreExpr](addrRes))
        else:
            let argRes2: Result[UirCoreExpr] = lowerExprValue(b, argNode3, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](argRes2):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes2))
            add(args, Value[UirCoreExpr](argRes2))
    let valueLikeCall0: bool = (callInternal == "Value") || (callName == "Value") ||
        (calleeFunc != nil && calleeFunc.linkName != nil && (calleeFunc.linkName == "Value"))
    if valueLikeCall0 && args.len >= 2 && b.module != nil:
        var srcPtr1: UirCoreExpr = args[1]
        if argNodes.len > 0 && argNodes[0] != nil:
            var srcKey1: str = uirCoreInferNodeTypeKeyForOverload(b, argNodes[0])
            if uirCoreStrStartsWith(srcKey1, "ref_"):
                srcKey1 = str(ptr_add(void*(srcKey1), 4))
            elif uirCoreStrStartsWith(srcKey1, "var_ref_"):
                srcKey1 = str(ptr_add(void*(srcKey1), 8))
            elif uirCoreStrStartsWith(srcKey1, "var_"):
                srcKey1 = str(ptr_add(void*(srcKey1), 4))
            if uirCoreStrStartsWith(srcKey1, "ptr_"):
                srcKey1 = str(ptr_add(void*(srcKey1), 4))
            var valueOff1: int32 = -1
            let srcObj1: str = uirCoreObjTypeFromTypeKey(b.module, srcKey1)
            if srcObj1 != nil && len(srcObj1) > 0 && uirCoreHasObjType(b.module, srcObj1):
                let srcOt1: UirCoreObjType = uirCoreGetObjType(b.module, srcObj1)
                for sfi1 in 0..<srcOt1.fields.len:
                    let sf1: UirCoreObjField = srcOt1.fields[sfi1]
                    if (sf1.name == "value") || uirCoreStrStartsWith(sf1.name, "value."):
                        if valueOff1 < 0 || sf1.offset < valueOff1:
                            valueOff1 = sf1.offset
            if valueOff1 < 0 && uirCoreStrStartsWith(srcKey1, "Result_"):
                valueOff1 = 0
            if valueOff1 > 0:
                srcPtr1 = uirCoreBin(mbAdd, srcPtr1, uirCoreConstI64(int64(valueOff1)))
        var dstObj1: str = ""
        if callNode.typeCacheValid && callNode.typeCache != nil:
            dstObj1 = typeNodeObjTypeName(b.module, callNode.typeCache)
        if (dstObj1 == nil || len(dstObj1) == 0) && b != nil && b.func != nil &&
           lead != nil && lead.kind == meLocal:
            let leadSlot1: int32 = lead.localIndex
            if leadSlot1 >= 0 && funcFindObjLocal(b.func, leadSlot1) >= 0:
                dstObj1 = funcObjTypeName(b.func, leadSlot1)
        if dstObj1 != nil && len(dstObj1) > 0:
            let copyRes1: Result[bool] = emitObjCopyPtrs(b, lead, dstObj1, srcPtr1)
            if !IsOk[bool](copyRes1):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes1))
            return Ok[UirCoreExpr](lead)
        add(b.currentStmts, uirCoreStmtStore(lead, uirCoreLoad(srcPtr1, uirCoreTypeI64()), uirCoreTypeI64()))
        return Ok[UirCoreExpr](lead)
    if callInternal == "Value" && getEnv "BACKEND_DEBUG_VALUE_CALLSITE" == "1":
        var fnDbg2: str = ""
        if b != nil && b.func != nil:
            let fDbg2: UirCoreFunc = b.func
            fnDbg2 = fDbg2.name
        echo("[backend] debugValueCallsite: fn=" + fnDbg2 +
             " name='" + name + "' callName='" + callName + "' argc=" + intToStr(argNodes.len))
    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(callInternal, args)))
    return Ok[UirCoreExpr](lead)

fn lowerInExpr(b: BlockBuilder, lhsNode0: Node, rhsNode0: Node, negate: bool): Result[UirCoreExpr] =
    if b == nil:
        return Err[UirCoreExpr]("uirCore_builder: in missing builder")
    var lhsNode: Node = lhsNode0
    while lhsNode != nil && lhsNode.kind == nkPar && kidCount(lhsNode) > 0:
        lhsNode = kid(lhsNode, 0)
    var rhsNode: Node = rhsNode0
    while rhsNode != nil && rhsNode.kind == nkPar && kidCount(rhsNode) > 0:
        rhsNode = kid(rhsNode, 0)
    if lhsNode == nil || rhsNode == nil:
        return Err[UirCoreExpr]("uirCore_builder: in expects lhs/rhs")

    # Evaluate LHS once (as i64) and reuse it in all branches.
    let lhsRes0: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, uirCoreTypeI64())
    if ! IsOk[UirCoreExpr](lhsRes0):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsRes0))
    let lhsTmpName: str = blockBuilderNextTemp(b, "__in_lhs")
    let lhsTmpSlot: int32 = localAdd(b.env, lhsTmpName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, lhsTmpSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(lhsTmpName, lhsTmpSlot, Value[UirCoreExpr](lhsRes0)))
    let lhsTmp: UirCoreExpr = uirCoreLocal(lhsTmpSlot)

    # Range membership: `x in a..b` / `a..<b`
    if rhsNode.kind == nkInfix && kidCount(rhsNode) >= 3:
        let opNode: Node = kid(rhsNode, 0)
        let op: str = backendOpName(opNode)
        if op == ".." || op == "..<":
            let startRes: Result[UirCoreExpr] = lowerExprValue(b, kid(rhsNode, 1), uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](startRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](startRes))
            let endRes: Result[UirCoreExpr] = lowerExprValue(b, kid(rhsNode, 2), uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](endRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](endRes))
            let geExpr: UirCoreExpr = uirCoreCmp(mcGe, lhsTmp, Value[UirCoreExpr](startRes))
            var leExpr: UirCoreExpr
            if op == "..":
                leExpr = uirCoreCmp(mcLe, lhsTmp, Value[UirCoreExpr](endRes))
            else:
                leExpr = uirCoreCmp(mcLt, lhsTmp, Value[UirCoreExpr](endRes))
            let inExpr: UirCoreExpr = uirCoreBin(mbAnd, geExpr, leExpr)
            if negate:
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, inExpr, uirCoreConstI64(0)))
            return Ok[UirCoreExpr](inExpr)

    # Literal membership: tuple/bracket/seq literals lowered as a chain of `==` checks.
    if rhsNode.kind == nkTupleLit || rhsNode.kind == nkBracket || rhsNode.kind == nkSeqLit:
        if kidCount(rhsNode) == 0:
            if negate:
                return Ok[UirCoreExpr](uirCoreConstI64(1))
            return Ok[UirCoreExpr](uirCoreConstI64(0))
        var out: UirCoreExpr = nil
        for i in 0..<kidCount(rhsNode):
            var elemNode: Node = kid(rhsNode, i)
            if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
                elemNode = kid(elemNode, 1)
            let elemRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](elemRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](elemRes))
            let eqExpr: UirCoreExpr = uirCoreCmp(mcEq, lhsTmp, Value[UirCoreExpr](elemRes))
            if out == nil:
                out = eqExpr
            else:
                out = uirCoreBin(mbOr, out, eqExpr)
        if out == nil:
            out = uirCoreConstI64(0)
        if negate:
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, out, uirCoreConstI64(0)))
        return Ok[UirCoreExpr](out)

    var rhsKey: str = ""
    if rhsNode.typeCacheValid && rhsNode.typeCache != nil:
        rhsKey = typeKey rhsNode.typeCache
    if len(rhsKey) == 0 && (rhsNode.kind == nkIdent || rhsNode.kind == nkSymbol):
        let nm: str = plainName(rhsNode)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
            rhsKey = funcObjTypeKey(b.func, slot0)
        elif slot0 >= 0:
            rhsKey = localTypeKey(b.env, slot0)
    if len(rhsKey) == 0 && rhsNode.kind == nkCall && b.module != nil && kidCount(rhsNode) > 0:
        # Fallback: infer object-return type key from the callee signature.
        let calleeNode: Node = kid(rhsNode, 0)
        var name: str = ""
        var typeArgs: Node[]
        if calleeNode != nil && calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
            let base: Node = kid(calleeNode, 0)
            name = backendStripSpaces(plainName(base))
            for ti in 1..<kidCount(calleeNode):
                let t: Node = kid(calleeNode, ti)
                if t != nil && t.kind != nkEmpty:
                    add(typeArgs, t)
        else:
            name = backendStripSpaces(plainName(calleeNode))
        var callName: str = name
        if typeArgs.len > 0:
            callName = mangleInstance(name, typeArgs)
        var argNodes: Node[]
        for ai in 1..<kidCount(rhsNode):
            var argNode: Node = kid(rhsNode, ai)
            if argNode != nil && argNode.kind == nkCallArg && kidCount(argNode) > 1:
                argNode = kid(argNode, 1)
            add(argNodes, argNode)
        let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, "")
        if callee0 != nil:
            if callee0.params.len > 0:
                let p0: UirCoreParam = callee0.params[0]
                if (p0.name == "__ret"):
                    rhsKey = funcObjTypeKey(callee0, p0.slot)
            if len(rhsKey) == 0 && callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                rhsKey = callee0.retTypeKey

    # set[T] is represented as a uint64 bitset.
    if rhsNode.kind == nkCurly || uirCoreStrStartsWith(rhsKey, "set_"):
        let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](rhsRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes))
        let bits: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](rhsRes))
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), lhsTmp)
        let mask: UirCoreExpr = uirCoreBin(mbShl, uirCoreConstI64(1), idx64)
        let inExpr: UirCoreExpr = uirCoreCmp(mcNe, uirCoreBin(mbAnd, bits, mask), uirCoreConstI64(0))
        if negate:
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, inExpr, uirCoreConstI64(0)))
        return Ok[UirCoreExpr](inExpr)

    # seq[T] membership: scan seq buffer.
    if uirCoreStrStartsWith(rhsKey, "seq_"):
        let elemKey: str = str(ptr_add(void*(rhsKey), 4))
        if elemKey == nil || len(elemKey) == 0:
            return Err[UirCoreExpr]("uirCore_builder: in seq missing element type")
        let elemTypeNode: Node = newIdent(elemKey, rhsNode.pos)
        let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)
        let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
        if ! IsOk[int32](sizeRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](sizeRes))
        let elemSize: int32 = Value[int32](sizeRes)

        let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](rhsRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes))
        let seqTmpName: str = blockBuilderNextTemp(b, "__in_seq")
        let seqTmpSlot: int32 = localAdd(b.env, seqTmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, seqTmpSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(seqTmpName, seqTmpSlot, Value[UirCoreExpr](rhsRes)))
        let seqPtr: UirCoreExpr = uirCoreLocal(seqTmpSlot)

        let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
        var lenOff: int32 = -1
        var bufOff: int32 = -1
        for fi in 0..<seqOt.fields.len:
            let f: UirCoreObjField = seqOt.fields[fi]
            if (f.name == "len"):
                lenOff = f.offset
            elif (f.name == "buffer"):
                bufOff = f.offset
        if lenOff < 0 || bufOff < 0:
            return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch")

        let lenAddr: UirCoreExpr = (lenOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(lenOff)))
        let bufAddr: UirCoreExpr = (bufOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(bufOff)))

        let lenName: str = blockBuilderNextTemp(b, "__in_len")
        let lenSlot: int32 = localAdd(b.env, lenName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, lenSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtLet(lenName, lenSlot, uirCoreLoad(lenAddr, uirCoreTypeI32())))

        let bufName: str = blockBuilderNextTemp(b, "__in_buf")
        let bufSlot: int32 = localAdd(b.env, bufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, bufSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(bufName, bufSlot, uirCoreLoad(bufAddr, uirCoreTypeI64())))

        let idxName: str = blockBuilderNextTemp(b, "__in_i")
        let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

        let resName: str = blockBuilderNextTemp(b, "__in_res")
        let resSlot: int32 = localAdd(b.env, resName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, resSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(resName, resSlot, uirCoreConstI64(0)))

        let condLabel: str = blockBuilderNextLabel(b, "in_cond")
        let bodyLabel: str = blockBuilderNextLabel(b, "in_body")
        let incLabel: str = blockBuilderNextLabel(b, "in_inc")
        let foundLabel: str = blockBuilderNextLabel(b, "in_found")
        let endLabel: str = blockBuilderNextLabel(b, "in_end")
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, condLabel)
        let condExpr: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(lenSlot))
        blockBuilderFinish(b, uirCoreTermCbr(condExpr, bodyLabel, endLabel))

        blockBuilderStart(b, bodyLabel)
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(idxSlot))
        let step: UirCoreExpr = uirCoreConstI64(int64(elemSize))
        let off: UirCoreExpr = (elemSize == 1) ? idx64 : uirCoreBin(mbMul, idx64, step)
        let addr: UirCoreExpr = (elemSize == 0) ? uirCoreLocal(bufSlot) : uirCoreBin(mbAdd, uirCoreLocal(bufSlot), off)
        let elemVal: UirCoreExpr = uirCoreLoad(addr, elemTy)
        let lhsCast: UirCoreExpr = uirCoreCast(elemTy, lhsTmp)
        let eqExpr: UirCoreExpr = uirCoreCmp(mcEq, elemVal, lhsCast)
        blockBuilderFinish(b, uirCoreTermCbr(eqExpr, foundLabel, incLabel))

        blockBuilderStart(b, foundLabel)
        add(b.currentStmts, uirCoreStmtAssign(resName, resSlot, uirCoreConstI64(1)))
        blockBuilderFinish(b, uirCoreTermBr(endLabel))

        blockBuilderStart(b, incLabel)
        let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
        add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr))
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, endLabel)
        if negate:
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, uirCoreLocal(resSlot), uirCoreConstI64(0)))
        return Ok[UirCoreExpr](uirCoreLocal(resSlot))

    # str membership: char/substring search.
    if (rhsKey == "str") || (rhsKey == "string") || (rhsKey == "cstring") || rhsNode.kind == nkStrLit:
        let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](rhsRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes))
        let hayName: str = blockBuilderNextTemp(b, "__in_hay")
        let haySlot: int32 = localAdd(b.env, hayName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, haySlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(hayName, haySlot, Value[UirCoreExpr](rhsRes)))
        let hayPtr: UirCoreExpr = uirCoreLocal(haySlot)

        var lhsIsStr: bool = false
        if lhsNode.kind == nkStrLit:
            lhsIsStr = true
        elif lhsNode.typeCacheValid && lhsNode.typeCache != nil:
            let lk: str = typeKey lhsNode.typeCache
            if (lk == "str") || (lk == "string") || (lk == "cstring"):
                lhsIsStr = true

        if ! lhsIsStr:
            # char in str
            let lenName: str = blockBuilderNextTemp(b, "__in_strlen")
            let lenSlot: int32 = localAdd(b.env, lenName, uirCoreTypeI32())
            uirCoreSetLocalType(b.func, lenSlot, uirCoreTypeI32())
            var strlenArgs: UirCoreExpr[]
            add(strlenArgs, hayPtr)
            add(b.currentStmts, uirCoreStmtLet(lenName, lenSlot, uirCoreCall("cheng_strlen", strlenArgs)))

            let idxName: str = blockBuilderNextTemp(b, "__in_i")
            let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
            uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
            add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

            let resName: str = blockBuilderNextTemp(b, "__in_res")
            let resSlot: int32 = localAdd(b.env, resName, uirCoreTypeI32())
            uirCoreSetLocalType(b.func, resSlot, uirCoreTypeI32())
            add(b.currentStmts, uirCoreStmtVar(resName, resSlot, uirCoreConstI64(0)))

            let condLabel: str = blockBuilderNextLabel(b, "in_cond")
            let bodyLabel: str = blockBuilderNextLabel(b, "in_body")
            let incLabel: str = blockBuilderNextLabel(b, "in_inc")
            let foundLabel: str = blockBuilderNextLabel(b, "in_found")
            let endLabel: str = blockBuilderNextLabel(b, "in_end")
            blockBuilderFinish(b, uirCoreTermBr(condLabel))

            blockBuilderStart(b, condLabel)
            let condExpr: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(lenSlot))
            blockBuilderFinish(b, uirCoreTermCbr(condExpr, bodyLabel, endLabel))

            blockBuilderStart(b, bodyLabel)
            let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(idxSlot))
            let addr: UirCoreExpr = uirCoreBin(mbAdd, hayPtr, idx64)
            let raw: UirCoreExpr = uirCoreLoad(addr, uirCoreTypeI32())
            let chVal: UirCoreExpr = uirCoreBin(mbAnd, raw, uirCoreConstI64(255))
            let needle: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), lhsTmp)
            let eqExpr: UirCoreExpr = uirCoreCmp(mcEq, chVal, needle)
            blockBuilderFinish(b, uirCoreTermCbr(eqExpr, foundLabel, incLabel))

            blockBuilderStart(b, foundLabel)
            add(b.currentStmts, uirCoreStmtAssign(resName, resSlot, uirCoreConstI64(1)))
            blockBuilderFinish(b, uirCoreTermBr(endLabel))

            blockBuilderStart(b, incLabel)
            let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
            add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr))
            blockBuilderFinish(b, uirCoreTermBr(condLabel))

            blockBuilderStart(b, endLabel)
            if negate:
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, uirCoreLocal(resSlot), uirCoreConstI64(0)))
            return Ok[UirCoreExpr](uirCoreLocal(resSlot))

        # str in str
        let needleName: str = blockBuilderNextTemp(b, "__in_need")
        let needleSlot: int32 = localAdd(b.env, needleName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, needleSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(needleName, needleSlot, lhsTmp))
        let needlePtr: UirCoreExpr = uirCoreLocal(needleSlot)

        let nName: str = blockBuilderNextTemp(b, "__in_n")
        let nSlot: int32 = localAdd(b.env, nName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, nSlot, uirCoreTypeI32())
        var nArgs: UirCoreExpr[]
        add(nArgs, hayPtr)
        add(b.currentStmts, uirCoreStmtLet(nName, nSlot, uirCoreCall("cheng_strlen", nArgs)))

        let mName: str = blockBuilderNextTemp(b, "__in_m")
        let mSlot: int32 = localAdd(b.env, mName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, mSlot, uirCoreTypeI32())
        var mArgs: UirCoreExpr[]
        add(mArgs, needlePtr)
        add(b.currentStmts, uirCoreStmtLet(mName, mSlot, uirCoreCall("cheng_strlen", mArgs)))

        let resName2: str = blockBuilderNextTemp(b, "__in_res")
        let resSlot2: int32 = localAdd(b.env, resName2, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, resSlot2, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(resName2, resSlot2, uirCoreConstI64(0)))

        let checkEmpty: str = blockBuilderNextLabel(b, "in_check_empty")
        let checkLong: str = blockBuilderNextLabel(b, "in_check_long")
        let initLabel: str = blockBuilderNextLabel(b, "in_init")
        let outerCond: str = blockBuilderNextLabel(b, "in_outer_cond")
        let outerBody: str = blockBuilderNextLabel(b, "in_outer_body")
        let innerCond: str = blockBuilderNextLabel(b, "in_inner_cond")
        let innerBody: str = blockBuilderNextLabel(b, "in_inner_body")
        let matchLabel: str = blockBuilderNextLabel(b, "in_match")
        let endLabel2: str = blockBuilderNextLabel(b, "in_end")
        blockBuilderFinish(b, uirCoreTermBr(checkEmpty))

        blockBuilderStart(b, checkEmpty)
        let emptyCond: UirCoreExpr = uirCoreCmp(mcEq, uirCoreLocal(mSlot), uirCoreConstI64(0))
        blockBuilderFinish(b, uirCoreTermCbr(emptyCond, matchLabel, checkLong))

        blockBuilderStart(b, checkLong)
        let longCond: UirCoreExpr = uirCoreCmp(mcGt, uirCoreLocal(mSlot), uirCoreLocal(nSlot))
        blockBuilderFinish(b, uirCoreTermCbr(longCond, endLabel2, initLabel))

        blockBuilderStart(b, initLabel)
        let iName: str = blockBuilderNextTemp(b, "__in_i")
        let iSlot: int32 = localAdd(b.env, iName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, iSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(iName, iSlot, uirCoreConstI64(0)))

        let jName: str = blockBuilderNextTemp(b, "__in_j")
        let jSlot: int32 = localAdd(b.env, jName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, jSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(jName, jSlot, uirCoreConstI64(0)))

        let limName: str = blockBuilderNextTemp(b, "__in_lim")
        let limSlot: int32 = localAdd(b.env, limName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, limSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtLet(limName, limSlot, uirCoreBin(mbSub, uirCoreLocal(nSlot), uirCoreLocal(mSlot))))

        blockBuilderFinish(b, uirCoreTermBr(outerCond))

        blockBuilderStart(b, outerCond)
        let outerOk: UirCoreExpr = uirCoreCmp(mcLe, uirCoreLocal(iSlot), uirCoreLocal(limSlot))
        blockBuilderFinish(b, uirCoreTermCbr(outerOk, outerBody, endLabel2))

        blockBuilderStart(b, outerBody)
        add(b.currentStmts, uirCoreStmtAssign(jName, jSlot, uirCoreConstI64(0)))
        blockBuilderFinish(b, uirCoreTermBr(innerCond))

        blockBuilderStart(b, innerCond)
        let innerOk: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(jSlot), uirCoreLocal(mSlot))
        blockBuilderFinish(b, uirCoreTermCbr(innerOk, innerBody, matchLabel))

        blockBuilderStart(b, innerBody)
        let ij: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(iSlot), uirCoreLocal(jSlot))
        let ij64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), ij)
        let hAddr: UirCoreExpr = uirCoreBin(mbAdd, hayPtr, ij64)
        let hRaw: UirCoreExpr = uirCoreLoad(hAddr, uirCoreTypeI32())
        let hCh: UirCoreExpr = uirCoreBin(mbAnd, hRaw, uirCoreConstI64(255))
        let j64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(jSlot))
        let nAddr: UirCoreExpr = uirCoreBin(mbAdd, needlePtr, j64)
        let nRaw: UirCoreExpr = uirCoreLoad(nAddr, uirCoreTypeI32())
        let nCh: UirCoreExpr = uirCoreBin(mbAnd, nRaw, uirCoreConstI64(255))
        let eqExpr2: UirCoreExpr = uirCoreCmp(mcEq, hCh, nCh)
        let stepJ: str = blockBuilderNextLabel(b, "in_step_j")
        let stepI: str = blockBuilderNextLabel(b, "in_step_i")
        blockBuilderFinish(b, uirCoreTermCbr(eqExpr2, stepJ, stepI))

        blockBuilderStart(b, stepJ)
        add(b.currentStmts, uirCoreStmtAssign(jName, jSlot, uirCoreBin(mbAdd, uirCoreLocal(jSlot), uirCoreConstI64(1))))
        blockBuilderFinish(b, uirCoreTermBr(innerCond))

        blockBuilderStart(b, stepI)
        add(b.currentStmts, uirCoreStmtAssign(iName, iSlot, uirCoreBin(mbAdd, uirCoreLocal(iSlot), uirCoreConstI64(1))))
        blockBuilderFinish(b, uirCoreTermBr(outerCond))

        blockBuilderStart(b, matchLabel)
        add(b.currentStmts, uirCoreStmtAssign(resName2, resSlot2, uirCoreConstI64(1)))
        blockBuilderFinish(b, uirCoreTermBr(endLabel2))

        blockBuilderStart(b, endLabel2)
        if negate:
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, uirCoreLocal(resSlot2), uirCoreConstI64(0)))
        return Ok[UirCoreExpr](uirCoreLocal(resSlot2))

    # Table membership: `key in Table[V]` => `TableHas[V](t, key)`
    if uirCoreStrStartsWith(rhsKey, "Table_"):
        let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](rhsRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes))
        let tblName: str = blockBuilderNextTemp(b, "__in_tbl")
        let tblSlot: int32 = localAdd(b.env, tblName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, tblSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(tblName, tblSlot, Value[UirCoreExpr](rhsRes)))
        let valKey: str = str(ptr_add(void*(rhsKey), 6))
        let callName: str = "TableHas_" + valKey
        var args: UirCoreExpr[]
        add(args, uirCoreLocal(tblSlot))
        add(args, lhsTmp)
        let hasExpr: UirCoreExpr = uirCoreCall(callName, args)
        if negate:
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, hasExpr, uirCoreConstI64(0)))
        return Ok[UirCoreExpr](hasExpr)

    let line: str = intToStr(rhsNode.pos.line)
    let col: str = intToStr(rhsNode.pos.col)
    return Err[UirCoreExpr]("uirCore_builder: unsupported 'in' rhs (key=" + rhsKey + " @" + line + ":" + col + ")")

fn isFloat64Key(key0: str): bool =
    if key0 == nil:
        return false
    let key: str = backendStripSpaces(key0)
    return (key == "float64") || (key == "float")

fn isFloat32Key(key0: str): bool =
    if key0 == nil:
        return false
    let key: str = backendStripSpaces(key0)
    return key == "float32"

fn isIntegralUirType(ty: UirCoreType): bool =
    return ty.kind == mtI8 || ty.kind == mtI16 || ty.kind == mtI32 || ty.kind == mtI64

fn isStringKey(key0: str): bool =
    if key0 == nil:
        return false
    let key: str = backendStripSpaces(key0)
    return (key == "str") || (key == "string") || (key == "cstring")

fn exprTypeKeyShallow(b: BlockBuilder, n0: Node): str =
    if b == nil:
        return ""
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return ""
    if n.kind != nkDotExpr && n.typeCacheValid && n.typeCache != nil:
        return typeKey n.typeCache
    if n.kind == nkDotExpr && kidCount(n) > 1:
        let base: Node = kid(n, 0)
        let field: Node = kid(n, 1)
        if base != nil && field != nil && (field.kind == nkIdent || field.kind == nkSymbol) && b.module != nil:
            var parentKey: str = backendStripSpaces(exprTypeKeyShallow(b, base))
            if uirCoreStrStartsWith(parentKey, "ref_"):
                parentKey = str(ptr_add(void*(parentKey), 4))
            elif uirCoreStrStartsWith(parentKey, "var_ref_"):
                parentKey = str(ptr_add(void*(parentKey), 8))
            elif uirCoreStrStartsWith(parentKey, "var_"):
                parentKey = str(ptr_add(void*(parentKey), 4))
            if uirCoreStrStartsWith(parentKey, "ptr_"):
                parentKey = str(ptr_add(void*(parentKey), 4))
            parentKey = uirCoreObjAliasCanon(parentKey)
            let parentObj: str = uirCorePtrBaseObjTypeName(b.module, parentKey)
            if parentObj != nil && len(parentObj) > 0:
                let fieldName: str = backendStripSpaces(plainName(field))
                let fieldKey: str = backendStripSpaces(uirCoreObjFieldTypeKeyGet(parentObj, fieldName))
                if fieldKey != nil && len(fieldKey) > 0:
                    return fieldKey
    if n.kind == nkFloatLit:
        return "float64"
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = plainName(n)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0:
            return localTypeKey(b.env, slot0)
    if n.kind == nkCall && kidCount(n) > 0:
        let callee0: Node = kid(n, 0)
        # Type conversion call: `T*(x)` / `ref T(x)` / `var T(x)` can show up without a typeCache.
        if callee0 != nil && (callee0.kind == nkPtrTy || callee0.kind == nkRefTy || callee0.kind == nkVarTy):
            return typeKey callee0
    return ""

fn isByteTypeKey(key: str): bool =
    if key == nil || len(key) == 0:
        return false
    return (key == "bool") || (key == "char") ||
           (key == "int8") || (key == "uint8") ||
           (key == "i8") || (key == "u8")

fn isBytePtrTypeKey(key: str): bool =
    if key == nil || len(key) == 0:
        return false
    if ! uirCoreStrStartsWith(key, "ptr_"):
        return false
    let elemKey: str = str(ptr_add(void*(key), 4))
    return isByteTypeKey(elemKey)

fn byteUirTypeFromKey(key0: str): UirCoreType =
    if key0 == nil || len(key0) == 0:
        return uirCoreTypeU8()
    let key: str = backendStripSpaces(key0)
    if (key == "int8") || (key == "i8"):
        return uirCoreTypeI8()
    return uirCoreTypeU8()

fn byteUirTypeFromPtrTypeKey(ptrKey0: str): UirCoreType =
    if ptrKey0 == nil || len(ptrKey0) == 0:
        return uirCoreTypeU8()
    let ptrKey: str = backendStripSpaces(ptrKey0)
    if !uirCoreStrStartsWith(ptrKey, "ptr_"):
        return uirCoreTypeU8()
    let elemKey: str = str(ptr_add(void*(ptrKey), 4))
    return byteUirTypeFromKey(elemKey)

fn byteUirTypeFromElemOrPtrKey(elemKey0: str, ptrKey0: str): UirCoreType =
    if elemKey0 != nil && len(elemKey0) > 0:
        var elemKey: str = backendStripSpaces(elemKey0)
        if uirCoreStrStartsWith(elemKey, "ptr_"):
            elemKey = backendStripSpaces(str(ptr_add(void*(elemKey), 4)))
        return byteUirTypeFromKey(elemKey)
    return byteUirTypeFromPtrTypeKey(ptrKey0)

fn lowerByteLoadNilChecked(b: BlockBuilder, addrExpr: UirCoreExpr, byteTy: UirCoreType, wantType: UirCoreType): UirCoreExpr =
    let addrName: str = blockBuilderNextTemp(b, "__byte_p")
    let addrSlot: int32 = localAdd(b.env, addrName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, addrSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(addrName, addrSlot, addrExpr))

    let resName: str = blockBuilderNextTemp(b, "__byte_res")
    let resSlot: int32 = localAdd(b.env, resName, wantType)
    uirCoreSetLocalType(b.func, resSlot, wantType)

    let thenLabel: str = blockBuilderNextLabel(b, "byte_then")
    let elseLabel: str = blockBuilderNextLabel(b, "byte_else")
    let joinLabel: str = blockBuilderNextLabel(b, "byte_join")
    let okCond: UirCoreExpr = uirCoreCmp(mcNe, uirCoreLocal(addrSlot), uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(okCond, thenLabel, elseLabel))

    blockBuilderStart(b, thenLabel)
    var loaded: UirCoreExpr = uirCoreLoad(uirCoreLocal(addrSlot), byteTy)
    if wantType.kind != byteTy.kind || wantType.isUnsigned != byteTy.isUnsigned:
        loaded = uirCoreCast(wantType, loaded)
    add(b.currentStmts, uirCoreStmtAssign(resName, resSlot, loaded))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, elseLabel)
    add(b.currentStmts, uirCoreStmtAssign(resName, resSlot, uirCoreConstI64(0)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, joinLabel)
    return uirCoreLocal(resSlot)

fn lowerByteStoreNilChecked(b: BlockBuilder, addrExpr: UirCoreExpr, valExpr: UirCoreExpr, valType: UirCoreType, storeTy: UirCoreType) =
    let addrName: str = blockBuilderNextTemp(b, "__byte_p")
    let addrSlot: int32 = localAdd(b.env, addrName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, addrSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(addrName, addrSlot, addrExpr))

    let valName: str = blockBuilderNextTemp(b, "__byte_v")
    let valSlot: int32 = localAdd(b.env, valName, valType)
    uirCoreSetLocalType(b.func, valSlot, valType)
    add(b.currentStmts, uirCoreStmtLet(valName, valSlot, valExpr))

    let thenLabel: str = blockBuilderNextLabel(b, "byte_then")
    let elseLabel: str = blockBuilderNextLabel(b, "byte_else")
    let joinLabel: str = blockBuilderNextLabel(b, "byte_join")
    let okCond: UirCoreExpr = uirCoreCmp(mcNe, uirCoreLocal(addrSlot), uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(okCond, thenLabel, elseLabel))

    blockBuilderStart(b, thenLabel)
    add(b.currentStmts, uirCoreStmtStore(uirCoreLocal(addrSlot), uirCoreLocal(valSlot), storeTy))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, elseLabel)
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, joinLabel)

fn uirCorePtrBaseObjTypeName(mod: UirCoreModule, baseKey0: str): str =
    if mod == nil || baseKey0 == nil || len(baseKey0) == 0:
        return ""
    if uirCoreHasObjType(mod, baseKey0):
        return baseKey0
    if (uirCoreStrStartsWith(baseKey0, "seq_") || uirCoreStrStartsWith(baseKey0, "seq_fixed_")) && uirCoreHasObjType(mod, "seq"):
        return "seq"
    if uirCoreStrStartsWith(baseKey0, "Table_") && uirCoreHasObjType(mod, "Table"):
        return "Table"
    let __for_start_i = len(baseKey0) - 1
    for __for_rev_i in 0..(__for_start_i - (0)):
        let i = __for_start_i - __for_rev_i
        if baseKey0[i] == '.':
            let sub: str = str(ptr_add(void*(baseKey0), i + 1))
            if sub != nil && len(sub) > 0 && uirCoreHasObjType(mod, sub):
                return sub
            break
    return ""

fn lowerToF64Bits(b: BlockBuilder, n0: Node): Result[UirCoreExpr] =
    if b == nil:
        return Err[UirCoreExpr]("uirCore_builder: float op missing builder")
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: float op expects operand")
    if n.kind == nkFloatLit:
        if n.strVal != nil && len(n.strVal) > 0:
            return Ok[UirCoreExpr](uirCoreConstI64(cheng_parse_f64_bits(n.strVal)))
        # Some stages may synthesize float literals without a raw string; default to 0.0 bits.
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    var key: str = exprTypeKeyShallow(b, n)
    if len(key) == 0 && n.kind == nkInfix && kidCount(n) >= 3:
        key = exprTypeKeyShallow(b, kid(n, 1))
        if len(key) == 0:
            key = exprTypeKeyShallow(b, kid(n, 2))
    if isFloat64Key(key):
        let valRes2: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeF64())
        if ! IsOk[UirCoreExpr](valRes2):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes2))
        return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](valRes2)))
    if n.kind == nkPrefix && kidCount(n) > 1:
        let opNode: Node = kid(n, 0)
        let op: str = backendOpName(opNode)
        if op == "-" || op == "+":
            let rhs: Node = kid(n, 1)
            var rhsKey: str = exprTypeKeyShallow(b, rhs)
            if len(rhsKey) == 0 && rhs != nil && rhs.kind == nkInfix && kidCount(rhs) >= 3:
                rhsKey = exprTypeKeyShallow(b, kid(rhs, 1))
                if len(rhsKey) == 0:
                    rhsKey = exprTypeKeyShallow(b, kid(rhs, 2))
            if isFloat64Key(rhsKey):
                let valRes3: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeF64())
                if ! IsOk[UirCoreExpr](valRes3):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes3))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](valRes3)))
    if n.kind == nkIntLit:
        return Ok[UirCoreExpr](uirCoreConstI64(cheng_i64_to_f64_bits(n.intVal)))
    let valRes: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeI64())
    if ! IsOk[UirCoreExpr](valRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
    var val: UirCoreExpr = Value[UirCoreExpr](valRes)
    let vty: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, n, uirCoreTypeI32())
    if vty.kind == mtI32 || vty.kind == mtF32:
        val = uirCoreCast(uirCoreTypeI64(), val)
    var args: UirCoreExpr[]
    add(args, val)
    return Ok[UirCoreExpr](uirCoreCall("cheng_i64_to_f64_bits", args))

fn lowerToF32Bits(b: BlockBuilder, n0: Node): Result[UirCoreExpr] =
    if b == nil:
        return Err[UirCoreExpr]("uirCore_builder: float32 op missing builder")
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: float32 op expects operand")
    if n.kind == nkFloatLit:
        var bits64: int64 = 0
        if n.strVal != nil && len(n.strVal) > 0:
            bits64 = cheng_parse_f64_bits(n.strVal)
        var argsLit: UirCoreExpr[]
        add(argsLit, uirCoreConstI64(bits64))
        return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", argsLit))
    if n.kind == nkCall && kidCount(n) > 0:
        let calleeNode: Node = kid(n, 0)
        let calleeName: str = backendStripSpaces(plainName(calleeNode))
        if calleeName == "float32":
            let vRes0: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeF32())
            if !IsOk[UirCoreExpr](vRes0):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](vRes0))
            return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](vRes0)))
        if calleeName == "float64" || calleeName == "float":
            let bits64ResCall: Result[UirCoreExpr] = lowerToF64Bits(b, n)
            if !IsOk[UirCoreExpr](bits64ResCall):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](bits64ResCall))
            var argsCall: UirCoreExpr[]
            add(argsCall, Value[UirCoreExpr](bits64ResCall))
            return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", argsCall))

    var key: str = exprTypeKeyShallow(b, n)
    if len(key) == 0 && n.kind == nkInfix && kidCount(n) >= 3:
        key = exprTypeKeyShallow(b, kid(n, 1))
        if len(key) == 0:
            key = exprTypeKeyShallow(b, kid(n, 2))
    if isFloat32Key(key):
        let vRes: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeF32())
        if !IsOk[UirCoreExpr](vRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](vRes))
        return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](vRes)))
    if isFloat64Key(key):
        let bits64Res0: Result[UirCoreExpr] = lowerToF64Bits(b, n)
        if !IsOk[UirCoreExpr](bits64Res0):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](bits64Res0))
        var args64_0: UirCoreExpr[]
        add(args64_0, Value[UirCoreExpr](bits64Res0))
        return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", args64_0))
    if n.kind == nkIntLit:
        var argsInt: UirCoreExpr[]
        add(argsInt, uirCoreConstI64(cheng_i64_to_f64_bits(n.intVal)))
        return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", argsInt))

    let vty: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, n, uirCoreTypeI32())
    if vty.kind == mtF32:
        let vRes2: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeF32())
        if !IsOk[UirCoreExpr](vRes2):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](vRes2))
        return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](vRes2)))
    if vty.kind == mtF64:
        let bits64Res1: Result[UirCoreExpr] = lowerToF64Bits(b, n)
        if !IsOk[UirCoreExpr](bits64Res1):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](bits64Res1))
        var args64_1: UirCoreExpr[]
        add(args64_1, Value[UirCoreExpr](bits64Res1))
        return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", args64_1))

    let valRes: Result[UirCoreExpr] = lowerExprValue(b, n, uirCoreTypeI64())
    if !IsOk[UirCoreExpr](valRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
    var val: UirCoreExpr = Value[UirCoreExpr](valRes)
    if vty.kind == mtI32:
        val = uirCoreCast(uirCoreTypeI64(), val)
    let intToF64Helper: str = vty.isUnsigned ? "cheng_u64_to_f64_bits" : "cheng_i64_to_f64_bits"
    var upArgs: UirCoreExpr[]
    add(upArgs, val)
    var downArgs: UirCoreExpr[]
    add(downArgs, uirCoreCall(intToF64Helper, upArgs))
    return Ok[UirCoreExpr](uirCoreCall("cheng_f64_bits_to_f32_bits", downArgs))

fn lowerObjConstructorCall(b: BlockBuilder, callNode: Node, objTypeName: str): Result[UirCoreExpr] =
    if b == nil || b.module == nil || b.func == nil:
        return Err[UirCoreExpr]("uirCore_builder: object constructor missing builder/module")
    if callNode == nil || callNode.kind != nkCall:
        return Err[UirCoreExpr]("uirCore_builder: invalid object constructor call")
    if objTypeName == nil || len(objTypeName) == 0 || !uirCoreHasObjType(b.module, objTypeName):
        return Err[UirCoreExpr]("uirCore_builder: unknown object constructor type")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objTypeName)

    let tmpName: str = blockBuilderNextTemp(b, "__obj")
    let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
    localSetTypeKey(b.env, tmpSlot, objTypeName)
    let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objTypeName)
    if ! IsOk[bool](allocRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
    let initRes: Result[bool] = emitObjDefaultInit(b, tmpSlot, objTypeName)
    if ! IsOk[bool](initRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))

    let basePtr: UirCoreExpr = uirCoreLocal(tmpSlot)
    for ai in 1..<kidCount(callNode):
        let arg0: Node = kid(callNode, ai)
        if arg0 == nil || arg0.kind != nkCallArg || kidCount(arg0) < 2:
            return Err[UirCoreExpr]("uirCore_builder: object constructor expects named args")
        let keyNode: Node = kid(arg0, 0)
        let valNode: Node = kid(arg0, 1)
        if keyNode == nil || (keyNode.kind != nkIdent && keyNode.kind != nkSymbol):
            return Err[UirCoreExpr]("uirCore_builder: object constructor field expects identifier")
        let fieldName: str = backendStripSpaces(plainName(keyNode))

        var found: bool = false
        var field: UirCoreObjField
        for fi in 0..<ot.fields.len:
            let f: UirCoreObjField = ot.fields[fi]
            if (f.name == fieldName):
                field = f
                found = true
                break
        if found:
            var addr: UirCoreExpr = basePtr
            if field.offset != 0:
                addr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(field.offset)))
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, valNode, field.ty)
            if ! IsOk[UirCoreExpr](valRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
            add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), field.ty))
            continue

        let prefix: str = fieldName + "."
        var hasPrefix: bool = false
        var minOff: int32 = 2147483647
        for fi2 in 0..<ot.fields.len:
            let f2: UirCoreObjField = ot.fields[fi2]
            if uirCoreStrStartsWith(f2.name, prefix):
                hasPrefix = true
                if f2.offset < minOff:
                    minOff = f2.offset
        if !hasPrefix:
            let line: str = intToStr(keyNode.pos.line)
            let col: str = intToStr(keyNode.pos.col)
            if (getEnv "BACKEND_DEBUG_OBJCTOR" == "1"):
                let calleeDbg: str = backendStripSpaces(plainName(kid(callNode, 0)))
                echo("[backend] debugObjCtorUnknown: objType='" + objTypeName + "' field='" + fieldName +
                     "' callee='" + calleeDbg + "' @" + line + ":" + col)
            return Err[UirCoreExpr]("uirCore_builder: unknown object field '" + fieldName + "' @" + line + ":" + col)

        var dstObjName: str = uirCoreInlineObjFieldTypeGet(objTypeName, fieldName)
        let fieldKey0: str = backendStripSpaces(uirCoreObjFieldTypeKeyGet(objTypeName, fieldName))
        if fieldKey0 != nil && len(fieldKey0) > 0:
            dstObjName = uirCoreObjTypeFromTypeKey(b.module, fieldKey0)
            if len(dstObjName) == 0 && uirCoreHasObjType(b.module, fieldKey0):
                dstObjName = fieldKey0
            if len(dstObjName) == 0:
                let fieldCanon: str = uirCoreObjAliasCanon(fieldKey0)
                if fieldCanon != nil && len(fieldCanon) > 0 && uirCoreHasObjType(b.module, fieldCanon):
                    dstObjName = fieldCanon

        var srcObjName: str = ""
        if valNode != nil && valNode.typeCacheValid && valNode.typeCache != nil:
            srcObjName = typeNodeObjTypeName(b.module, valNode.typeCache)
        if len(srcObjName) == 0 && valNode != nil && (valNode.kind == nkIdent || valNode.kind == nkSymbol):
            let nm: str = plainName(valNode)
            let slot0: int32 = localIndex(b.env, nm)
            if slot0 >= 0:
                srcObjName = funcObjTypeName(b.func, slot0)
        if len(srcObjName) == 0 && valNode != nil && b != nil && b.module != nil:
            let key0: str = caseInferExprTypeKey(b, valNode)
            if key0 != nil && len(key0) > 0:
                srcObjName = uirCoreObjTypeFromTypeKey(b.module, key0)
                if len(srcObjName) == 0:
                    let tn0: Node = newIdent(key0, valNode.pos)
                    srcObjName = typeNodeObjTypeName(b.module, tn0)
        if len(srcObjName) == 0 && valNode != nil && b != nil && b.module != nil:
            let key1: str = uirCoreInferNodeTypeKeyForOverload(b, valNode)
            if key1 != nil && len(key1) > 0:
                srcObjName = uirCoreObjTypeFromTypeKey(b.module, key1)
        if len(srcObjName) == 0 && valNode != nil && valNode.kind == nkCall && kidCount(valNode) > 1 && b != nil && b.module != nil:
            let valKey0: str = uirCoreInferValueCallInnerKey(b, valNode)
            if valKey0 != nil && len(valKey0) > 0:
                srcObjName = uirCoreObjTypeFromTypeKey(b.module, valKey0)
        if len(srcObjName) == 0 && len(dstObjName) > 0:
            srcObjName = dstObjName
        if (getEnv "BACKEND_DEBUG_NESTED_CTOR" == "1") &&
           (((objTypeName == "GossipsubContext") && (fieldName == "params")) ||
            ((objTypeName == "Cid") && (fieldName == "codec"))):
            let kDbg: str = (valNode != nil) ? caseInferExprTypeKey(b, valNode) : ""
            let vkDbg: str = (valNode != nil) ? intToStr(int32(valNode.kind)) : "nil"
            let kDbg2: str = (valNode != nil) ? uirCoreInferNodeTypeKeyForOverload(b, valNode) : ""
            let oDbg2: str = (kDbg2 != nil && len(kDbg2) > 0) ? uirCoreObjTypeFromTypeKey(b.module, kDbg2) : ""
            echo("[backend] debugNestedCtor: ctor=" + objTypeName + " field=" + fieldName +
                 " valKind=nk#" + vkDbg + " key='" + kDbg + "' srcObjName='" + srcObjName + "'")
            echo("[backend] debugNestedCtor: ctor=" + objTypeName + " field=" + fieldName +
                 " inferKey='" + kDbg2 + "' inferObj='" + oDbg2 + "'")
        if len(srcObjName) == 0:
            let fkDbg: str = backendStripSpaces(uirCoreObjFieldTypeKeyGet(objTypeName, fieldName))
            let vkDbg2: str = (valNode != nil) ? intToStr(int32(valNode.kind)) : "nil"
            return Err[UirCoreExpr]("uirCore_builder: object constructor field '" + fieldName + "' expects object value" +
                                " (obj=" + objTypeName + " fieldKey=" + fkDbg +
                                " inlineObj=" + dstObjName + " valKind=nk#" + vkDbg2 + ")")
        let srcRes: Result[UirCoreExpr] = lowerExprValue(b, valNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](srcRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes))
        var dstPtr: UirCoreExpr = basePtr
        if minOff != 0 && minOff != 2147483647:
            dstPtr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(minOff)))
        let copyRes: Result[bool] = emitObjCopyPtrs(b, dstPtr, srcObjName, Value[UirCoreExpr](srcRes))
        if ! IsOk[bool](copyRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes))
    return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))

fn lowerObjConstructorCallPositional(b: BlockBuilder, callNode: Node, objTypeName: str): Result[UirCoreExpr] =
    if b == nil || b.module == nil || b.func == nil:
        return Err[UirCoreExpr]("uirCore_builder: object constructor missing builder/module")
    if callNode == nil || callNode.kind != nkCall:
        return Err[UirCoreExpr]("uirCore_builder: invalid object constructor call")
    if objTypeName == nil || len(objTypeName) == 0 || !uirCoreHasObjType(b.module, objTypeName):
        return Err[UirCoreExpr]("uirCore_builder: unknown object constructor type")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objTypeName)
    let argCount: int32 = kidCount(callNode) - 1
    if (getEnv "BACKEND_DEBUG_OBJCTOR" == "1") && (objTypeName == "Option_PublicKey"):
        var fnNameDbg: str = ""
        if b != nil && b.func != nil:
            let fDbg: UirCoreFunc = b.func
            fnNameDbg = fDbg.name
        echo("[backend] debugObjCtor: obj=" + objTypeName +
             " argc=" + intToStr(argCount) + " fields=" + intToStr(ot.fields.len) +
             " fn=" + fnNameDbg)
    if argCount == 0:
        let tmpName: str = blockBuilderNextTemp(b, "__obj")
        let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
        localSetTypeKey(b.env, tmpSlot, objTypeName)
        let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objTypeName)
        if !IsOk[bool](allocRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
        let initRes: Result[bool] = emitObjDefaultInit(b, tmpSlot, objTypeName)
        if !IsOk[bool](initRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))
        return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))
    if argCount > 0 && argCount <= ot.fields.len:
        let tmpName: str = blockBuilderNextTemp(b, "__obj")
        let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
        localSetTypeKey(b.env, tmpSlot, objTypeName)
        let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objTypeName)
        if !IsOk[bool](allocRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
        let initRes: Result[bool] = emitObjDefaultInit(b, tmpSlot, objTypeName)
        if !IsOk[bool](initRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))
        let dstPtr: UirCoreExpr = uirCoreLocal(tmpSlot)

        for fi0 in 0..<argCount:
            let f0: UirCoreObjField = ot.fields[fi0]
            var valNode0: Node = kid(callNode, 1 + fi0)
            if valNode0 != nil && valNode0.kind == nkCallArg && kidCount(valNode0) > 1:
                valNode0 = kid(valNode0, 1)
            let valRes0: Result[UirCoreExpr] = lowerExprValue(b, valNode0, f0.ty)
            if !IsOk[UirCoreExpr](valRes0):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes0))
            var addr0: UirCoreExpr = dstPtr
            if f0.offset != 0:
                addr0 = uirCoreBin(mbAdd, dstPtr, uirCoreConstI64(int64(f0.offset)))
            add(b.currentStmts, uirCoreStmtStore(addr0, Value[UirCoreExpr](valRes0), f0.ty))
        return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))

    if argCount <= ot.fields.len + 1:
        var dstNode: Node = kid(callNode, 1)
        if dstNode != nil && dstNode.kind == nkCallArg && kidCount(dstNode) > 1:
            dstNode = kid(dstNode, 1)
        let dstRes: Result[UirCoreExpr] = lowerExprValue(b, dstNode, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](dstRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](dstRes))
        let dstPtr: UirCoreExpr = Value[UirCoreExpr](dstRes)
        let initRes: Result[bool] = emitObjDefaultInitPtrs(b, dstPtr, objTypeName)
        if !IsOk[bool](initRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))

        let argFields: int32 = argCount - 1
        for fi in 0..<argFields:
            let f: UirCoreObjField = ot.fields[fi]
            var valNode: Node = kid(callNode, 2 + fi)
            if valNode != nil && valNode.kind == nkCallArg && kidCount(valNode) > 1:
                valNode = kid(valNode, 1)
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, valNode, f.ty)
            if ! IsOk[UirCoreExpr](valRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
            var addr: UirCoreExpr = dstPtr
            if f.offset != 0:
                addr = uirCoreBin(mbAdd, dstPtr, uirCoreConstI64(int64(f.offset)))
            add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), f.ty))
        return Ok[UirCoreExpr](dstPtr)

    # Too many args for a positional object constructor.
    if argCount > ot.fields.len + 1:
        let line1: str = intToStr(callNode.pos.line)
        let col1: str = intToStr(callNode.pos.col)
        var fnName1: str = ""
        var fp1: str = ""
        if b != nil && b.func != nil:
            let bf1: UirCoreFunc = b.func
            fnName1 = bf1.name
            fp1 = bf1.originFile
        return Err[UirCoreExpr]("uirCore_builder: object constructor '" + objTypeName +
                            "' expects all fields (or dst + all fields)" +
                            " (argc=" + intToStr(argCount) + " fields=" + intToStr(ot.fields.len) +
                            " fn=" + fnName1 + " " + fp1 + ":" + line1 + ":" + col1 + ")")
    return Err[UirCoreExpr]("uirCore_builder: object constructor internal error")

fn lowerVarArgAddr(b: BlockBuilder, argNode0: Node): Result[UirCoreExpr] =
    if b == nil:
        return Err[UirCoreExpr]("uirCore_builder: var arg missing builder")
    var argNode: Node = argNode0
    while argNode != nil && argNode.kind == nkPar && kidCount(argNode) > 0:
        argNode = kid(argNode, 0)
    if argNode != nil && argNode.kind == nkCall && kidCount(argNode) > 0:
        let calleeNode: Node = kid(argNode, 0)
        if calleeNode != nil && (calleeNode.kind == nkIdent || calleeNode.kind == nkSymbol):
            let name: str = backendStripSpaces(plainName(calleeNode))
            if name == "__addr":
                return lowerExprValue(b, argNode, uirCoreTypeI64())
    if argNode != nil && argNode.kind == nkDotExpr:
        let daRes: Result[DotAccess] = lowerDotAccess(b, argNode)
        if !IsOk[DotAccess](daRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[DotAccess](daRes))
        let da: DotAccess = Value[DotAccess](daRes)
        return Ok[UirCoreExpr](da.addr)
    if argNode != nil && argNode.kind == nkBracketExpr && kidCount(argNode) == 1:
        return lowerExprValue(b, kid(argNode, 0), uirCoreTypeI64())
    if argNode != nil && (argNode.kind == nkHiddenDeref || argNode.kind == nkDerefExpr) && kidCount(argNode) > 0:
        return lowerExprValue(b, kid(argNode, 0), uirCoreTypeI64())
    if argNode == nil || (argNode.kind != nkIdent && argNode.kind != nkSymbol):
        let k: str = (argNode != nil) ? intToStr(int32(argNode.kind)) : "0"
        let line: str = (argNode != nil) ? intToStr(argNode.pos.line) : "0"
        let col: str = (argNode != nil) ? intToStr(argNode.pos.col) : "0"
        return Err[UirCoreExpr]("uirCore_builder: var arg expects lvalue (got nk#" + k + " @" + line + ":" + col + ")")
    let nm: str = plainName(argNode)
    let idx: int32 = localIndex(b.env, nm)
    if idx >= 0:
        # Object locals are represented as i64 pointer slots.
        # For object values that own stack storage (frameOff >= 0), the lvalue is the
        # pointed-to storage; passing `var Obj` should pass the pointer value (uirCoreLocal),
        # not the address of the pointer slot (uirCoreAddr).
        let olIdx: int32 = funcFindObjLocal(b.func, idx)
        if olIdx >= 0:
            let fref: UirCoreFunc = b.func
            let ol: UirCoreObjLocal = fref.objLocals[olIdx]
            if ol.frameOff >= 0:
                return Ok[UirCoreExpr](uirCoreLocal(idx))
        return Ok[UirCoreExpr](uirCoreAddr(idx))
    let gi: int32 = moduleGlobalIndex(b.module, nm)
    if gi >= 0:
        let gObj: str = uirCoreGlobalObjTypeGet(nm)
        if len(gObj) > 0:
            return Ok[UirCoreExpr](uirCoreLoad(uirCoreGlobalAddr(nm), uirCoreTypeI64()))
        return Ok[UirCoreExpr](uirCoreGlobalAddr(nm))
    return Ok[UirCoreExpr](uirCoreGlobalAddr(nm))

fn lowerExprPtrValue(b: BlockBuilder, n: Node): Result[UirCoreExpr] =
    # Pointer-context expression lowering (used by deref stores like `*p = v`).
    # `lowerExprValue` loads through `var_` slots to produce the underlying value.
    # For stores, we need the address:
    # - `var T` where T is a scalar: the slot already holds the target address; do not load.
    # - `var ptr_T`: the slot holds the address of a pointer value; load once to get ptr_T.
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil ptr expr")
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil ptr expr")
    if node.kind == nkIdent || node.kind == nkSymbol:
        let nm: str = backendStripSpaces(plainName(node))
        let idx: int32 = localIndex(b.env, nm)
        if idx >= 0:
            let key0: str = localTypeKey(b.env, idx)
            if key0 != nil && len(key0) > 0:
                var baseKey: str = ""
                if uirCoreStrStartsWith(key0, "var_ref_"):
                    baseKey = str(ptr_add(void*(key0), 8))
                elif uirCoreStrStartsWith(key0, "var_"):
                    baseKey = str(ptr_add(void*(key0), 4))
                if baseKey != nil && len(baseKey) > 0:
                    if uirCoreStrStartsWith(baseKey, "ptr_"):
                        return Ok[UirCoreExpr](uirCoreLoad(uirCoreLocal(idx), uirCoreTypeI64()))
                    return Ok[UirCoreExpr](uirCoreLocal(idx))
    return lowerExprValue(b, node, uirCoreTypeI64())

fn lowerSpawnEntryArg(b: BlockBuilder, argNode0: Node): Result[UirCoreExpr] =
    if b == nil:
        return Err[UirCoreExpr]("uirCore_builder: spawn entry missing builder")
    var argNode: Node = argNode0
    while argNode != nil && argNode.kind == nkPar && kidCount(argNode) > 0:
        argNode = kid(argNode, 0)
    if argNode == nil || argNode.kind == nkNilLit:
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    let baseRes: Result[UirCoreExpr] = lowerExprValue(b, argNode, uirCoreTypeI64())
    if IsOk[UirCoreExpr](baseRes):
        return baseRes
    if argNode.kind == nkIdent || argNode.kind == nkSymbol:
        let msg: str = Error(baseRes)
        if msg != nil && uirCoreStrStartsWith(msg, "uirCore_builder: unknown local/global: "):
            let nm: str = backendStripSpaces(plainName(argNode))
            if nm != nil && len(nm) > 0:
                var sym: str = nm
                if uirCoreDupFnBasesHas(nm) && b.func != nil:
                    let f0: UirCoreFunc = b.func
                    let m0: str = uirCoreMaybeMangleDupFnBase(nm, f0.originFile)
                    if m0 != nil && len(m0) > 0:
                        sym = m0
                return Ok[UirCoreExpr](uirCoreGlobalAddr(sym))
    return baseRes

fn lowerExprValue(b: BlockBuilder, n: Node, wantType: UirCoreType): Result[UirCoreExpr] =
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil expr")
    var node: Node = n
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    while node != nil && node.kind == nkCallArg && kidCount(node) > 0:
        node = kid(node, kidCount(node) - 1)
    if node == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil expr")
    if node.kind == nkHiddenDeref || node.kind == nkDerefExpr:
        if kidCount(node) == 0:
            return Err[UirCoreExpr]("uirCore_builder: deref expects operand")
        let addrNode: Node = kid(node, 0)
        var elemKey: str = ""
        if node.typeCacheValid && node.typeCache != nil:
            elemKey = backendStripSpaces(typeKey node.typeCache)
            if uirCoreStrStartsWith(elemKey, "ptr_"):
                elemKey = backendStripSpaces(str(ptr_add(void*(elemKey), 4)))
        let ptrKey: str = exprTypeKeyShallow(b, addrNode)
        if isByteTypeKey(elemKey) || isBytePtrTypeKey(ptrKey):
            let addrRes: Result[UirCoreExpr] = lowerExprValue(b, addrNode, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](addrRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](addrRes))
            let byteTy: UirCoreType = byteUirTypeFromElemOrPtrKey(elemKey, ptrKey)
            let loaded: UirCoreExpr = lowerByteLoadNilChecked(b, Value[UirCoreExpr](addrRes), byteTy, wantType)
            return Ok[UirCoreExpr](loaded)
        if uirCoreStrStartsWith(ptrKey, "ptr_"):
            # Pointer-to-object deref is a no-op in MIR because object values are represented as pointers.
            # Example: `seq[T]*` is lowered as an i64 pointer to the seq storage; `*p` yields the same pointer.
            let baseKey: str = str(ptr_add(void*(ptrKey), 4))
            if b != nil && b.module != nil && baseKey != nil && len(baseKey) > 0:
                let objTypeName: str = uirCorePtrBaseObjTypeName(b.module, baseKey)
                if objTypeName != nil && len(objTypeName) > 0:
                    let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(b.module, objTypeName)
                    if aliasTy.kind == mtVoid:
                        return lowerExprValue(b, addrNode, uirCoreTypeI64())
            let addrRes2: Result[UirCoreExpr] = lowerExprValue(b, addrNode, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](addrRes2):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](addrRes2))
            return Ok[UirCoreExpr](uirCoreLoad(Value[UirCoreExpr](addrRes2), wantType))
        # Object values are represented as pointers in MIR; deref is a no-op.
        return lowerExprValue(b, addrNode, uirCoreTypeI64())
    if node.kind == nkStrLit:
        var value: str = node.strVal
        if value == nil:
            value = ""
        let label: str = uirCoreAddCString(b.module, value)
        return Ok[UirCoreExpr](uirCoreGlobalAddr(label))
    if node.kind == nkFloatLit:
        if node.strVal != nil && len(node.strVal) > 0:
            return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreConstI64(cheng_parse_f64_bits(node.strVal))))
        # Some stages may synthesize float literals without a raw string; default to 0.0 bits.
        return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreConstI64(0)))
    if node.kind == nkDotExpr:
        # Dot-call sugar (no-paren) for a zero-arg receiver method.
        # Example: `seq.reset` is lowered as `freeSeq[T](seq)` (where T is inferred from `seq[T]`).
        if kidCount(node) == 2:
            let base0: Node = kid(node, 0)
            let member0: Node = kid(node, 1)
            if base0 != nil && member0 != nil && (member0.kind == nkIdent || member0.kind == nkSymbol):
                let memberName0: str = backendStripSpaces(plainName(member0))
                if memberName0 == "reset":
                    let baseKey0: str = exprTypeKeyShallow(b, base0)
                    if uirCoreStrStartsWith(baseKey0, "seq_"):
                        let elemKey0: str = str(ptr_add(void*(baseKey0), 4))
                        if elemKey0 == nil || len(elemKey0) == 0:
                            return Err[UirCoreExpr]("uirCore_builder: seq.reset missing element type")
                        let baseRes0: Result[UirCoreExpr] = lowerExprValue(b, base0, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](baseRes0):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes0))
                        let typeArg0: Node = newIdent(elemKey0, node.pos)
                        var typeArgs0: Node[]
                        add(typeArgs0, typeArg0)
                        var callName0: str = mangleInstance("freeSeq", typeArgs0)
                        var callInternal0: str = callName0
                        if b.module != nil:
                            var argNodes0: Node[]
                            add(argNodes0, base0)
                            let cand0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName0, argNodes0, "")
                            if cand0 != nil:
                                callInternal0 = cand0.name
                            else:
                                let cand1: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, "freeSeq", argNodes0, "")
                                if cand1 != nil:
                                    callInternal0 = cand1.name
                        var args0: UirCoreExpr[]
                        add(args0, Value[UirCoreExpr](baseRes0))
                        return Ok[UirCoreExpr](uirCoreCall(callInternal0, args0))
        let daRes: Result[DotAccess] = lowerDotAccess(b, node)
        if ! IsOk[DotAccess](daRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[DotAccess](daRes))
        let da: DotAccess = Value[DotAccess](daRes)
        if da.fieldTy.kind == mtVoid:
            return Ok[UirCoreExpr](da.addr)
        if node.typeCacheValid && node.typeCache != nil:
            let objNm: str = typeNodeObjTypeName(b.module, node.typeCache)
            if len(objNm) > 0 && typeNodeIsObjValue(b.module, node.typeCache):
                # Object values in MIR are pointers to their storage; dot returns the field address.
                return Ok[UirCoreExpr](da.addr)
        return Ok[UirCoreExpr](uirCoreLoad(da.addr, da.fieldTy))
    if node.kind == nkBracketExpr:
        # Generic bracket expressions used as values (e.g. `default[T]`).
        # Note: prefix-deref `*p` is also represented as `nkBracketExpr` with a single child.
        if kidCount(node) == 2:
            let base0: Node = kid(node, 0)
            if base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                let baseName: str = backendStripSpaces(plainName(base0))
                if baseName == "default":
                    let typeArg0: Node = kid(node, 1)
                    if typeArg0 != nil && (typeArg0.kind == nkIdent || typeArg0.kind == nkSymbol):
                        let tn: str = backendStripSpaces(plainName(typeArg0))
                        if tn == "str" || tn == "string" || tn == "cstring":
                            let label0: str = uirCoreAddCString(b.module, "")
                            return Ok[UirCoreExpr](uirCoreGlobalAddr(label0))
                    let mod0: UirCoreModule = b.module
                    if mod0 != nil:
                        let objNm: str = typeNodeObjTypeName(mod0, typeArg0)
                        if len(objNm) > 0 && typeNodeIsObjValue(mod0, typeArg0):
                            let tmpName: str = blockBuilderNextTemp(b, "__default")
                            let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                            uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                            let tk0: str = typeKey(typeArg0)
                            if len(tk0) > 0:
                                localSetTypeKey(b.env, tmpSlot, tk0)
                                funcSetObjTypeKey(b.func, tmpSlot, tk0)
                            let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objNm)
                            if !IsOk[bool](allocRes):
                                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                            let initRes: Result[bool] = emitObjDefaultInit(b, tmpSlot, objNm)
                            if !IsOk[bool](initRes):
                                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](initRes))
                            return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))
                    return Ok[UirCoreExpr](uirCoreConstI64(0))

            # Slice: `str/seq[T][a..b]` / `a..<b`
            var idx0: Node = kid(node, 1)
            while idx0 != nil && idx0.kind == nkPar && kidCount(idx0) > 0:
                idx0 = kid(idx0, 0)
            if idx0 != nil && idx0.kind == nkInfix && kidCount(idx0) >= 3:
                let opNode: Node = kid(idx0, 0)
                let op: str = backendOpName(opNode)
                if op == ".." || op == "..<":
                    var baseKey: str = ""
                    if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
                        baseKey = typeKey base0.typeCache
                    if len(baseKey) == 0 && base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                        let nm: str = plainName(base0)
                        let slot0: int32 = localIndex(b.env, nm)
                        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                            baseKey = funcObjTypeKey(b.func, slot0)
                        elif slot0 >= 0:
                            baseKey = localTypeKey(b.env, slot0)
                    if len(baseKey) == 0 && base0 != nil && base0.kind == nkCall && b.module != nil && kidCount(base0) > 0:
                        let calleeNode: Node = kid(base0, 0)
                        var name: str = ""
                        var typeArgs: Node[]
                        if calleeNode != nil && calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
                            let base: Node = kid(calleeNode, 0)
                            name = backendStripSpaces(plainName(base))
                            for ti in 1..<kidCount(calleeNode):
                                let t: Node = kid(calleeNode, ti)
                                if t != nil && t.kind != nkEmpty:
                                    add(typeArgs, t)
                        else:
                            name = backendStripSpaces(plainName(calleeNode))
                        var callName: str = name
                        if typeArgs.len > 0:
                            callName = mangleInstance(name, typeArgs)
                        var argNodes: Node[]
                        for ai in 1..<kidCount(base0):
                            var argNode: Node = kid(base0, ai)
                            if argNode != nil && argNode.kind == nkCallArg && kidCount(argNode) > 1:
                                argNode = kid(argNode, 1)
                            add(argNodes, argNode)
                        let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, "")
                        if callee0 != nil:
                            if callee0.params.len > 0:
                                let p0: UirCoreParam = callee0.params[0]
                                if (p0.name == "__ret"):
                                    baseKey = funcObjTypeKey(callee0, p0.slot)
                            if len(baseKey) == 0 && callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                                baseKey = callee0.retTypeKey
                    if len(baseKey) == 0 && base0 != nil && base0.kind == nkStrLit:
                        baseKey = "str"

                    let startRes: Result[UirCoreExpr] = lowerExprValue(b, kid(idx0, 1), uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](startRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](startRes))
                    let stopRes: Result[UirCoreExpr] = lowerExprValue(b, kid(idx0, 2), uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](stopRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](stopRes))
                    let exclusive: UirCoreExpr = (op == "..<") ? uirCoreConstI64(1) : uirCoreConstI64(0)
                    let start32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](startRes))
                    let stop32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](stopRes))

                    if (baseKey == "str") || (baseKey == "string") || (baseKey == "cstring") || (base0 != nil && base0.kind == nkStrLit):
                        let baseRes: Result[UirCoreExpr] = lowerExprValue(b, base0, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](baseRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes))
                        var args: UirCoreExpr[]
                        add(args, Value[UirCoreExpr](baseRes))
                        add(args, start32)
                        add(args, stop32)
                        add(args, exclusive)
                        return Ok[UirCoreExpr](uirCoreCall("__cheng_slice_string", args))

                    if uirCoreStrStartsWith(baseKey, "seq_"):
                        let elemKey: str = str(ptr_add(void*(baseKey), 4))
                        if elemKey == nil || len(elemKey) == 0:
                            return Err[UirCoreExpr]("uirCore_builder: seq slice missing element type")
                        let typeArg0: Node = newIdent(elemKey, node.pos)
                        var typeArgs2: Node[]
                        add(typeArgs2, typeArg0)
                        let callName2: str = mangleInstance("__cheng_slice_vec", typeArgs2)

                        let tmpName: str = blockBuilderNextTemp(b, "__slice_seq")
                        let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                        uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                        let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, "seq")
                        if !IsOk[bool](allocRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                        funcSetObjTypeKey(b.func, tmpSlot, baseKey)

                        let baseRes2: Result[UirCoreExpr] = lowerExprValue(b, base0, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](baseRes2):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes2))
                        var args2: UirCoreExpr[]
                        add(args2, uirCoreLocal(tmpSlot))
                        add(args2, Value[UirCoreExpr](baseRes2))
                        add(args2, start32)
                        add(args2, stop32)
                        add(args2, exclusive)
                        return Ok[UirCoreExpr](uirCoreCall(callName2, args2))

            # Indexing: currently support fixed-size `array[N, T]` (object value).
            var baseObj: str = ""
            var baseKey2: str = ""
            if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
                baseKey2 = typeKey base0.typeCache
                baseObj = typeNodeObjTypeName(b.module, base0.typeCache)
            if base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                let nm: str = plainName(base0)
                let slot0: int32 = localIndex(b.env, nm)
                if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                    baseObj = funcObjTypeName(b.func, slot0)
                    baseKey2 = funcObjTypeKey(b.func, slot0)
                elif slot0 >= 0 && len(baseKey2) == 0:
                    baseKey2 = localTypeKey(b.env, slot0)
                elif slot0 < 0 && len(baseKey2) == 0:
                    let gk0: str = uirCoreGlobalTypeKeyByBaseUnique(b.module, nm)
                    if gk0 != nil && len(gk0) > 0:
                        baseKey2 = gk0
                    let gObj0: str = uirCoreGlobalObjTypeGet(nm)
                    if len(gObj0) > 0:
                        baseObj = gObj0
                        if len(baseKey2) == 0:
                            baseKey2 = gObj0

            var strKey0: str = baseKey2
            if uirCoreStrStartsWith(strKey0, "var_ref_"):
                strKey0 = str(ptr_add(void*(strKey0), 8))
            elif uirCoreStrStartsWith(strKey0, "var_") || uirCoreStrStartsWith(strKey0, "ref_"):
                strKey0 = str(ptr_add(void*(strKey0), 4))
            if uirCoreStrStartsWith(strKey0, "ptr_"):
                strKey0 = str(ptr_add(void*(strKey0), 4))
            if (strKey0 == "str") || (strKey0 == "string") || (strKey0 == "cstring") || (base0 != nil && base0.kind == nkStrLit):
                var idx1: Node = kid(node, 1)
                while idx1 != nil && idx1.kind == nkPar && kidCount(idx1) > 0:
                    idx1 = kid(idx1, 0)
                if idx1 == nil:
                    return Err[UirCoreExpr]("uirCore_builder: string subscript expects index")
                let baseRes: Result[UirCoreExpr] = lowerExprValue(b, base0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](baseRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes))
                let idxRes: Result[UirCoreExpr] = lowerExprValue(b, idx1, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](idxRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](idxRes))
                let addr: UirCoreExpr = uirCoreBin(mbAdd, Value[UirCoreExpr](baseRes), Value[UirCoreExpr](idxRes))
                return Ok[UirCoreExpr](uirCoreLoad(addr, uirCoreTypeU8()))

            var basePtrOverride: UirCoreExpr = uirCoreConstI64(0)
            var haveBasePtrOverride: bool = false
            if base0 != nil && base0.kind == nkDotExpr:
                let daRes: Result[DotAccess] = lowerDotAccess(b, base0)
                if IsOk[DotAccess](daRes):
                    let da: DotAccess = Value[DotAccess](daRes)
                    if da.fieldTy.kind == mtVoid && da.objTypeName != nil && len(da.objTypeName) > 0:
                        haveBasePtrOverride = true
                        basePtrOverride = da.addr
                        if len(baseObj) == 0:
                            baseObj = da.objTypeName
                        if len(baseKey2) == 0:
                            baseKey2 = da.objTypeName
                # Some stage1 pipelines omit typeCache on dot expressions. Recover a stable generic
                # type key (e.g. `seq_T`) via the same field-type map used by `caseInferExprTypeKey`,
                # so indexing doesn't fall back to `[](base, idx)`.
                let inferredKey2: str = caseInferExprTypeKey(b, base0)
                if inferredKey2 != nil && len(inferredKey2) > 0:
                    if uirCoreStrStartsWith(inferredKey2, "seq_") && !uirCoreStrStartsWith(baseKey2, "seq_"):
                        baseKey2 = inferredKey2
                    elif uirCoreStrStartsWith(inferredKey2, "seq_fixed_") && !uirCoreStrStartsWith(baseKey2, "seq_fixed_"):
                        baseKey2 = inferredKey2
                    elif uirCoreStrStartsWith(inferredKey2, "Table_") && !uirCoreStrStartsWith(baseKey2, "Table_"):
                        baseKey2 = inferredKey2
                    elif len(baseKey2) == 0:
                        baseKey2 = inferredKey2

            var objName: str = baseObj
            if len(objName) == 0:
                objName = baseKey2
            if uirCoreStrStartsWith(objName, "var_ref_"):
                objName = str(ptr_add(void*(objName), 8))
            elif uirCoreStrStartsWith(objName, "var_") || uirCoreStrStartsWith(objName, "ref_"):
                objName = str(ptr_add(void*(objName), 4))

            # Indexing for dynamic `seq[T]`: lower to runtime `cheng_seq_get`.
            var seqKey: str = baseKey2
            if uirCoreStrStartsWith(seqKey, "var_ref_"):
                seqKey = str(ptr_add(void*(seqKey), 8))
            elif uirCoreStrStartsWith(seqKey, "var_") || uirCoreStrStartsWith(seqKey, "ref_"):
                seqKey = str(ptr_add(void*(seqKey), 4))
            if uirCoreStrStartsWith(seqKey, "ptr_"):
                seqKey = str(ptr_add(void*(seqKey), 4))
            if uirCoreStrStartsWith(seqKey, "seq_") && b.module != nil:
                let elemKey: str = str(ptr_add(void*(seqKey), 4))
                if elemKey == nil || len(elemKey) == 0:
                    return Err[UirCoreExpr]("uirCore_builder: seq subscript missing element type")
                let elemTypeNode: Node = newIdent(elemKey, node.pos)
                let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
                if !IsOk[int32](sizeRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](sizeRes))
                let elemSize: int32 = Value[int32](sizeRes)
                let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)

                var baseRes3: Result[UirCoreExpr]
                if haveBasePtrOverride:
                    baseRes3 = Ok[UirCoreExpr](basePtrOverride)
                else:
                    baseRes3 = lowerExprValue(b, base0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](baseRes3):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes3))
                let seqName: str = blockBuilderNextTemp(b, "__seq_base")
                let seqSlot: int32 = localAdd(b.env, seqName, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, seqSlot, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(seqName, seqSlot, Value[UirCoreExpr](baseRes3)))
                let seqPtr: UirCoreExpr = uirCoreLocal(seqSlot)

                var lenOff: int32 = 0
                var bufOff: int32 = 8
                if uirCoreHasObjType(b.module, "seq"):
                    let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
                    var lenFound: bool = false
                    var bufFound: bool = false
                    for fi in 0..<seqOt.fields.len:
                        let f: UirCoreObjField = seqOt.fields[fi]
                        if (f.name == "len"):
                            lenOff = f.offset
                            lenFound = true
                        elif (f.name == "buffer"):
                            bufOff = f.offset
                            bufFound = true
                    if !lenFound || !bufFound:
                        return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch")

                let lenAddr: UirCoreExpr = (lenOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(lenOff)))
                let bufAddr: UirCoreExpr = (bufOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(bufOff)))
                let lenVal: UirCoreExpr = uirCoreLoad(lenAddr, uirCoreTypeI32())
                let bufVal: UirCoreExpr = uirCoreLoad(bufAddr, uirCoreTypeI64())
                let idxRes3: Result[UirCoreExpr] = lowerExprValue(b, idx0, uirCoreTypeI32())
                if !IsOk[UirCoreExpr](idxRes3):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](idxRes3))
                let elemSize32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreConstI64(int64(elemSize)))
                var args3: UirCoreExpr[]
                add(args3, bufVal)
                add(args3, lenVal)
                add(args3, Value[UirCoreExpr](idxRes3))
                add(args3, elemSize32)
                let ptrExpr: UirCoreExpr = uirCoreCall("cheng_seq_get", args3)
                if (elemKey == "bool"):
                    let loaded: UirCoreExpr = lowerByteLoadNilChecked(b, ptrExpr, uirCoreTypeU8(), wantType)
                    return Ok[UirCoreExpr](loaded)
                if (elemKey == "char"):
                    let raw: UirCoreExpr = uirCoreLoad(ptrExpr, uirCoreTypeI32())
                    let chVal: UirCoreExpr = uirCoreBin(mbAnd, raw, uirCoreConstI64(255))
                    if wantType.kind == mtI32:
                        return Ok[UirCoreExpr](chVal)
                    return Ok[UirCoreExpr](uirCoreCast(wantType, chVal))
                let elemObjName: str = typeNodeObjTypeName(b.module, elemTypeNode)
                if len(elemObjName) > 0 && typeNodeIsObjValue(b.module, elemTypeNode):
                    # Object values in MIR are pointers to storage. For `seq[T]` where `T` is an
                    # object value, `cheng_seq_get` already returns the element address.
                    return Ok[UirCoreExpr](ptrExpr)
                let loaded: UirCoreExpr = uirCoreLoad(ptrExpr, elemTy)
                if wantType.kind != elemTy.kind || wantType.isUnsigned != elemTy.isUnsigned:
                    return Ok[UirCoreExpr](uirCoreCast(wantType, loaded))
                return Ok[UirCoreExpr](loaded)

            if uirCoreStrStartsWith(objName, "array_") && b.module != nil && uirCoreHasObjType(b.module, objName):
                var basePtrRes: Result[UirCoreExpr]
                if haveBasePtrOverride:
                    basePtrRes = Ok[UirCoreExpr](basePtrOverride)
                else:
                    basePtrRes = lowerExprValue(b, base0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](basePtrRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](basePtrRes))
                let idxRes32: Result[UirCoreExpr] = lowerExprValue(b, idx0, uirCoreTypeI32())
                if !IsOk[UirCoreExpr](idxRes32):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](idxRes32))
                let basePtr: UirCoreExpr = Value[UirCoreExpr](basePtrRes)
                let idx32: UirCoreExpr = Value[UirCoreExpr](idxRes32)

                let ot: UirCoreObjType = uirCoreGetObjType(b.module, objName)
                if ot.fields.len == 0:
                    return Err[UirCoreExpr]("uirCore_builder: array type has no fields: " + objName)
                let arrLen32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreConstI64(int64(ot.fields.len)))
                var bcArgs: UirCoreExpr[]
                add(bcArgs, arrLen32)
                add(bcArgs, idx32)
                add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("cheng_bounds_check", bcArgs)))
                let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), idx32)
                let f0: UirCoreObjField = ot.fields[0]
                let elemTy: UirCoreType = f0.ty
                let elemSize: int32 = uirCoreTypeSize(elemTy)
                if elemSize <= 0:
                    return Err[UirCoreExpr]("uirCore_builder: array element size unsupported: " + objName)
                var stride: int64 = int64(alignUpPow2(elemSize, uirCoreTypeAlignPow2(elemTy)))
                if ot.fields.len > 1:
                    let f1: UirCoreObjField = ot.fields[1]
                    let d: int32 = f1.offset - f0.offset
                    if d > 0:
                        stride = int64(d)
                let off: UirCoreExpr = (stride == 1) ? idx64 : uirCoreBin(mbMul, idx64, uirCoreConstI64(stride))
                let addr: UirCoreExpr = uirCoreBin(mbAdd, basePtr, off)
                let loaded: UirCoreExpr = uirCoreLoad(addr, elemTy)
                if wantType.kind != elemTy.kind || wantType.isUnsigned != elemTy.isUnsigned:
                    return Ok[UirCoreExpr](uirCoreCast(wantType, loaded))
                return Ok[UirCoreExpr](loaded)

            # Fallback: treat `base[idx]` as an operator call `[](base, idx)`.
            let callNode: Node = newNode(nkCall, node.pos)
            callNode.typeCache = node.typeCache
            callNode.typeCacheValid = node.typeCacheValid
            addSon(callNode, newIdent("[]", node.pos))
            addSon(callNode, base0)
            addSon(callNode, idx0)
            return lowerExprValue(b, callNode, wantType)
        if kidCount(node) == 1:
            let addrNode: Node = kid(node, 0)
            let ptrKey0: str = exprTypeKeyShallow(b, addrNode)
            let addrRes: Result[UirCoreExpr] = lowerExprValue(b, addrNode, uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](addrRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](addrRes))
            if isBytePtrTypeKey(ptrKey0):
                let byteTy: UirCoreType = byteUirTypeFromPtrTypeKey(ptrKey0)
                let loaded: UirCoreExpr = lowerByteLoadNilChecked(b, Value[UirCoreExpr](addrRes), byteTy, wantType)
                return Ok[UirCoreExpr](loaded)
            if uirCoreStrStartsWith(ptrKey0, "ptr_"):
                let baseKey0: str = str(ptr_add(void*(ptrKey0), 4))
                let objTypeName0: str = uirCorePtrBaseObjTypeName(b.module, baseKey0)
                if objTypeName0 != nil && len(objTypeName0) > 0:
                    let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(b.module, objTypeName0)
                    if aliasTy0.kind == mtVoid:
                        return Ok[UirCoreExpr](Value[UirCoreExpr](addrRes))
            return Ok[UirCoreExpr](uirCoreLoad(Value[UirCoreExpr](addrRes), wantType))
        var fnName: str = ""
        var fp: str = ""
        if b != nil && b.func != nil:
            let f0: UirCoreFunc = b.func
            fnName = f0.name
            fp = f0.originFile
        let line: str = intToStr(node.pos.line)
        let col: str = intToStr(node.pos.col)
        return Err[UirCoreExpr]("uirCore_builder: subscript is not supported (fn=" + fnName + " " + fp +
                            ":" + line + ":" + col + ")")
    if node.kind == nkCurly:
        # Minimal set literal lowering: `set[int32]` as a uint64 bitset.
        # Current implementation supports only constant ordinal elements and constant ranges.
        let mod0: UirCoreModule = b.module
        var bits: int64 = 0
        for i in 0..<kidCount(node):
            var item: Node = kid(node, i)
            while item != nil && item.kind == nkPar && kidCount(item) > 0:
                item = kid(item, 0)
            if item == nil:
                continue
            var fnName: str = ""
            var fp: str = ""
            if b != nil && b.func != nil:
                let f0: UirCoreFunc = b.func
                fnName = f0.name
                fp = f0.originFile
            let line: str = intToStr(item.pos.line)
            let col: str = intToStr(item.pos.col)
            var startVal: int64 = 0
            var endVal: int64 = 0
            var hasRange: bool = false
            var exclusive: bool = false
            if item.kind == nkInfix && kidCount(item) >= 3:
                let opNode: Node = kid(item, 0)
                let op: str = backendOpName(opNode)
                if op == ".." || op == "..<":
                    hasRange = true
                    exclusive = op == "..<"
                    var lhs0: Node = kid(item, 1)
                    var rhs0: Node = kid(item, 2)
                    while lhs0 != nil && lhs0.kind == nkPar && kidCount(lhs0) > 0:
                        lhs0 = kid(lhs0, 0)
                    while rhs0 != nil && rhs0.kind == nkPar && kidCount(rhs0) > 0:
                        rhs0 = kid(rhs0, 0)
                    var okL: bool = false
                    var okR: bool = false
                    if lhs0 != nil && lhs0.kind == nkIntLit:
                        startVal = lhs0.intVal
                        okL = true
                    elif lhs0 != nil && lhs0.kind == nkCharLit:
                        if lhs0.strVal != nil && len(lhs0.strVal) > 0:
                            startVal = int64(lhs0.strVal[0])
                        okL = true
                    elif lhs0 != nil && (lhs0.kind == nkIdent || lhs0.kind == nkSymbol):
                        let nm: str = plainName(lhs0)
                        let gi: int32 = moduleGlobalIndex(mod0, nm)
                        if gi >= 0:
                            let g: UirCoreGlobal = mod0.globals[gi]
                            if g.hasInit:
                                startVal = g.init
                                okL = true
                    if rhs0 != nil && rhs0.kind == nkIntLit:
                        endVal = rhs0.intVal
                        okR = true
                    elif rhs0 != nil && rhs0.kind == nkCharLit:
                        if rhs0.strVal != nil && len(rhs0.strVal) > 0:
                            endVal = int64(rhs0.strVal[0])
                        okR = true
                    elif rhs0 != nil && (rhs0.kind == nkIdent || rhs0.kind == nkSymbol):
                        let nm2: str = plainName(rhs0)
                        let gi2: int32 = moduleGlobalIndex(mod0, nm2)
                        if gi2 >= 0:
                            let g2: UirCoreGlobal = mod0.globals[gi2]
                            if g2.hasInit:
                                endVal = g2.init
                                okR = true
                    if !okL || !okR:
                        return Err[UirCoreExpr]("uirCore_builder: set range expects const ordinals (fn=" + fnName +
                                            " " + fp + ":" + line + ":" + col + ")")
            if hasRange:
                var v: int64 = startVal
                var stop: int64 = endVal
                if exclusive:
                    stop = stop - 1
                let __for_start_v_1 = v
                for __for_v_1 in __for_start_v_1..stop:
                    v = __for_v_1
                    if v >= 0 && v < 64:
                        bits = bits | (int64(1) << int32(v))
                    v = v + 1
                continue
            var v2: int64 = 0
            var okItem: bool = false
            if item.kind == nkIntLit:
                v2 = item.intVal
                okItem = true
            elif item.kind == nkCharLit:
                if item.strVal != nil && len(item.strVal) > 0:
                    v2 = int64(item.strVal[0])
                okItem = true
            elif item.kind == nkIdent || item.kind == nkSymbol:
                let nm3: str = plainName(item)
                let gi3: int32 = moduleGlobalIndex(mod0, nm3)
                if gi3 >= 0:
                    let g3: UirCoreGlobal = mod0.globals[gi3]
                    if g3.hasInit:
                        v2 = g3.init
                        okItem = true
            if !okItem:
                let k: str = intToStr(int32(item.kind))
                return Err[UirCoreExpr]("uirCore_builder: set literal expects const ordinals (nk#" + k +
                                    " fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")
            if v2 >= 0 && v2 < 64:
                bits = bits | (int64(1) << int32(v2))
        return Ok[UirCoreExpr](uirCoreConstI64(bits))
    if node.kind == nkTupleLit:
        var tupleType: Node = nil
        if node.typeCacheValid && node.typeCache != nil:
            tupleType = node.typeCache
        else:
            # Stage1 may clear typeCache for tuple literals. Infer a best-effort element type list.
            var ty: Node = newNode(nkTupleTy, node.pos)
            for i0 in 0..<kidCount(node):
                var elemNode0: Node = kid(node, i0)
                if elemNode0 != nil && elemNode0.kind == nkCallArg && kidCount(elemNode0) > 1:
                    elemNode0 = kid(elemNode0, 1)
                var ek: str = ""
                if elemNode0 != nil && elemNode0.typeCacheValid && elemNode0.typeCache != nil:
                    ek = typeKey elemNode0.typeCache
                if len(ek) == 0:
                    if elemNode0 != nil && elemNode0.kind == nkStrLit:
                        ek = "str"
                    elif elemNode0 != nil && elemNode0.kind == nkCharLit:
                        ek = "char"
                    elif elemNode0 != nil && elemNode0.kind == nkBoolLit:
                        ek = "bool"
                    else:
                        ek = "int64"
                addSon(ty, newIdent(ek, node.pos))
            tupleType = ty
        let tupleObj: str = typeNodeObjTypeName(b.module, tupleType)
        if len(tupleObj) == 0 || ! typeNodeIsObjValue(b.module, tupleType):
            return Err[UirCoreExpr]("uirCore_builder: tuple literal unsupported type")
        let tmpName: str = blockBuilderNextTemp(b, "__tuple")
        let slot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, slot, uirCoreTypeI64())
        let allocRes: Result[bool] = allocObjValueLocal(b, slot, tupleObj)
        if ! IsOk[bool](allocRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
        let ot: UirCoreObjType = uirCoreGetObjType(b.module, tupleObj)
        for i in 0..<kidCount(node):
            var elemNode: Node = kid(node, i)
            if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
                elemNode = kid(elemNode, 1)
            let fieldName: str = "f" + intToStr(i)
            for fi in 0..<ot.fields.len:
                let f: UirCoreObjField = ot.fields[fi]
                if (f.name == fieldName):
                    let valRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, f.ty)
                    if ! IsOk[UirCoreExpr](valRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
                    let basePtr: UirCoreExpr = uirCoreLocal(slot)
                    var addr: UirCoreExpr = basePtr
                    if f.offset != 0:
                        addr = uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(f.offset)))
                    add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), f.ty))
                    break
        return Ok[UirCoreExpr](uirCoreLocal(slot))
    if node.kind == nkSeqLit:
        if b == nil || b.module == nil || b.func == nil:
            return Err[UirCoreExpr]("uirCore_builder: seq literal missing builder/module")
        let count: int32 = kidCount(node)
        var elemSize: int32 = 0
        var elemUirTy: UirCoreType = uirCoreTypeI64()
        if count > 0:
            if ! node.typeCacheValid || node.typeCache == nil:
                var fnName: str = ""
                var fp: str = ""
                if b != nil && b.func != nil:
                    let f0: UirCoreFunc = b.func
                    fnName = f0.name
                    fp = f0.originFile
                let line: str = intToStr(node.pos.line)
                let col: str = intToStr(node.pos.col)
                return Err[UirCoreExpr]("uirCore_builder: seq literal requires type (fn=" + fnName + " " + fp +
                                    ":" + line + ":" + col + ")")
            var elemType: Node = nil
            let litType: Node = node.typeCache
            if litType != nil && litType.kind == nkBracketExpr && kidCount(litType) > 1:
                let base: Node = kid(litType, 0)
                if base != nil && (base.kind == nkIdent || base.kind == nkSymbol):
                    let nm: str = backendStripSpaces(plainName(base))
                    if nm == "seq":
                        elemType = kid(litType, 1)
            if elemType == nil:
                var fnName2: str = ""
                var fp2: str = ""
                if b != nil && b.func != nil:
                    let f2: UirCoreFunc = b.func
                    fnName2 = f2.name
                    fp2 = f2.originFile
                let line2: str = intToStr(node.pos.line)
                let col2: str = intToStr(node.pos.col)
                return Err[UirCoreExpr]("uirCore_builder: seq literal unsupported type (fn=" + fnName2 + " " + fp2 +
                                    ":" + line2 + ":" + col2 + ")")

            let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemType)
            if ! IsOk[int32](sizeRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](sizeRes))
            elemSize = Value[int32](sizeRes)
            elemUirTy = uirCoreTypeFromNodeWithModule(b.module, elemType)

        let seqObj: str = "seq"
        let tmpName: str = blockBuilderNextTemp(b, "__seq")
        let slot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, slot, uirCoreTypeI64())
        let allocRes: Result[bool] = allocObjValueLocal(b, slot, seqObj)
        if ! IsOk[bool](allocRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))

        let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, seqObj)
        var lenOff: int32 = -1
        var capOff: int32 = -1
        var bufOff: int32 = -1
        for fi in 0..<seqOt.fields.len:
            let f: UirCoreObjField = seqOt.fields[fi]
            if (f.name == "len"):
                lenOff = f.offset
            elif (f.name == "cap"):
                capOff = f.offset
            elif (f.name == "buffer"):
                bufOff = f.offset
        if lenOff < 0 || capOff < 0 || bufOff < 0:
            return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch")

        let basePtr: UirCoreExpr = uirCoreLocal(slot)
        let lenAddr: UirCoreExpr = (lenOff == 0) ? basePtr : uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(lenOff)))
        let capAddr: UirCoreExpr = (capOff == 0) ? basePtr : uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(capOff)))
        let bufAddr: UirCoreExpr = (bufOff == 0) ? basePtr : uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(bufOff)))
        add(b.currentStmts, uirCoreStmtStore(lenAddr, uirCoreConstI64(int64(count)), uirCoreTypeI32()))
        add(b.currentStmts, uirCoreStmtStore(capAddr, uirCoreConstI64(int64(count)), uirCoreTypeI32()))

        var bufPtr: UirCoreExpr = uirCoreConstI64(0)
        if count > 0 && elemSize > 0:
            let bytes: int64 = int64(count) * int64(elemSize)
            var allocArgs: UirCoreExpr[]
            add(allocArgs, uirCoreConstI64(bytes))
            let allocCall: UirCoreExpr = uirCoreCall("alloc", allocArgs)
            let bufName: str = blockBuilderNextTemp(b, "__seq_buf")
            let bufSlot: int32 = localAdd(b.env, bufName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, bufSlot, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(bufName, bufSlot, allocCall))
            bufPtr = uirCoreLocal(bufSlot)
        add(b.currentStmts, uirCoreStmtStore(bufAddr, bufPtr, uirCoreTypeI64()))

        if count > 0 && elemSize > 0:
            for i in 0..<count:
                var elemNode: Node = kid(node, i)
                if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
                    elemNode = kid(elemNode, 1)
                let valRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, elemUirTy)
                if ! IsOk[UirCoreExpr](valRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
                let off: int64 = int64(i) * int64(elemSize)
                let addr: UirCoreExpr = (off == 0) ? bufPtr : uirCoreBin(mbAdd, bufPtr, uirCoreConstI64(off))
                add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), elemUirTy))

        return Ok[UirCoreExpr](uirCoreLocal(slot))
    if isControlExpr(node):
        let tmpName: str = blockBuilderNextTemp(b, "__tmp")
        let tmpSlot: int32 = localAdd(b.env, tmpName, wantType)
        uirCoreSetLocalType(b.func, tmpSlot, wantType)
        let assignRes: Result[bool] = lowerAssignValue(b, node, tmpName, tmpSlot)
        if ! IsOk[bool](assignRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](assignRes))
        return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))
    if node.kind == nkIntLit:
        return Ok[UirCoreExpr](uirCoreConstI64(node.intVal))
    if node.kind == nkBoolLit:
        let name: str = backendStripSpaces(node.ident)
        if name == "true":
            return Ok[UirCoreExpr](uirCoreConstI64(1))
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if node.kind == nkCharLit:
        if node.strVal != nil && len(node.strVal) > 0:
            let c: char = node.strVal[0]
            return Ok[UirCoreExpr](uirCoreConstI64(int64(c)))
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if node.kind == nkNilLit:
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if node.kind == nkIdent || node.kind == nkSymbol:
        let nm: str = plainName(node)
        let idx: int32 = localIndex(b.env, nm)
        if idx >= 0:
            let key0: str = localTypeKey(b.env, idx)
            if key0 != nil && len(key0) > 0 && b.module != nil:
                var key: str = key0
                var baseKey: str = ""
                if uirCoreStrStartsWith(key, "var_ref_"):
                    baseKey = str(ptr_add(void*(key), 8))
                elif uirCoreStrStartsWith(key, "var_"):
                    baseKey = str(ptr_add(void*(key), 4))
                if baseKey != nil && len(baseKey) > 0:
                    let canon: str = uirCoreObjAliasCanon(baseKey)
                    if canon != nil && len(canon) > 0:
                        baseKey = canon
                    var wantLoad: bool = true
                    if uirCoreHasObjType(b.module, baseKey):
                        # Object values are represented as pointers to storage; `var Obj` passes the
                        # pointer itself (no extra indirection). Ref-like aliases still use an
                        # extra indirection and must be loaded.
                        let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(b.module, baseKey)
                        wantLoad = aliasTy0.kind != mtVoid
                    elif ((baseKey == "seq") || uirCoreStrStartsWith(baseKey, "seq_") || uirCoreStrStartsWith(baseKey, "seq_fixed_")) &&
                         uirCoreHasObjType(b.module, "seq"):
                        wantLoad = false
                    elif ((baseKey == "Table") || uirCoreStrStartsWith(baseKey, "Table_")) && uirCoreHasObjType(b.module, "Table"):
                        wantLoad = false
                    if wantLoad:
                        let baseTy: UirCoreType = uirCoreTypeFromTypeKeyName(baseKey)
                        let loaded: UirCoreExpr = uirCoreLoad(uirCoreLocal(idx), baseTy)
                        if wantType.kind != baseTy.kind || wantType.isUnsigned != baseTy.isUnsigned:
                            return Ok[UirCoreExpr](uirCoreCast(wantType, loaded))
                        return Ok[UirCoreExpr](loaded)
            if wantType.kind != mtI64:
                let olIdx: int32 = funcFindObjLocal(b.func, idx)
                if olIdx >= 0:
                    let fref: UirCoreFunc = b.func
                    let ol: UirCoreObjLocal = fref.objLocals[olIdx]
                    if ol.frameOff >= 0:
                        let wantNm: str = uirCoreTypeKindName(wantType)
                        let line: str = intToStr(node.pos.line)
                        let col: str = intToStr(node.pos.col)
                        let fp: str = fref.originFile
                        let msg: str = "uirCore_builder: object value must use field access: " + nm +
                                       " (obj=" + ol.objTypeName + " want=" + wantNm +
                                       " fn=" + fref.name + " " + fp + ":" + line + ":" + col + ")"
                        return Err[UirCoreExpr](msg)
            return Ok[UirCoreExpr](uirCoreLocal(idx))
        let mod: UirCoreModule = b.module
        var gi: int32 = moduleGlobalIndex(mod, nm)
        if gi < 0 && b.func != nil && uirCoreDupGlobalNamesHas(nm):
            let f2: UirCoreFunc = b.func
            let gName: str = uirCoreMaybeMangleDupGlobalName(nm, f2.originFile)
            if gName != nil && len(gName) > 0:
                gi = moduleGlobalIndex(mod, gName)
        if gi < 0 && uirCoreDupGlobalNamesHas(nm):
            let gi2: int32 = moduleFindGlobalIndexByBaseUnique(mod, nm)
            if gi2 >= 0 && gi2 < mod.globals.len:
                let g2: UirCoreGlobal = mod.globals[gi2]
                return Ok[UirCoreExpr](uirCoreLoad(uirCoreGlobalAddr(g2.name), g2.ty))
        if gi >= 0:
            let g: UirCoreGlobal = mod.globals[gi]
            return Ok[UirCoreExpr](uirCoreLoad(uirCoreGlobalAddr(g.name), g.ty))
        var fnRefName: str = nm
        if uirCoreDupFnBasesHas(nm) && b.func != nil:
            let f2: UirCoreFunc = b.func
            let mangledRef: str = uirCoreMaybeMangleDupFnBase(nm, f2.originFile)
            if mangledRef != nil && len(mangledRef) > 0 && moduleHasFuncByBase(mod, mangledRef):
                fnRefName = mangledRef
        if moduleHasFuncByBase(mod, fnRefName):
            var callerFile: str = ""
            if b != nil && b.func != nil:
                let fCur: UirCoreFunc = b.func
                callerFile = fCur.originFile
            let f1: UirCoreFunc = moduleFindFuncByBasePreferOrigin(mod, fnRefName, callerFile)
            if f1 == nil:
                let line0: str = intToStr(node.pos.line)
                let col0: str = intToStr(node.pos.col)
                var fnDbg: str = ""
                var fpDbg: str = ""
                if b != nil && b.func != nil:
                    let fDbg: UirCoreFunc = b.func
                    fnDbg = fDbg.name
                    fpDbg = fDbg.originFile
                return Err[UirCoreExpr]("uirCore_builder: ambiguous function reference: " + fnRefName + " @" + line0 + ":" + col0 +
                                    " (fn=" + fnDbg + " " + fpDbg + ")")
            let sym: str = (f1.linkName != nil && len(f1.linkName) > 0) ? f1.linkName : f1.name
            return Ok[UirCoreExpr](uirCoreGlobalAddr(sym))
        var fnName: str = ""
        var fp: str = ""
        if b != nil && b.func != nil:
            let f0: UirCoreFunc = b.func
            fnName = f0.name
            fp = f0.originFile
        if (getEnv "BACKEND_DEBUG_UNKNOWN_NAME" == "1"):
            var wantNm: str = uirCoreTypeKindName(wantType)
            var tcKey: str = ""
            if node.typeCacheValid && node.typeCache != nil:
                tcKey = typeKey(node.typeCache)
            echo("[backend] debugUnknownName: ident='" + nm + "' want=" + wantNm +
                 " typeCacheKey='" + tcKey + "' fn=" + fnName)
        let line: str = intToStr(node.pos.line)
        let col: str = intToStr(node.pos.col)
        let msg: str = "uirCore_builder: unknown local/global: " + nm +
                       " (fn=" + fnName + " " + fp + ":" + line + ":" + col + ")"
        return Err[UirCoreExpr](msg)
    if node.kind == nkCall && kidCount(node) > 0:
        let calleeNode: Node = kid(node, 0)
        if calleeNode == nil:
            return Err[UirCoreExpr]("uirCore_builder: call expects callee")
        if kidCount(node) == 2 &&
           (calleeNode.kind == nkPtrTy || calleeNode.kind == nkRefTy || calleeNode.kind == nkVarTy ||
            calleeNode.kind == nkFnTy || calleeNode.kind == nkTupleTy || calleeNode.kind == nkSetTy):
            var argNode0: Node = kid(node, 1)
            if argNode0 != nil && argNode0.kind == nkCallArg && kidCount(argNode0) > 1:
                argNode0 = kid(argNode0, 1)
            let castRes: Result[UirCoreExpr] = lowerExprValue(b, argNode0, uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](castRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](castRes))
            let castType: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, calleeNode)
            return Ok[UirCoreExpr](uirCoreCast(castType, Value[UirCoreExpr](castRes)))
        if (calleeNode.kind == nkIdent || calleeNode.kind == nkSymbol) && kidCount(node) == 2:
            let name0: str = backendStripSpaces(plainName(calleeNode))
            if name0 == "sizeof":
                var argNode0: Node = kid(node, 1)
                if argNode0 != nil && argNode0.kind == nkCallArg && kidCount(argNode0) > 1:
                    argNode0 = kid(argNode0, 1)
                var szRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, argNode0)
                # `sizeof` is frequently used on fields/locals where typeCache might be cleared by lowering.
                if !IsOk[int32](szRes) && argNode0 != nil:
                    if argNode0.kind == nkDotExpr:
                        let daRes: Result[DotAccess] = lowerDotAccess(b, argNode0)
                        if IsOk[DotAccess](daRes):
                            let da0: DotAccess = Value[DotAccess](daRes)
                            if da0.fieldTy.kind == mtI32:
                                szRes = Ok[int32](4)
                            elif da0.fieldTy.kind == mtI64:
                                szRes = Ok[int32](8)
                            elif da0.fieldTy.kind == mtVoid && len(da0.objTypeName) > 0 &&
                                 b.module != nil && uirCoreHasObjType(b.module, da0.objTypeName):
                                let ot0: UirCoreObjType = uirCoreGetObjType(b.module, da0.objTypeName)
                                szRes = Ok[int32](ot0.size)
                    elif argNode0.kind == nkIdent || argNode0.kind == nkSymbol:
                        let nm: str = plainName(argNode0)
                        let slot: int32 = localIndex(b.env, nm)
                        if slot >= 0:
                            let olIdx: int32 = funcFindObjLocal(b.func, slot)
                            if olIdx >= 0:
                                let objNm: str = funcObjTypeName(b.func, slot)
                                if len(objNm) > 0 && b.module != nil && uirCoreHasObjType(b.module, objNm):
                                    let ot1: UirCoreObjType = uirCoreGetObjType(b.module, objNm)
                                    szRes = Ok[int32](ot1.size)
                            else:
                                let ty0: UirCoreType = localType(b.env, slot)
                                if ty0.kind == mtI64:
                                    szRes = Ok[int32](8)
                                elif ty0.kind == mtI32:
                                    szRes = Ok[int32](4)
                                elif ty0.kind == mtVoid:
                                    szRes = Ok[int32](0)
                        else:
                            let gi0: int32 = moduleGlobalIndex(b.module, nm)
                            if gi0 >= 0:
                                let mod0: UirCoreModule = b.module
                                let g0: UirCoreGlobal = mod0.globals[gi0]
                                if g0.ty.kind == mtI64:
                                    szRes = Ok[int32](8)
                                elif g0.ty.kind == mtI32:
                                    szRes = Ok[int32](4)
                                elif g0.ty.kind == mtVoid:
                                    szRes = Ok[int32](0)
                if !IsOk[int32](szRes) && argNode0 != nil && argNode0.typeCacheValid && argNode0.typeCache != nil:
                    szRes = uirCoreSizeOfTypeNode(b.module, argNode0.typeCache)
                if !IsOk[int32](szRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](szRes))
                return Ok[UirCoreExpr](uirCoreConstI64(int64(Value[int32](szRes))))
            if name0 == "new":
                var argNode0: Node = kid(node, 1)
                if argNode0 != nil && argNode0.kind == nkCallArg && kidCount(argNode0) > 1:
                    argNode0 = kid(argNode0, 1)
                if argNode0 == nil || (argNode0.kind != nkIdent && argNode0.kind != nkSymbol):
                    let k: str = (argNode0 != nil) ? intToStr(int32(argNode0.kind)) : "0"
                    let line: str = (argNode0 != nil) ? intToStr(argNode0.pos.line) : "0"
                    let col: str = (argNode0 != nil) ? intToStr(argNode0.pos.col) : "0"
                    return Err[UirCoreExpr]("uirCore_builder: new expects local var ref (got nk#" + k + " @" + line + ":" + col + ")")
                let nm: str = plainName(argNode0)
                let slot: int32 = localIndex(b.env, nm)
                if slot < 0:
                    return Err[UirCoreExpr]("uirCore_builder: new expects local var ref")
                var typeNode: Node = nil
                if argNode0.typeCacheValid && argNode0.typeCache != nil:
                    typeNode = argNode0.typeCache
                var inner: Node = typeNode
                while inner != nil && inner.kind == nkVarTy && kidCount(inner) > 0:
                    inner = kid(inner, 0)
                if inner != nil && inner.kind == nkRefTy && kidCount(inner) > 0:
                    inner = kid(inner, 0)
                # Stage1 may leave a bare `ref/var` wrapper in typeCache without a child.
                # In that case, fall back to local type keys to recover the concrete object type.
                if inner != nil && (inner.kind == nkRefTy || inner.kind == nkPtrTy || inner.kind == nkVarTy) && kidCount(inner) == 0:
                    inner = nil
                # Some pipelines may keep the concrete object decl node; prefer the named type key.
                if inner != nil && inner.kind == nkObjectDecl:
                    inner = nil
                if inner == nil || inner.kind == nkEmpty:
                    let key: str = localTypeKey(b.env, slot)
                    if uirCoreStrStartsWith(key, "ref_"):
                        let innerKey: str = str(ptr_add(void*(key), 4))
                        inner = newIdent(innerKey, argNode0.pos)
                    elif uirCoreStrStartsWith(key, "var_ref_"):
                        let innerKey2: str = str(ptr_add(void*(key), 8))
                        inner = newIdent(innerKey2, argNode0.pos)
                    elif key != nil && len(key) > 0:
                        # Newer stage1 pipelines may keep only the inner type key for ref locals.
                        inner = newIdent(key, argNode0.pos)
                if inner == nil || inner.kind == nkEmpty:
                    let line2: str = intToStr(argNode0.pos.line)
                    let col2: str = intToStr(argNode0.pos.col)
                    let key2: str = localTypeKey(b.env, slot)
                    return Err[UirCoreExpr]("uirCore_builder: new missing type info (var=" + nm + " @" + line2 + ":" + col2 + ", key=" + key2 + ")")
                var size: int64 = 0
                let innerObjName: str = typeNodeObjTypeName(b.module, inner)
                if len(innerObjName) > 0 && b.module != nil && uirCoreHasObjType(b.module, innerObjName):
                    let otNew: UirCoreObjType = uirCoreGetObjType(b.module, innerObjName)
                    size = int64(otNew.size)
                else:
                    let szRes2: Result[int32] = uirCoreSizeOfTypeNode(b.module, inner)
                    if !IsOk[int32](szRes2):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](szRes2))
                    size = int64(Value[int32](szRes2))

                let tmpName: str = blockBuilderNextTemp(b, "__new_p")
                let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                var allocArgs: UirCoreExpr[]
                add(allocArgs, uirCoreConstI64(size))
                add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, uirCoreCall("alloc", allocArgs)))

                let thenLabel: str = blockBuilderNextLabel(b, "new_then")
                let elseLabel: str = blockBuilderNextLabel(b, "new_else")
                let joinLabel: str = blockBuilderNextLabel(b, "new_join")
                let okCond: UirCoreExpr = uirCoreCmp(mcNe, uirCoreLocal(tmpSlot), uirCoreConstI64(0))
                blockBuilderFinish(b, uirCoreTermCbr(okCond, thenLabel, elseLabel))

                blockBuilderStart(b, thenLabel)
                var zeroArgs: UirCoreExpr[]
                add(zeroArgs, uirCoreLocal(tmpSlot))
                add(zeroArgs, uirCoreConstI64(size))
                add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("zeroMem", zeroArgs)))
                add(b.currentStmts, uirCoreStmtAssign(nm, slot, uirCoreLocal(tmpSlot)))
                blockBuilderFinish(b, uirCoreTermBr(joinLabel))

                blockBuilderStart(b, elseLabel)
                blockBuilderFinish(b, uirCoreTermBr(joinLabel))

                blockBuilderStart(b, joinLabel)
                return Ok[UirCoreExpr](uirCoreLocal(slot))
        # Method-call sugar: `obj.method(args)` -> `method(obj, args)` when `method` is not a real field.
        # Avoid treating these as function-pointer field calls (e.g. `times.now().format("unix")`).
        if b.module != nil && calleeNode != nil && calleeNode.kind == nkDotExpr && kidCount(calleeNode) > 1:
            var dotBase0: Node = kid(calleeNode, 0)
            while dotBase0 != nil && dotBase0.kind == nkPar && kidCount(dotBase0) > 0:
                dotBase0 = kid(dotBase0, 0)
            let dotMember0: Node = kid(calleeNode, 1)
            if dotBase0 != nil && dotMember0 != nil && (dotMember0.kind == nkIdent || dotMember0.kind == nkSymbol):
                var baseKey0: str = caseInferExprTypeKey(b, dotBase0)
                if uirCoreStrStartsWith(baseKey0, "ref_"):
                    baseKey0 = str(ptr_add(void*(baseKey0), 4))
                elif uirCoreStrStartsWith(baseKey0, "var_ref_"):
                    baseKey0 = str(ptr_add(void*(baseKey0), 8))
                elif uirCoreStrStartsWith(baseKey0, "var_"):
                    baseKey0 = str(ptr_add(void*(baseKey0), 4))
                if baseKey0 != nil && len(baseKey0) > 0:
                    let canon0: str = uirCoreObjAliasCanon(baseKey0)
                    if canon0 != nil && len(canon0) > 0:
                        baseKey0 = canon0
                if uirCoreStrStartsWith(baseKey0, "ptr_"):
                    baseKey0 = str(ptr_add(void*(baseKey0), 4))

                var objTypeName0: str = ""
                if baseKey0 != nil && len(baseKey0) > 0:
                    if uirCoreHasObjType(b.module, baseKey0):
                        objTypeName0 = baseKey0
                    elif uirCoreStrStartsWith(baseKey0, "seq_") && uirCoreHasObjType(b.module, "seq"):
                        objTypeName0 = "seq"
                    elif uirCoreStrStartsWith(baseKey0, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                        objTypeName0 = "seq"
                    elif uirCoreStrStartsWith(baseKey0, "Table_") && uirCoreHasObjType(b.module, "Table"):
                        objTypeName0 = "Table"

                if objTypeName0 != nil && len(objTypeName0) > 0:
                    let fieldName0: str = backendStripSpaces(plainName(dotMember0))
                    if fieldName0 != nil && len(fieldName0) > 0:
                        let ot0: UirCoreObjType = uirCoreGetObjType(b.module, objTypeName0)
                        var hasField0: bool = false
                        let prefix0: str = fieldName0 + "."
                        for fi0 in 0..<ot0.fields.len:
                            let f0: UirCoreObjField = ot0.fields[fi0]
                            if (f0.name == fieldName0) || uirCoreStrStartsWith(f0.name, prefix0):
                                hasField0 = true
                                break
                        if !hasField0 && moduleHasFuncByBase(b.module, fieldName0):
                            let call2: Node = newNode(nkCall, node.pos)
                            addSon(call2, newIdent(fieldName0, node.pos))
                            let baseArg0: Node = newNode(nkCallArg, node.pos)
                            addSon(baseArg0, dotBase0)
                            addSon(call2, baseArg0)
                            for ai0 in 1..<kidCount(node):
                                addSon(call2, kid(node, ai0))
                            call2.typeCacheValid = node.typeCacheValid
                            call2.typeCache = node.typeCache
                            return lowerExprValue(b, call2, wantType)
                        if !hasField0:
                            let line0: str = intToStr(node.pos.line)
                            let col0: str = intToStr(node.pos.col)
                            return Err[UirCoreExpr]("uirCore_builder: unknown member call '" + fieldName0 +
                                                "' for type '" + objTypeName0 + "' @" + line0 + ":" + col0)
        var name: str = ""
        var typeArgs: Node[]
        if calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
            let base: Node = kid(calleeNode, 0)
            name = backendStripSpaces(plainName(base))
            for ti in 1..<kidCount(calleeNode):
                let t: Node = kid(calleeNode, ti)
                if t != nil && t.kind != nkEmpty:
                    add(typeArgs, t)
        elif calleeNode.kind == nkDotExpr && kidCount(calleeNode) > 1:
            let member: Node = kid(calleeNode, 1)
            if member != nil && member.kind == nkBracketExpr && kidCount(member) > 0:
                let base2: Node = kid(member, 0)
                name = backendStripSpaces(plainName(base2))
                for ti2 in 1..<kidCount(member):
                    let t2: Node = kid(member, ti2)
                    if t2 != nil && t2.kind != nkEmpty:
                        add(typeArgs, t2)
            else:
                name = backendStripSpaces(plainName(member))
        else:
            if calleeNode.kind != nkIdent && calleeNode.kind != nkSymbol:
                var fnName: str = ""
                var fp: str = ""
                if b.func != nil:
                    let f0: UirCoreFunc = b.func
                    fnName = f0.name
                    fp = f0.originFile
                let line: str = intToStr(node.pos.line)
                let col: str = intToStr(node.pos.col)
                let k: str = intToStr(int32(calleeNode.kind))
                return Err[UirCoreExpr]("uirCore_builder: call expects identifier callee (kind=nk#" + k +
                                    " fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")
            name = backendStripSpaces(plainName(calleeNode))
        let localCalleeIdx: int32 = localIndex(b.env, name)
        if localCalleeIdx >= 0:
            let target: str = localCallTarget(b.env, localCalleeIdx)
            if target != nil && len(target) > 0:
                name = target
        # Intrinsics: lower common runtime helpers as pure MIR operations to avoid call overhead.
        if name == "ptr_add":
            if kidCount(node) != 3:
                return Err[UirCoreExpr]("uirCore_builder: ptr_add expects two arguments")
            var baseNode: Node = kid(node, 1)
            if baseNode != nil && baseNode.kind == nkCallArg:
                if kidCount(baseNode) > 1:
                    baseNode = kid(baseNode, 1)
                elif kidCount(baseNode) > 0:
                    baseNode = kid(baseNode, 0)
            var offNode: Node = kid(node, 2)
            if offNode != nil && offNode.kind == nkCallArg:
                if kidCount(offNode) > 1:
                    offNode = kid(offNode, 1)
                elif kidCount(offNode) > 0:
                    offNode = kid(offNode, 0)
            if baseNode == nil || offNode == nil:
                return Err[UirCoreExpr]("uirCore_builder: ptr_add expects non-nil arguments")
            let baseRes: Result[UirCoreExpr] = lowerExprValue(b, baseNode, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](baseRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](baseRes))
            let offRes: Result[UirCoreExpr] = lowerExprValue(b, offNode, uirCoreTypeI32())
            if !IsOk[UirCoreExpr](offRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](offRes))
            let off64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](offRes))
            let sum: UirCoreExpr = uirCoreBin(mbAdd, Value[UirCoreExpr](baseRes), off64)
            if wantType.kind != mtI64:
                return Ok[UirCoreExpr](uirCoreCast(wantType, sum))
            return Ok[UirCoreExpr](sum)
        if name == "xor_0" || name == "bitand_0" || name == "bitor_0" ||
           name == "shl_0" || name == "shr_0" || name == "mul_0" ||
           name == "div_0" || name == "mod_0":
            if kidCount(node) != 3:
                return Err[UirCoreExpr]("uirCore_builder: " + name + " expects two arguments")
            var lhsNode: Node = kid(node, 1)
            if lhsNode != nil && lhsNode.kind == nkCallArg:
                if kidCount(lhsNode) > 1:
                    lhsNode = kid(lhsNode, 1)
                elif kidCount(lhsNode) > 0:
                    lhsNode = kid(lhsNode, 0)
            var rhsNode: Node = kid(node, 2)
            if rhsNode != nil && rhsNode.kind == nkCallArg:
                if kidCount(rhsNode) > 1:
                    rhsNode = kid(rhsNode, 1)
                elif kidCount(rhsNode) > 0:
                    rhsNode = kid(rhsNode, 0)
            if lhsNode == nil || rhsNode == nil:
                return Err[UirCoreExpr]("uirCore_builder: " + name + " expects non-nil arguments")
            let lhsRes: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, uirCoreTypeI32())
            if !IsOk[UirCoreExpr](lhsRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsRes))
            let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI32())
            if !IsOk[UirCoreExpr](rhsRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes))
            var op: UirCoreBinOp = mbAdd
            if name == "xor_0":
                op = mbXor
            elif name == "bitand_0":
                op = mbAnd
            elif name == "bitor_0":
                op = mbOr
            elif name == "shl_0":
                op = mbShl
            elif name == "shr_0":
                op = mbShr
            elif name == "mul_0":
                op = mbMul
            elif name == "div_0":
                op = mbSdiv
            elif name == "mod_0":
                op = mbSmod
            let out0: UirCoreExpr = uirCoreBin(op, Value[UirCoreExpr](lhsRes), Value[UirCoreExpr](rhsRes))
            if wantType.kind != mtI32:
                return Ok[UirCoreExpr](uirCoreCast(wantType, out0))
            return Ok[UirCoreExpr](out0)
        if (name == "add" || name == "seqAdd") && kidCount(node) == 3:
            # Backend intrinsic: append to seq without relying on monomorphized stdlib helpers.
            # `seqAdd` is a legacy alias used by older std/web call sites.
            if b == nil || b.module == nil || !uirCoreHasObjType(b.module, "seq"):
                return Err[UirCoreExpr]("uirCore_builder: " + name + " intrinsic missing seq layout")
            var seqArgNode0: Node = kid(node, 1)
            if seqArgNode0 != nil && seqArgNode0.kind == nkCallArg && kidCount(seqArgNode0) > 1:
                seqArgNode0 = kid(seqArgNode0, 1)
            var valArgNode0: Node = kid(node, 2)
            if valArgNode0 != nil && valArgNode0.kind == nkCallArg && kidCount(valArgNode0) > 1:
                valArgNode0 = kid(valArgNode0, 1)
            if seqArgNode0 == nil || valArgNode0 == nil:
                return Err[UirCoreExpr]("uirCore_builder: " + name + " expects non-nil arguments")
            var elemTypeNode: Node = nil
            if typeArgs.len == 1:
                elemTypeNode = typeArgs[0]
            elif typeArgs.len > 1:
                return Err[UirCoreExpr]("uirCore_builder: " + name + " expects at most one type argument")
            if elemTypeNode == nil || elemTypeNode.kind == nkEmpty:
                var seqKey0: str = uirCoreInferNodeTypeKeyForOverload(b, seqArgNode0)
                if uirCoreStrStartsWith(seqKey0, "ref_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 4))
                elif uirCoreStrStartsWith(seqKey0, "var_ref_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 8))
                elif uirCoreStrStartsWith(seqKey0, "var_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 4))
                if uirCoreStrStartsWith(seqKey0, "ptr_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 4))
                if uirCoreStrStartsWith(seqKey0, "seq_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 4))
                elif uirCoreStrStartsWith(seqKey0, "seq_fixed_"):
                    seqKey0 = str(ptr_add(void*(seqKey0), 10))
                else:
                    seqKey0 = ""
                if seqKey0 != nil && len(seqKey0) > 0:
                    elemTypeNode = newIdent(seqKey0, node.pos)
            if (elemTypeNode == nil || elemTypeNode.kind == nkEmpty):
                var valKey0: str = uirCoreInferNodeTypeKeyForOverload(b, valArgNode0)
                if uirCoreStrStartsWith(valKey0, "ref_"):
                    valKey0 = str(ptr_add(void*(valKey0), 4))
                elif uirCoreStrStartsWith(valKey0, "var_ref_"):
                    valKey0 = str(ptr_add(void*(valKey0), 8))
                elif uirCoreStrStartsWith(valKey0, "var_"):
                    valKey0 = str(ptr_add(void*(valKey0), 4))
                if valKey0 == "void*" || uirCoreStrStartsWith(valKey0, "ptr_"):
                    valKey0 = "ptr"
                if valKey0 != nil && len(valKey0) > 0:
                    elemTypeNode = newIdent(valKey0, node.pos)
            if elemTypeNode != nil && elemTypeNode.kind != nkEmpty:
                let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
                if !IsOk[int32](sizeRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](sizeRes))
                let elemSize: int32 = Value[int32](sizeRes)
                if elemSize <= 0:
                    return Err[UirCoreExpr]("uirCore_builder: " + name + " element size unsupported")
                let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)

                let seqPtrRes0: Result[UirCoreExpr] = lowerExprValue(b, seqArgNode0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](seqPtrRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](seqPtrRes0))
                let seqName0: str = blockBuilderNextTemp(b, "__addptr_seq")
                let seqSlot0: int32 = localAdd(b.env, seqName0, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, seqSlot0, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(seqName0, seqSlot0, Value[UirCoreExpr](seqPtrRes0)))
                let seqPtr: UirCoreExpr = uirCoreLocal(seqSlot0)

                let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
                var lenOff: int32 = -1
                var capOff: int32 = -1
                var bufOff: int32 = -1
                for fi in 0..<seqOt.fields.len:
                    let f: UirCoreObjField = seqOt.fields[fi]
                    if (f.name == "len"):
                        lenOff = f.offset
                    elif (f.name == "cap"):
                        capOff = f.offset
                    elif (f.name == "buffer"):
                        bufOff = f.offset
                if lenOff < 0 || capOff < 0 || bufOff < 0:
                    return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch (" + name + ")")
                let lenAddr: UirCoreExpr = (lenOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(lenOff)))
                let capAddr: UirCoreExpr = (capOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(capOff)))
                let bufAddr: UirCoreExpr = (bufOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(bufOff)))

                let lenVal32: UirCoreExpr = uirCoreLoad(lenAddr, uirCoreTypeI32())
                let capVal32: UirCoreExpr = uirCoreLoad(capAddr, uirCoreTypeI32())
                let growCond: UirCoreExpr = uirCoreCmp(mcGe, uirCoreCast(uirCoreTypeI64(), lenVal32), uirCoreCast(uirCoreTypeI64(), capVal32))

                let growLabel: str = blockBuilderNextLabel(b, "addptr_grow")
                let appendLabel: str = blockBuilderNextLabel(b, "addptr_append")
                blockBuilderFinish(b, uirCoreTermCbr(growCond, growLabel, appendLabel))

                blockBuilderStart(b, growLabel)
                let capValG: UirCoreExpr = uirCoreLoad(capAddr, uirCoreTypeI32())
                let capIsZero: UirCoreExpr = uirCoreCmp(mcEq, uirCoreCast(uirCoreTypeI64(), capValG), uirCoreConstI64(0))
                let capZeroLabel: str = blockBuilderNextLabel(b, "addptr_cap0")
                let capDoubleLabel: str = blockBuilderNextLabel(b, "addptr_cap2x")
                let capJoinLabel: str = blockBuilderNextLabel(b, "addptr_cap_join")

                let newCapName: str = blockBuilderNextTemp(b, "__addptr_newcap")
                let newCapSlot: int32 = localAdd(b.env, newCapName, uirCoreTypeI32())
                uirCoreSetLocalType(b.func, newCapSlot, uirCoreTypeI32())
                add(b.currentStmts, uirCoreStmtLet(newCapName, newCapSlot, uirCoreConstI64(0)))
                blockBuilderFinish(b, uirCoreTermCbr(capIsZero, capZeroLabel, capDoubleLabel))

                blockBuilderStart(b, capZeroLabel)
                add(b.currentStmts, uirCoreStmtAssign(newCapName, newCapSlot, uirCoreConstI64(4)))
                blockBuilderFinish(b, uirCoreTermBr(capJoinLabel))

                blockBuilderStart(b, capDoubleLabel)
                let cap64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), capValG)
                let dbl64: UirCoreExpr = uirCoreBin(mbMul, cap64, uirCoreConstI64(2))
                let dbl32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), dbl64)
                add(b.currentStmts, uirCoreStmtAssign(newCapName, newCapSlot, dbl32))
                blockBuilderFinish(b, uirCoreTermBr(capJoinLabel))

                blockBuilderStart(b, capJoinLabel)
                add(b.currentStmts, uirCoreStmtStore(capAddr, uirCoreLocal(newCapSlot), uirCoreTypeI32()))
                let bufValG: UirCoreExpr = uirCoreLoad(bufAddr, uirCoreTypeI64())
                let newBytes64: UirCoreExpr = uirCoreBin(mbMul, uirCoreCast(uirCoreTypeI64(), uirCoreLocal(newCapSlot)), uirCoreConstI64(int64(elemSize)))
                let newBytes32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), newBytes64)
                var reallocArgs: UirCoreExpr[]
                add(reallocArgs, bufValG)
                add(reallocArgs, newBytes32)
                let newBuf: UirCoreExpr = uirCoreCall("realloc", reallocArgs)
                add(b.currentStmts, uirCoreStmtStore(bufAddr, newBuf, uirCoreTypeI64()))
                blockBuilderFinish(b, uirCoreTermBr(appendLabel))

                blockBuilderStart(b, appendLabel)
                let bufValA: UirCoreExpr = uirCoreLoad(bufAddr, uirCoreTypeI64())
                let lenValA32: UirCoreExpr = uirCoreLoad(lenAddr, uirCoreTypeI32())
                let lenPlus1_32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreBin(mbAdd, uirCoreCast(uirCoreTypeI64(), lenValA32), uirCoreConstI64(1)))
                let elemSize32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreConstI64(int64(elemSize)))
                var setArgs: UirCoreExpr[]
                add(setArgs, bufValA)
                add(setArgs, lenPlus1_32)
                add(setArgs, lenValA32)
                add(setArgs, elemSize32)
                let slotPtr: UirCoreExpr = uirCoreCall("cheng_seq_set", setArgs)

                var elemKey0: str = ""
                if elemTypeNode != nil && (elemTypeNode.kind == nkIdent || elemTypeNode.kind == nkSymbol):
                    elemKey0 = backendStripSpaces(plainName(elemTypeNode))
                if elemKey0 == "bool":
                    let valResB: Result[UirCoreExpr] = lowerExprValue(b, valArgNode0, uirCoreTypeI32())
                    if !IsOk[UirCoreExpr](valResB):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valResB))
                    lowerByteStoreNilChecked(b, slotPtr, Value[UirCoreExpr](valResB), uirCoreTypeI32(), uirCoreTypeU8())
                else:
                    let elemObjName: str = typeNodeObjTypeName(b.module, elemTypeNode)
                    if len(elemObjName) > 0 && typeNodeIsObjValue(b.module, elemTypeNode):
                        let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, valArgNode0, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](srcRes0):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes0))
                        let copyRes0: Result[bool] = emitObjCopyPtrs(b, slotPtr, elemObjName, Value[UirCoreExpr](srcRes0))
                        if !IsOk[bool](copyRes0):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](copyRes0))
                    else:
                        let valRes: Result[UirCoreExpr] = lowerExprValue(b, valArgNode0, elemTy)
                        if !IsOk[UirCoreExpr](valRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes))
                        add(b.currentStmts, uirCoreStmtStore(slotPtr, Value[UirCoreExpr](valRes), elemTy))
                add(b.currentStmts, uirCoreStmtStore(lenAddr, lenPlus1_32, uirCoreTypeI32()))
                return Ok[UirCoreExpr](uirCoreConstI64(0))
        let helperBaseName0: str = uirCoreStripLeadingUnderscores(name)
        let isSetLenHelper0: bool = (helperBaseName0 == "setLen") || uirCoreStrStartsWith(helperBaseName0, "setLen_")
        let isReserveHelper0: bool = (helperBaseName0 == "reserve") || uirCoreStrStartsWith(helperBaseName0, "reserve_")
        if getEnv "BACKEND_DEBUG_DICT_HELPER" == "1":
            let isResultHelperDbg: bool =
                helperBaseName0 == "Ok" || helperBaseName0 == "Err" || helperBaseName0 == "ErrInfo" ||
                uirCoreStrStartsWith(helperBaseName0, "Ok_") ||
                uirCoreStrStartsWith(helperBaseName0, "Err_") ||
                uirCoreStrStartsWith(helperBaseName0, "ErrInfo_")
            let isOptionHelperDbg: bool =
                helperBaseName0 == "Some" || helperBaseName0 == "None" ||
                uirCoreStrStartsWith(helperBaseName0, "Some_") ||
                uirCoreStrStartsWith(helperBaseName0, "None_")
            let isSeqBytesHelperDbg: bool =
                helperBaseName0 == "seqBytesOf" || uirCoreStrStartsWith(helperBaseName0, "seqBytesOf_")
            if isResultHelperDbg || isOptionHelperDbg || isSeqBytesHelperDbg || isSetLenHelper0 || isReserveHelper0:
                echo("[backend] dict_helper_probe mode=" + uirCoreGenericModeNormalized() +
                     " name='" + name + "' base='" + helperBaseName0 + "' kids=" + intToStr(kidCount(node)))
        if (isSetLenHelper0 || isReserveHelper0) && kidCount(node) == 3:
            # Skip-mono compatibility: lower seq helpers without requiring
            # monomorphized stdlib implementations.
            var seqArgNode1: Node = kid(node, 1)
            if seqArgNode1 != nil && seqArgNode1.kind == nkCallArg:
                if kidCount(seqArgNode1) > 1:
                    seqArgNode1 = kid(seqArgNode1, 1)
                elif kidCount(seqArgNode1) > 0:
                    seqArgNode1 = kid(seqArgNode1, 0)
            var sizeArgNode1: Node = kid(node, 2)
            if sizeArgNode1 != nil && sizeArgNode1.kind == nkCallArg:
                if kidCount(sizeArgNode1) > 1:
                    sizeArgNode1 = kid(sizeArgNode1, 1)
                elif kidCount(sizeArgNode1) > 0:
                    sizeArgNode1 = kid(sizeArgNode1, 0)
            if seqArgNode1 == nil || sizeArgNode1 == nil:
                return Err[UirCoreExpr]("uirCore_builder: " + helperBaseName0 + " expects non-nil arguments")
            let capLhs1: Node = newNode(nkDotExpr, node.pos)
            addSon(capLhs1, seqArgNode1)
            addSon(capLhs1, newIdent("cap", node.pos))
            let capGrowRes1: Result[bool] = lowerSeqCapAssignFallback(b, capLhs1, sizeArgNode1)
            if !IsOk[bool](capGrowRes1):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](capGrowRes1))
            if Value[bool](capGrowRes1):
                if isSetLenHelper0:
                    let lenLhs1: Node = newNode(nkDotExpr, node.pos)
                    addSon(lenLhs1, seqArgNode1)
                    addSon(lenLhs1, newIdent("len", node.pos))
                    let lenAccessRes1: Result[DotAccess] = lowerDotAccess(b, lenLhs1)
                    if !IsOk[DotAccess](lenAccessRes1):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[DotAccess](lenAccessRes1))
                    let lenAccess1: DotAccess = Value[DotAccess](lenAccessRes1)
                    let lenValRes1: Result[UirCoreExpr] = lowerExprValue(b, sizeArgNode1, lenAccess1.fieldTy)
                    if !IsOk[UirCoreExpr](lenValRes1):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lenValRes1))
                    add(b.currentStmts, uirCoreStmtStore(lenAccess1.addr, Value[UirCoreExpr](lenValRes1), lenAccess1.fieldTy))
                return Ok[UirCoreExpr](uirCoreConstI64(0))
        if name == "__addr":
            if kidCount(node) < 2:
                return Err[UirCoreExpr]("uirCore_builder: __addr expects one argument")
            var argNode0: Node = kid(node, 1)
            if argNode0 != nil && argNode0.kind == nkCallArg && kidCount(argNode0) > 1:
                argNode0 = kid(argNode0, 1)
            if argNode0 != nil && argNode0.kind == nkDotExpr:
                let daRes: Result[DotAccess] = lowerDotAccess(b, argNode0)
                if !IsOk[DotAccess](daRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[DotAccess](daRes))
                let da: DotAccess = Value[DotAccess](daRes)
                return Ok[UirCoreExpr](da.addr)
            if argNode0 != nil && argNode0.kind == nkBracketExpr && kidCount(argNode0) == 1:
                # `ptr[]` in stage1 AST (dereference); address-of yields the pointer value.
                return lowerExprValue(b, kid(argNode0, 0), uirCoreTypeI64())
            if argNode0 != nil && (argNode0.kind == nkHiddenDeref || argNode0.kind == nkDerefExpr) &&
               kidCount(argNode0) > 0:
                # `*ptr` (deref); address-of yields the pointer value.
                return lowerExprValue(b, kid(argNode0, 0), uirCoreTypeI64())
            if argNode0 == nil || (argNode0.kind != nkIdent && argNode0.kind != nkSymbol):
                let k: str = (argNode0 != nil) ? intToStr(int32(argNode0.kind)) : "0"
                let line: str = (argNode0 != nil) ? intToStr(argNode0.pos.line) : "0"
                let col: str = (argNode0 != nil) ? intToStr(argNode0.pos.col) : "0"
                return Err[UirCoreExpr]("uirCore_builder: __addr expects lvalue (got nk#" + k + " @" + line + ":" + col + ")")
            let nm: str = plainName(argNode0)
            let idx: int32 = localIndex(b.env, nm)
            if idx >= 0:
                if b.func != nil:
                    let fref: UirCoreFunc = b.func
                    let olIdx: int32 = funcFindObjLocal(fref, idx)
                    if olIdx >= 0:
                        let ol: UirCoreObjLocal = fref.objLocals[olIdx]
                        # Object-value locals are represented as pointers to their storage in MIR,
                        # so `__addr(x)` should generally yield that storage pointer (even for
                        # external pointers like the implicit `__ret` param).
                        #
                        # Pointer-like locals (e.g. `T*`, `ref T`, or aliases to those) are also
                        # tracked as objLocals; for them, `__addr(x)` must yield `&x` (slot addr).
                        var key0: str = ol.typeKey
                        if key0 == nil || len(key0) == 0:
                            key0 = localTypeKey(b.env, idx)
                        var baseKey0: str = key0
                        var step0: int32 = 0
                        while baseKey0 != nil && len(baseKey0) > 0 && step0 < 4:
                            if uirCoreStrStartsWith(baseKey0, "var_ref_"):
                                baseKey0 = str(ptr_add(void*(baseKey0), 8))
                            elif uirCoreStrStartsWith(baseKey0, "var_"):
                                baseKey0 = str(ptr_add(void*(baseKey0), 4))
                            else:
                                break
                            step0 = step0 + 1
                        var aliasTy0: UirCoreType = uirCoreTypeVoid()
                        if b.module != nil && baseKey0 != nil && len(baseKey0) > 0:
                            aliasTy0 = uirCoreTryGetTypeAlias(b.module, baseKey0)
                        let isPtrLike0: bool = (baseKey0 != nil && (uirCoreStrStartsWith(baseKey0, "ptr_") || uirCoreStrStartsWith(baseKey0, "ref_"))) ||
                                              aliasTy0.kind != mtVoid
                        if isPtrLike0:
                            return Ok[UirCoreExpr](uirCoreAddr(idx))
                        return Ok[UirCoreExpr](uirCoreLocal(idx))
                return Ok[UirCoreExpr](uirCoreAddr(idx))
            let gi: int32 = moduleGlobalIndex(b.module, nm)
            if gi >= 0:
                let gObj: str = uirCoreGlobalObjTypeGet(nm)
                if len(gObj) > 0:
                    return Ok[UirCoreExpr](uirCoreLoad(uirCoreGlobalAddr(nm), uirCoreTypeI64()))
                return Ok[UirCoreExpr](uirCoreGlobalAddr(nm))
            # Fall back to treating it as a function symbol (e.g. async wrapper takes `__addr(driver)`).
            if moduleHasFuncByBase(b.module, nm):
                var callerFile2: str = ""
                if b != nil && b.func != nil:
                    let fCur2: UirCoreFunc = b.func
                    callerFile2 = fCur2.originFile
                let f1: UirCoreFunc = moduleFindFuncByBasePreferOrigin(b.module, nm, callerFile2)
                if f1 == nil:
                    let line0: str = intToStr(argNode0.pos.line)
                    let col0: str = intToStr(argNode0.pos.col)
                    var fnDbg2: str = ""
                    var fpDbg2: str = ""
                    if b != nil && b.func != nil:
                        let fDbg2: UirCoreFunc = b.func
                        fnDbg2 = fDbg2.name
                        fpDbg2 = fDbg2.originFile
                    return Err[UirCoreExpr]("uirCore_builder: ambiguous function reference: " + nm + " @" + line0 + ":" + col0 +
                                        " (fn=" + fnDbg2 + " " + fpDbg2 + ")")
                let sym: str = (f1.linkName != nil && len(f1.linkName) > 0) ? f1.linkName : f1.name
                return Ok[UirCoreExpr](uirCoreGlobalAddr(sym))
            return Ok[UirCoreExpr](uirCoreGlobalAddr(nm))
        if kidCount(node) == 2 &&
           (name == "int64" || name == "i64" || name == "uint64" || name == "u64" ||
            name == "int32" || name == "i32" || name == "uint32" || name == "u32" ||
            name == "int" || name == "uint" || name == "NI" || name == "NU" ||
            name == "bool" || name == "char" ||
            name == "int8" || name == "uint8" || name == "i8" || name == "u8" ||
            name == "int16" || name == "uint16" || name == "i16" || name == "u16" ||
            name == "float32" || name == "float64" || name == "float" ||
            name == "str" || name == "string" || name == "cstring" ||
            name == "ptr" || name == "void*"):
            let argNode0: Node = kid(node, 1)
            var castArg: Node = argNode0
            if argNode0 != nil && argNode0.kind == nkCallArg:
                if kidCount(argNode0) > 1:
                    castArg = kid(argNode0, 1)
                elif kidCount(argNode0) > 0:
                    castArg = kid(argNode0, 0)
            let castType: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, calleeNode)
            let srcTy: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, castArg, uirCoreTypeI32())
            let srcKey: str = exprTypeKeyShallow(b, castArg)
            var srcIsF64: bool = srcTy.kind == mtF64 || isFloat64Key(srcKey)
            var srcIsF32: bool = srcTy.kind == mtF32 || isFloat32Key(srcKey)
            if (!srcIsF64 && !srcIsF32) && castArg != nil && castArg.kind == nkCall && kidCount(castArg) > 0:
                let srcCallee: Node = kid(castArg, 0)
                let srcCalleeName: str = backendStripSpaces(plainName(srcCallee))
                if srcCalleeName == "float64" || srcCalleeName == "float":
                    srcIsF64 = true
                elif srcCalleeName == "float32":
                    srcIsF32 = true
            let srcIsIntegral: bool = isIntegralUirType(srcTy)
            let dstIsIntegral: bool = isIntegralUirType(castType)

            if dstIsIntegral && (srcIsF64 || srcIsF32):
                let srcWantTy: UirCoreType = srcIsF64 ? uirCoreTypeF64() : uirCoreTypeF32()
                let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, castArg, srcWantTy)
                if !IsOk[UirCoreExpr](srcRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes0))
                let srcExpr0: UirCoreExpr = Value[UirCoreExpr](srcRes0)
                let bitsExpr: UirCoreExpr = srcIsF64 ? uirCoreCast(uirCoreTypeI64(), srcExpr0) : uirCoreCast(uirCoreTypeI32(), srcExpr0)
                var helper0: str = ""
                if srcIsF64:
                    helper0 = castType.isUnsigned ? "cheng_f64_bits_to_u64" : "cheng_f64_bits_to_i64"
                else:
                    helper0 = castType.isUnsigned ? "cheng_f32_bits_to_u64" : "cheng_f32_bits_to_i64"
                var args0: UirCoreExpr[]
                add(args0, bitsExpr)
                let wideInt: UirCoreExpr = uirCoreCall(helper0, args0)
                return Ok[UirCoreExpr](uirCoreCast(castType, wideInt))

            if castType.kind == mtF64 && (srcIsIntegral || srcIsF32):
                if srcIsIntegral:
                    let srcWantTy: UirCoreType = (srcTy.kind == mtI64) ? uirCoreTypeI64() : uirCoreTypeI32()
                    let srcRes1: Result[UirCoreExpr] = lowerExprValue(b, castArg, srcWantTy)
                    if !IsOk[UirCoreExpr](srcRes1):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes1))
                    var srcWide: UirCoreExpr = Value[UirCoreExpr](srcRes1)
                    if srcTy.kind != mtI64:
                        srcWide = uirCoreCast(uirCoreTypeI64(), srcWide)
                    let helper1: str = srcTy.isUnsigned ? "cheng_u64_to_f64_bits" : "cheng_i64_to_f64_bits"
                    var args1: UirCoreExpr[]
                    add(args1, srcWide)
                    return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall(helper1, args1)))
                let srcRes2: Result[UirCoreExpr] = lowerExprValue(b, castArg, uirCoreTypeF32())
                if !IsOk[UirCoreExpr](srcRes2):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes2))
                let srcBits32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](srcRes2))
                var args2: UirCoreExpr[]
                add(args2, srcBits32)
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f32_bits_to_f64_bits", args2)))

            if castType.kind == mtF32 && (srcIsIntegral || srcIsF64):
                var f64BitsExpr: UirCoreExpr
                if srcIsIntegral:
                    let srcWantTy: UirCoreType = (srcTy.kind == mtI64) ? uirCoreTypeI64() : uirCoreTypeI32()
                    let srcRes3: Result[UirCoreExpr] = lowerExprValue(b, castArg, srcWantTy)
                    if !IsOk[UirCoreExpr](srcRes3):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes3))
                    var srcWide2: UirCoreExpr = Value[UirCoreExpr](srcRes3)
                    if srcTy.kind != mtI64:
                        srcWide2 = uirCoreCast(uirCoreTypeI64(), srcWide2)
                    let helper2: str = srcTy.isUnsigned ? "cheng_u64_to_f64_bits" : "cheng_i64_to_f64_bits"
                    var args3: UirCoreExpr[]
                    add(args3, srcWide2)
                    f64BitsExpr = uirCoreCall(helper2, args3)
                else:
                    let srcRes4: Result[UirCoreExpr] = lowerExprValue(b, castArg, uirCoreTypeF64())
                    if !IsOk[UirCoreExpr](srcRes4):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](srcRes4))
                    f64BitsExpr = uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](srcRes4))
                var args4: UirCoreExpr[]
                add(args4, f64BitsExpr)
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF32(), uirCoreCall("cheng_f64_bits_to_f32_bits", args4)))

            let castRes: Result[UirCoreExpr] = lowerExprValue(b, castArg, wantType)
            if ! IsOk[UirCoreExpr](castRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](castRes))
            return Ok[UirCoreExpr](uirCoreCast(castType, Value[UirCoreExpr](castRes)))
        var callName0: str = name
        if typeArgs.len > 0:
            callName0 = mangleInstance(name, typeArgs)
        let helperCallName0: str = uirCoreStripLeadingUnderscores(callName0)

        if uirCoreDictHelperClosureEnabled() && kidCount(node) == 2:
            var helperArg0: Node = kid(node, 1)
            if helperArg0 != nil && helperArg0.kind == nkCallArg:
                if kidCount(helperArg0) > 1:
                    helperArg0 = kid(helperArg0, 1)
                elif kidCount(helperArg0) > 0:
                    helperArg0 = kid(helperArg0, 0)
            if helperArg0 != nil:
                let isValueHelper0: bool = helperCallName0 == "Value" || uirCoreStrStartsWith(helperCallName0, "Value_")
                if isValueHelper0:
                    let valueDot0: Node = newNode(nkDotExpr, node.pos)
                    addSon(valueDot0, helperArg0)
                    addSon(valueDot0, newIdent("value", node.pos))
                    return lowerExprValue(b, valueDot0, wantType)

                let isErrorInfoHelper0: bool = helperCallName0 == "ErrorInfoOf" ||
                                               uirCoreStrStartsWith(helperCallName0, "ErrorInfoOf_")
                if isErrorInfoHelper0:
                    let errDot0: Node = newNode(nkDotExpr, node.pos)
                    addSon(errDot0, helperArg0)
                    addSon(errDot0, newIdent("err", node.pos))
                    return lowerExprValue(b, errDot0, wantType)

                let isIsOkHelper0: bool = helperCallName0 == "IsOk" || uirCoreStrStartsWith(helperCallName0, "IsOk_")
                let isIsErrHelper0: bool = helperCallName0 == "IsErr" || uirCoreStrStartsWith(helperCallName0, "IsErr_")
                if isIsOkHelper0 || isIsErrHelper0:
                    let okDot0: Node = newNode(nkDotExpr, node.pos)
                    addSon(okDot0, helperArg0)
                    addSon(okDot0, newIdent("ok", node.pos))
                    let okRes0: Result[UirCoreExpr] = lowerExprValue(b, okDot0, uirCoreTypeI32())
                    if !IsOk[UirCoreExpr](okRes0):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](okRes0))
                    var boolExpr0: UirCoreExpr = uirCoreCmp(mcNe, uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](okRes0)), uirCoreConstI64(0))
                    if isIsErrHelper0:
                        boolExpr0 = uirCoreCmp(mcEq, uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](okRes0)), uirCoreConstI64(0))
                    if wantType.kind != mtI32 || wantType.isUnsigned:
                        return Ok[UirCoreExpr](uirCoreCast(wantType, boolExpr0))
                    return Ok[UirCoreExpr](boolExpr0)

        # Skip-mono/dict mode can leave generic helper calls unresolved.
        # Lower helper families structurally to object constructors.
        if uirCoreDictHelperClosureEnabled() && b.module != nil:
            if kidCount(node) == 2:
                var ctorKind0: int32 = 0
                var resultSuffix0: str = ""
                if uirCoreStrStartsWith(helperCallName0, "Ok_"):
                    ctorKind0 = 1
                    resultSuffix0 = str(ptr_add(void*(helperCallName0), 3))
                elif uirCoreStrStartsWith(helperCallName0, "Err_"):
                    ctorKind0 = 2
                    resultSuffix0 = str(ptr_add(void*(helperCallName0), 4))
                elif uirCoreStrStartsWith(helperCallName0, "ErrInfo_"):
                    ctorKind0 = 3
                    resultSuffix0 = str(ptr_add(void*(helperCallName0), 8))
                if ctorKind0 <= 0:
                    if helperCallName0 == "Ok":
                        ctorKind0 = 1
                    elif helperCallName0 == "Err":
                        ctorKind0 = 2
                    elif helperCallName0 == "ErrInfo":
                        ctorKind0 = 3
                    if ctorKind0 > 0:
                        resultSuffix0 = uirCoreInferCtorSuffixFromTypeCache(b, node, "Result_")
                if ctorKind0 > 0 && resultSuffix0 != nil && len(resultSuffix0) > 0:
                    let resultObjName0: str = "Result_" + resultSuffix0
                    if !uirCoreHasObjType(b.module, resultObjName0):
                        let _ensResult0: bool = ensureResultObjType(b.module, resultObjName0)
                    if uirCoreHasObjType(b.module, resultObjName0):
                        var payloadNode0: Node = kid(node, 1)
                        if payloadNode0 != nil && payloadNode0.kind == nkCallArg:
                            if kidCount(payloadNode0) > 1:
                                payloadNode0 = kid(payloadNode0, 1)
                            elif kidCount(payloadNode0) > 0:
                                payloadNode0 = kid(payloadNode0, 0)
                        var payloadExpr0: Node = payloadNode0
                        if ctorKind0 == 2:
                            # Err[T](msg) expects `err: ErrorInfo`.
                            var errCtor0: Node = newNode(nkCall, node.pos)
                            addSon(errCtor0, newIdent("ErrorInfo", node.pos))
                            var errCodeArg0: Node = newNode(nkCallArg, node.pos)
                            addSon(errCodeArg0, newIdent("code", node.pos))
                            addSon(errCodeArg0, newIntLit(0, node.pos))
                            addSon(errCtor0, errCodeArg0)
                            var errMsgArg0: Node = newNode(nkCallArg, node.pos)
                            addSon(errMsgArg0, newIdent("msg", node.pos))
                            addSon(errMsgArg0, payloadNode0)
                            addSon(errCtor0, errMsgArg0)
                            payloadExpr0 = errCtor0

                        var ctorCall0: Node = newNode(nkCall, node.pos)
                        addSon(ctorCall0, newIdent(resultObjName0, node.pos))
                        var okArg0: Node = newNode(nkCallArg, node.pos)
                        addSon(okArg0, newIdent("ok", node.pos))
                        if ctorKind0 == 1:
                            addSon(okArg0, newBoolLit(true, node.pos))
                        else:
                            addSon(okArg0, newBoolLit(false, node.pos))
                        addSon(ctorCall0, okArg0)
                        var payloadArg0: Node = newNode(nkCallArg, node.pos)
                        if ctorKind0 == 1:
                            addSon(payloadArg0, newIdent("value", node.pos))
                        else:
                            addSon(payloadArg0, newIdent("err", node.pos))
                        addSon(payloadArg0, payloadExpr0)
                        addSon(ctorCall0, payloadArg0)
                        return lowerObjConstructorCall(b, ctorCall0, resultObjName0)

            var optionCtorKind0: int32 = 0
            var optionSuffix0: str = ""
            if kidCount(node) == 2 && uirCoreStrStartsWith(helperCallName0, "Some_"):
                optionCtorKind0 = 1
                optionSuffix0 = str(ptr_add(void*(helperCallName0), 5))
            elif kidCount(node) == 1 && uirCoreStrStartsWith(helperCallName0, "None_"):
                optionCtorKind0 = 2
                optionSuffix0 = str(ptr_add(void*(helperCallName0), 5))
            if optionCtorKind0 <= 0:
                if kidCount(node) == 2 && helperCallName0 == "Some":
                    optionCtorKind0 = 1
                    optionSuffix0 = uirCoreInferCtorSuffixFromTypeCache(b, node, "Option_")
                elif kidCount(node) == 1 && helperCallName0 == "None":
                    optionCtorKind0 = 2
                    optionSuffix0 = uirCoreInferCtorSuffixFromTypeCache(b, node, "Option_")
            if optionCtorKind0 > 0 && optionSuffix0 != nil && len(optionSuffix0) > 0:
                let optionObjName0: str = "Option_" + optionSuffix0
                if !uirCoreHasObjType(b.module, optionObjName0):
                    let _ensOption0: bool = ensureOptionObjType(b.module, optionObjName0)
                if uirCoreHasObjType(b.module, optionObjName0):
                    var ctorCall1: Node = newNode(nkCall, node.pos)
                    addSon(ctorCall1, newIdent(optionObjName0, node.pos))
                    var hasArg1: Node = newNode(nkCallArg, node.pos)
                    addSon(hasArg1, newIdent("has", node.pos))
                    addSon(hasArg1, newBoolLit(optionCtorKind0 == 1, node.pos))
                    addSon(ctorCall1, hasArg1)
                    if optionCtorKind0 == 1:
                        var payloadNode1: Node = kid(node, 1)
                        if payloadNode1 != nil && payloadNode1.kind == nkCallArg:
                            if kidCount(payloadNode1) > 1:
                                payloadNode1 = kid(payloadNode1, 1)
                            elif kidCount(payloadNode1) > 0:
                                payloadNode1 = kid(payloadNode1, 0)
                        var payloadArg1: Node = newNode(nkCallArg, node.pos)
                        addSon(payloadArg1, newIdent("value", node.pos))
                        addSon(payloadArg1, payloadNode1)
                        addSon(ctorCall1, payloadArg1)
                    return lowerObjConstructorCall(b, ctorCall1, optionObjName0)

        # Keep `__seqBytesOf[T](n)` available when generic helper emission is skipped.
        if uirCoreDictHelperClosureEnabled() && kidCount(node) == 2 &&
           (helperCallName0 == "seqBytesOf" ||
            uirCoreStrStartsWith(helperCallName0, "seqBytesOf_")):
            var elemTypeNode0: Node = nil
            if typeArgs.len == 1:
                elemTypeNode0 = typeArgs[0]
            elif uirCoreStrStartsWith(helperCallName0, "seqBytesOf_"):
                let elemKey0: str = str(ptr_add(void*(helperCallName0), 11))
                if elemKey0 != nil && len(elemKey0) > 0:
                    elemTypeNode0 = newIdent(elemKey0, node.pos)
            if elemTypeNode0 != nil && elemTypeNode0.kind != nkEmpty:
                let elemSizeRes0: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode0)
                if !IsOk[int32](elemSizeRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](elemSizeRes0))
                let elemSize0: int32 = Value[int32](elemSizeRes0)
                if elemSize0 > 0:
                    var countNode0: Node = kid(node, 1)
                    if countNode0 != nil && countNode0.kind == nkCallArg:
                        if kidCount(countNode0) > 1:
                            countNode0 = kid(countNode0, 1)
                        elif kidCount(countNode0) > 0:
                            countNode0 = kid(countNode0, 0)
                    let countRes0: Result[UirCoreExpr] = lowerExprValue(b, countNode0, uirCoreTypeI32())
                    if !IsOk[UirCoreExpr](countRes0):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](countRes0))
                    let bytes64_0: UirCoreExpr = uirCoreBin(mbMul,
                        uirCoreCast(uirCoreTypeI64(), Value[UirCoreExpr](countRes0)),
                        uirCoreConstI64(int64(elemSize0)))
                    let bytes32_0: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), bytes64_0)
                    if wantType.kind != mtI32:
                        return Ok[UirCoreExpr](uirCoreCast(wantType, bytes32_0))
                    return Ok[UirCoreExpr](bytes32_0)
        if kidCount(node) == 2 && b.module != nil:
            let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(b.module, callName0)
            if aliasTy.kind != mtVoid:
                let argNode0: Node = kid(node, 1)
                var castArg: Node = argNode0
                if argNode0 != nil && argNode0.kind == nkCallArg:
                    if kidCount(argNode0) > 1:
                        castArg = kid(argNode0, 1)
                    elif kidCount(argNode0) > 0:
                        castArg = kid(argNode0, 0)
                let castRes: Result[UirCoreExpr] = lowerExprValue(b, castArg, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](castRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](castRes))
                return Ok[UirCoreExpr](uirCoreCast(aliasTy, Value[UirCoreExpr](castRes)))
        if b.module != nil && uirCoreHasObjType(b.module, callName0):
            let ot0: UirCoreObjType = uirCoreGetObjType(b.module, callName0)
            if (getEnv "BACKEND_DEBUG_OBJCAST" == "1") && (callName0 == "Node"):
                var fp0: str = ""
                var fn0: str = ""
                if b != nil && b.func != nil:
                    let bf0: UirCoreFunc = b.func
                    fp0 = bf0.originFile
                    fn0 = bf0.name
                let line0: str = (node != nil) ? intToStr(node.pos.line) : "0"
                let col0: str = (node != nil) ? intToStr(node.pos.col) : "0"
                echo("[backend] debug: Node-call fn=" + fn0 + " " + fp0 + ":" + line0 + ":" + col0 +
                     " kids=" + intToStr(kidCount(node)))
                for di0 in 0..<kidCount(node):
                    let ch0: Node = kid(node, di0)
                    let k0: str = (ch0 != nil) ? intToStr(int32(ch0.kind)) : "nil"
                    var extra0: str = ""
                    if ch0 != nil && (ch0.kind == nkIdent || ch0.kind == nkSymbol):
                        extra0 = " name=" + plainName(ch0)
                    if ch0 != nil && ch0.kind == nkCallArg:
                        extra0 = extra0 + " callarg_kids=" + intToStr(kidCount(ch0))
                        if kidCount(ch0) > 0:
                            let kn0: Node = kid(ch0, 0)
                            if kn0 != nil && (kn0.kind == nkIdent || kn0.kind == nkSymbol):
                                extra0 = extra0 + " key=" + plainName(kn0)
                    echo("[backend] debug:  kid#" + intToStr(di0) + " kind=" + k0 + extra0)
            var hasNamedArgs: bool = false
            var hasFieldNamedArgs: bool = false
            for nai in 1..<kidCount(node):
                let an: Node = kid(node, nai)
                if an != nil && an.kind == nkCallArg && kidCount(an) > 1:
                    let keyNode: Node = kid(an, 0)
                    if keyNode != nil && (keyNode.kind == nkIdent || keyNode.kind == nkSymbol):
                        let keyName: str = plainName(keyNode)
                        if len(keyName) > 0 && !(keyName == "_"):
                            hasNamedArgs = true
                            let keyPrefix: str = keyName + "."
                            for fi in 0..<ot0.fields.len:
                                let f: UirCoreObjField = ot0.fields[fi]
                                if (f.name == keyName) || uirCoreStrStartsWith(f.name, keyPrefix):
                                    hasFieldNamedArgs = true
                                    break
                            if hasFieldNamedArgs:
                                break
            # Type conversions use `T(x)` while object construction should use named fields.
            # Treat the 1-arg form as a cast/reinterpretation by default. Allow a single-field
            # object constructor only when the argument key matches the lone field.
            if kidCount(node) == 2:
                if hasNamedArgs:
                    return lowerObjConstructorCall(b, node, callName0)
                var aliasTy: UirCoreType = uirCoreTryGetTypeAlias(b.module, callName0)
                if aliasTy.kind == mtVoid:
                    aliasTy = uirCoreTypeI64()
                let argNode0: Node = kid(node, 1)
                var castArg: Node = argNode0
                if argNode0 != nil && argNode0.kind == nkCallArg:
                    if kidCount(argNode0) > 1:
                        castArg = kid(argNode0, 1)
                    elif kidCount(argNode0) > 0:
                        castArg = kid(argNode0, 0)
                let castRes: Result[UirCoreExpr] = lowerExprValue(b, castArg, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](castRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](castRes))
                return Ok[UirCoreExpr](uirCoreCast(aliasTy, Value[UirCoreExpr](castRes)))
            if hasNamedArgs:
                return lowerObjConstructorCall(b, node, callName0)
            return lowerObjConstructorCallPositional(b, node, callName0)
        # Some stage1 wrappers (e.g. `Foo__wrap_*`) construct object values via the implicit `__ret`.
        # Their return type is encoded in the name prefix before `__wrap_`.
        if b.module != nil:
            let wrapIdx: int32 = uirCoreStrIndexOf(callName0, "__wrap_")
            if wrapIdx > 0:
                let objCand: str = uirCoreStrTake(callName0, wrapIdx)
                if len(objCand) > 0 && uirCoreHasObjType(b.module, objCand):
                    let tmpName: str = blockBuilderNextTemp(b, "__callret")
                    let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                    uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                    localSetTypeKey(b.env, tmpSlot, objCand)
                    let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objCand)
                    if ! IsOk[bool](allocRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                    return lowerCallWithLeadingArg(b, node, uirCoreLocal(tmpSlot))
        # Object-return calls use an implicit leading `__ret` pointer argument.
        if node.typeCacheValid && node.typeCache != nil &&
           !(callName0 == "Value" && kidCount(node) == 2):
            let retObjName: str = typeNodeObjTypeName(b.module, node.typeCache)
            if len(retObjName) > 0 && typeNodeIsObjValue(b.module, node.typeCache):
                if getEnv "BACKEND_DEBUG_OBJRET_CALL" == "1":
                    echo("[backend] debugObjRetCall: callName0='" + callName0 + "' retObj='" + retObjName + "'")
                let tmpName: str = blockBuilderNextTemp(b, "__callret")
                let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, retObjName)
                if ! IsOk[bool](allocRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                # If the callee is a function pointer (e.g. `svc.handler(req)` or `handlerFn(req)`),
                # lower as an indirect call.
                var isIndirect0: bool = false
                var callee0: Node = calleeNode
                while callee0 != nil && callee0.kind == nkPar && kidCount(callee0) > 0:
                    callee0 = kid(callee0, 0)
                if callee0 != nil && (callee0.kind == nkIdent || callee0.kind == nkSymbol):
                    let nm0: str = plainName(callee0)
                    if localIndex(b.env, nm0) >= 0:
                        isIndirect0 = true
                elif callee0 != nil && callee0.kind == nkDotExpr && kidCount(callee0) > 1:
                    var base0: Node = kid(callee0, 0)
                    while base0 != nil && base0.kind == nkPar && kidCount(base0) > 0:
                        base0 = kid(base0, 0)
                    var baseKey0: str = caseInferExprTypeKey(b, base0)
                    if uirCoreStrStartsWith(baseKey0, "ref_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    elif uirCoreStrStartsWith(baseKey0, "var_ref_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 8))
                    elif uirCoreStrStartsWith(baseKey0, "var_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    if baseKey0 != nil && len(baseKey0) > 0:
                        let canon0: str = uirCoreObjAliasCanon(baseKey0)
                        if canon0 != nil && len(canon0) > 0:
                            baseKey0 = canon0
                    if uirCoreStrStartsWith(baseKey0, "ptr_"):
                        baseKey0 = str(ptr_add(void*(baseKey0), 4))
                    if (baseKey0 != nil && len(baseKey0) > 0 && uirCoreHasObjType(b.module, baseKey0)) ||
                       (uirCoreStrStartsWith(baseKey0, "seq_") && uirCoreHasObjType(b.module, "seq")) ||
                       (uirCoreStrStartsWith(baseKey0, "seq_fixed_") && uirCoreHasObjType(b.module, "seq")) ||
                       (uirCoreStrStartsWith(baseKey0, "Table_") && uirCoreHasObjType(b.module, "Table")):
                        isIndirect0 = true
                if !isIndirect0:
                    var calleeKey0: str = caseInferExprTypeKey(b, callee0)
                    if uirCoreStrStartsWith(calleeKey0, "ref_"):
                        calleeKey0 = str(ptr_add(void*(calleeKey0), 4))
                    elif uirCoreStrStartsWith(calleeKey0, "var_ref_"):
                        calleeKey0 = str(ptr_add(void*(calleeKey0), 8))
                    elif uirCoreStrStartsWith(calleeKey0, "var_"):
                        calleeKey0 = str(ptr_add(void*(calleeKey0), 4))
                    if uirCoreStrStartsWith(calleeKey0, "ptr_"):
                        calleeKey0 = str(ptr_add(void*(calleeKey0), 4))
                    if uirCoreStrStartsWith(calleeKey0, "fn") || uirCoreStrStartsWith(calleeKey0, "fn_"):
                        isIndirect0 = true
                if isIndirect0:
                    let dbgIndirect0: bool = (getEnv "BACKEND_DEBUG_INDIRECT" == "1")
                    if dbgIndirect0:
                        let dbgName0: str = getEnv "BACKEND_DEBUG_INDIRECT_NAME"
                        var calleeNm0: str = ""
                        if callee0 != nil && (callee0.kind == nkIdent || callee0.kind == nkSymbol):
                            calleeNm0 = backendStripSpaces(plainName(callee0))
                        elif callee0 != nil && callee0.kind == nkDotExpr && kidCount(callee0) > 1:
                            let mem0: Node = kid(callee0, 1)
                            if mem0 != nil && (mem0.kind == nkIdent || mem0.kind == nkSymbol):
                                calleeNm0 = backendStripSpaces(plainName(mem0))
                        if dbgName0 == nil || len(dbgName0) == 0 || (calleeNm0 == dbgName0):
                            var fn0: str = ""
                            var fp0: str = ""
                            if b != nil && b.func != nil:
                                let f0: UirCoreFunc = b.func
                                fn0 = f0.name
                                fp0 = f0.originFile
                            let line0: str = intToStr(node.pos.line)
                            let col0: str = intToStr(node.pos.col)
                            echo("[backend] debugIndirect(objret): callee='" + calleeNm0 + "' isIndirect=1 fn=" + fn0 +
                                 " " + fp0 + ":" + line0 + ":" + col0)
                    var argNodes0: Node[]
                    for ai0 in 1..<kidCount(node):
                        var argNode0: Node = kid(node, ai0)
                        if argNode0 != nil && argNode0.kind == nkCallArg:
                            if kidCount(argNode0) > 1:
                                argNode0 = kid(argNode0, 1)
                            elif kidCount(argNode0) > 0:
                                argNode0 = kid(argNode0, 0)
                        add(argNodes0, argNode0)

                    let fnPtrRes0: Result[UirCoreExpr] = lowerExprValue(b, calleeNode, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](fnPtrRes0):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](fnPtrRes0))
                    var indArgs: UirCoreExpr[]
                    add(indArgs, Value[UirCoreExpr](fnPtrRes0))
                    add(indArgs, uirCoreLocal(tmpSlot))
                    for xi0 in 0..<argNodes0.len:
                        let argNode1: Node = argNodes0[xi0]
                        let argRes0: Result[UirCoreExpr] = lowerExprValue(b, argNode1, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](argRes0):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes0))
                        add(indArgs, Value[UirCoreExpr](argRes0))
                    let indName0: str = "__cheng_call_indirect_" + intToStr(indArgs.len - 1)
                    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(indName0, indArgs)))
                    return Ok[UirCoreExpr](uirCoreLocal(tmpSlot))
                return lowerCallWithLeadingArg(b, node, uirCoreLocal(tmpSlot))

        var argNodes: Node[]
        for ai in 1..<kidCount(node):
            var argNode: Node = kid(node, ai)
            if argNode != nil && argNode.kind == nkCallArg:
                if kidCount(argNode) > 1:
                    argNode = kid(argNode, 1)
                elif kidCount(argNode) > 0:
                    argNode = kid(argNode, 0)
            add(argNodes, argNode)

        # Some stage1 paths rewrite bracket access to a plain call (`[](base, idx)`).
        # For seq-like bases we want builtin indexed load lowering, not overload lookup.
        if name == "[]" && typeArgs.len == 0 && argNodes.len == 2:
            var baseKeyBr: str = uirCoreInferNodeTypeKeyForOverload(b, argNodes[0])
            if uirCoreStrStartsWith(baseKeyBr, "var_ref_"):
                baseKeyBr = str(ptr_add(void*(baseKeyBr), 8))
            elif uirCoreStrStartsWith(baseKeyBr, "var_") || uirCoreStrStartsWith(baseKeyBr, "ref_"):
                baseKeyBr = str(ptr_add(void*(baseKeyBr), 4))
            if uirCoreStrStartsWith(baseKeyBr, "ptr_"):
                baseKeyBr = str(ptr_add(void*(baseKeyBr), 4))
            if uirCoreStrStartsWith(baseKeyBr, "seq_") || uirCoreStrStartsWith(baseKeyBr, "seq_fixed_"):
                let brNode: Node = newNode(nkBracketExpr, node.pos)
                brNode.typeCacheValid = node.typeCacheValid
                brNode.typeCache = node.typeCache
                addSon(brNode, argNodes[0])
                addSon(brNode, argNodes[1])
                return lowerExprValue(b, brNode, wantType)

        # Structural Result-like builtins: prefer field-based lowering over missing monomorphized helpers.
        if b.module != nil && argNodes.len == 1:
            let arg0: Node = argNodes[0]
            if arg0 != nil:
                var arg0Key: str = uirCoreInferNodeTypeKeyForOverload(b, arg0)
                if uirCoreStrStartsWith(arg0Key, "ref_"):
                    arg0Key = str(ptr_add(void*(arg0Key), 4))
                elif uirCoreStrStartsWith(arg0Key, "var_ref_"):
                    arg0Key = str(ptr_add(void*(arg0Key), 8))
                elif uirCoreStrStartsWith(arg0Key, "var_"):
                    arg0Key = str(ptr_add(void*(arg0Key), 4))
                if uirCoreStrStartsWith(arg0Key, "ptr_"):
                    arg0Key = str(ptr_add(void*(arg0Key), 4))
                if uirCoreHasObjType(b.module, arg0Key):
                    let ot0: UirCoreObjType = uirCoreGetObjType(b.module, arg0Key)
                    var hasOk: bool = false
                    var hasValue: bool = false
                    var hasErr: bool = false
                    for fi0 in 0..<ot0.fields.len:
                        let f0: UirCoreObjField = ot0.fields[fi0]
                        if (f0.name == "ok"):
                            hasOk = true
                        elif (f0.name == "value") || uirCoreStrStartsWith(f0.name, "value."):
                            hasValue = true
                        elif (f0.name == "err") || uirCoreStrStartsWith(f0.name, "err."):
                            hasErr = true
                        if hasOk && hasValue && hasErr:
                            break
                    var resultLike: bool = hasValue &&
                        (hasOk || hasErr || arg0Key == "Result" || uirCoreStrStartsWith(arg0Key, "Result_"))
                    if resultLike:
                        if name == "Value":
                            let dotNode0: Node = newNode(nkDotExpr, node.pos)
                            addSon(dotNode0, arg0)
                            addSon(dotNode0, newIdent("value", node.pos))
                            return lowerExprValue(b, dotNode0, wantType)
                        if name == "ErrorInfoOf" && hasErr:
                            let dotNode1: Node = newNode(nkDotExpr, node.pos)
                            addSon(dotNode1, arg0)
                            addSon(dotNode1, newIdent("err", node.pos))
                            return lowerExprValue(b, dotNode1, wantType)
                        if name == "IsOk" && hasOk:
                            let dotNode2: Node = newNode(nkDotExpr, node.pos)
                            addSon(dotNode2, arg0)
                            addSon(dotNode2, newIdent("ok", node.pos))
                            return lowerExprValue(b, dotNode2, wantType)
                        if name == "IsErr" && hasOk:
                            let dotNode3: Node = newNode(nkDotExpr, node.pos)
                            addSon(dotNode3, arg0)
                            addSon(dotNode3, newIdent("ok", node.pos))
                            let notNode: Node = newNode(nkPrefix, node.pos)
                            addSon(notNode, newIdent("!", node.pos))
                            addSon(notNode, dotNode3)
                            return lowerExprValue(b, notNode, wantType)
                        if name == "Error" && hasErr:
                            let dotNode4: Node = newNode(nkDotExpr, node.pos)
                            addSon(dotNode4, arg0)
                            addSon(dotNode4, newIdent("err", node.pos))
                            if moduleHasFuncByBase(b.module, "ErrorMessage"):
                                let errCall0: Node = newNode(nkCall, node.pos)
                                addSon(errCall0, newIdent("ErrorMessage", node.pos))
                                addSon(errCall0, dotNode4)
                                return lowerExprValue(b, errCall0, wantType)
                            if moduleHasFuncByBase(b.module, "Lp2pErrorMessage"):
                                let errCall1: Node = newNode(nkCall, node.pos)
                                addSon(errCall1, newIdent("Lp2pErrorMessage", node.pos))
                                addSon(errCall1, dotNode4)
                                return lowerExprValue(b, errCall1, wantType)
                            if uirCoreHasObjType(b.module, "ErrorInfo"):
                                let msgNode0: Node = newNode(nkDotExpr, node.pos)
                                addSon(msgNode0, dotNode4)
                                addSon(msgNode0, newIdent("msg", node.pos))
                                return lowerExprValue(b, msgNode0, wantType)

        # Legacy fallback: lower unresolved `Value(x)` from Result-like object layout.
        if b.module != nil && name == "Value" && argNodes.len == 1:
            let baseNode: Node = argNodes[0]
            if baseNode != nil:
                var baseKey: str = uirCoreInferNodeTypeKeyForOverload(b, baseNode)
                if uirCoreStrStartsWith(baseKey, "ref_"):
                    baseKey = str(ptr_add(void*(baseKey), 4))
                elif uirCoreStrStartsWith(baseKey, "var_ref_"):
                    baseKey = str(ptr_add(void*(baseKey), 8))
                elif uirCoreStrStartsWith(baseKey, "var_"):
                    baseKey = str(ptr_add(void*(baseKey), 4))
                if uirCoreStrStartsWith(baseKey, "ptr_"):
                    baseKey = str(ptr_add(void*(baseKey), 4))
                let objName1: str = uirCoreObjTypeFromTypeKey(b.module, baseKey)
                var hasOk1: bool = false
                var hasErr1: bool = false
                var valueOff1: int32 = -1
                var valueTy1: UirCoreType = uirCoreTypeVoid()
                var valueKey1: str = ""
                if objName1 != nil && len(objName1) > 0 && uirCoreHasObjType(b.module, objName1):
                    let ot1: UirCoreObjType = uirCoreGetObjType(b.module, objName1)
                    for fi1 in 0..<ot1.fields.len:
                        let f1: UirCoreObjField = ot1.fields[fi1]
                        if (f1.name == "ok"):
                            hasOk1 = true
                        elif (f1.name == "err") || uirCoreStrStartsWith(f1.name, "err."):
                            hasErr1 = true
                        elif ((f1.name == "value") || uirCoreStrStartsWith(f1.name, "value.")) && valueOff1 < 0:
                            valueOff1 = f1.offset
                            valueTy1 = f1.ty
                            valueKey1 = uirCoreObjFieldTypeKeyGet(objName1, "value")
                if valueOff1 < 0 && uirCoreStrStartsWith(baseKey, "Result_"):
                    valueOff1 = 0
                    hasErr1 = true
                    let baseValKey1: str = str(ptr_add(void*(baseKey), 7))
                    if baseValKey1 != nil && len(baseValKey1) > 0:
                        valueKey1 = baseValKey1
                var resultLike1: bool = false
                if valueOff1 >= 0:
                    if hasOk1 || hasErr1:
                        resultLike1 = true
                    elif objName1 == "Result" || uirCoreStrStartsWith(objName1, "Result_") || uirCoreStrStartsWith(baseKey, "Result_"):
                        resultLike1 = true
                if resultLike1:
                    let baseRes1: Result[UirCoreExpr] = lowerExprValue(b, baseNode, uirCoreTypeI64())
                    if IsOk[UirCoreExpr](baseRes1):
                        let basePtr1: UirCoreExpr = Value[UirCoreExpr](baseRes1)
                        var valueAddr1: UirCoreExpr = basePtr1
                        if valueOff1 != 0:
                            valueAddr1 = uirCoreBin(mbAdd, basePtr1, uirCoreConstI64(int64(valueOff1)))
                        var outTy1: UirCoreType = wantType
                        if outTy1.kind == mtVoid && valueTy1.kind != mtVoid:
                            outTy1 = valueTy1
                        if outTy1.kind == mtVoid && valueKey1 != nil && len(valueKey1) > 0:
                            outTy1 = uirCoreTypeFromNodeWithModule(b.module, newIdent(valueKey1, node.pos))
                        if outTy1.kind == mtVoid:
                            let innerKey1: str = uirCoreInferValueCallInnerKey(b, node)
                            if innerKey1 != nil && len(innerKey1) > 0:
                                outTy1 = uirCoreTypeFromNodeWithModule(b.module, newIdent(innerKey1, node.pos))
                        if outTy1.kind == mtVoid:
                            outTy1 = uirCoreTypeI64()
                        return Ok[UirCoreExpr](uirCoreLoad(valueAddr1, outTy1))

        # Indirect call: callee is a function pointer expression (stored in a local/field).
        if b.module != nil:
            var isIndirect: bool = false
            var callee1: Node = calleeNode
            while callee1 != nil && callee1.kind == nkPar && kidCount(callee1) > 0:
                callee1 = kid(callee1, 0)
            if callee1 != nil && (callee1.kind == nkIdent || callee1.kind == nkSymbol):
                let nm1: str = plainName(callee1)
                if localIndex(b.env, nm1) >= 0:
                    isIndirect = true
            elif callee1 != nil && callee1.kind == nkDotExpr && kidCount(callee1) > 1:
                var base1: Node = kid(callee1, 0)
                while base1 != nil && base1.kind == nkPar && kidCount(base1) > 0:
                    base1 = kid(base1, 0)
                var baseKey1: str = caseInferExprTypeKey(b, base1)
                if uirCoreStrStartsWith(baseKey1, "ref_"):
                    baseKey1 = str(ptr_add(void*(baseKey1), 4))
                elif uirCoreStrStartsWith(baseKey1, "var_ref_"):
                    baseKey1 = str(ptr_add(void*(baseKey1), 8))
                elif uirCoreStrStartsWith(baseKey1, "var_"):
                    baseKey1 = str(ptr_add(void*(baseKey1), 4))
                if baseKey1 != nil && len(baseKey1) > 0:
                    let canon1: str = uirCoreObjAliasCanon(baseKey1)
                    if canon1 != nil && len(canon1) > 0:
                        baseKey1 = canon1
                if uirCoreStrStartsWith(baseKey1, "ptr_"):
                    baseKey1 = str(ptr_add(void*(baseKey1), 4))
                if (baseKey1 != nil && len(baseKey1) > 0 && uirCoreHasObjType(b.module, baseKey1)) ||
                   (uirCoreStrStartsWith(baseKey1, "seq_") && uirCoreHasObjType(b.module, "seq")) ||
                   (uirCoreStrStartsWith(baseKey1, "seq_fixed_") && uirCoreHasObjType(b.module, "seq")) ||
                   (uirCoreStrStartsWith(baseKey1, "Table_") && uirCoreHasObjType(b.module, "Table")):
                    isIndirect = true
            if !isIndirect:
                var calleeKey: str = caseInferExprTypeKey(b, callee1)
                if uirCoreStrStartsWith(calleeKey, "ref_"):
                    calleeKey = str(ptr_add(void*(calleeKey), 4))
                elif uirCoreStrStartsWith(calleeKey, "var_ref_"):
                    calleeKey = str(ptr_add(void*(calleeKey), 8))
                elif uirCoreStrStartsWith(calleeKey, "var_"):
                    calleeKey = str(ptr_add(void*(calleeKey), 4))
                if uirCoreStrStartsWith(calleeKey, "ptr_"):
                    calleeKey = str(ptr_add(void*(calleeKey), 4))
                if uirCoreStrStartsWith(calleeKey, "fn") || uirCoreStrStartsWith(calleeKey, "fn_"):
                    isIndirect = true
            if isIndirect:
                let dbgIndirect1: bool = (getEnv "BACKEND_DEBUG_INDIRECT" == "1")
                if dbgIndirect1:
                    let dbgName1: str = getEnv "BACKEND_DEBUG_INDIRECT_NAME"
                    var calleeNm1: str = ""
                    if callee1 != nil && (callee1.kind == nkIdent || callee1.kind == nkSymbol):
                        calleeNm1 = backendStripSpaces(plainName(callee1))
                    elif callee1 != nil && callee1.kind == nkDotExpr && kidCount(callee1) > 1:
                        let mem1: Node = kid(callee1, 1)
                        if mem1 != nil && (mem1.kind == nkIdent || mem1.kind == nkSymbol):
                            calleeNm1 = backendStripSpaces(plainName(mem1))
                    if dbgName1 == nil || len(dbgName1) == 0 || (calleeNm1 == dbgName1):
                        var fn1: str = ""
                        var fp1: str = ""
                        if b != nil && b.func != nil:
                            let f1: UirCoreFunc = b.func
                            fn1 = f1.name
                            fp1 = f1.originFile
                        let line1: str = intToStr(node.pos.line)
                        let col1: str = intToStr(node.pos.col)
                        echo("[backend] debugIndirect: callee='" + calleeNm1 + "' isIndirect=1 fn=" + fn1 +
                             " " + fp1 + ":" + line1 + ":" + col1)
                let fnPtrRes: Result[UirCoreExpr] = lowerExprValue(b, calleeNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](fnPtrRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](fnPtrRes))
                var indArgs: UirCoreExpr[]
                add(indArgs, Value[UirCoreExpr](fnPtrRes))
                for xi in 0..<argNodes.len:
                    let argNode2: Node = argNodes[xi]
                    let argRes: Result[UirCoreExpr] = lowerExprValue(b, argNode2, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](argRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes))
                    add(indArgs, Value[UirCoreExpr](argRes))
                let indName: str = "__cheng_call_indirect_" + intToStr(indArgs.len - 1)
                return Ok[UirCoreExpr](uirCoreCall(indName, indArgs))

        let modSig: UirCoreModule = b.module
        if modSig != nil && !(name == "Value" && argNodes.len == 1):
            let hintSig: str = uirCoreInferCallRetKeyHint(node)
            let calleeSig: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName0, argNodes, hintSig)
            if calleeSig != nil && calleeSig.params.len > 0:
                let pFirstSig: UirCoreParam = calleeSig.params[0]
                if (pFirstSig.name == "__ret"):
                    let retObjName: str = funcObjTypeName(calleeSig, pFirstSig.slot)
                    if len(retObjName) > 0:
                        let tmpName: str = blockBuilderNextTemp(b, "__callret")
                        let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                        uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                        let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, retObjName)
                        if ! IsOk[bool](allocRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                        return lowerCallWithLeadingArg(b, node, uirCoreLocal(tmpSlot))

        # builtin: len(x) for str/seq/Table (cannot rely on overload resolution because `len`
        # can also be user-defined for custom types).
        if name == "len" && typeArgs.len == 0 && argNodes.len == 1:
            let arg0: Node = argNodes[0]
            var k0: str = caseInferExprTypeKey(b, arg0)
            if len(k0) == 0 && arg0 != nil && (arg0.kind == nkIdent || arg0.kind == nkSymbol):
                let nm0: str = plainName(arg0)
                let slot0: int32 = localIndex(b.env, nm0)
                if slot0 >= 0 && b.func != nil:
                    let olIdx0: int32 = funcFindObjLocal(b.func, slot0)
                    if olIdx0 >= 0:
                        k0 = funcObjTypeName(b.func, slot0)
                    else:
                        let ty0: UirCoreType = localType(b.env, slot0)
                        if ty0.kind == mtI64:
                            k0 = "str"

            # str/cstring
            if (k0 == "str") || (k0 == "string") || (k0 == "cstring") || (arg0 != nil && arg0.kind == nkStrLit):
                let valRes0: Result[UirCoreExpr] = lowerExprValue(b, arg0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](valRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](valRes0))
                let lenName0: str = blockBuilderNextTemp(b, "__len_str")
                let lenSlot0: int32 = localAdd(b.env, lenName0, uirCoreTypeI32())
                uirCoreSetLocalType(b.func, lenSlot0, uirCoreTypeI32())
                var args0: UirCoreExpr[]
                add(args0, Value[UirCoreExpr](valRes0))
                add(b.currentStmts, uirCoreStmtLet(lenName0, lenSlot0, uirCoreCall("cheng_strlen", args0)))
                return Ok[UirCoreExpr](uirCoreLocal(lenSlot0))

            # seq[T]
            if b.module != nil && uirCoreHasObjType(b.module, "seq") &&
               ((k0 == "seq") || uirCoreStrStartsWith(k0, "seq_") || uirCoreStrStartsWith(k0, "seq_fixed_")):
                let seqRes0: Result[UirCoreExpr] = lowerExprValue(b, arg0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](seqRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](seqRes0))
                let seqName0: str = blockBuilderNextTemp(b, "__len_seq")
                let seqSlot0: int32 = localAdd(b.env, seqName0, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, seqSlot0, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(seqName0, seqSlot0, Value[UirCoreExpr](seqRes0)))
                let seqPtr0: UirCoreExpr = uirCoreLocal(seqSlot0)

                let seqOt0: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
                var lenOff0: int32 = -1
                for fi0 in 0..<seqOt0.fields.len:
                    let f0: UirCoreObjField = seqOt0.fields[fi0]
                    if (f0.name == "len"):
                        lenOff0 = f0.offset
                        break
                if lenOff0 < 0:
                    return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch")

                let lenAddr0: UirCoreExpr = (lenOff0 == 0) ? seqPtr0 : uirCoreBin(mbAdd, seqPtr0, uirCoreConstI64(int64(lenOff0)))
                let lenName1: str = blockBuilderNextTemp(b, "__len")
                let lenSlot1: int32 = localAdd(b.env, lenName1, uirCoreTypeI32())
                uirCoreSetLocalType(b.func, lenSlot1, uirCoreTypeI32())
                add(b.currentStmts, uirCoreStmtLet(lenName1, lenSlot1, uirCoreLoad(lenAddr0, uirCoreTypeI32())))
                return Ok[UirCoreExpr](uirCoreLocal(lenSlot1))

            # tables.Table[V]
            if b.module != nil && uirCoreHasObjType(b.module, "Table") &&
               ((k0 == "Table") || uirCoreStrStartsWith(k0, "Table_")):
                let tabRes0: Result[UirCoreExpr] = lowerExprValue(b, arg0, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](tabRes0):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](tabRes0))
                let tabName0: str = blockBuilderNextTemp(b, "__len_table")
                let tabSlot0: int32 = localAdd(b.env, tabName0, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, tabSlot0, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(tabName0, tabSlot0, Value[UirCoreExpr](tabRes0)))
                let tabPtr0: UirCoreExpr = uirCoreLocal(tabSlot0)

                let tabOt0: UirCoreObjType = uirCoreGetObjType(b.module, "Table")
                var lenOff1: int32 = -1
                for fj0 in 0..<tabOt0.fields.len:
                    let f1: UirCoreObjField = tabOt0.fields[fj0]
                    if (f1.name == "len"):
                        lenOff1 = f1.offset
                        break
                if lenOff1 < 0:
                    return Err[UirCoreExpr]("uirCore_builder: Table layout mismatch")

                let lenAddr1: UirCoreExpr = (lenOff1 == 0) ? tabPtr0 : uirCoreBin(mbAdd, tabPtr0, uirCoreConstI64(int64(lenOff1)))
                let lenName2: str = blockBuilderNextTemp(b, "__len")
                let lenSlot2: int32 = localAdd(b.env, lenName2, uirCoreTypeI32())
                uirCoreSetLocalType(b.func, lenSlot2, uirCoreTypeI32())
                add(b.currentStmts, uirCoreStmtLet(lenName2, lenSlot2, uirCoreLoad(lenAddr1, uirCoreTypeI32())))
                return Ok[UirCoreExpr](uirCoreLocal(lenSlot2))

        # Fallback: infer object-return calls from the callee signature when typeCache is missing
        # or doesn't indicate an object value.
        if b.module != nil &&
           (!node.typeCacheValid || node.typeCache == nil || !typeNodeIsObjValue(b.module, node.typeCache)):
            var callName2: str = name
            if typeArgs.len > 0:
                callName2 = mangleInstance(name, typeArgs)
            let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName2, argNodes, "")
            if callee0 != nil && callee0.params.len > 0:
                let p0: UirCoreParam = callee0.params[0]
                if (p0.name == "__ret"):
                    let objNm: str = funcObjTypeName(callee0, p0.slot)
                    if len(objNm) > 0:
                        let tmpName: str = blockBuilderNextTemp(b, "__callret")
                        let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                        uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                        let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, objNm)
                        if ! IsOk[bool](allocRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[bool](allocRes))
                        let kret: str = funcObjTypeKey(callee0, p0.slot)
                        if len(kret) > 0:
                            funcSetObjTypeKey(b.func, tmpSlot, kret)
                        return lowerCallWithLeadingArg(b, node, uirCoreLocal(tmpSlot))

        var callName: str = name
        if typeArgs.len > 0:
            callName = mangleInstance(name, typeArgs)
        var calleeFunc: UirCoreFunc = nil
        var callInternal: str = callName
        let mod2: UirCoreModule = b.module
        if mod2 != nil:
            let hint: str = uirCoreInferCallRetKeyHint(node)
            let cand: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, hint)
            if cand != nil:
                calleeFunc = cand
                callInternal = cand.name
            elif moduleHasFuncByBase(mod2, callName):
                let calleeRes: Result[UirCoreFunc] = uirCoreResolveCalleeFunc(b, node, callName, argNodes)
                if !IsOk[UirCoreFunc](calleeRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreFunc](calleeRes))
                calleeFunc = Value[UirCoreFunc](calleeRes)
                callInternal = calleeFunc.name
        if name == "Value" && argNodes.len == 1:
            let valueArg0: Node = argNodes[0]
            if valueArg0 != nil:
                let valueBaseRes: Result[UirCoreExpr] = lowerExprValue(b, valueArg0, uirCoreTypeI64())
                if IsOk[UirCoreExpr](valueBaseRes):
                    var valueAddr0: UirCoreExpr = Value[UirCoreExpr](valueBaseRes)
                    if mod2 != nil:
                        var valueArgKey0: str = uirCoreInferNodeTypeKeyForOverload(b, valueArg0)
                        if uirCoreStrStartsWith(valueArgKey0, "ref_"):
                            valueArgKey0 = str(ptr_add(void*(valueArgKey0), 4))
                        elif uirCoreStrStartsWith(valueArgKey0, "var_ref_"):
                            valueArgKey0 = str(ptr_add(void*(valueArgKey0), 8))
                        elif uirCoreStrStartsWith(valueArgKey0, "var_"):
                            valueArgKey0 = str(ptr_add(void*(valueArgKey0), 4))
                        if uirCoreStrStartsWith(valueArgKey0, "ptr_"):
                            valueArgKey0 = str(ptr_add(void*(valueArgKey0), 4))
                        let valueObj0: str = uirCoreObjTypeFromTypeKey(mod2, valueArgKey0)
                        if valueObj0 != nil && len(valueObj0) > 0 && uirCoreHasObjType(mod2, valueObj0):
                            let valueOt0: UirCoreObjType = uirCoreGetObjType(mod2, valueObj0)
                            var valueOff0: int32 = -1
                            for vfi in 0..<valueOt0.fields.len:
                                let vf0: UirCoreObjField = valueOt0.fields[vfi]
                                if (vf0.name == "value") || uirCoreStrStartsWith(vf0.name, "value."):
                                    valueOff0 = vf0.offset
                                    break
                            if valueOff0 > 0:
                                valueAddr0 = uirCoreBin(mbAdd, valueAddr0, uirCoreConstI64(int64(valueOff0)))
                    var valueOutTy0: UirCoreType = wantType
                    if valueOutTy0.kind == mtVoid && mod2 != nil:
                        let valueInnerKey0: str = uirCoreInferValueCallInnerKey(b, node)
                        if valueInnerKey0 != nil && len(valueInnerKey0) > 0:
                            valueOutTy0 = uirCoreTypeFromNodeWithModule(mod2, newIdent(valueInnerKey0, node.pos))
                    if valueOutTy0.kind == mtVoid:
                        valueOutTy0 = uirCoreTypeI64()
                    if getEnv "BACKEND_DEBUG_VALUE_LOWER" == "1":
                        var fnDbg0: str = ""
                        if b != nil && b.func != nil:
                            let fDbg0: UirCoreFunc = b.func
                            fnDbg0 = fDbg0.name
                        echo("[backend] debugValueLower: fn=" + fnDbg0 + " valueOutTy=" + uirCoreTypeKindName(valueOutTy0))
                    return Ok[UirCoreExpr](uirCoreLoad(valueAddr0, valueOutTy0))

        var args: UirCoreExpr[]
        let dbgVarCallRaw: str = getEnv "BACKEND_DEBUG_VARCALL"
        var dbgVarCall: bool = (dbgVarCallRaw == "1")
        let dbgVarCallName: str = getEnv "BACKEND_DEBUG_VARCALL_NAME"
        if dbgVarCall && dbgVarCallName != nil && len(dbgVarCallName) > 0:
            dbgVarCall = (callName == dbgVarCallName)
        for ai2 in 0..<argNodes.len:
            let argNode: Node = argNodes[ai2]
            let dbgSpawn: bool = (getEnv "BACKEND_DEBUG_SPAWN" == "1")
            if dbgSpawn && name == "spawn":
                var kindStr: str = "nil"
                if argNode != nil:
                    kindStr = intToStr(int32(argNode.kind))
                echo("[backend] debugSpawn: arg#" + intToStr(ai2 + 1) + " kind=nk#" + kindStr)
            var wantVarAddr: bool = false
            var pi2: int32 = ai2
            var dbgParamKey: str = ""
            if calleeFunc != nil && calleeFunc.params.len > 0:
                let pFirst: UirCoreParam = calleeFunc.params[0]
                if (pFirst.name == "__ret"):
                    pi2 = ai2 + 1
            if calleeFunc != nil && pi2 >= 0 && pi2 < calleeFunc.params.len:
                let p0: UirCoreParam = calleeFunc.params[pi2]
                dbgParamKey = p0.typeKey
                if uirCoreStrStartsWith(p0.typeKey, "var_"):
                    let baseKey: str = str(ptr_add(void*(p0.typeKey), 4))
                    if baseKey == nil || len(baseKey) == 0 || mod2 == nil:
                        wantVarAddr = true
                    elif uirCoreHasObjType(mod2, baseKey):
                        # Ref-like types have an object layout but are represented as pointer aliases.
                        # `var RefType` expects a pointer-to-pointer (i.e. take the slot address).
                        let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(mod2, baseKey)
                        wantVarAddr = aliasTy0.kind != mtVoid
                    elif uirCoreStrStartsWith(baseKey, "seq_") && uirCoreHasObjType(mod2, "seq"):
                        wantVarAddr = false
                    else:
                        wantVarAddr = true
                elif (p0.typeKey == "var"):
                    wantVarAddr = true
            if dbgVarCall:
                var calleeDbg: str = ""
                if calleeFunc != nil:
                    calleeDbg = calleeFunc.name
                echo("[backend] debugVarCall: call=" + callName +
                     " callee=" + calleeDbg +
                     " argIdx=" + intToStr(ai2) +
                     " paramKey=" + dbgParamKey +
                     " wantVarAddr=" + (wantVarAddr ? "1" : "0"))
            if wantVarAddr:
                let addrRes: Result[UirCoreExpr] = lowerVarArgAddr(b, argNode)
                if !IsOk[UirCoreExpr](addrRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](addrRes))
                add(args, Value[UirCoreExpr](addrRes))
            elif (ai2 == 0) && (name == "spawn"):
                let fnRes: Result[UirCoreExpr] = lowerSpawnEntryArg(b, argNode)
                if !IsOk[UirCoreExpr](fnRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](fnRes))
                add(args, Value[UirCoreExpr](fnRes))
            else:
                # Call argument lowering should not depend on the call's return type.
                let argRes: Result[UirCoreExpr] = lowerExprValue(b, argNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](argRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes))
                add(args, Value[UirCoreExpr](argRes))
        let valueLikeCall1: bool = (callInternal == "Value") || (callName == "Value") ||
            (calleeFunc != nil && calleeFunc.linkName != nil && (calleeFunc.linkName == "Value"))
        if valueLikeCall1 && args.len >= 1:
            var valueAddr1: UirCoreExpr = args[0]
            if mod2 != nil && argNodes.len > 0 && argNodes[0] != nil:
                var valueArgKey1: str = uirCoreInferNodeTypeKeyForOverload(b, argNodes[0])
                if uirCoreStrStartsWith(valueArgKey1, "ref_"):
                    valueArgKey1 = str(ptr_add(void*(valueArgKey1), 4))
                elif uirCoreStrStartsWith(valueArgKey1, "var_ref_"):
                    valueArgKey1 = str(ptr_add(void*(valueArgKey1), 8))
                elif uirCoreStrStartsWith(valueArgKey1, "var_"):
                    valueArgKey1 = str(ptr_add(void*(valueArgKey1), 4))
                if uirCoreStrStartsWith(valueArgKey1, "ptr_"):
                    valueArgKey1 = str(ptr_add(void*(valueArgKey1), 4))
                var valueOff1: int32 = -1
                let valueObj1: str = uirCoreObjTypeFromTypeKey(mod2, valueArgKey1)
                if valueObj1 != nil && len(valueObj1) > 0 && uirCoreHasObjType(mod2, valueObj1):
                    let valueOt1: UirCoreObjType = uirCoreGetObjType(mod2, valueObj1)
                    for vfi1 in 0..<valueOt1.fields.len:
                        let vf1: UirCoreObjField = valueOt1.fields[vfi1]
                        if (vf1.name == "value") || uirCoreStrStartsWith(vf1.name, "value."):
                            if valueOff1 < 0 || vf1.offset < valueOff1:
                                valueOff1 = vf1.offset
                if valueOff1 < 0 && uirCoreStrStartsWith(valueArgKey1, "Result_"):
                    valueOff1 = 0
                if valueOff1 > 0:
                    valueAddr1 = uirCoreBin(mbAdd, valueAddr1, uirCoreConstI64(int64(valueOff1)))
            var outTy1: UirCoreType = wantType
            if outTy1.kind == mtVoid && mod2 != nil:
                let innerKey2: str = uirCoreInferValueCallInnerKey(b, node)
                if innerKey2 != nil && len(innerKey2) > 0:
                    outTy1 = uirCoreTypeFromNodeWithModule(mod2, newIdent(innerKey2, node.pos))
            if outTy1.kind == mtVoid:
                outTy1 = uirCoreTypeI64()
            return Ok[UirCoreExpr](uirCoreLoad(valueAddr1, outTy1))
        return Ok[UirCoreExpr](uirCoreCall(callInternal, args))
    if node.kind == nkPrefix && kidCount(node) > 1:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        let rhs: Node = kid(node, 1)
        if op == "$":
            var argNodes0: Node[1]
            add(argNodes0, rhs)
            var callInternal0: str = "$"
            let mod2: UirCoreModule = b.module
            if mod2 != nil:
                let cand: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, "$", argNodes0, "str")
                if cand != nil:
                    callInternal0 = cand.name
                elif moduleHasFuncByBase(mod2, "$"):
                    let calleeRes: Result[UirCoreFunc] = uirCoreResolveCalleeFunc(b, node, "$", argNodes0)
                    if !IsOk[UirCoreFunc](calleeRes):
                        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreFunc](calleeRes))
                    let callee: UirCoreFunc = Value[UirCoreFunc](calleeRes)
                    callInternal0 = callee.name
            let rhsRes0: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](rhsRes0):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsRes0))
            var args0: UirCoreExpr[]
            add(args0, Value[UirCoreExpr](rhsRes0))
            return Ok[UirCoreExpr](uirCoreCall(callInternal0, args0))
        if op == "-":
            var k: str = exprTypeKeyShallow(b, node)
            if len(k) == 0:
                k = exprTypeKeyShallow(b, rhs)
            if isFloat64Key(k):
                let rhsBitsRes: Result[UirCoreExpr] = lowerToF64Bits(b, rhs)
                if ! IsOk[UirCoreExpr](rhsBitsRes):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsBitsRes))
                var args: UirCoreExpr[]
                add(args, Value[UirCoreExpr](rhsBitsRes))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f64_neg_bits", args)))
            let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, wantType)
            if ! IsOk[UirCoreExpr](rhsRes):
                return rhsRes
            let zero: UirCoreExpr = uirCoreConstI64(0)
            return Ok[UirCoreExpr](uirCoreBin(mbSub, zero, Value[UirCoreExpr](rhsRes)))
        if op == "+":
            return lowerExprValue(b, rhs, wantType)
        if op == "~":
            let rhsRes2: Result[UirCoreExpr] = lowerExprValue(b, rhs, wantType)
            if ! IsOk[UirCoreExpr](rhsRes2):
                return rhsRes2
            let allBits: UirCoreExpr = uirCoreConstI64(-1)
            return Ok[UirCoreExpr](uirCoreBin(mbXor, Value[UirCoreExpr](rhsRes2), allBits))
        if op == "!":
            let rhsRes3: Result[UirCoreExpr] = lowerExprValue(b, rhs, wantType)
            if ! IsOk[UirCoreExpr](rhsRes3):
                return rhsRes3
            let zero2: UirCoreExpr = uirCoreConstI64(0)
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, Value[UirCoreExpr](rhsRes3), zero2))
    if node.kind == nkInfix && kidCount(node) >= 3:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        let lhsNode: Node = kid(node, 1)
        let rhsNode: Node = kid(node, 2)
        if op == "in" || op == "notin":
            return lowerInExpr(b, lhsNode, rhsNode, op == "notin")
        if op == "+" || op == "==" || op == "!=":
            let lk: str = caseInferExprTypeKey(b, lhsNode)
            let rk: str = caseInferExprTypeKey(b, rhsNode)
            let selfK: str = exprTypeKeyShallow(b, node)
            if isStringKey(selfK) || isStringKey(lk) || isStringKey(rk) || lhsNode.kind == nkStrLit || rhsNode.kind == nkStrLit:
                let lhsResS: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](lhsResS):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsResS))
                let rhsResS: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](rhsResS):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsResS))
                let lhsS: UirCoreExpr = Value[UirCoreExpr](lhsResS)
                let rhsS: UirCoreExpr = Value[UirCoreExpr](rhsResS)
                var argsS: UirCoreExpr[]
                add(argsS, lhsS)
                add(argsS, rhsS)
                if op == "+":
                    return Ok[UirCoreExpr](uirCoreCall(backendSanitizeLinkName("+"), argsS))
                let eqCall: UirCoreExpr = uirCoreCall("__cheng_str_eq", argsS)
                if op == "==":
                    return Ok[UirCoreExpr](eqCall)
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, eqCall, uirCoreConstI64(0)))
            if (op == "==" || op == "!=") && (uirCoreObjAliasCanon(lk) == "Bytes") && (uirCoreObjAliasCanon(rk) == "Bytes"):
                let lhsResB: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](lhsResB):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsResB))
                let rhsResB: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](rhsResB):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsResB))
                let lhsB: UirCoreExpr = Value[UirCoreExpr](lhsResB)
                let rhsB: UirCoreExpr = Value[UirCoreExpr](rhsResB)
                var argsB: UirCoreExpr[]
                add(argsB, lhsB)
                add(argsB, rhsB)
                let eqCall: UirCoreExpr = uirCoreCall("bytesEqual", argsB)
                if op == "==":
                    return Ok[UirCoreExpr](eqCall)
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, eqCall, uirCoreConstI64(0)))
        var kInfix: str = exprTypeKeyShallow(b, node)
        if len(kInfix) == 0:
            kInfix = exprTypeKeyShallow(b, lhsNode)
        if len(kInfix) == 0:
            kInfix = exprTypeKeyShallow(b, rhsNode)
        let lhsInferTy: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, lhsNode, uirCoreTypeI32())
        let rhsInferTy: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, rhsNode, uirCoreTypeI32())
        let inferF64: bool = lhsInferTy.kind == mtF64 || rhsInferTy.kind == mtF64
        let inferF32: bool = lhsInferTy.kind == mtF32 || rhsInferTy.kind == mtF32
        if (isFloat32Key(kInfix) || (inferF32 && !inferF64)):
            let lhsBits32Res: Result[UirCoreExpr] = lowerToF32Bits(b, lhsNode)
            if !IsOk[UirCoreExpr](lhsBits32Res):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsBits32Res))
            let rhsBits32Res: Result[UirCoreExpr] = lowerToF32Bits(b, rhsNode)
            if !IsOk[UirCoreExpr](rhsBits32Res):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsBits32Res))
            let lhsBits32: UirCoreExpr = Value[UirCoreExpr](lhsBits32Res)
            let rhsBits32: UirCoreExpr = Value[UirCoreExpr](rhsBits32Res)
            if op == "==":
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, lhsBits32, rhsBits32))
            if op == "!=":
                return Ok[UirCoreExpr](uirCoreCmp(mcNe, lhsBits32, rhsBits32))

            var lhsUpArgs: UirCoreExpr[]
            add(lhsUpArgs, lhsBits32)
            let lhsBits64: UirCoreExpr = uirCoreCall("cheng_f32_bits_to_f64_bits", lhsUpArgs)
            var rhsUpArgs: UirCoreExpr[]
            add(rhsUpArgs, rhsBits32)
            let rhsBits64: UirCoreExpr = uirCoreCall("cheng_f32_bits_to_f64_bits", rhsUpArgs)
            var args32: UirCoreExpr[]
            add(args32, lhsBits64)
            add(args32, rhsBits64)
            if op == "+":
                var downArgs0: UirCoreExpr[]
                add(downArgs0, uirCoreCall("cheng_f64_add_bits", args32))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF32(), uirCoreCall("cheng_f64_bits_to_f32_bits", downArgs0)))
            if op == "-":
                var downArgs1: UirCoreExpr[]
                add(downArgs1, uirCoreCall("cheng_f64_sub_bits", args32))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF32(), uirCoreCall("cheng_f64_bits_to_f32_bits", downArgs1)))
            if op == "*":
                var downArgs2: UirCoreExpr[]
                add(downArgs2, uirCoreCall("cheng_f64_mul_bits", args32))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF32(), uirCoreCall("cheng_f64_bits_to_f32_bits", downArgs2)))
            if op == "/":
                var downArgs3: UirCoreExpr[]
                add(downArgs3, uirCoreCall("cheng_f64_div_bits", args32))
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF32(), uirCoreCall("cheng_f64_bits_to_f32_bits", downArgs3)))
            if op == "<":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_lt_bits", args32))
            if op == "<=":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_le_bits", args32))
            if op == ">":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_gt_bits", args32))
            if op == ">=":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_ge_bits", args32))
            let lineF32: str = intToStr(node.pos.line)
            let colF32: str = intToStr(node.pos.col)
            return Err[UirCoreExpr]("uirCore_builder: unsupported float32 infix op '" + op + "' @" + lineF32 + ":" + colF32)
        if isFloat64Key(kInfix) || inferF64:
            let lhsBitsRes: Result[UirCoreExpr] = lowerToF64Bits(b, lhsNode)
            if ! IsOk[UirCoreExpr](lhsBitsRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](lhsBitsRes))
            let rhsBitsRes: Result[UirCoreExpr] = lowerToF64Bits(b, rhsNode)
            if ! IsOk[UirCoreExpr](rhsBitsRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](rhsBitsRes))
            let lhsBits: UirCoreExpr = Value[UirCoreExpr](lhsBitsRes)
            let rhsBits: UirCoreExpr = Value[UirCoreExpr](rhsBitsRes)
            if op == "==":
                return Ok[UirCoreExpr](uirCoreCmp(mcEq, lhsBits, rhsBits))
            if op == "!=":
                return Ok[UirCoreExpr](uirCoreCmp(mcNe, lhsBits, rhsBits))
            var args2: UirCoreExpr[]
            add(args2, lhsBits)
            add(args2, rhsBits)
            if op == "+":
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f64_add_bits", args2)))
            if op == "-":
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f64_sub_bits", args2)))
            if op == "*":
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f64_mul_bits", args2)))
            if op == "/":
                return Ok[UirCoreExpr](uirCoreCast(uirCoreTypeF64(), uirCoreCall("cheng_f64_div_bits", args2)))
            if op == "<":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_lt_bits", args2))
            if op == "<=":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_le_bits", args2))
            if op == ">":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_gt_bits", args2))
            if op == ">=":
                return Ok[UirCoreExpr](uirCoreCall("cheng_f64_ge_bits", args2))
            let lineF: str = intToStr(node.pos.line)
            let colF: str = intToStr(node.pos.col)
            return Err[UirCoreExpr]("uirCore_builder: unsupported float infix op '" + op + "' @" + lineF + ":" + colF)
        let lhsRes: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, wantType)
        if ! IsOk[UirCoreExpr](lhsRes):
            return lhsRes
        let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, wantType)
        if ! IsOk[UirCoreExpr](rhsRes):
            return rhsRes
        let lhs: UirCoreExpr = Value[UirCoreExpr](lhsRes)
        let rhs: UirCoreExpr = Value[UirCoreExpr](rhsRes)
        if op == "+":
            return Ok[UirCoreExpr](uirCoreBin(mbAdd, lhs, rhs))
        if op == "-":
            return Ok[UirCoreExpr](uirCoreBin(mbSub, lhs, rhs))
        if op == "*":
            return Ok[UirCoreExpr](uirCoreBin(mbMul, lhs, rhs))
        if op == "/":
            return Ok[UirCoreExpr](uirCoreBin(mbSdiv, lhs, rhs))
        if op == "%":
            return Ok[UirCoreExpr](uirCoreBin(mbSmod, lhs, rhs))
        if op == "&":
            return Ok[UirCoreExpr](uirCoreBin(mbAnd, lhs, rhs))
        if op == "|":
            return Ok[UirCoreExpr](uirCoreBin(mbOr, lhs, rhs))
        if op == "^":
            return Ok[UirCoreExpr](uirCoreBin(mbXor, lhs, rhs))
        if op == "<<":
            return Ok[UirCoreExpr](uirCoreBin(mbShl, lhs, rhs))
        if op == ">>":
            return Ok[UirCoreExpr](uirCoreBin(mbShr, lhs, rhs))
        if op == "==":
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, lhs, rhs))
        if op == "!=":
            return Ok[UirCoreExpr](uirCoreCmp(mcNe, lhs, rhs))
        if op == "<":
            return Ok[UirCoreExpr](uirCoreCmp(mcLt, lhs, rhs))
        if op == "<=":
            return Ok[UirCoreExpr](uirCoreCmp(mcLe, lhs, rhs))
        if op == ">":
            return Ok[UirCoreExpr](uirCoreCmp(mcGt, lhs, rhs))
        if op == ">=":
            return Ok[UirCoreExpr](uirCoreCmp(mcGe, lhs, rhs))
        var fnName: str = ""
        var fp: str = ""
        if b != nil && b.func != nil:
            let f2: UirCoreFunc = b.func
            fnName = f2.name
            fp = f2.originFile
        let line: str = intToStr(node.pos.line)
        let col: str = intToStr(node.pos.col)
        return Err[UirCoreExpr]("uirCore_builder: unsupported infix op '" + op + "' (fn=" + fnName +
                            " " + fp + ":" + line + ":" + col + ")")
    var fnName2: str = ""
    var fp2: str = ""
    if b != nil && b.func != nil:
        let f2: UirCoreFunc = b.func
        fnName2 = f2.name
        fp2 = f2.originFile
    let k2: str = intToStr(int32(node.kind))
    let line2: str = intToStr(node.pos.line)
    let col2: str = intToStr(node.pos.col)
    return Err[UirCoreExpr]("uirCore_builder: unsupported expr kind (nk#" + k2 +
                        " fn=" + fnName2 + " " + fp2 + ":" + line2 + ":" + col2 + ")")

fn uirCoreBuildExpr(env: LocalEnv, n: Node): Result[UirCoreExpr] =
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil expr")
    if n.kind == nkCallArg:
        if kidCount(n) > 0:
            return uirCoreBuildExpr(env, kid(n, kidCount(n) - 1))
        return Err[UirCoreExpr]("uirCore_builder: invalid call arg expr")
    if n.kind == nkIntLit:
        return Ok[UirCoreExpr](uirCoreConstI64(n.intVal))
    if n.kind == nkFloatLit:
        if n.strVal != nil && len(n.strVal) > 0:
            return Ok[UirCoreExpr](uirCoreConstI64(cheng_parse_f64_bits(n.strVal)))
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if n.kind == nkBoolLit:
        let name: str = backendStripSpaces(n.ident)
        if name == "true":
            return Ok[UirCoreExpr](uirCoreConstI64(1))
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if n.kind == nkCharLit:
        if n.strVal != nil && len(n.strVal) > 0:
            let c: char = n.strVal[0]
            return Ok[UirCoreExpr](uirCoreConstI64(int64(c)))
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if n.kind == nkNilLit:
        return Ok[UirCoreExpr](uirCoreConstI64(0))
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = plainName(n)
        let idx: int32 = localIndex(env, nm)
        if idx < 0:
            return Err[UirCoreExpr]("uirCore_builder: unknown local")
        return Ok[UirCoreExpr](uirCoreLocal(idx))
    if n.kind == nkPar && kidCount(n) > 0:
        return uirCoreBuildExpr(env, kid(n, 0))
    if n.kind == nkCall && kidCount(n) > 0:
        let calleeNode: Node = kid(n, 0)
        if calleeNode == nil ||(calleeNode.kind != nkIdent && calleeNode.kind != nkSymbol):
            return Err[UirCoreExpr]("uirCore_builder: call expects identifier callee")
        let name: str = backendStripSpaces(plainName(calleeNode))
        if kidCount(n) == 2 &&
           (name == "int64" || name == "i64" || name == "uint64" || name == "u64" ||
            name == "int32" || name == "i32" || name == "uint32" || name == "u32" ||
            name == "int" || name == "uint" || name == "NI" || name == "NU"):
            let argNode0: Node = kid(n, 1)
            var castArg: Node = argNode0
            if argNode0 != nil && argNode0.kind == nkCallArg && kidCount(argNode0) > 1:
                castArg = kid(argNode0, 1)
            let castRes: Result[UirCoreExpr] = uirCoreBuildExpr(env, castArg)
            if ! IsOk[UirCoreExpr](castRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](castRes))
            let castType: UirCoreType = uirCoreTypeFromNodeWithModule(nil, calleeNode)
            return Ok[UirCoreExpr](uirCoreCast(castType, Value[UirCoreExpr](castRes)))
        var args: UirCoreExpr[]
        for ai in 1..<kidCount(n):
            var argNode: Node = kid(n, ai)
            if argNode != nil && argNode.kind == nkCallArg && kidCount(argNode) > 1:
                argNode = kid(argNode, 1)
            let argRes: Result[UirCoreExpr] = uirCoreBuildExpr(env, argNode)
            if ! IsOk[UirCoreExpr](argRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](argRes))
            add(args, Value[UirCoreExpr](argRes))
        return Ok[UirCoreExpr](uirCoreCall(name, args))
    if n.kind == nkPrefix && kidCount(n) > 1:
        let opNode: Node = kid(n, 0)
        let op: str = backendOpName(opNode)
        let rhs: Node = kid(n, 1)
        if op == "-":
            let rhsRes: Result[UirCoreExpr] = uirCoreBuildExpr(env, rhs)
            if ! IsOk[UirCoreExpr](rhsRes):
                return rhsRes
            let zero: UirCoreExpr = uirCoreConstI64(0)
            return Ok[UirCoreExpr](uirCoreBin(mbSub, zero, Value[UirCoreExpr](rhsRes)))
        if op == "+":
            return uirCoreBuildExpr(env, rhs)
        if op == "~":
            let rhsRes2: Result[UirCoreExpr] = uirCoreBuildExpr(env, rhs)
            if ! IsOk[UirCoreExpr](rhsRes2):
                return rhsRes2
            let allBits: UirCoreExpr = uirCoreConstI64(-1)
            return Ok[UirCoreExpr](uirCoreBin(mbXor, Value[UirCoreExpr](rhsRes2), allBits))
        if op == "!":
            let rhsRes3: Result[UirCoreExpr] = uirCoreBuildExpr(env, rhs)
            if ! IsOk[UirCoreExpr](rhsRes3):
                return rhsRes3
            let zero2: UirCoreExpr = uirCoreConstI64(0)
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, Value[UirCoreExpr](rhsRes3), zero2))
    if n.kind == nkInfix && kidCount(n) >= 3:
        let opNode: Node = kid(n, 0)
        let op: str = backendOpName(opNode)
        let lhsNode: Node = kid(n, 1)
        let rhsNode: Node = kid(n, 2)
        let lhsRes: Result[UirCoreExpr] = uirCoreBuildExpr(env, lhsNode)
        if ! IsOk[UirCoreExpr](lhsRes):
            return lhsRes
        let rhsRes: Result[UirCoreExpr] = uirCoreBuildExpr(env, rhsNode)
        if ! IsOk[UirCoreExpr](rhsRes):
            return rhsRes
        let lhs: UirCoreExpr = Value[UirCoreExpr](lhsRes)
        let rhs: UirCoreExpr = Value[UirCoreExpr](rhsRes)
        if op == "+":
            return Ok[UirCoreExpr](uirCoreBin(mbAdd, lhs, rhs))
        if op == "-":
            return Ok[UirCoreExpr](uirCoreBin(mbSub, lhs, rhs))
        if op == "*":
            return Ok[UirCoreExpr](uirCoreBin(mbMul, lhs, rhs))
        if op == "/":
            return Ok[UirCoreExpr](uirCoreBin(mbSdiv, lhs, rhs))
        if op == "%":
            return Ok[UirCoreExpr](uirCoreBin(mbSmod, lhs, rhs))
        if op == "&":
            return Ok[UirCoreExpr](uirCoreBin(mbAnd, lhs, rhs))
        if op == "|":
            return Ok[UirCoreExpr](uirCoreBin(mbOr, lhs, rhs))
        if op == "^":
            return Ok[UirCoreExpr](uirCoreBin(mbXor, lhs, rhs))
        if op == "<<":
            return Ok[UirCoreExpr](uirCoreBin(mbShl, lhs, rhs))
        if op == ">>":
            return Ok[UirCoreExpr](uirCoreBin(mbShr, lhs, rhs))
        if op == "&&":
            let lhsNz: UirCoreExpr = uirCoreCmp(mcNe, lhs, uirCoreConstI64(0))
            let rhsNz: UirCoreExpr = uirCoreCmp(mcNe, rhs, uirCoreConstI64(0))
            return Ok[UirCoreExpr](uirCoreBin(mbAnd, lhsNz, rhsNz))
        if op == "||":
            let lhsNz2: UirCoreExpr = uirCoreCmp(mcNe, lhs, uirCoreConstI64(0))
            let rhsNz2: UirCoreExpr = uirCoreCmp(mcNe, rhs, uirCoreConstI64(0))
            return Ok[UirCoreExpr](uirCoreBin(mbOr, lhsNz2, rhsNz2))
        if op == "==":
            return Ok[UirCoreExpr](uirCoreCmp(mcEq, lhs, rhs))
        if op == "!=":
            return Ok[UirCoreExpr](uirCoreCmp(mcNe, lhs, rhs))
        if op == "<":
            return Ok[UirCoreExpr](uirCoreCmp(mcLt, lhs, rhs))
        if op == "<=":
            return Ok[UirCoreExpr](uirCoreCmp(mcLe, lhs, rhs))
        if op == ">":
            return Ok[UirCoreExpr](uirCoreCmp(mcGt, lhs, rhs))
        if op == ">=":
            return Ok[UirCoreExpr](uirCoreCmp(mcGe, lhs, rhs))
        let line4: str = intToStr(n.pos.line)
        let col4: str = intToStr(n.pos.col)
        return Err[UirCoreExpr]("uirCore_builder: unsupported infix op '" + op + "' @" + line4 + ":" + col4)
    let k3: str = intToStr(int32(n.kind))
    let line3: str = intToStr(n.pos.line)
    let col3: str = intToStr(n.pos.col)
    return Err[UirCoreExpr]("uirCore_builder: unsupported expr kind (nk#" + k3 + " @" + line3 + ":" + col3 + ")")

fn uirCoreExprFromIfBranch(b: BlockBuilder, n: Node, wantType: UirCoreType): Result[UirCoreExpr] =
    if n == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil if branch")
    if n.kind == nkStmtList:
        if kidCount(n) != 1:
            return Err[UirCoreExpr]("uirCore_builder: if expr branch expects single expr")
        return lowerExprValue(b, kid(n, 0), wantType)
    return lowerExprValue(b, n, wantType)

fn lowerIfAssign(b: BlockBuilder, ifNode: Node, name: str, slot: int32): Result[bool] =
    if ifNode == nil || ifNode.kind != nkIf:
        return Err[bool]("uirCore_builder: invalid if expr")
    let total: int32 = kidCount(ifNode)
    if total < 3:
        return Err[bool]("uirCore_builder: if expr expects condition and else")
    let hasElse: bool = (total % 2) == 1
    if ! hasElse:
        return Err[bool]("uirCore_builder: if expr requires else")
    let slotType: UirCoreType = localType(b.env, slot)
    let condCount: int32 = (total - 1) / 2
    let joinLabel: str = blockBuilderNextLabel(b, "if_join")
    var elseLabel: str = ""
    for ci in 0..<condCount:
        let condNode: Node = kid(ifNode, ci * 2)
        let thenNode: Node = kid(ifNode, ci * 2 + 1)
        let thenLabel: str = blockBuilderNextLabel(b, "if_then")
        let isLast: bool = ci == condCount - 1
        var falseLabel: str = ""
        var nextCondLabel: str = ""
        if isLast:
            elseLabel = blockBuilderNextLabel(b, "if_else")
            falseLabel = elseLabel
        else:
            nextCondLabel = blockBuilderNextLabel(b, "if_cond")
            falseLabel = nextCondLabel
        let condRes: Result[bool] = lowerCondBranch(b, condNode, thenLabel, falseLabel)
        if ! IsOk[bool](condRes):
            return ErrInfo[bool](ErrorInfoOf[bool](condRes))
        blockBuilderStart(b, thenLabel)
        let thenRes: Result[UirCoreExpr] = uirCoreExprFromIfBranch(b, thenNode, slotType)
        if ! IsOk[UirCoreExpr](thenRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](thenRes))
        add(b.currentStmts, uirCoreStmtAssign(name, slot, Value[UirCoreExpr](thenRes)))
        blockBuilderFinish(b, uirCoreTermBr(joinLabel))
        if ! isLast:
            blockBuilderStart(b, nextCondLabel)
    let elseNode: Node = kid(ifNode, total - 1)
    blockBuilderStart(b, elseLabel)
    let elseRes: Result[UirCoreExpr] = uirCoreExprFromIfBranch(b, elseNode, slotType)
    if ! IsOk[UirCoreExpr](elseRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](elseRes))
    add(b.currentStmts, uirCoreStmtAssign(name, slot, Value[UirCoreExpr](elseRes)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))
    blockBuilderStart(b, joinLabel)
    return Ok[bool](false)

fn lowerIfAssignObjValue(b: BlockBuilder, ifNode: Node, name: str, slot: int32): Result[bool] =
    if ifNode == nil || ifNode.kind != nkIf:
        return Err[bool]("uirCore_builder: invalid if expr")
    let total: int32 = kidCount(ifNode)
    if total < 3:
        return Err[bool]("uirCore_builder: if expr expects condition and else")
    let hasElse: bool = (total % 2) == 1
    if ! hasElse:
        return Err[bool]("uirCore_builder: if expr requires else")
    let condCount: int32 = (total - 1) / 2
    let joinLabel: str = blockBuilderNextLabel(b, "if_join")
    var elseLabel: str = ""
    for ci in 0..<condCount:
        let condNode: Node = kid(ifNode, ci * 2)
        var thenExpr: Node = kid(ifNode, ci * 2 + 1)
        if thenExpr != nil && thenExpr.kind == nkStmtList:
            if kidCount(thenExpr) != 1:
                return Err[bool]("uirCore_builder: if expr branch expects single expr")
            thenExpr = kid(thenExpr, 0)
        let thenLabel: str = blockBuilderNextLabel(b, "if_then")
        let isLast: bool = ci == condCount - 1
        var falseLabel: str = ""
        var nextCondLabel: str = ""
        if isLast:
            elseLabel = blockBuilderNextLabel(b, "if_else")
            falseLabel = elseLabel
        else:
            nextCondLabel = blockBuilderNextLabel(b, "if_cond")
            falseLabel = nextCondLabel
        let condRes: Result[bool] = lowerCondBranch(b, condNode, thenLabel, falseLabel)
        if ! IsOk[bool](condRes):
            return ErrInfo[bool](ErrorInfoOf[bool](condRes))
        blockBuilderStart(b, thenLabel)
        let thenAssignRes: Result[bool] = lowerAssignValue(b, thenExpr, name, slot)
        if !IsOk[bool](thenAssignRes):
            return ErrInfo[bool](ErrorInfoOf[bool](thenAssignRes))
        blockBuilderFinish(b, uirCoreTermBr(joinLabel))
        if ! isLast:
            blockBuilderStart(b, nextCondLabel)
    var elseExpr: Node = kid(ifNode, total - 1)
    if elseExpr != nil && elseExpr.kind == nkStmtList:
        if kidCount(elseExpr) != 1:
            return Err[bool]("uirCore_builder: if expr branch expects single expr")
        elseExpr = kid(elseExpr, 0)
    blockBuilderStart(b, elseLabel)
    let elseAssignRes: Result[bool] = lowerAssignValue(b, elseExpr, name, slot)
    if !IsOk[bool](elseAssignRes):
        return ErrInfo[bool](ErrorInfoOf[bool](elseAssignRes))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))
    blockBuilderStart(b, joinLabel)
    return Ok[bool](false)

fn lowerIfStmt(b: BlockBuilder, ifNode: Node): Result[bool] =
    if ifNode == nil || ifNode.kind != nkIf:
        return Err[bool]("uirCore_builder: invalid if stmt")
    let total: int32 = kidCount(ifNode)
    if total < 2:
        return Err[bool]("uirCore_builder: if expects branches")
    let hasElse: bool = (total % 2) == 1
    let condCount: int32 = total / 2
    let joinLabel: str = blockBuilderNextLabel(b, "if_join")
    var needsJoin: bool = false
    var allTerminated: bool = true
    var elseLabel: str = ""
    for ci in 0..<condCount:
        let condNode: Node = kid(ifNode, ci * 2)
        var thenNode: Node = kid(ifNode, ci * 2 + 1)
        if thenNode != nil && thenNode.kind != nkStmtList:
            var wrap: Node = newNode(nkStmtList, thenNode.pos)
            addSon(wrap, thenNode)
            thenNode = wrap
        if thenNode == nil || thenNode.kind != nkStmtList:
            return Err[bool]("uirCore_builder: if stmt expects stmt list")
        let thenLabel: str = blockBuilderNextLabel(b, "if_then")
        let isLast: bool = ci == condCount - 1
        var falseLabel: str = ""
        var nextCondLabel: str = ""
        if isLast:
            if hasElse:
                elseLabel = blockBuilderNextLabel(b, "if_else")
                falseLabel = elseLabel
            else:
                falseLabel = joinLabel
                needsJoin = true
                allTerminated = false
        else:
            nextCondLabel = blockBuilderNextLabel(b, "if_cond")
            falseLabel = nextCondLabel
        let condRes: Result[bool] = lowerCondBranch(b, condNode, thenLabel, falseLabel)
        if ! IsOk[bool](condRes):
            return ErrInfo[bool](ErrorInfoOf[bool](condRes))
        blockBuilderStart(b, thenLabel)
        let thenTermRes: Result[bool] = lowerStmtList(b, thenNode)
        if ! IsOk[bool](thenTermRes):
            return ErrInfo[bool](ErrorInfoOf[bool](thenTermRes))
        let thenTerminated: bool = Value[bool](thenTermRes)
        if ! thenTerminated:
            allTerminated = false
            needsJoin = true
            blockBuilderFinish(b, uirCoreTermBr(joinLabel))
        if ! isLast:
            blockBuilderStart(b, nextCondLabel)
    if hasElse:
        var elseNode: Node = kid(ifNode, total - 1)
        if elseNode != nil && elseNode.kind != nkStmtList:
            var wrap2: Node = newNode(nkStmtList, elseNode.pos)
            addSon(wrap2, elseNode)
            elseNode = wrap2
        if elseNode == nil || elseNode.kind != nkStmtList:
            return Err[bool]("uirCore_builder: if else expects stmt list")
        blockBuilderStart(b, elseLabel)
        let elseTermRes: Result[bool] = lowerStmtList(b, elseNode)
        if ! IsOk[bool](elseTermRes):
            return ErrInfo[bool](ErrorInfoOf[bool](elseTermRes))
        let elseTerminated: bool = Value[bool](elseTermRes)
        if ! elseTerminated:
            allTerminated = false
            needsJoin = true
            blockBuilderFinish(b, uirCoreTermBr(joinLabel))
    if needsJoin:
        blockBuilderStart(b, joinLabel)
        return Ok[bool](false)
    if allTerminated:
        return Ok[bool](true)
    blockBuilderStart(b, joinLabel)
    return Ok[bool](false)

fn nodeIsTrueLiteral(n0: Node): bool =
    if n0 == nil:
        return false
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return false
    if n.kind == nkBoolLit:
        let v: str = backendStripSpaces(n.ident)
        return (v == "true")
    return false

fn nodeHasBreakAtLoopDepth(n: Node, loopDepth: int32): bool =
    if n == nil:
        return false
    if n.kind == nkBreak:
        return loopDepth == 0
    var childDepth: int32 = loopDepth
    if n.kind == nkWhile || n.kind == nkFor:
        childDepth = loopDepth + 1
    for i in 0..<kidCount(n):
        if nodeHasBreakAtLoopDepth(kid(n, i), childDepth):
            return true
    return false

fn lowerWhileStmt(b: BlockBuilder, whileNode: Node): Result[bool] =
    if whileNode == nil || whileNode.kind != nkWhile:
        return Err[bool]("uirCore_builder: invalid while")
    if kidCount(whileNode) < 2:
        return Err[bool]("uirCore_builder: while expects cond/body")
    let isInfinite: bool = nodeIsTrueLiteral(kid(whileNode, 0)) &&
                           ! nodeHasBreakAtLoopDepth(kid(whileNode, 1), 0)
    let condLabel: str = blockBuilderNextLabel(b, "while_cond")
    let bodyLabel: str = blockBuilderNextLabel(b, "while_body")
    let endLabel: str = blockBuilderNextLabel(b, "while_end")
    blockBuilderFinish(b, uirCoreTermBr(condLabel))
    blockBuilderStart(b, condLabel)
    let condRes: Result[bool] = lowerCondBranch(b, kid(whileNode, 0), bodyLabel, endLabel)
    if ! IsOk[bool](condRes):
        return ErrInfo[bool](ErrorInfoOf[bool](condRes))
    blockBuilderStart(b, bodyLabel)
    blockBuilderPushLoop(b, endLabel, condLabel)
    let bodyNode: Node = kid(whileNode, 1)
    if bodyNode == nil || bodyNode.kind != nkStmtList:
        return Err[bool]("uirCore_builder: while expects stmt list body")
    if (getEnv "BACKEND_DEBUG_SCOPE" == "1") && b != nil && b.func != nil:
        let fDbg: UirCoreFunc = b.func
        if (fDbg.name == "verifyLockAgainstRegistry"):
            echo("[backend] debugWhileBody: fn=" + fDbg.name + " kids=" + intToStr(kidCount(bodyNode)) +
                 " @" + intToStr(bodyNode.pos.line) + ":" + intToStr(bodyNode.pos.col))
            for di in 0..<kidCount(bodyNode):
                let st: Node = kid(bodyNode, di)
                let sk: str = (st != nil) ? intToStr(int32(st.kind)) : "nil"
                let sl: str = (st != nil) ? intToStr(st.pos.line) : "0"
                let sc: str = (st != nil) ? intToStr(st.pos.col) : "0"
                var sn: str = ""
                if st != nil && (st.kind == nkLet || st.kind == nkVar) && kidCount(st) > 0:
                    sn = plainName(kid(st, 0))
                echo("[backend] debugWhileStmt: i=" + intToStr(di) + " kind=nk#" + sk + " @" + sl + ":" + sc + " name=" + sn)
    let bodyTermRes: Result[bool] = lowerStmtList(b, bodyNode)
    blockBuilderPopLoop(b)
    if ! IsOk[bool](bodyTermRes):
        return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes))
    let bodyTerminated: bool = Value[bool](bodyTermRes)
    if ! bodyTerminated:
        blockBuilderFinish(b, uirCoreTermBr(condLabel))
    if isInfinite:
        # Ensure the unused false-branch label exists for CFG integrity.
        blockBuilderStart(b, endLabel)
        blockBuilderFinish(b, uirCoreTermBr(endLabel))
        return Ok[bool](true)
    blockBuilderStart(b, endLabel)
    return Ok[bool](false)

fn lowerCondBranch(b: BlockBuilder, condNode: Node, tLabel: str, fLabel: str): Result[bool] =
    if condNode == nil:
        return Err[bool]("uirCore_builder: nil cond")
    var node: Node = condNode
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node != nil && node.kind == nkInfix && kidCount(node) >= 3:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        if op == "&&" || op == "||":
            let lhsNode: Node = kid(node, 1)
            let rhsNode: Node = kid(node, 2)
            let lhsRes: Result[UirCoreExpr] = lowerExprValue(b, lhsNode, uirCoreTypeI32())
            if ! IsOk[UirCoreExpr](lhsRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](lhsRes))
            if op == "&&":
                let rhsLabel: str = blockBuilderNextLabel(b, "and_rhs")
                blockBuilderFinish(b, uirCoreTermCbr(Value[UirCoreExpr](lhsRes), rhsLabel, fLabel))
                blockBuilderStart(b, rhsLabel)
                let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI32())
                if ! IsOk[UirCoreExpr](rhsRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsRes))
                blockBuilderFinish(b, uirCoreTermCbr(Value[UirCoreExpr](rhsRes), tLabel, fLabel))
                return Ok[bool](true)
            else:
                let rhsLabel2: str = blockBuilderNextLabel(b, "or_rhs")
                blockBuilderFinish(b, uirCoreTermCbr(Value[UirCoreExpr](lhsRes), tLabel, rhsLabel2))
                blockBuilderStart(b, rhsLabel2)
                let rhsRes2: Result[UirCoreExpr] = lowerExprValue(b, rhsNode, uirCoreTypeI32())
                if ! IsOk[UirCoreExpr](rhsRes2):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsRes2))
                blockBuilderFinish(b, uirCoreTermCbr(Value[UirCoreExpr](rhsRes2), tLabel, fLabel))
                return Ok[bool](true)
    let condRes: Result[UirCoreExpr] = lowerExprValue(b, node, uirCoreTypeI32())
    if ! IsOk[UirCoreExpr](condRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](condRes))
    blockBuilderFinish(b, uirCoreTermCbr(Value[UirCoreExpr](condRes), tLabel, fLabel))
    return Ok[bool](true)

fn lowerBoolAssign(b: BlockBuilder, exprNode: Node, name: str, slot: int32): Result[bool] =
    let trueLabel: str = blockBuilderNextLabel(b, "bool_true")
    let falseLabel: str = blockBuilderNextLabel(b, "bool_false")
    let joinLabel: str = blockBuilderNextLabel(b, "bool_join")
    let condRes: Result[bool] = lowerCondBranch(b, exprNode, trueLabel, falseLabel)
    if ! IsOk[bool](condRes):
        return ErrInfo[bool](ErrorInfoOf[bool](condRes))
    blockBuilderStart(b, trueLabel)
    add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(1)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))
    blockBuilderStart(b, falseLabel)
    add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))
    blockBuilderStart(b, joinLabel)
    return Ok[bool](false)

fn lowerAssignValue(b: BlockBuilder, exprNode: Node, name: str, slot: int32): Result[bool] =
    let objLocalIdx: int32 = funcFindObjLocal(b.func, slot)
    if objLocalIdx >= 0:
        let fref: UirCoreFunc = b.func
        let dstOl: UirCoreObjLocal = fref.objLocals[objLocalIdx]
        let objTypeName: str = dstOl.objTypeName
        let dstPtr: UirCoreExpr = uirCoreLocal(slot)
        let aliasTy: UirCoreType = uirCoreTryGetTypeAlias(b.module, objTypeName)
        if (getEnv "BACKEND_DEBUG_ALIAS" == "1") && (objTypeName == "Node"):
            let mTmp: UirCoreModule = b.module
            echo("[backend] debug: alias Node kind=" + intToStr(int32(aliasTy.kind)) +
                 " aliases=" + intToStr(mTmp.typeAliases.len) +
                 " objs=" + intToStr(mTmp.objTypes.len))
        if aliasTy.kind != mtVoid:
            if exprNode == nil || exprNode.kind == nkEmpty:
                add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
                return Ok[bool](false)
            let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, aliasTy)
            if ! IsOk[UirCoreExpr](rhsRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsRes))
            add(b.currentStmts, uirCoreStmtAssign(name, slot, Value[UirCoreExpr](rhsRes)))
            return Ok[bool](false)
        if dstOl.frameOff < 0:
            # Pointer-like locals (e.g. `T*`, `ref T`) are tracked as objLocals for layout info,
            # but they do not own object storage. Assign them like scalar pointer slots.
            let slotKeyPtr: str = localTypeKey(b.env, slot)
            if slotKeyPtr != nil && len(slotKeyPtr) > 0 && uirCoreStrStartsWith(slotKeyPtr, "var_") &&
               !uirCoreStrStartsWith(slotKeyPtr, "var_ref_"):
                let dstPtrVar: UirCoreExpr = uirCoreLocal(slot)
                if exprNode == nil || exprNode.kind == nkEmpty:
                    let initVarRes: Result[bool] = emitObjDefaultInitPtrs(b, dstPtrVar, objTypeName)
                    if !IsOk[bool](initVarRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](initVarRes))
                    return Ok[bool](false)
                var nodeVarPtr: Node = exprNode
                while nodeVarPtr != nil && nodeVarPtr.kind == nkPar && kidCount(nodeVarPtr) > 0:
                    nodeVarPtr = kid(nodeVarPtr, 0)
                if nodeVarPtr != nil && nodeVarPtr.kind == nkCall:
                    let callVarRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, nodeVarPtr, dstPtrVar)
                    if !IsOk[UirCoreExpr](callVarRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callVarRes))
                    return Ok[bool](false)
                let srcVarPtrRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcVarPtrRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcVarPtrRes))
                let copyVarPtrRes: Result[bool] = emitObjCopyPtrs(b, dstPtrVar, objTypeName, Value[UirCoreExpr](srcVarPtrRes))
                if !IsOk[bool](copyVarPtrRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyVarPtrRes))
                return Ok[bool](false)
            if exprNode == nil || exprNode.kind == nkEmpty:
                add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
                return Ok[bool](false)
            var node2: Node = exprNode
            while node2 != nil && node2.kind == nkPar && kidCount(node2) > 0:
                node2 = kid(node2, 0)
            if node2 != nil && node2.kind == nkCase:
                let caseRes: Result[bool] = lowerCaseAssign(b, node2, name, slot)
                if !IsOk[bool](caseRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](caseRes))
                return caseRes
            if node2 != nil && node2.kind == nkIf:
                let ifRes: Result[bool] = lowerIfAssign(b, node2, name, slot)
                if ! IsOk[bool](ifRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](ifRes))
                return Ok[bool](false)
            if node2 != nil && node2.kind == nkInfix && kidCount(node2) >= 3:
                let opNode: Node = kid(node2, 0)
                let op: str = backendOpName(opNode)
                if op == "&&" || op == "||":
                    let boolRes: Result[bool] = lowerBoolAssign(b, node2, name, slot)
                    if ! IsOk[bool](boolRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](boolRes))
                    return Ok[bool](false)
            let slotType0: UirCoreType = localType(b.env, slot)
            let rhsRes0: Result[UirCoreExpr] = lowerExprValue(b, exprNode, slotType0)
            if ! IsOk[UirCoreExpr](rhsRes0):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsRes0))
            add(b.currentStmts, uirCoreStmtAssign(name, slot, Value[UirCoreExpr](rhsRes0)))
            return Ok[bool](false)
        if exprNode == nil || exprNode.kind == nkEmpty:
            let initRes: Result[bool] = emitObjDefaultInitPtrs(b, dstPtr, objTypeName)
            if ! IsOk[bool](initRes):
                return ErrInfo[bool](ErrorInfoOf[bool](initRes))
            return Ok[bool](false)
        var node: Node = exprNode
        while node != nil && node.kind == nkPar && kidCount(node) > 0:
            node = kid(node, 0)
        if node != nil && (node.kind == nkIdent || node.kind == nkSymbol):
            let srcName: str = plainName(node)
            let srcSlot: int32 = localIndex(b.env, srcName)
            if srcSlot >= 0:
                let srcObjLocalIdx: int32 = funcFindObjLocal(b.func, srcSlot)
                if srcObjLocalIdx >= 0:
                    let srcOl: UirCoreObjLocal = fref.objLocals[srcObjLocalIdx]
                    let dstLayout: str = uirCoreObjLayoutName(b.module, objTypeName)
                    let srcLayout: str = uirCoreObjLayoutName(b.module, srcOl.objTypeName)
                    if ! (srcLayout == dstLayout):
                        let line: str = intToStr(node.pos.line)
                        let col: str = intToStr(node.pos.col)
                        return Err[bool]("uirCore_builder: object copy type mismatch dst=" + objTypeName +
                                         " src=" + srcOl.objTypeName +
                                         " (dstName=" + name + " srcName=" + srcName +
                                         " fn=" + fref.name + " " + fref.originFile + ":" + line + ":" + col + ")")
                    let copyRes: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, uirCoreLocal(srcSlot))
                    if ! IsOk[bool](copyRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                    return Ok[bool](false)
            if srcSlot < 0:
                var gSym: str = srcName
                let mod0: UirCoreModule = b.module
                var gi: int32 = moduleGlobalIndex(mod0, gSym)
                if gi < 0 && b.func != nil && uirCoreDupGlobalNamesHas(srcName):
                    let f2: UirCoreFunc = b.func
                    let g2: str = uirCoreMaybeMangleDupGlobalName(srcName, f2.originFile)
                    if g2 != nil && len(g2) > 0:
                        gSym = g2
                        gi = moduleGlobalIndex(mod0, gSym)
                if gi < 0 && uirCoreDupGlobalNamesHas(srcName):
                    let gi2: int32 = moduleFindGlobalIndexByBaseUnique(mod0, srcName)
                    if mod0 != nil && gi2 >= 0 && gi2 < mod0.globals.len:
                        let g2: UirCoreGlobal = mod0.globals[gi2]
                        if g2.name != nil && len(g2.name) > 0:
                            gSym = g2.name
                            gi = gi2
                if gi >= 0:
                    let gObj: str = uirCoreGlobalObjTypeGet(gSym)
                    if len(gObj) > 0:
                        if ! (gObj == objTypeName):
                            return Err[bool]("uirCore_builder: object copy global type mismatch")
                        let srcPtr: UirCoreExpr = uirCoreLoad(uirCoreGlobalAddr(gSym), uirCoreTypeI64())
                        let copyRes2: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, srcPtr)
                        if ! IsOk[bool](copyRes2):
                            return ErrInfo[bool](ErrorInfoOf[bool](copyRes2))
                        return Ok[bool](false)
        if node != nil && node.kind == nkCall:
            if node.typeCacheValid && node.typeCache != nil:
                let callObj: str = typeNodeObjTypeName(b.module, node.typeCache)
                if len(callObj) > 0 && ! (callObj == objTypeName):
                    return Err[bool]("uirCore_builder: object call return type mismatch")
            let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, node, dstPtr)
            if ! IsOk[UirCoreExpr](callRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
            return Ok[bool](false)
        if node != nil && node.kind == nkDotExpr:
            let srcRes: Result[UirCoreExpr] = lowerExprValue(b, node, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](srcRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
            let tmpName: str = "__obj_src"
            let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, Value[UirCoreExpr](srcRes)))
            let copyRes3: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, uirCoreLocal(tmpSlot))
            if !IsOk[bool](copyRes3):
                return ErrInfo[bool](ErrorInfoOf[bool](copyRes3))
            return Ok[bool](false)
        if node != nil && node.kind == nkTupleLit:
            let litRes: Result[bool] = emitTupleLitToPtr(b, dstPtr, objTypeName, node)
            if ! IsOk[bool](litRes):
                return ErrInfo[bool](ErrorInfoOf[bool](litRes))
            return Ok[bool](false)
        if node != nil && node.kind == nkSeqLit && uirCoreStrStartsWith(dstOl.typeKey, "seq_"):
            let key: str = dstOl.typeKey
            let litRes2: Result[bool] = emitSeqLitToPtr(b, dstPtr, key, node)
            if ! IsOk[bool](litRes2):
                return ErrInfo[bool](ErrorInfoOf[bool](litRes2))
            return Ok[bool](false)
        if node != nil && node.kind == nkComprehension && uirCoreStrStartsWith(dstOl.typeKey, "seq_"):
            let key2: str = dstOl.typeKey
            let compRes: Result[bool] = emitSeqComprehensionToPtr(b, name, dstPtr, key2, node)
            if !IsOk[bool](compRes):
                return ErrInfo[bool](ErrorInfoOf[bool](compRes))
            return compRes
        if node != nil && node.kind == nkBracketExpr && kidCount(node) == 2 && uirCoreStrStartsWith(dstOl.typeKey, "seq_"):
            var idx0: Node = kid(node, 1)
            while idx0 != nil && idx0.kind == nkPar && kidCount(idx0) > 0:
                idx0 = kid(idx0, 0)
            if idx0 != nil && idx0.kind == nkInfix && kidCount(idx0) >= 3:
                let opNode: Node = kid(idx0, 0)
                let op: str = backendOpName(opNode)
                if op == ".." || op == "..<":
                    let base0: Node = kid(node, 0)
                    var baseKey: str = ""
                    if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
                        baseKey = typeKey base0.typeCache
                    if len(baseKey) == 0 && base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                        let nm: str = plainName(base0)
                        let slot0: int32 = localIndex(b.env, nm)
                        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                            baseKey = funcObjTypeKey(b.func, slot0)
                    if len(baseKey) > 0 && uirCoreStrStartsWith(baseKey, "seq_") && !(baseKey == dstOl.typeKey):
                        return Err[bool]("uirCore_builder: seq slice type mismatch")

                    let baseRes: Result[UirCoreExpr] = lowerExprValue(b, base0, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](baseRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](baseRes))
                    let startRes: Result[UirCoreExpr] = lowerExprValue(b, kid(idx0, 1), uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](startRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](startRes))
                    let stopRes: Result[UirCoreExpr] = lowerExprValue(b, kid(idx0, 2), uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](stopRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](stopRes))
                    let exclusive: UirCoreExpr = (op == "..<") ? uirCoreConstI64(1) : uirCoreConstI64(0)
                    let start32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](startRes))
                    let stop32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), Value[UirCoreExpr](stopRes))

                    let elemKey: str = str(ptr_add(void*(dstOl.typeKey), 4))
                    let typeArg0: Node = newIdent(elemKey, node.pos)
                    var typeArgs2: Node[]
                    add(typeArgs2, typeArg0)
                    let callName2: str = mangleInstance("__cheng_slice_vec", typeArgs2)
                    var args2: UirCoreExpr[]
                    add(args2, dstPtr)
                    add(args2, Value[UirCoreExpr](baseRes))
                    add(args2, start32)
                    add(args2, stop32)
                    add(args2, exclusive)
                    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(callName2, args2)))
                    return Ok[bool](false)
        if node != nil && node.typeCacheValid && node.typeCache != nil:
            let rhsObj: str = typeNodeObjTypeName(b.module, node.typeCache)
            if len(rhsObj) > 0 && typeNodeIsObjValue(b.module, node.typeCache):
                if !(rhsObj == objTypeName):
                    return Err[bool]("uirCore_builder: object value assignment type mismatch")
                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, node, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                let tmpName: str = "__obj_src"
                let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, Value[UirCoreExpr](srcRes)))
                let copyRes3: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, uirCoreLocal(tmpSlot))
                if !IsOk[bool](copyRes3):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes3))
                return Ok[bool](false)
        if node != nil && node.kind == nkBracketExpr && kidCount(node) == 2:
            let srcRes: Result[UirCoreExpr] = lowerExprValue(b, node, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](srcRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
            let tmpName: str = "__obj_src"
            let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, Value[UirCoreExpr](srcRes)))
            let copyRes3: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, uirCoreLocal(tmpSlot))
            if !IsOk[bool](copyRes3):
                return ErrInfo[bool](ErrorInfoOf[bool](copyRes3))
            return Ok[bool](false)
        if node != nil && (node.kind == nkInfix || node.kind == nkPrefix || node.kind == nkPostfix):
            let srcRes4: Result[UirCoreExpr] = lowerExprValue(b, node, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](srcRes4):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes4))
            let tmpName4: str = "__obj_src"
            let tmpSlot4: int32 = localAdd(b.env, tmpName4, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, tmpSlot4, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(tmpName4, tmpSlot4, Value[UirCoreExpr](srcRes4)))
            let srcObjLocalIdx4: int32 = funcFindObjLocal(b.func, tmpSlot4)
            if srcObjLocalIdx4 >= 0:
                let srcOl4: UirCoreObjLocal = fref.objLocals[srcObjLocalIdx4]
                let dstLayout4: str = uirCoreObjLayoutName(b.module, objTypeName)
                let srcLayout4: str = uirCoreObjLayoutName(b.module, srcOl4.objTypeName)
                if ! (srcLayout4 == dstLayout4):
                    return Err[bool]("uirCore_builder: object value assignment type mismatch")
                let copyRes4: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName, uirCoreLocal(tmpSlot4))
                if !IsOk[bool](copyRes4):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes4))
                return Ok[bool](false)
        var fnName: str = ""
        var fp: str = ""
        if b != nil && b.func != nil:
            let f0: UirCoreFunc = b.func
            fnName = f0.name
            fp = f0.originFile
        let line: str = (exprNode != nil) ? intToStr(exprNode.pos.line) : "0"
        let col: str = (exprNode != nil) ? intToStr(exprNode.pos.col) : "0"
        let k: str = (node != nil) ? intToStr(int32(node.kind)) : "0"
        var tcObj: str = ""
        var tcKind: str = "0"
        if node != nil && node.typeCacheValid && node.typeCache != nil:
            let tc0: Node = node.typeCache
            tcObj = typeNodeObjTypeName(b.module, tc0)
            tcKind = intToStr(int32(tc0.kind))
        return Err[bool]("uirCore_builder: object value assignment not supported: " + name +
                         " (obj=" + objTypeName + " rhsKind=nk#" + k +
                         " tcObj=" + tcObj + " tcKind=nk#" + tcKind +
                         " fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")
    let slotKey0: str = localTypeKey(b.env, slot)
    if slotKey0 != nil && len(slotKey0) > 0 &&
       (uirCoreStrStartsWith(slotKey0, "var_") || uirCoreStrStartsWith(slotKey0, "var_ref_") || (slotKey0 == "var")):
        var baseKey0: str = slotKey0
        if uirCoreStrStartsWith(baseKey0, "var_ref_"):
            baseKey0 = str(ptr_add(void*(baseKey0), 8))
        elif uirCoreStrStartsWith(baseKey0, "var_"):
            baseKey0 = str(ptr_add(void*(baseKey0), 4))
        var storeThroughAddr: bool = true
        if baseKey0 != nil && len(baseKey0) > 0 && b.module != nil:
            if uirCoreHasObjType(b.module, baseKey0):
                let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(b.module, baseKey0)
                storeThroughAddr = aliasTy0.kind != mtVoid
            elif uirCoreStrStartsWith(baseKey0, "seq_") && uirCoreHasObjType(b.module, "seq"):
                storeThroughAddr = false
        if storeThroughAddr:
            var storeTy0: UirCoreType = uirCoreTypeI64()
            if baseKey0 != nil && len(baseKey0) > 0:
                if uirCoreStrStartsWith(baseKey0, "ptr_") || uirCoreStrStartsWith(baseKey0, "ref_") ||
                   uirCoreStrStartsWith(baseKey0, "var_") || uirCoreStrStartsWith(baseKey0, "var_ref_") ||
                   (baseKey0 == "ptr") || (baseKey0 == "ref") || (baseKey0 == "var"):
                    storeTy0 = uirCoreTypeI64()
                else:
                    storeTy0 = uirCoreTypeFromTypeKeyName(baseKey0)
                    if storeTy0.kind == mtVoid:
                        storeTy0 = uirCoreTypeI64()
            if exprNode == nil || exprNode.kind == nkEmpty:
                add(b.currentStmts, uirCoreStmtStore(uirCoreLocal(slot), uirCoreConstI64(0), storeTy0))
                return Ok[bool](false)
            let rhsVarRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, storeTy0)
            if !IsOk[UirCoreExpr](rhsVarRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsVarRes))
            add(b.currentStmts, uirCoreStmtStore(uirCoreLocal(slot), Value[UirCoreExpr](rhsVarRes), storeTy0))
            return Ok[bool](false)
        # Object-value `var` assignment must write through the pointed storage.
        # Rebinding the local pointer slot drops the caller-visible update.
        var dstObjType: str = ""
        if baseKey0 != nil && len(baseKey0) > 0 && b.module != nil:
            dstObjType = uirCoreObjTypeFromTypeKey(b.module, baseKey0)
            if (dstObjType == nil || len(dstObjType) == 0) &&
               (baseKey0 == "seq" || uirCoreStrStartsWith(baseKey0, "seq_") || uirCoreStrStartsWith(baseKey0, "seq_fixed_")) &&
               uirCoreHasObjType(b.module, "seq"):
                dstObjType = "seq"
            if (dstObjType == nil || len(dstObjType) == 0) &&
               (baseKey0 == "Table" || uirCoreStrStartsWith(baseKey0, "Table_")) &&
               uirCoreHasObjType(b.module, "Table"):
                dstObjType = "Table"
        if dstObjType != nil && len(dstObjType) > 0:
            let dstPtr0: UirCoreExpr = uirCoreLocal(slot)
            if exprNode == nil || exprNode.kind == nkEmpty:
                let initRes0: Result[bool] = emitObjDefaultInitPtrs(b, dstPtr0, dstObjType)
                if !IsOk[bool](initRes0):
                    return ErrInfo[bool](ErrorInfoOf[bool](initRes0))
                return Ok[bool](false)
            var nodeVar0: Node = exprNode
            while nodeVar0 != nil && nodeVar0.kind == nkPar && kidCount(nodeVar0) > 0:
                nodeVar0 = kid(nodeVar0, 0)
            if nodeVar0 != nil && nodeVar0.kind == nkCall:
                let callRes0: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, nodeVar0, dstPtr0)
                if !IsOk[UirCoreExpr](callRes0):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes0))
                return Ok[bool](false)
            let srcVarRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](srcVarRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcVarRes))
            let copyVarRes: Result[bool] = emitObjCopyPtrs(b, dstPtr0, dstObjType, Value[UirCoreExpr](srcVarRes))
            if !IsOk[bool](copyVarRes):
                return ErrInfo[bool](ErrorInfoOf[bool](copyVarRes))
            return Ok[bool](false)
    if exprNode == nil || exprNode.kind == nkEmpty:
        add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
        return Ok[bool](false)
    var node: Node = exprNode
    while node != nil && node.kind == nkPar && kidCount(node) > 0:
        node = kid(node, 0)
    if node != nil && node.kind == nkCase:
        let caseRes: Result[bool] = lowerCaseAssign(b, node, name, slot)
        if !IsOk[bool](caseRes):
            return ErrInfo[bool](ErrorInfoOf[bool](caseRes))
        return caseRes
    if node != nil && node.kind == nkIf:
        let ifRes: Result[bool] = lowerIfAssign(b, node, name, slot)
        if ! IsOk[bool](ifRes):
            return ErrInfo[bool](ErrorInfoOf[bool](ifRes))
        return Ok[bool](false)
    if node != nil && node.kind == nkInfix && kidCount(node) >= 3:
        let opNode: Node = kid(node, 0)
        let op: str = backendOpName(opNode)
        if op == "&&" || op == "||":
            let boolRes: Result[bool] = lowerBoolAssign(b, node, name, slot)
            if ! IsOk[bool](boolRes):
                return ErrInfo[bool](ErrorInfoOf[bool](boolRes))
            return Ok[bool](false)
    let slotType: UirCoreType = localType(b.env, slot)
    let rhsRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, slotType)
    if ! IsOk[UirCoreExpr](rhsRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](rhsRes))
    add(b.currentStmts, uirCoreStmtAssign(name, slot, Value[UirCoreExpr](rhsRes)))
    return Ok[bool](false)

fn lowerForStmt(b: BlockBuilder, forNode: Node): Result[bool] =
    if forNode == nil || forNode.kind != nkFor:
        return Err[bool]("uirCore_builder: invalid for")
    if kidCount(forNode) < 3:
        return Err[bool]("uirCore_builder: for expects pattern/iter/body")
    let iterExpr: Node = kid(forNode, 1)
    let bodyRaw: Node = kid(forNode, 2)

    # Parse patterns:
    # - Single: `for v in xs:`
    # - Tuple: `for i, v in xs:` (parser represents it as nkTupleLit of patterns)
    var patNames: str[2]
    var patTypes: Node[2]
    let patNode: Node = kid(forNode, 0)
    if patNode != nil && patNode.kind == nkTupleLit:
        for pi in 0..<kidCount(patNode):
            let p: Node = kid(patNode, pi)
            var nameNode: Node = p
            var typeNode: Node = nil
            if p != nil && p.kind == nkPattern && kidCount(p) > 0:
                nameNode = kid(p, 0)
                if kidCount(p) > 1:
                    typeNode = kid(p, 1)
            if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
                return Err[bool]("uirCore_builder: for expects identifier patterns")
            add(patNames, plainName(nameNode))
            add(patTypes, typeNode)
    else:
        var nameNode: Node = patNode
        var typeNode: Node = nil
        if patNode != nil && patNode.kind == nkPattern && kidCount(patNode) > 0:
            nameNode = kid(patNode, 0)
            if kidCount(patNode) > 1:
                typeNode = kid(patNode, 1)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            return Err[bool]("uirCore_builder: for expects identifier pattern")
        add(patNames, plainName(nameNode))
        add(patTypes, typeNode)
    if patNames.len <= 0:
        return Err[bool]("uirCore_builder: for expects pattern")
    if patNames.len > 2:
        return Err[bool]("uirCore_builder: for supports up to 2 patterns")

    var bodyNode: Node = bodyRaw
    if bodyNode != nil && bodyNode.kind != nkStmtList:
        var wrapBody: Node = newNode(nkStmtList, bodyNode.pos)
        addSon(wrapBody, bodyNode)
        bodyNode = wrapBody
    if bodyNode == nil || bodyNode.kind != nkStmtList:
        return Err[bool]("uirCore_builder: for expects stmt list body")

    # 1) Range loops: `for i in a..b` / `a..<b`
    if iterExpr != nil && iterExpr.kind == nkInfix && kidCount(iterExpr) >= 3:
        let opNode: Node = kid(iterExpr, 0)
        let op: str = backendOpName(opNode)
        if op == ".." || op == "..<":
            if patNames.len != 1:
                return Err[bool]("uirCore_builder: range for expects single pattern")
            let varName: str = patNames[0]
            let varTypeNode: Node = patTypes[0]
            let varType: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, varTypeNode)
            let slot: int32 = localAdd(b.env, varName, varType)
            uirCoreSetLocalType(b.func, slot, varType)

            let startNode: Node = kid(iterExpr, 1)
            let endNode: Node = kid(iterExpr, 2)
            let startRes: Result[UirCoreExpr] = lowerExprValue(b, startNode, varType)
            if ! IsOk[UirCoreExpr](startRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](startRes))
            add(b.currentStmts, uirCoreStmtVar(varName, slot, Value[UirCoreExpr](startRes)))

            let endName: str = blockBuilderNextTemp(b, "__for_end")
            let endSlot: int32 = localAdd(b.env, endName, varType)
            uirCoreSetLocalType(b.func, endSlot, varType)
            let endRes: Result[UirCoreExpr] = lowerExprValue(b, endNode, varType)
            if ! IsOk[UirCoreExpr](endRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](endRes))
            add(b.currentStmts, uirCoreStmtVar(endName, endSlot, Value[UirCoreExpr](endRes)))

            let condLabel: str = blockBuilderNextLabel(b, "for_cond")
            let bodyLabel: str = blockBuilderNextLabel(b, "for_body")
            let incLabel: str = blockBuilderNextLabel(b, "for_inc")
            let endLabel: str = blockBuilderNextLabel(b, "for_end")
            blockBuilderFinish(b, uirCoreTermBr(condLabel))

            blockBuilderStart(b, condLabel)
            var condExpr: UirCoreExpr
            if op == "..":
                condExpr = uirCoreCmp(mcLe, uirCoreLocal(slot), uirCoreLocal(endSlot))
            else:
                condExpr = uirCoreCmp(mcLt, uirCoreLocal(slot), uirCoreLocal(endSlot))
            blockBuilderFinish(b, uirCoreTermCbr(condExpr, bodyLabel, endLabel))

            blockBuilderStart(b, bodyLabel)
            blockBuilderPushLoop(b, endLabel, incLabel)
            let bodyTermRes: Result[bool] = lowerStmtList(b, bodyNode)
            blockBuilderPopLoop(b)
            if ! IsOk[bool](bodyTermRes):
                return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes))
            let bodyTerminated: bool = Value[bool](bodyTermRes)
            if ! bodyTerminated:
                blockBuilderFinish(b, uirCoreTermBr(incLabel))

            blockBuilderStart(b, incLabel)
            let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(slot), uirCoreConstI64(1))
            add(b.currentStmts, uirCoreStmtAssign(varName, slot, incExpr))
            blockBuilderFinish(b, uirCoreTermBr(condLabel))

            blockBuilderStart(b, endLabel)
            return Ok[bool](false)

    # 2) Iterable loops: `for v in seq/str/Table/HashMap`
    var iterKey: str = ""
    if iterExpr != nil && iterExpr.typeCacheValid && iterExpr.typeCache != nil:
        iterKey = typeKey iterExpr.typeCache
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil && (iterExpr.kind == nkIdent || iterExpr.kind == nkSymbol):
        let nm: str = plainName(iterExpr)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
            iterKey = funcObjTypeKey(b.func, slot0)
        elif slot0 >= 0:
            iterKey = localTypeKey(b.env, slot0)
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil && iterExpr.kind == nkSeqLit:
        # For seq literals, stage1 sometimes clears typeCache. Infer a best-effort element type.
        if kidCount(iterExpr) > 0:
            var elemKey: str = "int32"
            for ii in 0..<kidCount(iterExpr):
                var e: Node = kid(iterExpr, ii)
                if e != nil && e.kind == nkCallArg && kidCount(e) > 1:
                    e = kid(e, 1)
                if e != nil && e.kind == nkIntLit:
                    if e.intVal > 2147483647 || e.intVal < (-2147483647 - 1):
                        elemKey = "int64"
                elif e != nil && e.typeCacheValid && e.typeCache != nil:
                    let ek: str = typeKey e.typeCache
                    if len(ek) > 0:
                        elemKey = ek
            if elemKey != nil && len(elemKey) > 0:
                iterKey = "seq_" + elemKey
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil && iterExpr.kind == nkStrLit:
        iterKey = "str"
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil && iterExpr.kind == nkBracketExpr && kidCount(iterExpr) == 2:
        # Slices preserve the base container type key, e.g. `s[1..<3]` is still `str`.
        let base0: Node = kid(iterExpr, 0)
        var baseKey: str = ""
        if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
            baseKey = typeKey base0.typeCache
        if len(baseKey) == 0 && base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
            let nm: str = plainName(base0)
            let slot0: int32 = localIndex(b.env, nm)
            if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                baseKey = funcObjTypeKey(b.func, slot0)
            elif slot0 >= 0:
                baseKey = localTypeKey(b.env, slot0)
        if len(baseKey) == 0 && base0 != nil && base0.kind == nkStrLit:
            baseKey = "str"
        if len(baseKey) > 0:
            iterKey = baseKey
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil:
        iterKey = caseInferExprTypeKey(b, iterExpr)
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil:
        iterKey = exprTypeKeyShallow(b, iterExpr)
    if (len(iterKey) == 0 || (iterKey == "node")) && iterExpr != nil &&
       iterExpr.typeCacheValid && iterExpr.typeCache != nil:
        let looseKey: str = uirCoreTypeKeyFromNodeLoose(iterExpr.typeCache)
        if looseKey != nil && len(looseKey) > 0:
            iterKey = looseKey

    iterKey = uirCoreTypeKeyStripIterWrappers(iterKey)
    var iterKeyBase: str = uirCoreTypeKeyBaseName(iterKey)
    if iterKeyBase == nil || len(iterKeyBase) == 0:
        iterKeyBase = iterKey

    if uirCoreStrStartsWith(iterKeyBase, "seq_"):
        var iterPtr: UirCoreExpr
        let iterSeqKey: str = iterKeyBase
        if iterExpr != nil && iterExpr.kind == nkSeqLit && !(iterExpr.typeCacheValid && iterExpr.typeCache != nil):
            let lit: Node = iterExpr
            let seqSlotName: str = blockBuilderNextTemp(b, "__for_seq")
            let seqSlot: int32 = localAdd(b.env, seqSlotName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, seqSlot, uirCoreTypeI64())
            let allocRes: Result[bool] = allocObjValueLocal(b, seqSlot, "seq")
            if ! IsOk[bool](allocRes):
                return ErrInfo[bool](ErrorInfoOf[bool](allocRes))
            funcSetObjTypeKey(b.func, seqSlot, iterSeqKey)
            let litRes: Result[bool] = emitSeqLitToPtr(b, uirCoreLocal(seqSlot), iterSeqKey, lit)
            if ! IsOk[bool](litRes):
                return ErrInfo[bool](ErrorInfoOf[bool](litRes))
            iterPtr = uirCoreLocal(seqSlot)
        else:
            let iterRes: Result[UirCoreExpr] = lowerExprValue(b, iterExpr, uirCoreTypeI64())
            if ! IsOk[UirCoreExpr](iterRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](iterRes))
            let iterTmpName: str = blockBuilderNextTemp(b, "__for_iter")
            let iterTmpSlot: int32 = localAdd(b.env, iterTmpName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, iterTmpSlot, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(iterTmpName, iterTmpSlot, Value[UirCoreExpr](iterRes)))
            iterPtr = uirCoreLocal(iterTmpSlot)

        let elemKey: str = str(ptr_add(void*(iterSeqKey), 4))
        if elemKey == nil || len(elemKey) == 0:
            return Err[bool]("uirCore_builder: for seq missing element type")
        let elemTypeNode: Node = newIdent(elemKey, forNode.pos)
        let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)
        let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
        if ! IsOk[int32](sizeRes):
            return ErrInfo[bool](ErrorInfoOf[int32](sizeRes))
        let elemSize: int32 = Value[int32](sizeRes)

        let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
        var lenOff: int32 = -1
        var bufOff: int32 = -1
        for fi in 0..<seqOt.fields.len:
            let f: UirCoreObjField = seqOt.fields[fi]
            if (f.name == "len"):
                lenOff = f.offset
            elif (f.name == "buffer"):
                bufOff = f.offset
        if lenOff < 0 || bufOff < 0:
            return Err[bool]("uirCore_builder: seq layout mismatch")

        let lenAddr: UirCoreExpr = (lenOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(lenOff)))
        let bufAddr: UirCoreExpr = (bufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(bufOff)))

        let lenName: str = blockBuilderNextTemp(b, "__for_len")
        let lenSlot: int32 = localAdd(b.env, lenName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, lenSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtLet(lenName, lenSlot, uirCoreLoad(lenAddr, uirCoreTypeI32())))

        let bufName: str = blockBuilderNextTemp(b, "__for_buf")
        let bufSlot: int32 = localAdd(b.env, bufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, bufSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(bufName, bufSlot, uirCoreLoad(bufAddr, uirCoreTypeI64())))

        var idxName: str = blockBuilderNextTemp(b, "__for_i")
        var valName: str = patNames[0]
        if patNames.len == 2:
            idxName = patNames[0]
            valName = patNames[1]

        let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

        let valSlot: int32 = localAdd(b.env, valName, elemTy)
        uirCoreSetLocalType(b.func, valSlot, elemTy)
        add(b.currentStmts, uirCoreStmtVar(valName, valSlot, uirCoreConstI64(0)))

        let condLabel: str = blockBuilderNextLabel(b, "for_cond")
        let bodyLabel: str = blockBuilderNextLabel(b, "for_body")
        let incLabel: str = blockBuilderNextLabel(b, "for_inc")
        let endLabel: str = blockBuilderNextLabel(b, "for_end")
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, condLabel)
        let condExpr: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(lenSlot))
        blockBuilderFinish(b, uirCoreTermCbr(condExpr, bodyLabel, endLabel))

        blockBuilderStart(b, bodyLabel)
        # Load element: *(buffer + i*elemSize)
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(idxSlot))
        let step: UirCoreExpr = uirCoreConstI64(int64(elemSize))
        let off: UirCoreExpr = (elemSize == 1) ? idx64 : uirCoreBin(mbMul, idx64, step)
        let addr: UirCoreExpr = (elemSize == 0) ? uirCoreLocal(bufSlot) : uirCoreBin(mbAdd, uirCoreLocal(bufSlot), off)
        let elemVal: UirCoreExpr = uirCoreLoad(addr, elemTy)
        add(b.currentStmts, uirCoreStmtAssign(valName, valSlot, elemVal))

        blockBuilderPushLoop(b, endLabel, incLabel)
        let bodyTermRes: Result[bool] = lowerStmtList(b, bodyNode)
        blockBuilderPopLoop(b)
        if ! IsOk[bool](bodyTermRes):
            return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes))
        let bodyTerminated: bool = Value[bool](bodyTermRes)
        if ! bodyTerminated:
            blockBuilderFinish(b, uirCoreTermBr(incLabel))

        blockBuilderStart(b, incLabel)
        let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
        add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr))
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, endLabel)
        return Ok[bool](false)

    if (iterKeyBase == "str") || (iterKeyBase == "string") || (iterKeyBase == "cstring"):
        let iterRes: Result[UirCoreExpr] = lowerExprValue(b, iterExpr, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](iterRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](iterRes))
        let iterTmpName: str = blockBuilderNextTemp(b, "__for_iter")
        let iterTmpSlot: int32 = localAdd(b.env, iterTmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, iterTmpSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(iterTmpName, iterTmpSlot, Value[UirCoreExpr](iterRes)))
        let iterPtr: UirCoreExpr = uirCoreLocal(iterTmpSlot)

        # String iteration: index-by-byte over a C string, returns char(i32) masked to 0..255.
        let lenName: str = blockBuilderNextTemp(b, "__for_strlen")
        let lenSlot: int32 = localAdd(b.env, lenName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, lenSlot, uirCoreTypeI32())
        var strlenArgs: UirCoreExpr[]
        add(strlenArgs, iterPtr)
        add(b.currentStmts, uirCoreStmtLet(lenName, lenSlot, uirCoreCall("cheng_strlen", strlenArgs)))

        var idxName: str = blockBuilderNextTemp(b, "__for_i")
        var chName: str = patNames[0]
        if patNames.len == 2:
            idxName = patNames[0]
            chName = patNames[1]

        let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

        let chSlot: int32 = localAdd(b.env, chName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, chSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(chName, chSlot, uirCoreConstI64(0)))

        let condLabel: str = blockBuilderNextLabel(b, "for_cond")
        let bodyLabel: str = blockBuilderNextLabel(b, "for_body")
        let incLabel: str = blockBuilderNextLabel(b, "for_inc")
        let endLabel: str = blockBuilderNextLabel(b, "for_end")
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, condLabel)
        let condExpr: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(lenSlot))
        blockBuilderFinish(b, uirCoreTermCbr(condExpr, bodyLabel, endLabel))

        blockBuilderStart(b, bodyLabel)
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(idxSlot))
        let addr: UirCoreExpr = uirCoreBin(mbAdd, iterPtr, idx64)
        let raw: UirCoreExpr = uirCoreLoad(addr, uirCoreTypeI32())
        let chVal: UirCoreExpr = uirCoreBin(mbAnd, raw, uirCoreConstI64(255))
        add(b.currentStmts, uirCoreStmtAssign(chName, chSlot, chVal))

        blockBuilderPushLoop(b, endLabel, incLabel)
        let bodyTermRes: Result[bool] = lowerStmtList(b, bodyNode)
        blockBuilderPopLoop(b)
        if ! IsOk[bool](bodyTermRes):
            return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes))
        let bodyTerminated: bool = Value[bool](bodyTermRes)
        if ! bodyTerminated:
            blockBuilderFinish(b, uirCoreTermBr(incLabel))

        blockBuilderStart(b, incLabel)
        let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
        add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr))
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, endLabel)
        return Ok[bool](false)

    if uirCoreTypeKeyIsTableIter(iterKey):
        let iterRes: Result[UirCoreExpr] = lowerExprValue(b, iterExpr, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](iterRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](iterRes))
        let iterTmpName: str = blockBuilderNextTemp(b, "__for_iter")
        let iterTmpSlot: int32 = localAdd(b.env, iterTmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, iterTmpSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(iterTmpName, iterTmpSlot, Value[UirCoreExpr](iterRes)))
        let iterPtr: UirCoreExpr = uirCoreLocal(iterTmpSlot)

        # Inline table iteration: scan `states` and yield matching `keys`/`vals`.
        var tblObjName: str = ""
        if b.module != nil:
            tblObjName = uirCorePtrBaseObjTypeName(b.module, iterKey)
        if len(tblObjName) == 0:
            tblObjName = iterKeyBase
        if iterExpr != nil && (iterExpr.kind == nkIdent || iterExpr.kind == nkSymbol):
            let nm: str = plainName(iterExpr)
            let slot0: int32 = localIndex(b.env, nm)
            if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                let objNm: str = funcObjTypeName(b.func, slot0)
                if len(objNm) > 0:
                    tblObjName = objNm

        if b.module != nil:
            let resolved: str = uirCorePtrBaseObjTypeName(b.module, tblObjName)
            if len(resolved) > 0:
                tblObjName = resolved
        if b.module == nil || tblObjName == nil || len(tblObjName) == 0 || ! uirCoreHasObjType(b.module, tblObjName):
            return Err[bool]("uirCore_builder: unknown Table object type")
        let tblOt: UirCoreObjType = uirCoreGetObjType(b.module, tblObjName)
        var keysLenOff: int32 = -1
        var keysBufOff: int32 = -1
        var valsBufOff: int32 = -1
        var statesBufOff: int32 = -1
        for fi2 in 0..<tblOt.fields.len:
            let f: UirCoreObjField = tblOt.fields[fi2]
            if (f.name == "keys.len"):
                keysLenOff = f.offset
            elif (f.name == "keys.buffer"):
                keysBufOff = f.offset
            elif (f.name == "vals.buffer"):
                valsBufOff = f.offset
            elif (f.name == "states.buffer"):
                statesBufOff = f.offset
        if keysLenOff < 0 || keysBufOff < 0 || valsBufOff < 0 || statesBufOff < 0:
            return Err[bool]("uirCore_builder: Table layout mismatch")

        let capName: str = blockBuilderNextTemp(b, "__tbl_cap")
        let capSlot: int32 = localAdd(b.env, capName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, capSlot, uirCoreTypeI32())
        let capAddr: UirCoreExpr = (keysLenOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(keysLenOff)))
        add(b.currentStmts, uirCoreStmtLet(capName, capSlot, uirCoreLoad(capAddr, uirCoreTypeI32())))

        let keysBufName: str = blockBuilderNextTemp(b, "__tbl_kbuf")
        let keysBufSlot: int32 = localAdd(b.env, keysBufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, keysBufSlot, uirCoreTypeI64())
        let keysBufAddr: UirCoreExpr = (keysBufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(keysBufOff)))
        add(b.currentStmts, uirCoreStmtLet(keysBufName, keysBufSlot, uirCoreLoad(keysBufAddr, uirCoreTypeI64())))

        let valsBufName: str = blockBuilderNextTemp(b, "__tbl_vbuf")
        let valsBufSlot: int32 = localAdd(b.env, valsBufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, valsBufSlot, uirCoreTypeI64())
        let valsBufAddr: UirCoreExpr = (valsBufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(valsBufOff)))
        add(b.currentStmts, uirCoreStmtLet(valsBufName, valsBufSlot, uirCoreLoad(valsBufAddr, uirCoreTypeI64())))

        let statesBufName: str = blockBuilderNextTemp(b, "__tbl_sbuf")
        let statesBufSlot: int32 = localAdd(b.env, statesBufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, statesBufSlot, uirCoreTypeI64())
        let statesBufAddr: UirCoreExpr = (statesBufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(statesBufOff)))
        add(b.currentStmts, uirCoreStmtLet(statesBufName, statesBufSlot, uirCoreLoad(statesBufAddr, uirCoreTypeI64())))

        let keyName: str = patNames[0]
        let keySlot: int32 = localAdd(b.env, keyName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, keySlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtVar(keyName, keySlot, uirCoreConstI64(0)))

        var hasVal: bool = false
        var valName: str = ""
        var valSlot: int32 = -1
        var valTy: UirCoreType = uirCoreTypeI64()
        var valSize: int32 = 8
        if patNames.len == 2:
            hasVal = true
            valName = patNames[1]
            var valKey: str = uirCoreTypeKeyTableValKey(iterKey)
            if (valKey == nil || len(valKey) == 0) && iterExpr != nil && iterExpr.typeCacheValid && iterExpr.typeCache != nil:
                valKey = uirCoreTypeKeyTableValKey(typeKey(iterExpr.typeCache))
            if valKey != nil && len(valKey) > 0:
                let valTypeNode: Node = newIdent(valKey, forNode.pos)
                let valTy2: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, valTypeNode)
                if valTy2.kind != mtVoid:
                    valTy = valTy2
                    let valSize2: int32 = uirCoreTypeSize(valTy)
                    if valSize2 > 0:
                        valSize = valSize2
            valSlot = localAdd(b.env, valName, valTy)
            uirCoreSetLocalType(b.func, valSlot, valTy)
            add(b.currentStmts, uirCoreStmtVar(valName, valSlot, uirCoreConstI64(0)))

        let idxName: str = blockBuilderNextTemp(b, "__tbl_i")
        let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

        let curIdxName: str = blockBuilderNextTemp(b, "__tbl_cur_i")
        let curIdxSlot: int32 = localAdd(b.env, curIdxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, curIdxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(curIdxName, curIdxSlot, uirCoreConstI64(0)))

        let scanLabel: str = blockBuilderNextLabel(b, "for_scan")
        let loadLabel: str = blockBuilderNextLabel(b, "for_load")
        let bodyLabel: str = blockBuilderNextLabel(b, "for_body")
        let endLabel: str = blockBuilderNextLabel(b, "for_end")
        blockBuilderFinish(b, uirCoreTermBr(scanLabel))

        blockBuilderStart(b, scanLabel)
        let scanCond: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(capSlot))
        blockBuilderFinish(b, uirCoreTermCbr(scanCond, loadLabel, endLabel))

        blockBuilderStart(b, loadLabel)
        add(b.currentStmts, uirCoreStmtAssign(curIdxName, curIdxSlot, uirCoreLocal(idxSlot)))
        let curIdx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(curIdxSlot))
        let stAddr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(statesBufSlot), curIdx64)
        let stVal: UirCoreExpr = uirCoreLoad(stAddr, uirCoreTypeU8())
        let incExpr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
        add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr))
        let isUsed: UirCoreExpr = uirCoreCmp(mcNe, stVal, uirCoreConstI64(0))
        blockBuilderFinish(b, uirCoreTermCbr(isUsed, bodyLabel, scanLabel))

        blockBuilderStart(b, bodyLabel)
        let keyOff2: UirCoreExpr = uirCoreBin(mbMul, curIdx64, uirCoreConstI64(8))
        let keyAddr2: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(keysBufSlot), keyOff2)
        let keyVal: UirCoreExpr = uirCoreLoad(keyAddr2, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtAssign(keyName, keySlot, keyVal))
        if hasVal:
            let valOff2: UirCoreExpr = uirCoreBin(mbMul, curIdx64, uirCoreConstI64(int64(valSize)))
            let valAddr2: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(valsBufSlot), valOff2)
            let valVal: UirCoreExpr = uirCoreLoad(valAddr2, valTy)
            add(b.currentStmts, uirCoreStmtAssign(valName, valSlot, valVal))

        blockBuilderPushLoop(b, endLabel, scanLabel)
        let bodyTermRes2: Result[bool] = lowerStmtList(b, bodyNode)
        blockBuilderPopLoop(b)
        if ! IsOk[bool](bodyTermRes2):
            return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes2))
        let bodyTerminated2: bool = Value[bool](bodyTermRes2)
        if ! bodyTerminated2:
            blockBuilderFinish(b, uirCoreTermBr(scanLabel))

        blockBuilderStart(b, endLabel)
        return Ok[bool](false)

    let mapFlavor0: int32 = uirCoreHashMapIterFlavorFromTypeKey(iterKey)
    if mapFlavor0 != 0:
        let iterRes: Result[UirCoreExpr] = lowerExprValue(b, iterExpr, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](iterRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](iterRes))
        let iterTmpName: str = blockBuilderNextTemp(b, "__for_iter")
        let iterTmpSlot: int32 = localAdd(b.env, iterTmpName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, iterTmpSlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtLet(iterTmpName, iterTmpSlot, Value[UirCoreExpr](iterRes)))
        let iterPtr: UirCoreExpr = uirCoreLocal(iterTmpSlot)

        var mapObjName: str = ""
        if b.module != nil:
            mapObjName = uirCorePtrBaseObjTypeName(b.module, iterKey)
        if iterExpr != nil && (iterExpr.kind == nkIdent || iterExpr.kind == nkSymbol):
            let nm: str = plainName(iterExpr)
            let slot0: int32 = localIndex(b.env, nm)
            if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                let objNm: str = funcObjTypeName(b.func, slot0)
                if len(objNm) > 0:
                    mapObjName = objNm
        if b.module != nil:
            let resolved: str = uirCorePtrBaseObjTypeName(b.module, mapObjName)
            if len(resolved) > 0:
                mapObjName = resolved

        var mapFlavor: int32 = mapFlavor0
        if mapFlavor == 0:
            mapFlavor = uirCoreHashMapIterFlavorFromTypeKey(mapObjName)
        if mapFlavor == 0:
            return Err[bool]("uirCore_builder: unsupported HashMap iter type")

        var keysLenOff: int32 = -1
        var keysBufOff: int32 = -1
        var valsBufOff: int32 = -1
        let hasMapObjLayout: bool = b.module != nil && mapObjName != nil && len(mapObjName) > 0 &&
                                    uirCoreHasObjType(b.module, mapObjName)
        if hasMapObjLayout:
            let mapOt: UirCoreObjType = uirCoreGetObjType(b.module, mapObjName)
            for fiMap in 0..<mapOt.fields.len:
                let f: UirCoreObjField = mapOt.fields[fiMap]
                if (f.name == "keys.len"):
                    keysLenOff = f.offset
                elif (f.name == "keys.buffer"):
                    keysBufOff = f.offset
                elif (f.name == "vals.buffer"):
                    valsBufOff = f.offset
        if keysLenOff < 0 || keysBufOff < 0 || valsBufOff < 0:
            # Fallback to std/hashmaps stable layout:
            # HashMap* = { keys: seq, vals: seq, ... }.
            keysLenOff = 0
            keysBufOff = 8
            valsBufOff = 24

        let capName: str = blockBuilderNextTemp(b, "__map_cap")
        let capSlot: int32 = localAdd(b.env, capName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, capSlot, uirCoreTypeI32())
        let capAddr: UirCoreExpr = (keysLenOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(keysLenOff)))
        add(b.currentStmts, uirCoreStmtLet(capName, capSlot, uirCoreLoad(capAddr, uirCoreTypeI32())))

        let keysBufName: str = blockBuilderNextTemp(b, "__map_kbuf")
        let keysBufSlot: int32 = localAdd(b.env, keysBufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, keysBufSlot, uirCoreTypeI64())
        let keysBufAddr: UirCoreExpr = (keysBufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(keysBufOff)))
        add(b.currentStmts, uirCoreStmtLet(keysBufName, keysBufSlot, uirCoreLoad(keysBufAddr, uirCoreTypeI64())))

        let valsBufName: str = blockBuilderNextTemp(b, "__map_vbuf")
        let valsBufSlot: int32 = localAdd(b.env, valsBufName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, valsBufSlot, uirCoreTypeI64())
        let valsBufAddr: UirCoreExpr = (valsBufOff == 0) ? iterPtr : uirCoreBin(mbAdd, iterPtr, uirCoreConstI64(int64(valsBufOff)))
        add(b.currentStmts, uirCoreStmtLet(valsBufName, valsBufSlot, uirCoreLoad(valsBufAddr, uirCoreTypeI64())))

        let keyName: str = patNames[0]
        let keySlot: int32 = localAdd(b.env, keyName, uirCoreTypeI64())
        uirCoreSetLocalType(b.func, keySlot, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtVar(keyName, keySlot, uirCoreConstI64(0)))

        var hasVal: bool = false
        var valName: str = ""
        var valSlot: int32 = -1
        var valTy: UirCoreType = uirCoreTypeI32()
        var valSize: int32 = 4
        if patNames.len == 2:
            hasVal = true
            valName = patNames[1]
            if mapFlavor == 2:
                valTy = uirCoreTypeI64()
                let valTyNode: Node = newIdent("seq_int32", forNode.pos)
                valTy = uirCoreTypeFromNodeWithModule(b.module, valTyNode)
                let valSizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, valTyNode)
                if IsOk[int32](valSizeRes):
                    valSize = Value[int32](valSizeRes)
                else:
                    valSize = 8
            valSlot = localAdd(b.env, valName, valTy)
            uirCoreSetLocalType(b.func, valSlot, valTy)
            add(b.currentStmts, uirCoreStmtVar(valName, valSlot, uirCoreConstI64(0)))

        let idxName: str = blockBuilderNextTemp(b, "__map_i")
        let idxSlot: int32 = localAdd(b.env, idxName, uirCoreTypeI32())
        uirCoreSetLocalType(b.func, idxSlot, uirCoreTypeI32())
        add(b.currentStmts, uirCoreStmtVar(idxName, idxSlot, uirCoreConstI64(0)))

        let condLabel: str = blockBuilderNextLabel(b, "for_cond")
        let loadLabel: str = blockBuilderNextLabel(b, "for_load")
        let bodyLabel: str = blockBuilderNextLabel(b, "for_body")
        let incLabel: str = blockBuilderNextLabel(b, "for_inc")
        let endLabel: str = blockBuilderNextLabel(b, "for_end")
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, condLabel)
        let condExpr: UirCoreExpr = uirCoreCmp(mcLt, uirCoreLocal(idxSlot), uirCoreLocal(capSlot))
        blockBuilderFinish(b, uirCoreTermCbr(condExpr, loadLabel, endLabel))

        blockBuilderStart(b, loadLabel)
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreLocal(idxSlot))
        let keyOff: UirCoreExpr = uirCoreBin(mbMul, idx64, uirCoreConstI64(8))
        let keyAddr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(keysBufSlot), keyOff)
        let keyVal: UirCoreExpr = uirCoreLoad(keyAddr, uirCoreTypeI64())
        add(b.currentStmts, uirCoreStmtAssign(keyName, keySlot, keyVal))
        let hasEntry: UirCoreExpr = uirCoreCmp(mcNe, uirCoreLocal(keySlot), uirCoreConstI64(0))
        blockBuilderFinish(b, uirCoreTermCbr(hasEntry, bodyLabel, incLabel))

        blockBuilderStart(b, bodyLabel)
        if hasVal:
            let stepExpr: UirCoreExpr = uirCoreConstI64(int64(valSize))
            let valOff: UirCoreExpr = (valSize == 1) ? idx64 : uirCoreBin(mbMul, idx64, stepExpr)
            let valAddr: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(valsBufSlot), valOff)
            let valVal: UirCoreExpr = uirCoreLoad(valAddr, valTy)
            add(b.currentStmts, uirCoreStmtAssign(valName, valSlot, valVal))

        blockBuilderPushLoop(b, endLabel, incLabel)
        let bodyTermRes3: Result[bool] = lowerStmtList(b, bodyNode)
        blockBuilderPopLoop(b)
        if ! IsOk[bool](bodyTermRes3):
            return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes3))
        let bodyTerminated3: bool = Value[bool](bodyTermRes3)
        if ! bodyTerminated3:
            blockBuilderFinish(b, uirCoreTermBr(incLabel))

        blockBuilderStart(b, incLabel)
        let incExpr2: UirCoreExpr = uirCoreBin(mbAdd, uirCoreLocal(idxSlot), uirCoreConstI64(1))
        add(b.currentStmts, uirCoreStmtAssign(idxName, idxSlot, incExpr2))
        blockBuilderFinish(b, uirCoreTermBr(condLabel))

        blockBuilderStart(b, endLabel)
        return Ok[bool](false)

    let k: str = (iterExpr != nil) ? intToStr(int32(iterExpr.kind)) : "0"
    let line: str = (iterExpr != nil) ? intToStr(iterExpr.pos.line) : "0"
    let col: str = (iterExpr != nil) ? intToStr(iterExpr.pos.col) : "0"
    let keyDbg: str = iterKey
    var extra: str = ""
    if iterExpr != nil && iterExpr.kind == nkInfix && kidCount(iterExpr) > 0:
        extra = " op=" + backendOpName(kid(iterExpr, 0))
    return Err[bool]("uirCore_builder: for unsupported iter expression (kind=nk#" + k + " @" + line + ":" + col + " key='" + keyDbg + "'" + extra + ")")

fn casePatternCore(p0: Node): Node =
    var p: Node = p0
    while p != nil && p.kind == nkPar && kidCount(p) > 0:
        p = kid(p, 0)
    if p != nil && p.kind == nkPattern && kidCount(p) > 0:
        p = kid(p, 0)
        while p != nil && p.kind == nkPar && kidCount(p) > 0:
            p = kid(p, 0)
    return p

fn casePatternTypeNode(p0: Node): Node =
    var p: Node = p0
    while p != nil && p.kind == nkPar && kidCount(p) > 0:
        p = kid(p, 0)
    if p != nil && p.kind == nkPattern && kidCount(p) > 1:
        return kid(p, 1)
    return nil

fn casePatternIsWildcard(p0: Node): bool =
    let core: Node = casePatternCore(p0)
    if core != nil && (core.kind == nkIdent || core.kind == nkSymbol):
        return (plainName(core) == "_")
    return false

fn caseInferExprTypeKey(b: BlockBuilder, n0: Node): str =
    if b == nil:
        return ""
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return ""
    if n.kind == nkBracketExpr && kidCount(n) == 2:
        let baseNode: Node = kid(n, 0)
        var idxNode: Node = kid(n, 1)
        while idxNode != nil && idxNode.kind == nkPar && kidCount(idxNode) > 0:
            idxNode = kid(idxNode, 0)
        if idxNode != nil && idxNode.kind == nkCallArg:
            if kidCount(idxNode) > 1:
                idxNode = kid(idxNode, 1)
            elif kidCount(idxNode) > 0:
                idxNode = kid(idxNode, 0)
        let debugBracketInfer: bool = (getEnv "BACKEND_DEBUG_BRACKET_INFER" == "1")
        var dbgTarget: bool = false
        if debugBracketInfer:
            if baseNode != nil && (baseNode.kind == nkIdent || baseNode.kind == nkSymbol) && (plainName(baseNode) == "root"):
                if idxNode != nil && idxNode.kind == nkStrLit && (idxNode.strVal == "source_addrs"):
                    dbgTarget = true
            if dbgTarget:
                echo("[backend] debugBracketInfer: root['source_addrs'] start")
        if idxNode != nil && idxNode.kind == nkInfix && kidCount(idxNode) >= 3:
            let opNode: Node = kid(idxNode, 0)
            let op: str = backendOpName(opNode)
            if op == ".." || op == "..<":
                let bk0: str = caseInferExprTypeKey(b, baseNode)
                if isStringKey(bk0) || (baseNode != nil && baseNode.kind == nkStrLit):
                    return "str"
                if uirCoreStrStartsWith(bk0, "seq_") || uirCoreStrStartsWith(bk0, "seq_fixed_"):
                    return bk0
        var baseKey: str = caseInferExprTypeKey(b, baseNode)
        if dbgTarget:
            echo("[backend] debugBracketInfer: baseKey='" + baseKey + "' idxKind=nk#" +
                ((idxNode != nil) ? intToStr(int32(idxNode.kind)) : "-1"))
        if baseKey != nil && len(baseKey) > 0:
            if uirCoreStrStartsWith(baseKey, "ref_"):
                baseKey = str(ptr_add(void*(baseKey), 4))
            elif uirCoreStrStartsWith(baseKey, "var_ref_"):
                baseKey = str(ptr_add(void*(baseKey), 8))
            elif uirCoreStrStartsWith(baseKey, "var_"):
                baseKey = str(ptr_add(void*(baseKey), 4))
            if uirCoreStrStartsWith(baseKey, "ptr_"):
                baseKey = str(ptr_add(void*(baseKey), 4))
            if uirCoreStrStartsWith(baseKey, "seq_"):
                return str(ptr_add(void*(baseKey), 4))
            if isStringKey(baseKey) || (baseNode != nil && baseNode.kind == nkStrLit):
                return "char"
        if b.module != nil:
            var argNodes: Node[]
            add(argNodes, baseNode)
            add(argNodes, idxNode)
            var hintSig: str = ""
            if n.typeCacheValid && n.typeCache != nil:
                hintSig = typeKey n.typeCache
            let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, "[]", argNodes, hintSig)
            if dbgTarget:
                let calleeName: str = (callee0 != nil) ? callee0.name : ""
                echo("[backend] debugBracketInfer: resolve '[]' hint='" + hintSig + "' callee='" + calleeName + "'")
            if callee0 != nil:
                var outKey: str = ""
                if callee0.params.len > 0:
                    let p0: UirCoreParam = callee0.params[0]
                    if (p0.name == "__ret"):
                        outKey = funcObjTypeKey(callee0, p0.slot)
                if len(outKey) == 0 && callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                    outKey = callee0.retTypeKey
                if len(outKey) > 0:
                    if dbgTarget:
                        echo("[backend] debugBracketInfer: outKey='" + outKey + "'")
                    return outKey
    if n.kind == nkInfix && kidCount(n) >= 3:
        let opNode: Node = kid(n, 0)
        let op: str = backendOpName(opNode)
        if op == "+":
            let lhsNode: Node = kid(n, 1)
            let rhsNode: Node = kid(n, 2)
            let lk: str = caseInferExprTypeKey(b, lhsNode)
            let rk: str = caseInferExprTypeKey(b, rhsNode)
            if isStringKey(lk) || isStringKey(rk) || lhsNode.kind == nkStrLit || rhsNode.kind == nkStrLit:
                return "str"
    if n.typeCacheValid && n.typeCache != nil:
        return typeKey n.typeCache
    if n.kind == nkStrLit:
        return "str"
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = plainName(n)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
            return funcObjTypeKey(b.func, slot0)
        if slot0 >= 0:
            return localTypeKey(b.env, slot0)
        if uirCoreDupGlobalNamesHas(nm) && b.func != nil:
            let f0: UirCoreFunc = b.func
            let sym0: str = uirCoreMaybeMangleDupGlobalName(nm, f0.originFile)
            let gk1: str = uirCoreGlobalTypeKeyGet(sym0)
            if gk1 != nil && len(gk1) > 0:
                return gk1
        let gk0: str = uirCoreGlobalTypeKeyByBaseUnique(b.module, nm)
        if gk0 != nil && len(gk0) > 0:
            return gk0
        return ""
    if n.kind == nkDotExpr && kidCount(n) > 1:
        let baseNode: Node = kid(n, 0)
        let fieldNode: Node = kid(n, 1)
        let fieldName: str = backendStripSpaces(plainName(fieldNode))
        var parentKey: str = caseInferExprTypeKey(b, baseNode)
        if parentKey != nil && len(parentKey) > 0 && len(fieldName) > 0:
            if uirCoreStrStartsWith(parentKey, "ref_"):
                parentKey = str(ptr_add(void*(parentKey), 4))
            elif uirCoreStrStartsWith(parentKey, "var_ref_"):
                parentKey = str(ptr_add(void*(parentKey), 8))
            elif uirCoreStrStartsWith(parentKey, "var_"):
                parentKey = str(ptr_add(void*(parentKey), 4))
            var fieldKey: str = uirCoreObjFieldTypeKeyGet(parentKey, fieldName)
            if len(fieldKey) == 0 && ((parentKey == "tuple") || uirCoreStrStartsWith(parentKey, "tuple_")):
                let ti: int32 = uirCoreTupleFieldIndexGet(parentKey, fieldName)
                if ti >= 0:
                    let altFieldName: str = "f" + intToStr(ti)
                    fieldKey = uirCoreObjFieldTypeKeyGet(parentKey, altFieldName)
            if len(fieldKey) == 0:
                var pk: str = parentKey
                if uirCoreStrStartsWith(pk, "ptr_"):
                    pk = str(ptr_add(void*(pk), 4))
                if pk != nil && len(pk) > 0 && !(pk == parentKey):
                    fieldKey = uirCoreObjFieldTypeKeyGet(pk, fieldName)
            if len(fieldKey) == 0 && b.module != nil:
                if uirCoreStrStartsWith(parentKey, "seq_") && uirCoreHasObjType(b.module, "seq"):
                    fieldKey = uirCoreObjFieldTypeKeyGet("seq", fieldName)
                elif uirCoreStrStartsWith(parentKey, "seq_fixed_") && uirCoreHasObjType(b.module, "seq"):
                    fieldKey = uirCoreObjFieldTypeKeyGet("seq", fieldName)
                elif uirCoreStrStartsWith(parentKey, "Table_") && uirCoreHasObjType(b.module, "Table"):
                    fieldKey = uirCoreObjFieldTypeKeyGet("Table", fieldName)
            if len(fieldKey) > 0:
                return fieldKey

    if n.kind == nkCall && b.module != nil && kidCount(n) > 0:
        let calleeNode: Node = kid(n, 0)
        var name: str = ""
        var typeArgs: Node[]
        if calleeNode != nil && calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
            let base: Node = kid(calleeNode, 0)
            name = backendStripSpaces(plainName(base))
            for ti in 1..<kidCount(calleeNode):
                let t: Node = kid(calleeNode, ti)
                if t != nil && t.kind != nkEmpty:
                    add(typeArgs, t)
        else:
            name = backendStripSpaces(plainName(calleeNode))
        var callName: str = name
        if typeArgs.len > 0:
            callName = mangleInstance(name, typeArgs)
        var argNodes: Node[]
        for ai in 1..<kidCount(n):
            var argNode: Node = kid(n, ai)
            if argNode != nil && argNode.kind == nkCallArg:
                if kidCount(argNode) > 1:
                    argNode = kid(argNode, 1)
                elif kidCount(argNode) > 0:
                    argNode = kid(argNode, 0)
            add(argNodes, argNode)
        let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, "")
        var outKey: str = ""
        if callee0 != nil:
            if callee0.params.len > 0:
                let p0: UirCoreParam = callee0.params[0]
                if (p0.name == "__ret"):
                    outKey = funcObjTypeKey(callee0, p0.slot)
            if len(outKey) == 0 && callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                outKey = callee0.retTypeKey
        if len(outKey) == 0 && (callName == "Value") && argNodes.len == 1 && b.module != nil:
            let arg0: Node = argNodes[0]
            var parentKey: str = caseInferExprTypeKey(b, arg0)
            if parentKey != nil && len(parentKey) > 0:
                if uirCoreStrStartsWith(parentKey, "ref_"):
                    parentKey = str(ptr_add(void*(parentKey), 4))
                elif uirCoreStrStartsWith(parentKey, "var_ref_"):
                    parentKey = str(ptr_add(void*(parentKey), 8))
                elif uirCoreStrStartsWith(parentKey, "var_"):
                    parentKey = str(ptr_add(void*(parentKey), 4))
                var fieldKey: str = uirCoreObjFieldTypeKeyGet(parentKey, "value")
                if len(fieldKey) == 0:
                    var pk: str = parentKey
                    if uirCoreStrStartsWith(pk, "ptr_"):
                        pk = str(ptr_add(void*(pk), 4))
                    if pk != nil && len(pk) > 0 && !(pk == parentKey):
                        fieldKey = uirCoreObjFieldTypeKeyGet(pk, "value")
                if len(fieldKey) > 0:
                    outKey = fieldKey
        if len(outKey) == 0 && (callName == "Value"):
            let innerKey: str = uirCoreInferValueCallInnerKey(b, n)
            if innerKey != nil && len(innerKey) > 0:
                outKey = innerKey
        if (getEnv "BACKEND_DEBUG_TYPEKEY_CALL" == "1") && (callName == "Value"):
            var a0k: str = ""
            if argNodes.len > 0:
                a0k = uirCoreInferNodeTypeKeyForOverload(b, argNodes[0])
            var calleeName: str = ""
            var calleeFile: str = ""
            if callee0 != nil:
                calleeName = callee0.name
                calleeFile = callee0.originFile
            echo("[backend] debugTypeKeyCall: callName='" + callName + "' arg0Key='" + a0k +
                "' callee='" + calleeName + "' file='" + calleeFile + "' retKey='" + outKey + "'")
        if len(outKey) > 0:
            return outKey
    if n.kind == nkTupleLit:
        var tupleTy: Node = newNode(nkTupleTy, n.pos)
        for i in 0..<kidCount(n):
            var elem: Node = kid(n, i)
            if elem != nil && elem.kind == nkCallArg && kidCount(elem) > 1:
                elem = kid(elem, 1)
            var ek: str = ""
            if elem != nil && elem.typeCacheValid && elem.typeCache != nil:
                ek = typeKey elem.typeCache
            if len(ek) == 0:
                ek = "int64"
            addSon(tupleTy, newIdent(ek, n.pos))
        return typeKey(tupleTy)
    if n.kind == nkSeqLit:
        if kidCount(n) > 0:
            var elemKey: str = "int32"
            for ii in 0..<kidCount(n):
                var e: Node = kid(n, ii)
                if e != nil && e.kind == nkCallArg && kidCount(e) > 1:
                    e = kid(e, 1)
                if e != nil && e.kind == nkIntLit:
                    if e.intVal > 2147483647 || e.intVal < (-2147483647 - 1):
                        elemKey = "int64"
                elif e != nil && e.typeCacheValid && e.typeCache != nil:
                    let ek: str = typeKey e.typeCache
                    if len(ek) > 0:
                        elemKey = ek
            if len(elemKey) > 0:
                return "seq_" + elemKey
    return ""

fn caseComputeSetBits(pat0: Node): Result[int64] =
    var pat: Node = pat0
    while pat != nil && pat.kind == nkPar && kidCount(pat) > 0:
        pat = kid(pat, 0)
    if pat == nil || pat.kind != nkCurly:
        return Err[int64]("uirCore_builder: case set pattern expects {}")
    var bits: int64 = 0
    for i in 0..<kidCount(pat):
        var item: Node = kid(pat, i)
        while item != nil && item.kind == nkPar && kidCount(item) > 0:
            item = kid(item, 0)
        if item == nil:
            continue
        var startVal: int64 = 0
        var endVal: int64 = 0
        var hasRange: bool = false
        var exclusive: bool = false
        if item.kind == nkInfix && kidCount(item) >= 3:
            let opNode: Node = kid(item, 0)
            let op: str = backendOpName(opNode)
            if op == ".." || op == "..<":
                hasRange = true
                exclusive = op == "..<"
                let lhs: Node = kid(item, 1)
                let rhs: Node = kid(item, 2)
                if lhs == nil || lhs.kind != nkIntLit || rhs == nil || rhs.kind != nkIntLit:
                    return Err[int64]("uirCore_builder: case set range expects int literals")
                startVal = lhs.intVal
                endVal = rhs.intVal
        if !hasRange:
            if item.kind != nkIntLit:
                return Err[int64]("uirCore_builder: case set pattern expects int literals")
            startVal = item.intVal
            endVal = item.intVal
        if exclusive:
            endVal = endVal - 1
        for v in startVal..endVal:
            if v < 0 || v >= 64:
                return Err[int64]("uirCore_builder: case set pattern out of 0..63")
            bits = bits | (int64(1) << v)
    return Ok[int64](bits)

fn caseMatchTuplePattern(b: BlockBuilder, pat: Node, selPtr: UirCoreExpr, selKey: str): Result[UirCoreExpr] =
    if b == nil || b.module == nil:
        return Err[UirCoreExpr]("uirCore_builder: case tuple match missing module")
    if pat == nil || pat.kind != nkTupleLit:
        return Err[UirCoreExpr]("uirCore_builder: case tuple match expects tuple literal")
    var tupleObj: str = ""
    if selKey != nil && len(selKey) > 0 && uirCoreHasObjType(b.module, selKey):
        tupleObj = selKey
    if len(tupleObj) == 0:
        var tupleTy: Node = newNode(nkTupleTy, pat.pos)
        for i in 0..<kidCount(pat):
            let elemPat: Node = kid(pat, i)
            var tyNode: Node = casePatternTypeNode(elemPat)
            if tyNode == nil || tyNode.kind == nkEmpty:
                tyNode = newIdent("int64", pat.pos)
            addSon(tupleTy, tyNode)
        tupleObj = typeNodeObjTypeName(b.module, tupleTy)
    if len(tupleObj) == 0 || !uirCoreHasObjType(b.module, tupleObj):
        return Err[UirCoreExpr]("uirCore_builder: unknown tuple object type")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, tupleObj)
    if ot.fields.len < kidCount(pat):
        return Err[UirCoreExpr]("uirCore_builder: tuple pattern length mismatch")
    var out: UirCoreExpr = uirCoreConstI64(1)
    for i2 in 0..<kidCount(pat):
        let elemPat2: Node = kid(pat, i2)
        if casePatternIsWildcard(elemPat2):
            continue
        let core: Node = casePatternCore(elemPat2)
        if core != nil && (core.kind == nkIdent || core.kind == nkSymbol):
            let tn: Node = casePatternTypeNode(elemPat2)
            if tn != nil && tn.kind != nkEmpty && !(plainName(core) == "_"):
                continue
        let f: UirCoreObjField = ot.fields[i2]
        var addr: UirCoreExpr = selPtr
        if f.offset != 0:
            addr = uirCoreBin(mbAdd, selPtr, uirCoreConstI64(int64(f.offset)))
        let loaded: UirCoreExpr = uirCoreLoad(addr, f.ty)
        let loaded64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loaded)
        let litRes: Result[UirCoreExpr] = lowerExprValue(b, elemPat2, uirCoreTypeI64())
        if !IsOk[UirCoreExpr](litRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](litRes))
        let cond: UirCoreExpr = uirCoreCmp(mcEq, loaded64, Value[UirCoreExpr](litRes))
        out = uirCoreBin(mbAnd, out, cond)
    return Ok[UirCoreExpr](out)

fn caseMatchSeqPattern(b: BlockBuilder, pat: Node, selPtr: UirCoreExpr, selKey: str): Result[UirCoreExpr] =
    if b == nil || b.module == nil:
        return Err[UirCoreExpr]("uirCore_builder: case seq match missing module")
    if pat == nil || pat.kind != nkSeqLit:
        return Err[UirCoreExpr]("uirCore_builder: case seq match expects seq literal")
    if selKey == nil || !uirCoreStrStartsWith(selKey, "seq_"):
        return Err[UirCoreExpr]("uirCore_builder: case seq match missing selector type")
    let elemKey: str = str(ptr_add(void*(selKey), 4))
    if elemKey == nil || len(elemKey) == 0:
        return Err[UirCoreExpr]("uirCore_builder: case seq match missing element type")
    let elemTypeNode: Node = newIdent(elemKey, pat.pos)
    let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)
    let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
    if !IsOk[int32](sizeRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[int32](sizeRes))
    let elemSize: int32 = Value[int32](sizeRes)

    let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
    var lenOff: int32 = -1
    var bufOff: int32 = -1
    for fi in 0..<seqOt.fields.len:
        let f: UirCoreObjField = seqOt.fields[fi]
        if (f.name == "len"):
            lenOff = f.offset
        elif (f.name == "buffer"):
            bufOff = f.offset
    if lenOff < 0 || bufOff < 0:
        return Err[UirCoreExpr]("uirCore_builder: seq layout mismatch")
    let lenAddr: UirCoreExpr = (lenOff == 0) ? selPtr : uirCoreBin(mbAdd, selPtr, uirCoreConstI64(int64(lenOff)))
    let bufAddr: UirCoreExpr = (bufOff == 0) ? selPtr : uirCoreBin(mbAdd, selPtr, uirCoreConstI64(int64(bufOff)))
    let lenVal: UirCoreExpr = uirCoreLoad(lenAddr, uirCoreTypeI32())
    let bufVal: UirCoreExpr = uirCoreLoad(bufAddr, uirCoreTypeI64())

    let count: int32 = kidCount(pat)
    var out: UirCoreExpr = uirCoreCmp(mcEq, lenVal, uirCoreConstI64(int64(count)))
    if count == 0:
        return Ok[UirCoreExpr](out)
    for i in 0..<count:
        var elemNode: Node = kid(pat, i)
        if elemNode != nil && elemNode.kind == nkCallArg && kidCount(elemNode) > 1:
            elemNode = kid(elemNode, 1)
        if casePatternIsWildcard(elemNode):
            continue
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreConstI64(int64(i)))
        let step: UirCoreExpr = uirCoreConstI64(int64(elemSize))
        let off: UirCoreExpr = (elemSize == 1) ? idx64 : uirCoreBin(mbMul, idx64, step)
        let addr: UirCoreExpr = (elemSize == 0) ? bufVal : uirCoreBin(mbAdd, bufVal, off)
        let loaded: UirCoreExpr = uirCoreLoad(addr, elemTy)
        let loaded64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loaded)
        let litRes: Result[UirCoreExpr] = lowerExprValue(b, elemNode, uirCoreTypeI64())
        if !IsOk[UirCoreExpr](litRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](litRes))
        let eqExpr: UirCoreExpr = uirCoreCmp(mcEq, loaded64, Value[UirCoreExpr](litRes))
        out = uirCoreBin(mbAnd, out, eqExpr)
    return Ok[UirCoreExpr](out)

fn caseMatchObjPattern(b: BlockBuilder, pat: Node, selPtr: UirCoreExpr, selKey: str): Result[UirCoreExpr] =
    if b == nil || b.module == nil:
        return Err[UirCoreExpr]("uirCore_builder: case object match missing module")
    if pat == nil || pat.kind != nkCall || kidCount(pat) == 0:
        return Err[UirCoreExpr]("uirCore_builder: case object match expects call pattern")
    let callee: Node = kid(pat, 0)
    var patPlain: str = ""
    var patKey: str = ""
    var objName: str = ""
    if callee != nil:
        patPlain = backendStripSpaces(plainName(callee))
        patKey = typeKey(callee)
        objName = patKey
        if len(objName) == 0:
            objName = patPlain
    if len(objName) == 0 || !uirCoreHasObjType(b.module, objName):
        if selKey != nil && len(selKey) > 0 && uirCoreHasObjType(b.module, selKey):
            objName = selKey
        else:
            let line: str = intToStr(pat.pos.line)
            let col: str = intToStr(pat.pos.col)
            return Err[UirCoreExpr]("uirCore_builder: case object match unknown type (pat=" + patPlain +
                                " key=" + patKey + " @" + line + ":" + col + ")")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objName)
    var out: UirCoreExpr = uirCoreConstI64(1)
    for ai in 1..<kidCount(pat):
        let arg: Node = kid(pat, ai)
        if arg == nil:
            continue
        if arg.kind == nkCallArg && kidCount(arg) > 1:
            let nameNode: Node = kid(arg, 0)
            let valNode: Node = kid(arg, 1)
            if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                let fieldName: str = backendStripSpaces(plainName(nameNode))
                var found: bool = false
                for fi in 0..<ot.fields.len:
                    let f: UirCoreObjField = ot.fields[fi]
                    if (f.name == fieldName):
                        found = true
                        var addr: UirCoreExpr = selPtr
                        if f.offset != 0:
                            addr = uirCoreBin(mbAdd, selPtr, uirCoreConstI64(int64(f.offset)))
                        let loaded: UirCoreExpr = uirCoreLoad(addr, f.ty)
                        let loaded64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loaded)
                        if casePatternIsWildcard(valNode):
                            break
                        let valCore: Node = casePatternCore(valNode)
                        if valCore != nil && (valCore.kind == nkIdent || valCore.kind == nkSymbol):
                            if !(plainName(valCore) == "_"):
                                # Binding subpattern: always matches.
                                break
                        let litRes: Result[UirCoreExpr] = lowerExprValue(b, valCore, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](litRes):
                            return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](litRes))
                        let cond: UirCoreExpr = uirCoreCmp(mcEq, loaded64, Value[UirCoreExpr](litRes))
                        out = uirCoreBin(mbAnd, out, cond)
                        break
                if !found:
                    return Err[UirCoreExpr]("uirCore_builder: case object match unknown field")
        else:
            let fieldIdx: int32 = ai - 1
            if fieldIdx >= 0 && fieldIdx < ot.fields.len:
                let f: UirCoreObjField = ot.fields[fieldIdx]
                var addr2: UirCoreExpr = selPtr
                if f.offset != 0:
                    addr2 = uirCoreBin(mbAdd, selPtr, uirCoreConstI64(int64(f.offset)))
                let loaded2: UirCoreExpr = uirCoreLoad(addr2, f.ty)
                let loaded64_2: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loaded2)
                if casePatternIsWildcard(arg):
                    continue
                let core: Node = casePatternCore(arg)
                if core != nil && (core.kind == nkIdent || core.kind == nkSymbol):
                    if !(plainName(core) == "_"):
                        # Binding subpattern: always matches.
                        continue
                let litRes2: Result[UirCoreExpr] = lowerExprValue(b, core, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](litRes2):
                    return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](litRes2))
                let cond2: UirCoreExpr = uirCoreCmp(mcEq, loaded64_2, Value[UirCoreExpr](litRes2))
                out = uirCoreBin(mbAnd, out, cond2)
    return Ok[UirCoreExpr](out)

fn caseMatchPattern(b: BlockBuilder, pat0: Node, selVal: UirCoreExpr, selKey: str): Result[UirCoreExpr] =
    if pat0 == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil case pattern")
    if casePatternIsWildcard(pat0):
        return Ok[UirCoreExpr](uirCoreConstI64(1))
    let core: Node = casePatternCore(pat0)
    if core == nil:
        return Err[UirCoreExpr]("uirCore_builder: nil case pattern")

    let typeNode: Node = casePatternTypeNode(pat0)
    if typeNode != nil && typeNode.kind != nkEmpty:
        if core.kind == nkIdent || core.kind == nkSymbol:
            if !(plainName(core) == "_"):
                # Typed binding pattern: always matches.
                return Ok[UirCoreExpr](uirCoreConstI64(1))

    if core.kind == nkTupleLit:
        return caseMatchTuplePattern(b, core, selVal, selKey)
    if core.kind == nkSeqLit:
        return caseMatchSeqPattern(b, core, selVal, selKey)
    if core.kind == nkCurly:
        let bitsRes: Result[int64] = caseComputeSetBits(core)
        if !IsOk[int64](bitsRes):
            return ErrInfo[UirCoreExpr](ErrorInfoOf[int64](bitsRes))
        let bits: UirCoreExpr = uirCoreConstI64(Value[int64](bitsRes))
        let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), selVal)
        let mask: UirCoreExpr = uirCoreBin(mbShl, uirCoreConstI64(1), idx64)
        return Ok[UirCoreExpr](uirCoreCmp(mcNe, uirCoreBin(mbAnd, bits, mask), uirCoreConstI64(0)))
    if core.kind == nkCall:
        return caseMatchObjPattern(b, core, selVal, selKey)
    if core.kind == nkInfix && kidCount(core) >= 3:
        let opNode: Node = kid(core, 0)
        let op: str = backendOpName(opNode)
        if op == ".." || op == "..<":
            let aRes: Result[UirCoreExpr] = lowerExprValue(b, kid(core, 1), uirCoreTypeI64())
            if !IsOk[UirCoreExpr](aRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](aRes))
            let bRes: Result[UirCoreExpr] = lowerExprValue(b, kid(core, 2), uirCoreTypeI64())
            if !IsOk[UirCoreExpr](bRes):
                return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](bRes))
            let sel64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), selVal)
            let geExpr: UirCoreExpr = uirCoreCmp(mcGe, sel64, Value[UirCoreExpr](aRes))
            var hiExpr: UirCoreExpr
            if op == "..":
                hiExpr = uirCoreCmp(mcLe, sel64, Value[UirCoreExpr](bRes))
            else:
                hiExpr = uirCoreCmp(mcLt, sel64, Value[UirCoreExpr](bRes))
            return Ok[UirCoreExpr](uirCoreBin(mbAnd, geExpr, hiExpr))

    # Fallback: treat pattern as a value equality check.
    let patRes: Result[UirCoreExpr] = lowerExprValue(b, core, uirCoreTypeI64())
    if !IsOk[UirCoreExpr](patRes):
        return ErrInfo[UirCoreExpr](ErrorInfoOf[UirCoreExpr](patRes))
    let sel64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), selVal)
    return Ok[UirCoreExpr](uirCoreCmp(mcEq, sel64, Value[UirCoreExpr](patRes)))

fn lowerCaseAssign(b: BlockBuilder, caseNode: Node, name: str, slot: int32): Result[bool] =
    if caseNode == nil || caseNode.kind != nkCase:
        return Err[bool]("uirCore_builder: invalid case assign")
    if kidCount(caseNode) < 1:
        return Err[bool]("uirCore_builder: case expects selector")
    let slotTy: UirCoreType = localType(b.env, slot)
    # Default to 0 so a missing else doesn't leave it uninitialized.
    add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))

    let selNode: Node = kid(caseNode, 0)
    let selTy: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, selNode, uirCoreTypeI64())
    let selRes: Result[UirCoreExpr] = lowerExprValue(b, selNode, selTy)
    if !IsOk[UirCoreExpr](selRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](selRes))
    let selName: str = blockBuilderNextTemp(b, "__case_sel")
    let selSlot: int32 = localAdd(b.env, selName, selTy)
    uirCoreSetLocalType(b.func, selSlot, selTy)
    add(b.currentStmts, uirCoreStmtLet(selName, selSlot, Value[UirCoreExpr](selRes)))
    let selVal: UirCoreExpr = uirCoreLocal(selSlot)
    let selKey: str = caseInferExprTypeKey(b, selNode)

    let endLabel: str = blockBuilderNextLabel(b, "case_end")
    let firstTest: str = blockBuilderNextLabel(b, "case_test")
    blockBuilderFinish(b, uirCoreTermBr(firstTest))
    blockBuilderStart(b, firstTest)

    for i in 1..<kidCount(caseNode):
        let br: Node = kid(caseNode, i)
        if br == nil:
            continue
        if br.kind == nkOfBranch:
            if kidCount(br) == 0:
                return Err[bool]("uirCore_builder: empty of-branch")
            let bodyRaw: Node = kid(br, kidCount(br) - 1)
            var bodyNode: Node = bodyRaw
            if bodyNode != nil && bodyNode.kind != nkStmtList:
                var wrap: Node = newNode(nkStmtList, bodyNode.pos)
                addSon(wrap, bodyNode)
                bodyNode = wrap
            var guardExpr: Node = nil
            var patEnd: int32 = kidCount(br) - 1
            if kidCount(br) >= 2:
                let maybeGuard: Node = kid(br, kidCount(br) - 2)
                if maybeGuard != nil && maybeGuard.kind == nkGuard && kidCount(maybeGuard) > 0:
                    guardExpr = kid(maybeGuard, 0)
                    patEnd = kidCount(br) - 2
            if patEnd <= 0:
                return Err[bool]("uirCore_builder: of-branch missing patterns")

            var cond: UirCoreExpr = nil
            for pi in 0..<patEnd:
                let pat: Node = kid(br, pi)
                let condRes: Result[UirCoreExpr] = caseMatchPattern(b, pat, selVal, selKey)
                if !IsOk[UirCoreExpr](condRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](condRes))
                if cond == nil:
                    cond = Value[UirCoreExpr](condRes)
                else:
                    cond = uirCoreBin(mbOr, cond, Value[UirCoreExpr](condRes))
            if cond == nil:
                cond = uirCoreConstI64(0)

            let matchLabel: str = blockBuilderNextLabel(b, "case_match")
            let nextLabel: str = blockBuilderNextLabel(b, "case_next")
            blockBuilderFinish(b, uirCoreTermCbr(cond, matchLabel, nextLabel))

            blockBuilderStart(b, matchLabel)
            # Typed binding patterns: assign selector to the bound name before evaluating guard/body.
            for bi in 0..<patEnd:
                let pat2: Node = kid(br, bi)
                let core2: Node = casePatternCore(pat2)
                let tyNode2: Node = casePatternTypeNode(pat2)
                if core2 != nil && tyNode2 != nil && tyNode2.kind != nkEmpty &&
                   (core2.kind == nkIdent || core2.kind == nkSymbol) && !(plainName(core2) == "_"):
                    let bindName: str = plainName(core2)
                    let bindTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, tyNode2)
                    let bindSlot: int32 = localAdd(b.env, bindName, bindTy)
                    uirCoreSetLocalType(b.func, bindSlot, bindTy)
                    add(b.currentStmts, uirCoreStmtAssign(bindName, bindSlot, uirCoreCast(bindTy, selVal)))

            if guardExpr != nil && guardExpr.kind != nkEmpty:
                let execLabel: str = blockBuilderNextLabel(b, "case_exec")
                let guardRes: Result[bool] = lowerCondBranch(b, guardExpr, execLabel, nextLabel)
                if !IsOk[bool](guardRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](guardRes))
                blockBuilderStart(b, execLabel)

            # Assign value from the last expression in the branch body.
            if bodyNode == nil || bodyNode.kind != nkStmtList || kidCount(bodyNode) == 0:
                add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
                blockBuilderFinish(b, uirCoreTermBr(endLabel))
                blockBuilderStart(b, nextLabel)
                continue
            for si in 0..<kidCount(bodyNode):
                if si + 1 >= kidCount(bodyNode):
                    break
                let stmt: Node = kid(bodyNode, si)
                let termRes: Result[bool] = lowerStmt(b, stmt)
                if !IsOk[bool](termRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](termRes))
                if Value[bool](termRes):
                    return Ok[bool](true)
            let last: Node = kid(bodyNode, kidCount(bodyNode) - 1)
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, last, slotTy)
            if !IsOk[UirCoreExpr](valRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
            add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreCast(slotTy, Value[UirCoreExpr](valRes))))
            blockBuilderFinish(b, uirCoreTermBr(endLabel))
            blockBuilderStart(b, nextLabel)
        elif br.kind == nkElse:
            if kidCount(br) == 0:
                return Err[bool]("uirCore_builder: else branch missing body")
            var bodyNode2: Node = kid(br, 0)
            if bodyNode2 != nil && bodyNode2.kind != nkStmtList:
                var wrap2: Node = newNode(nkStmtList, bodyNode2.pos)
                addSon(wrap2, bodyNode2)
                bodyNode2 = wrap2
            if bodyNode2 == nil || bodyNode2.kind != nkStmtList || kidCount(bodyNode2) == 0:
                add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreConstI64(0)))
            else:
                for sj in 0..<kidCount(bodyNode2):
                    if sj + 1 >= kidCount(bodyNode2):
                        break
                    let stmt2: Node = kid(bodyNode2, sj)
                    let termRes2: Result[bool] = lowerStmt(b, stmt2)
                    if !IsOk[bool](termRes2):
                        return ErrInfo[bool](ErrorInfoOf[bool](termRes2))
                    if Value[bool](termRes2):
                        return Ok[bool](true)
                let last2: Node = kid(bodyNode2, kidCount(bodyNode2) - 1)
                let valRes2: Result[UirCoreExpr] = lowerExprValue(b, last2, slotTy)
                if !IsOk[UirCoreExpr](valRes2):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes2))
                add(b.currentStmts, uirCoreStmtAssign(name, slot, uirCoreCast(slotTy, Value[UirCoreExpr](valRes2))))
            blockBuilderFinish(b, uirCoreTermBr(endLabel))
            blockBuilderStart(b, endLabel)
            return Ok[bool](false)

    blockBuilderFinish(b, uirCoreTermBr(endLabel))
    blockBuilderStart(b, endLabel)
    return Ok[bool](false)

fn lowerCaseStmt(b: BlockBuilder, caseNode: Node): Result[bool] =
    if caseNode == nil || caseNode.kind != nkCase:
        return Err[bool]("uirCore_builder: invalid case")
    if kidCount(caseNode) < 1:
        return Err[bool]("uirCore_builder: case expects selector")
    let selNode: Node = kid(caseNode, 0)
    let selTy: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, selNode, uirCoreTypeI64())
    let selRes: Result[UirCoreExpr] = lowerExprValue(b, selNode, selTy)
    if !IsOk[UirCoreExpr](selRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](selRes))
    let selName: str = blockBuilderNextTemp(b, "__case_sel")
    let selSlot: int32 = localAdd(b.env, selName, selTy)
    uirCoreSetLocalType(b.func, selSlot, selTy)
    add(b.currentStmts, uirCoreStmtLet(selName, selSlot, Value[UirCoreExpr](selRes)))
    let selVal: UirCoreExpr = uirCoreLocal(selSlot)
    let selKey: str = caseInferExprTypeKey(b, selNode)

    let endLabel: str = blockBuilderNextLabel(b, "case_end")
    var needsEnd: bool = false
    var allTerminated: bool = true
    let firstTest: str = blockBuilderNextLabel(b, "case_test")
    blockBuilderFinish(b, uirCoreTermBr(firstTest))
    blockBuilderStart(b, firstTest)

    for i in 1..<kidCount(caseNode):
        let br: Node = kid(caseNode, i)
        if br == nil:
            continue
        if br.kind == nkOfBranch:
            if kidCount(br) == 0:
                return Err[bool]("uirCore_builder: empty of-branch")
            let bodyRaw: Node = kid(br, kidCount(br) - 1)
            var bodyNode: Node = bodyRaw
            if bodyNode != nil && bodyNode.kind != nkStmtList:
                var wrap: Node = newNode(nkStmtList, bodyNode.pos)
                addSon(wrap, bodyNode)
                bodyNode = wrap
            var guardExpr: Node = nil
            var patEnd: int32 = kidCount(br) - 1
            if kidCount(br) >= 2:
                let maybeGuard: Node = kid(br, kidCount(br) - 2)
                if maybeGuard != nil && maybeGuard.kind == nkGuard && kidCount(maybeGuard) > 0:
                    guardExpr = kid(maybeGuard, 0)
                    patEnd = kidCount(br) - 2
            if patEnd <= 0:
                return Err[bool]("uirCore_builder: of-branch missing patterns")

            var cond: UirCoreExpr = nil
            for pi in 0..<patEnd:
                let pat: Node = kid(br, pi)
                let condRes: Result[UirCoreExpr] = caseMatchPattern(b, pat, selVal, selKey)
                if !IsOk[UirCoreExpr](condRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](condRes))
                if cond == nil:
                    cond = Value[UirCoreExpr](condRes)
                else:
                    cond = uirCoreBin(mbOr, cond, Value[UirCoreExpr](condRes))
            if cond == nil:
                cond = uirCoreConstI64(0)

            let matchLabel: str = blockBuilderNextLabel(b, "case_match")
            let nextLabel: str = blockBuilderNextLabel(b, "case_next")
            blockBuilderFinish(b, uirCoreTermCbr(cond, matchLabel, nextLabel))

            blockBuilderStart(b, matchLabel)
            # Typed binding patterns: assign selector to the bound name before evaluating guard/body.
            for bi in 0..<patEnd:
                let pat2: Node = kid(br, bi)
                let core2: Node = casePatternCore(pat2)
                let tyNode2: Node = casePatternTypeNode(pat2)
                if core2 != nil && tyNode2 != nil && tyNode2.kind != nkEmpty &&
                   (core2.kind == nkIdent || core2.kind == nkSymbol) && !(plainName(core2) == "_"):
                    let bindName: str = plainName(core2)
                    let bindTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, tyNode2)
                    let bindSlot: int32 = localAdd(b.env, bindName, bindTy)
                    uirCoreSetLocalType(b.func, bindSlot, bindTy)
                    add(b.currentStmts, uirCoreStmtAssign(bindName, bindSlot, uirCoreCast(bindTy, selVal)))

            if guardExpr != nil && guardExpr.kind != nkEmpty:
                let execLabel: str = blockBuilderNextLabel(b, "case_exec")
                let guardRes: Result[bool] = lowerCondBranch(b, guardExpr, execLabel, nextLabel)
                if !IsOk[bool](guardRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](guardRes))
                blockBuilderStart(b, execLabel)

            let bodyTermRes: Result[bool] = lowerStmtList(b, bodyNode)
            if !IsOk[bool](bodyTermRes):
                return ErrInfo[bool](ErrorInfoOf[bool](bodyTermRes))
            let bodyTerminated: bool = Value[bool](bodyTermRes)
            if !bodyTerminated:
                needsEnd = true
                allTerminated = false
                blockBuilderFinish(b, uirCoreTermBr(endLabel))
            blockBuilderStart(b, nextLabel)
        elif br.kind == nkElse:
            if kidCount(br) == 0:
                return Err[bool]("uirCore_builder: else branch missing body")
            var bodyNode2: Node = kid(br, 0)
            if bodyNode2 != nil && bodyNode2.kind != nkStmtList:
                var wrap2: Node = newNode(nkStmtList, bodyNode2.pos)
                addSon(wrap2, bodyNode2)
                bodyNode2 = wrap2
            let elseTermRes: Result[bool] = lowerStmtList(b, bodyNode2)
            if !IsOk[bool](elseTermRes):
                return ErrInfo[bool](ErrorInfoOf[bool](elseTermRes))
            let elseTerminated: bool = Value[bool](elseTermRes)
            if !elseTerminated:
                needsEnd = true
                allTerminated = false
                blockBuilderFinish(b, uirCoreTermBr(endLabel))
            if needsEnd:
                blockBuilderStart(b, endLabel)
                return Ok[bool](false)
            if allTerminated:
                return Ok[bool](true)
            blockBuilderStart(b, endLabel)
            return Ok[bool](false)

    # No else: fallthrough.
    blockBuilderFinish(b, uirCoreTermBr(endLabel))
    blockBuilderStart(b, endLabel)
    return Ok[bool](false)

fn lowerDestructureSeq(b: BlockBuilder, kind: NodeKind, pat: Node, init: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: seq destructure missing module")
    if pat == nil || pat.kind != nkSeqLit:
        return Err[bool]("uirCore_builder: seq destructure expects seq pattern")
    if init == nil || init.kind == nkEmpty:
        return Err[bool]("uirCore_builder: seq destructure expects init")
    let seqKey: str = caseInferExprTypeKey(b, init)
    if !uirCoreStrStartsWith(seqKey, "seq_"):
        return Err[bool]("uirCore_builder: seq destructure missing element type")
    let elemKey: str = str(ptr_add(void*(seqKey), 4))
    let elemTypeNode: Node = newIdent(elemKey, pat.pos)
    let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)
    let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
    if !IsOk[int32](sizeRes):
        return ErrInfo[bool](ErrorInfoOf[int32](sizeRes))
    let elemSize: int32 = Value[int32](sizeRes)

    let initRes: Result[UirCoreExpr] = lowerExprValue(b, init, uirCoreTypeI64())
    if !IsOk[UirCoreExpr](initRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](initRes))
    let seqName: str = blockBuilderNextTemp(b, "__pat_seq")
    let seqSlot: int32 = localAdd(b.env, seqName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, seqSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(seqName, seqSlot, Value[UirCoreExpr](initRes)))
    let seqPtr: UirCoreExpr = uirCoreLocal(seqSlot)

    let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
    var lenOff: int32 = -1
    var bufOff: int32 = -1
    for fi in 0..<seqOt.fields.len:
        let f: UirCoreObjField = seqOt.fields[fi]
        if (f.name == "len"):
            lenOff = f.offset
        elif (f.name == "buffer"):
            bufOff = f.offset
    if lenOff < 0 || bufOff < 0:
        return Err[bool]("uirCore_builder: seq layout mismatch")
    let bufAddr: UirCoreExpr = (bufOff == 0) ? seqPtr : uirCoreBin(mbAdd, seqPtr, uirCoreConstI64(int64(bufOff)))
    let bufVal: UirCoreExpr = uirCoreLoad(bufAddr, uirCoreTypeI64())

    for i in 0..<kidCount(pat):
        var elemPat: Node = kid(pat, i)
        if elemPat != nil && elemPat.kind == nkCallArg && kidCount(elemPat) > 1:
            elemPat = kid(elemPat, 1)
        if elemPat != nil && (elemPat.kind == nkIdent || elemPat.kind == nkSymbol) && !(plainName(elemPat) == "_"):
            let nm: str = plainName(elemPat)
            let slot: int32 = localAdd(b.env, nm, elemTy)
            uirCoreSetLocalType(b.func, slot, elemTy)
            let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), uirCoreConstI64(int64(i)))
            let step: UirCoreExpr = uirCoreConstI64(int64(elemSize))
            let off: UirCoreExpr = (elemSize == 1) ? idx64 : uirCoreBin(mbMul, idx64, step)
            let addr: UirCoreExpr = (elemSize == 0) ? bufVal : uirCoreBin(mbAdd, bufVal, off)
            let loaded: UirCoreExpr = uirCoreLoad(addr, elemTy)
            if kind == nkLet:
                add(b.currentStmts, uirCoreStmtLet(nm, slot, loaded))
            else:
                add(b.currentStmts, uirCoreStmtVar(nm, slot, loaded))
    return Ok[bool](false)

fn tupleTypeElemTypeNode(tupleType0: Node, idx: int32): Node =
    var tupleType: Node = tupleType0
    while tupleType != nil && tupleType.kind == nkPar && kidCount(tupleType) > 0:
        tupleType = kid(tupleType, 0)
    if tupleType != nil && tupleType.kind == nkVarTy && kidCount(tupleType) > 0:
        tupleType = kid(tupleType, 0)
    if tupleType == nil || tupleType.kind != nkTupleTy:
        return nil
    if idx < 0 || idx >= kidCount(tupleType):
        return nil
    let elem: Node = kid(tupleType, idx)
    if elem != nil && elem.kind == nkIdentDefs && kidCount(elem) > 1:
        return kid(elem, 1)
    return elem

fn tupleLitElemValueNode(tupleLit0: Node, idx: int32): Node =
    var tupleLit: Node = tupleLit0
    while tupleLit != nil && tupleLit.kind == nkPar && kidCount(tupleLit) > 0:
        tupleLit = kid(tupleLit, 0)
    if tupleLit == nil || tupleLit.kind != nkTupleLit:
        return nil
    if idx < 0 || idx >= kidCount(tupleLit):
        return nil
    var elem: Node = kid(tupleLit, idx)
    if elem != nil && elem.kind == nkCallArg && kidCount(elem) > 1:
        elem = kid(elem, 1)
    elif elem != nil && elem.kind == nkCallArg && kidCount(elem) > 0:
        elem = kid(elem, 0)
    return elem

fn inferTupleTypeNodeFromTupleLitBestEffort(lit0: Node): Node =
    var lit: Node = lit0
    while lit != nil && lit.kind == nkPar && kidCount(lit) > 0:
        lit = kid(lit, 0)
    if lit == nil || lit.kind != nkTupleLit:
        return nil
    if lit.typeCacheValid && lit.typeCache != nil:
        let tc: Node = lit.typeCache
        if tc != nil && tc.kind == nkTupleTy:
            return tc
    var tupleTy: Node = newNode(nkTupleTy, lit.pos)
    for i in 0..<kidCount(lit):
        var elem: Node = kid(lit, i)
        if elem != nil && elem.kind == nkCallArg && kidCount(elem) > 1:
            elem = kid(elem, 1)
        var elemTy: Node = nil
        if elem != nil && elem.typeCacheValid && elem.typeCache != nil:
            elemTy = elem.typeCache
        if elemTy == nil || elemTy.kind == nkEmpty:
            if elem != nil && elem.kind == nkTupleLit:
                elemTy = inferTupleTypeNodeFromTupleLitBestEffort(elem)
            elif elem != nil && elem.kind == nkStrLit:
                elemTy = newIdent("str", lit.pos)
            elif elem != nil && elem.kind == nkCharLit:
                elemTy = newIdent("char", lit.pos)
            elif elem != nil && elem.kind == nkBoolLit:
                elemTy = newIdent("bool", lit.pos)
            elif elem != nil && elem.kind == nkFloatLit:
                elemTy = newIdent("float64", lit.pos)
            else:
                elemTy = newIdent("int64", lit.pos)
        addSon(tupleTy, elemTy)
    return tupleTy

fn inferTupleTypeNodeFromTuplePatternBestEffort(pat0: Node): Node =
    var pat: Node = pat0
    while pat != nil && pat.kind == nkPar && kidCount(pat) > 0:
        pat = kid(pat, 0)
    if pat == nil || pat.kind != nkTupleLit:
        return nil
    var tupleTy: Node = newNode(nkTupleTy, pat.pos)
    for i in 0..<kidCount(pat):
        let elemPat: Node = kid(pat, i)
        var elemTy: Node = casePatternTypeNode(elemPat)
        if elemTy == nil || elemTy.kind == nkEmpty:
            elemTy = newIdent("int64", pat.pos)
        addSon(tupleTy, elemTy)
    return tupleTy

fn lowerDestructureTupleFromPtr(b: BlockBuilder, kind: NodeKind, pat: Node, typeNode: Node, init: Node, tupleObj: str, tupPtr: UirCoreExpr): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: tuple destructure missing module")
    if pat == nil || pat.kind != nkTupleLit:
        return Err[bool]("uirCore_builder: tuple destructure expects tuple pattern")
    var tupleObj2: str = tupleObj

    var initCore0: Node = init
    while initCore0 != nil && initCore0.kind == nkPar && kidCount(initCore0) > 0:
        initCore0 = kid(initCore0, 0)

    if len(tupleObj2) == 0 || !uirCoreHasObjType(b.module, tupleObj2):
        var tupleType: Node = typeNode
        if tupleType == nil || tupleType.kind == nkEmpty:
            if initCore0 != nil && initCore0.typeCacheValid && initCore0.typeCache != nil:
                let tc: Node = initCore0.typeCache
                if tc != nil && tc.kind == nkTupleTy:
                    tupleType = tc
            elif initCore0 != nil && initCore0.kind == nkTupleLit:
                tupleType = inferTupleTypeNodeFromTupleLitBestEffort(initCore0)
        if tupleType == nil || tupleType.kind == nkEmpty:
            tupleType = inferTupleTypeNodeFromTuplePatternBestEffort(pat)
        if tupleType != nil && tupleType.kind != nkEmpty:
            tupleObj2 = typeNodeObjTypeName(b.module, tupleType)

    if len(tupleObj2) == 0 || !uirCoreHasObjType(b.module, tupleObj2):
        let posNode: Node = pat
        let line: str = intToStr(posNode.pos.line)
        let col: str = intToStr(posNode.pos.col)
        let key: str = caseInferExprTypeKey(b, init)
        return Err[bool]("uirCore_builder: tuple destructure unknown tuple type @" + line + ":" + col + " key=" + key)
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, tupleObj2)

    let initCore: Node = initCore0

    for i in 0..<kidCount(pat):
        if ! (i < ot.fields.len):
            break
        var elemPat0: Node = kid(pat, i)
        if elemPat0 != nil && elemPat0.kind == nkCallArg && kidCount(elemPat0) > 1:
            elemPat0 = kid(elemPat0, 1)
        let core: Node = casePatternCore(elemPat0)

        var elemTypeNode: Node = tupleTypeElemTypeNode(typeNode, i)
        let patElemTy: Node = casePatternTypeNode(elemPat0)
        if patElemTy != nil && patElemTy.kind != nkEmpty:
            elemTypeNode = patElemTy
        if (elemTypeNode == nil || elemTypeNode.kind == nkEmpty) && initCore != nil &&
           initCore.typeCacheValid && initCore.typeCache != nil:
            elemTypeNode = tupleTypeElemTypeNode(initCore.typeCache, i)

        var elemInitNode: Node = nil
        if initCore != nil && initCore.kind == nkTupleLit:
            elemInitNode = tupleLitElemValueNode(initCore, i)

        if core != nil && (core.kind == nkIdent || core.kind == nkSymbol) && !(plainName(core) == "_"):
            let f: UirCoreObjField = ot.fields[i]
            var addr: UirCoreExpr = tupPtr
            if f.offset != 0:
                addr = uirCoreBin(mbAdd, tupPtr, uirCoreConstI64(int64(f.offset)))
            let loaded: UirCoreExpr = uirCoreLoad(addr, f.ty)
            let nm: str = plainName(core)
            let slot: int32 = localAdd(b.env, nm, f.ty)
            uirCoreSetLocalType(b.func, slot, f.ty)
            if kind == nkLet:
                add(b.currentStmts, uirCoreStmtLet(nm, slot, loaded))
            else:
                add(b.currentStmts, uirCoreStmtVar(nm, slot, loaded))
            continue

        if core != nil && (core.kind == nkIntLit || core.kind == nkBoolLit || core.kind == nkCharLit || core.kind == nkNilLit):
            let fLit: UirCoreObjField = ot.fields[i]
            var addrLit: UirCoreExpr = tupPtr
            if fLit.offset != 0:
                addrLit = uirCoreBin(mbAdd, tupPtr, uirCoreConstI64(int64(fLit.offset)))
            let loadedLit: UirCoreExpr = uirCoreLoad(addrLit, fLit.ty)
            let loaded64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loadedLit)
            var wantLit: UirCoreExpr = uirCoreConstI64(0)
            if core.kind == nkIntLit:
                wantLit = uirCoreConstI64(core.intVal)
            elif core.kind == nkCharLit:
                if core.strVal != nil && len(core.strVal) > 0:
                    wantLit = uirCoreConstI64(int64(core.strVal[0]))
            elif core.kind == nkBoolLit:
                let nameLit: str = backendStripSpaces(core.ident)
                wantLit = uirCoreConstI64((nameLit == "true") ? 1 : 0)
            # nkNilLit stays 0
            let condLit: UirCoreExpr = uirCoreCmp(mcEq, loaded64, wantLit)
            var argsLit: UirCoreExpr[]
            add(argsLit, condLit)
            let msgLabel: str = uirCoreAddCString(b.module, "literal tuple pattern mismatch")
            add(argsLit, uirCoreGlobalAddr(msgLabel))
            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("assert", argsLit)))
            continue

        if core != nil && core.kind == nkTupleLit:
            let f2: UirCoreObjField = ot.fields[i]
            var addr2: UirCoreExpr = tupPtr
            if f2.offset != 0:
                addr2 = uirCoreBin(mbAdd, tupPtr, uirCoreConstI64(int64(f2.offset)))
            let loaded2: UirCoreExpr = uirCoreLoad(addr2, f2.ty)
            let loadedPtr: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), loaded2)

            var innerTypeNode: Node = elemTypeNode
            if innerTypeNode == nil || innerTypeNode.kind == nkEmpty:
                if elemInitNode != nil && elemInitNode.typeCacheValid && elemInitNode.typeCache != nil:
                    let tc2: Node = elemInitNode.typeCache
                    if tc2 != nil && tc2.kind == nkTupleTy:
                        innerTypeNode = tc2
                elif elemInitNode != nil && elemInitNode.kind == nkTupleLit:
                    innerTypeNode = inferTupleTypeNodeFromTupleLitBestEffort(elemInitNode)
            if innerTypeNode == nil || innerTypeNode.kind == nkEmpty:
                innerTypeNode = inferTupleTypeNodeFromTuplePatternBestEffort(core)

            var innerObj: str = ""
            if innerTypeNode != nil && innerTypeNode.kind != nkEmpty:
                innerObj = typeNodeObjTypeName(b.module, innerTypeNode)
            if len(innerObj) == 0 && elemInitNode != nil:
                let innerKey: str = caseInferExprTypeKey(b, elemInitNode)
                if len(innerKey) > 0 && uirCoreHasObjType(b.module, innerKey):
                    innerObj = innerKey
            if len(innerObj) == 0 || !uirCoreHasObjType(b.module, innerObj):
                return Err[bool]("uirCore_builder: tuple destructure unknown inner tuple type")

            let innerName: str = blockBuilderNextTemp(b, "__pat_tup")
            let innerSlot: int32 = localAdd(b.env, innerName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, innerSlot, uirCoreTypeI64())
            add(b.currentStmts, uirCoreStmtLet(innerName, innerSlot, loadedPtr))

            let innerRes: Result[bool] = lowerDestructureTupleFromPtr(b, kind, core, innerTypeNode, elemInitNode, innerObj, uirCoreLocal(innerSlot))
            if !IsOk[bool](innerRes):
                return innerRes
    return Ok[bool](false)

fn lowerDestructureTuple(b: BlockBuilder, kind: NodeKind, pat: Node, typeNode: Node, init: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: tuple destructure missing module")
    if pat == nil || pat.kind != nkTupleLit:
        return Err[bool]("uirCore_builder: tuple destructure expects tuple pattern")
    if init == nil || init.kind == nkEmpty:
        return Err[bool]("uirCore_builder: tuple destructure expects init")
    var initCore: Node = init
    while initCore != nil && initCore.kind == nkPar && kidCount(initCore) > 0:
        initCore = kid(initCore, 0)

    var tupleType: Node = typeNode
    if tupleType == nil || tupleType.kind == nkEmpty:
        if initCore != nil && initCore.typeCacheValid && initCore.typeCache != nil:
            let tc: Node = initCore.typeCache
            if tc != nil && tc.kind == nkTupleTy:
                tupleType = tc
        elif initCore != nil && initCore.kind == nkTupleLit:
            tupleType = inferTupleTypeNodeFromTupleLitBestEffort(initCore)
    if tupleType == nil || tupleType.kind == nkEmpty:
        tupleType = inferTupleTypeNodeFromTuplePatternBestEffort(pat)

    var tupleObj: str = ""
    if tupleType != nil && tupleType.kind != nkEmpty:
        tupleObj = typeNodeObjTypeName(b.module, tupleType)
    if len(tupleObj) == 0:
        let k: str = caseInferExprTypeKey(b, initCore)
        if len(k) > 0 && uirCoreHasObjType(b.module, k):
            tupleObj = k
    if len(tupleObj) == 0 || !uirCoreHasObjType(b.module, tupleObj):
        let posNode: Node = pat
        let line: str = intToStr(posNode.pos.line)
        let col: str = intToStr(posNode.pos.col)
        let key: str = caseInferExprTypeKey(b, initCore)
        return Err[bool]("uirCore_builder: tuple destructure unknown tuple type @" + line + ":" + col + " key=" + key)

    # Stage1 may clear typeCache for tuple literals. Ensure tuple literals used as destructure init
    # are lowered with the same tuple type/layout selected for this destructure.
    var restoreTupleLitTypeCache: bool = false
    var savedTupleLitTypeCacheValid: bool = false
    var savedTupleLitTypeCache: Node = nil
    if initCore != nil && initCore.kind == nkTupleLit &&
       (!initCore.typeCacheValid || initCore.typeCache == nil) &&
       tupleType != nil && tupleType.kind != nkEmpty:
        let wantObj: str = typeNodeObjTypeName(b.module, tupleType)
        if len(wantObj) > 0 && (wantObj == tupleObj):
            restoreTupleLitTypeCache = true
            savedTupleLitTypeCacheValid = initCore.typeCacheValid
            savedTupleLitTypeCache = initCore.typeCache
            initCore.typeCacheValid = true
            initCore.typeCache = tupleType

    let initRes: Result[UirCoreExpr] = lowerExprValue(b, init, uirCoreTypeI64())
    if restoreTupleLitTypeCache:
        initCore.typeCacheValid = savedTupleLitTypeCacheValid
        initCore.typeCache = savedTupleLitTypeCache
    if !IsOk[UirCoreExpr](initRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](initRes))
    let tupName: str = blockBuilderNextTemp(b, "__pat_tup")
    let tupSlot: int32 = localAdd(b.env, tupName, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, tupSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(tupName, tupSlot, Value[UirCoreExpr](initRes)))
    let tupPtr: UirCoreExpr = uirCoreLocal(tupSlot)
    return lowerDestructureTupleFromPtr(b, kind, pat, typeNode, init, tupleObj, tupPtr)

fn lowerDestructureObject(b: BlockBuilder, kind: NodeKind, pat: Node, init: Node): Result[bool] =
    if b == nil || b.module == nil:
        return Err[bool]("uirCore_builder: object destructure missing module")
    if pat == nil || pat.kind != nkCall || kidCount(pat) == 0:
        return Err[bool]("uirCore_builder: object destructure expects call pattern")
    if init == nil || init.kind == nkEmpty:
        return Err[bool]("uirCore_builder: object destructure expects init")
    let callee: Node = kid(pat, 0)
    var patPlain: str = ""
    var patKey: str = ""
    var objName: str = ""
    var initKey: str = ""
    if callee != nil:
        patPlain = backendStripSpaces(plainName(callee))
        patKey = typeKey(callee)
        objName = patKey
        if len(objName) == 0:
            objName = patPlain
    if len(objName) == 0 || !uirCoreHasObjType(b.module, objName):
        initKey = caseInferExprTypeKey(b, init)
        if len(initKey) > 0 && uirCoreHasObjType(b.module, initKey):
            objName = initKey
    if len(objName) == 0 || !uirCoreHasObjType(b.module, objName):
        let line: str = intToStr(pat.pos.line)
        let col: str = intToStr(pat.pos.col)
        return Err[bool]("uirCore_builder: object destructure unknown type (pat=" + patPlain +
                         " key=" + patKey + " initKey=" + initKey + " @" + line + ":" + col + ")")
    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objName)
    let initRes: Result[UirCoreExpr] = lowerExprValue(b, init, uirCoreTypeI64())
    if !IsOk[UirCoreExpr](initRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](initRes))
    let objTmp: str = blockBuilderNextTemp(b, "__pat_obj")
    let objSlot: int32 = localAdd(b.env, objTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, objSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(objTmp, objSlot, Value[UirCoreExpr](initRes)))
    let objPtr: UirCoreExpr = uirCoreLocal(objSlot)

    let debug: bool = (getEnv "BACKEND_DEBUG_DESTRUCTURE" == "1")
    if debug:
        let line: str = intToStr(pat.pos.line)
        let col: str = intToStr(pat.pos.col)
        var msg: str = "[backend] destructure obj @" + line + ":" + col + " objName=" + objName
        msg = msg + " patPlain=" + patPlain
        msg = msg + " patKey=" + patKey
        msg = msg + " initKey=" + initKey
        msg = msg + " fields=" + intToStr(ot.fields.len)
        msg = msg + " nkCallArg=" + intToStr(int32(nkCallArg))
        echo msg

    for ai in 1..<kidCount(pat):
        let arg: Node = kid(pat, ai)
        if debug:
            let ak: str = (arg != nil) ? intToStr(int32(arg.kind)) : "nil"
            let ac: str = (arg != nil) ? intToStr(kidCount(arg)) : "0"
            let an: str = (arg != nil) ? plainName(arg) : ""
            var msg3: str = "[backend] destructure arg#" + intToStr(ai)
            msg3 = msg3 + " kind=nk#" + ak + " kids=" + ac + " name=" + an
            echo msg3
        if arg != nil:
            let fieldIdx: int32 = ai - 1
            var corePos: Node = arg
            while corePos != nil && corePos.kind == nkPar && kidCount(corePos) > 0:
                corePos = kid(corePos, 0)
            if corePos != nil && corePos.kind == nkPattern && kidCount(corePos) > 0:
                corePos = kid(corePos, 0)
            if fieldIdx >= 0 && fieldIdx < ot.fields.len &&
               corePos != nil && (corePos.kind == nkIdent || corePos.kind == nkSymbol) &&
               !(plainName(corePos) == "_"):
                let nm: str = plainName(corePos)
                let f: UirCoreObjField = ot.fields[fieldIdx]
                var addr: UirCoreExpr = objPtr
                if f.offset != 0:
                    addr = uirCoreBin(mbAdd, objPtr, uirCoreConstI64(int64(f.offset)))
                let loaded: UirCoreExpr = uirCoreLoad(addr, f.ty)
                let slot: int32 = localAdd(b.env, nm, f.ty)
                uirCoreSetLocalType(b.func, slot, f.ty)
                if debug:
                    var bindMsg: str = "[backend] destructure bind " + nm + " slot=" + intToStr(slot)
                    bindMsg = bindMsg + " field=" + f.name
                    echo bindMsg
                if kind == nkLet:
                    add(b.currentStmts, uirCoreStmtLet(nm, slot, loaded))
                else:
                    add(b.currentStmts, uirCoreStmtVar(nm, slot, loaded))
                continue
        if arg != nil && arg.kind == nkCallArg:
            var nameNode: Node = nil
            var valNode: Node = nil
            if kidCount(arg) > 1:
                nameNode = kid(arg, 0)
                valNode = kid(arg, 1)
            elif kidCount(arg) > 0:
                valNode = kid(arg, 0)
            var fieldName: str = ""
            if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                fieldName = backendStripSpaces(plainName(nameNode))
            else:
                fieldName = backendStripSpaces(plainName(arg))
            var core: Node = valNode
            while core != nil && core.kind == nkPar && kidCount(core) > 0:
                core = kid(core, 0)
            if core != nil && core.kind == nkCallArg && kidCount(core) > 1:
                core = kid(core, 1)
            if core != nil && core.kind == nkPattern && kidCount(core) > 0:
                core = kid(core, 0)
            if debug:
                let nk: str = (nameNode != nil) ? intToStr(int32(nameNode.kind)) : "nil"
                let vk: str = (valNode != nil) ? intToStr(int32(valNode.kind)) : "nil"
                let ck: str = (core != nil) ? intToStr(int32(core.kind)) : "nil"
                let nn: str = (nameNode != nil) ? plainName(nameNode) : ""
                let vn: str = (valNode != nil) ? plainName(valNode) : ""
                let cn: str = (core != nil) ? plainName(core) : ""
                var msg2: str = "[backend] destructure field nk#" + nk + " name=" + nn
                msg2 = msg2 + " val nk#" + vk + " val=" + vn
                msg2 = msg2 + " core nk#" + ck + " core=" + cn
                msg2 = msg2 + " field=" + fieldName
                echo msg2
            if len(fieldName) > 0 &&
               core != nil && (core.kind == nkIdent || core.kind == nkSymbol) && !(plainName(core) == "_"):
                for fi in 0..<ot.fields.len:
                    let f: UirCoreObjField = ot.fields[fi]
                    if (f.name == fieldName):
                        var addr: UirCoreExpr = objPtr
                        if f.offset != 0:
                            addr = uirCoreBin(mbAdd, objPtr, uirCoreConstI64(int64(f.offset)))
                        let loaded: UirCoreExpr = uirCoreLoad(addr, f.ty)
                        let nm: str = plainName(core)
                        let slot: int32 = localAdd(b.env, nm, f.ty)
                        uirCoreSetLocalType(b.func, slot, f.ty)
                        if kind == nkLet:
                            add(b.currentStmts, uirCoreStmtLet(nm, slot, loaded))
                        else:
                            add(b.currentStmts, uirCoreStmtVar(nm, slot, loaded))
                        break
    return Ok[bool](false)

fn lowerSeqCapAssignFallback(b: BlockBuilder, lhs: Node, rhs: Node): Result[bool] =
    if b == nil || b.module == nil || b.func == nil || lhs == nil || rhs == nil:
        return Ok[bool](false)
    if lhs.kind != nkDotExpr || kidCount(lhs) < 2:
        return Ok[bool](false)
    let base: Node = kid(lhs, 0)
    let member: Node = kid(lhs, 1)
    if base == nil || member == nil || (member.kind != nkIdent && member.kind != nkSymbol):
        return Ok[bool](false)
    let memberName: str = backendStripSpaces(plainName(member))
    if !(memberName == "cap"):
        return Ok[bool](false)
    let dbgSeqCap: bool = (getEnv "BACKEND_DEBUG_SEQ_CAP_ASSIGN" == "1")

    # Keep low-level seq internals on raw header writes in non-dict modes.
    # In dict helper-closure mode we must lower these too, otherwise
    # `reserve/setLen` can leak as undefined helper symbols.
    let fcur: UirCoreFunc = b.func
    let fp0: str = fcur.originFile
    let fp: str = (fp0 != nil) ? fp0 : ""
    if (len(fp) > 0 && strContains(fp, "src/std/seqs.cheng")) ||
       (len(fp) > 0 && strContains(fp, "src/stage1/seqs_mono_")):
        if !uirCoreDictHelperClosureEnabled():
            if dbgSeqCap:
                echo("[backend] seq.cap skip internal @" + fp + ":" + intToStr(lhs.pos.line) + ":" + intToStr(lhs.pos.col))
            return Ok[bool](false)

    var baseKey: str = caseInferExprTypeKey(b, base)
    if baseKey == nil || len(baseKey) == 0:
        baseKey = exprTypeKeyShallow(b, base)
    if (baseKey == nil || len(baseKey) == 0) && (base.kind == nkIdent || base.kind == nkSymbol):
        let nm0: str = plainName(base)
        let slot0: int32 = localIndex(b.env, nm0)
        if slot0 >= 0 && b.func != nil:
            let ol0: int32 = funcFindObjLocal(b.func, slot0)
            if ol0 >= 0:
                baseKey = funcObjTypeKey(b.func, slot0)
            else:
                baseKey = localTypeKey(b.env, slot0)
        if baseKey == nil || len(baseKey) == 0:
            let g0: str = uirCoreGlobalObjTypeGet(nm0)
            if g0 != nil && len(g0) > 0:
                baseKey = g0
        if baseKey == nil || len(baseKey) == 0:
            let g1: str = uirCoreGlobalTypeKeyGet(nm0)
            if g1 != nil && len(g1) > 0:
                baseKey = g1
    if baseKey == nil || len(baseKey) == 0:
        return Ok[bool](false)
    if uirCoreStrStartsWith(baseKey, "ref_"):
        baseKey = str(ptr_add(void*(baseKey), 4))
    elif uirCoreStrStartsWith(baseKey, "var_ref_"):
        baseKey = str(ptr_add(void*(baseKey), 8))
    elif uirCoreStrStartsWith(baseKey, "var_"):
        baseKey = str(ptr_add(void*(baseKey), 4))
    if uirCoreStrStartsWith(baseKey, "ptr_"):
        baseKey = str(ptr_add(void*(baseKey), 4))
    if baseKey != nil && len(baseKey) > 0:
        let canon: str = uirCoreObjAliasCanon(baseKey)
        if canon != nil && len(canon) > 0:
            baseKey = canon
    if dbgSeqCap:
        var nmDbg: str = ""
        if base != nil && (base.kind == nkIdent || base.kind == nkSymbol):
            nmDbg = plainName(base)
        echo("[backend] seq.cap probe @" + fp + ":" + intToStr(lhs.pos.line) + ":" + intToStr(lhs.pos.col) +
             " base=" + nmDbg + " key=" + baseKey)
    if !uirCoreStrStartsWith(baseKey, "seq_") && !uirCoreStrStartsWith(baseKey, "seq_fixed_") && !(baseKey == "seq"):
        if dbgSeqCap:
            echo("[backend] seq.cap miss non-seq key")
        return Ok[bool](false)
    if !uirCoreHasObjType(b.module, "seq"):
        return Ok[bool](false)

    var elemKey: str = ""
    if uirCoreStrStartsWith(baseKey, "seq_"):
        elemKey = str(ptr_add(void*(baseKey), 4))
    elif uirCoreStrStartsWith(baseKey, "seq_fixed_"):
        elemKey = str(ptr_add(void*(baseKey), 10))
    if (elemKey == nil || len(elemKey) == 0) && base != nil && base.typeCacheValid && base.typeCache != nil:
        var t0: Node = base.typeCache
        while t0 != nil && t0.kind == nkPar && kidCount(t0) > 0:
            t0 = kid(t0, 0)
        while t0 != nil && t0.kind == nkVarTy && kidCount(t0) > 0:
            t0 = kid(t0, 0)
            while t0 != nil && t0.kind == nkPar && kidCount(t0) > 0:
                t0 = kid(t0, 0)
        if t0 != nil && t0.kind == nkBracketExpr && kidCount(t0) > 1:
            let b0: str = backendStripSpaces(plainName(kid(t0, 0)))
            if (b0 == "seq") || (b0 == "seq_fixed"):
                elemKey = typeKey(kid(t0, 1))
    if elemKey == nil || len(elemKey) == 0:
        if dbgSeqCap:
            echo("[backend] seq.cap miss elem key")
        return Ok[bool](false)

    let elemNode: Node = newIdent(elemKey, lhs.pos)
    let elemSizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemNode)
    if !IsOk[int32](elemSizeRes):
        return ErrInfo[bool](ErrorInfoOf[int32](elemSizeRes))
    let elemSize: int32 = Value[int32](elemSizeRes)
    if elemSize <= 0:
        return Err[bool]("uirCore_builder: seq.cap assignment unknown element size")

    let baseRes: Result[UirCoreExpr] = lowerExprValue(b, base, uirCoreTypeI64())
    if !IsOk[UirCoreExpr](baseRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](baseRes))
    let baseTmp: str = blockBuilderNextTemp(b, "__seq_cap_base")
    let baseSlot: int32 = localAdd(b.env, baseTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, baseSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(baseTmp, baseSlot, Value[UirCoreExpr](baseRes)))
    let basePtr: UirCoreExpr = uirCoreLocal(baseSlot)

    let newCapRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI32())
    if !IsOk[UirCoreExpr](newCapRes):
        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](newCapRes))
    let newCapTmp: str = blockBuilderNextTemp(b, "__seq_cap_new")
    let newCapSlot: int32 = localAdd(b.env, newCapTmp, uirCoreTypeI32())
    uirCoreSetLocalType(b.func, newCapSlot, uirCoreTypeI32())
    add(b.currentStmts, uirCoreStmtLet(newCapTmp, newCapSlot, Value[UirCoreExpr](newCapRes)))
    let newCapVal: UirCoreExpr = uirCoreLocal(newCapSlot)

    let seqOt: UirCoreObjType = uirCoreGetObjType(b.module, "seq")
    var capOff: int32 = -1
    var bufOff: int32 = -1
    for fi in 0..<seqOt.fields.len:
        let f: UirCoreObjField = seqOt.fields[fi]
        if (f.name == "cap"):
            capOff = f.offset
        elif (f.name == "buffer"):
            bufOff = f.offset
    if capOff < 0 || bufOff < 0:
        return Err[bool]("uirCore_builder: seq layout mismatch")

    let capAddr: UirCoreExpr = (capOff == 0) ? basePtr : uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(capOff)))
    let bufAddr: UirCoreExpr = (bufOff == 0) ? basePtr : uirCoreBin(mbAdd, basePtr, uirCoreConstI64(int64(bufOff)))

    let oldCapTmp: str = blockBuilderNextTemp(b, "__seq_cap_old")
    let oldCapSlot: int32 = localAdd(b.env, oldCapTmp, uirCoreTypeI32())
    uirCoreSetLocalType(b.func, oldCapSlot, uirCoreTypeI32())
    add(b.currentStmts, uirCoreStmtLet(oldCapTmp, oldCapSlot, uirCoreLoad(capAddr, uirCoreTypeI32())))
    let oldCapVal: UirCoreExpr = uirCoreLocal(oldCapSlot)

    let oldBufTmp: str = blockBuilderNextTemp(b, "__seq_buf_old")
    let oldBufSlot: int32 = localAdd(b.env, oldBufTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, oldBufSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(oldBufTmp, oldBufSlot, uirCoreLoad(bufAddr, uirCoreTypeI64())))
    let oldBufVal: UirCoreExpr = uirCoreLocal(oldBufSlot)

    let growLabel: str = blockBuilderNextLabel(b, "seq_cap_grow")
    let hasBufLabel: str = blockBuilderNextLabel(b, "seq_cap_has_buf")
    let hasOldCapLabel: str = blockBuilderNextLabel(b, "seq_cap_has_oldcap")
    let doZeroLabel: str = blockBuilderNextLabel(b, "seq_cap_zero")
    let joinLabel: str = blockBuilderNextLabel(b, "seq_cap_join")
    let growCond: UirCoreExpr = uirCoreCmp(mcGt, newCapVal, oldCapVal)
    blockBuilderFinish(b, uirCoreTermCbr(growCond, growLabel, joinLabel))

    blockBuilderStart(b, growLabel)
    add(b.currentStmts, uirCoreStmtStore(capAddr, newCapVal, uirCoreTypeI32()))
    let bytesTmp: str = blockBuilderNextTemp(b, "__seq_cap_bytes")
    let bytesSlot: int32 = localAdd(b.env, bytesTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, bytesSlot, uirCoreTypeI64())
    let newCap64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), newCapVal)
    let newBytes: UirCoreExpr = uirCoreBin(mbMul, newCap64, uirCoreConstI64(int64(elemSize)))
    add(b.currentStmts, uirCoreStmtLet(bytesTmp, bytesSlot, newBytes))
    let bytesVal: UirCoreExpr = uirCoreLocal(bytesSlot)

    var reallocArgs: UirCoreExpr[]
    add(reallocArgs, oldBufVal)
    add(reallocArgs, bytesVal)
    let newBufTmp: str = blockBuilderNextTemp(b, "__seq_buf_new")
    let newBufSlot: int32 = localAdd(b.env, newBufTmp, uirCoreTypeI64())
    uirCoreSetLocalType(b.func, newBufSlot, uirCoreTypeI64())
    add(b.currentStmts, uirCoreStmtLet(newBufTmp, newBufSlot, uirCoreCall("realloc", reallocArgs)))
    let newBufVal: UirCoreExpr = uirCoreLocal(newBufSlot)
    add(b.currentStmts, uirCoreStmtStore(bufAddr, newBufVal, uirCoreTypeI64()))

    let hasBufCond: UirCoreExpr = uirCoreCmp(mcNe, newBufVal, uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(hasBufCond, hasBufLabel, joinLabel))

    blockBuilderStart(b, hasBufLabel)
    let hasOldCapCond: UirCoreExpr = uirCoreCmp(mcGe, oldCapVal, uirCoreConstI64(0))
    blockBuilderFinish(b, uirCoreTermCbr(hasOldCapCond, hasOldCapLabel, joinLabel))

    blockBuilderStart(b, hasOldCapLabel)
    let oldCap64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), oldCapVal)
    let oldBytes: UirCoreExpr = uirCoreBin(mbMul, oldCap64, uirCoreConstI64(int64(elemSize)))
    let needZeroCond: UirCoreExpr = uirCoreCmp(mcGt, bytesVal, oldBytes)
    blockBuilderFinish(b, uirCoreTermCbr(needZeroCond, doZeroLabel, joinLabel))

    blockBuilderStart(b, doZeroLabel)
    let zeroAddr: UirCoreExpr = uirCoreBin(mbAdd, newBufVal, oldBytes)
    let zeroBytes: UirCoreExpr = uirCoreBin(mbSub, bytesVal, oldBytes)
    var zeroArgs: UirCoreExpr[]
    add(zeroArgs, zeroAddr)
    add(zeroArgs, zeroBytes)
    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("zeroMem", zeroArgs)))
    blockBuilderFinish(b, uirCoreTermBr(joinLabel))

    blockBuilderStart(b, joinLabel)
    if dbgSeqCap:
        echo("[backend] seq.cap lowered ok @" + fp + ":" + intToStr(lhs.pos.line) + ":" + intToStr(lhs.pos.col))
    return Ok[bool](true)

fn lowerStmt(b: BlockBuilder, stmt: Node): Result[bool] =
    if stmt == nil:
        return Ok[bool](false)
    case stmt.kind
    of nkLet, nkVar:
        var pat: Node = nil
        if kidCount(stmt) > 0:
            pat = kid(stmt, 0)
        var init: Node = nil
        if kidCount(stmt) > 2:
            init = kid(stmt, 2)
        var nameNode: Node = pat
        var typeNode: Node = nil
        if kidCount(stmt) > 1:
            typeNode = kid(stmt, 1)
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
            if kidCount(pat) > 1:
                typeNode = kid(pat, 1)
        var nameCore: Node = nameNode
        while nameCore != nil && nameCore.kind == nkPar && kidCount(nameCore) > 0:
            nameCore = kid(nameCore, 0)
        if nameCore != nil && nameCore.kind == nkSeqLit:
            return lowerDestructureSeq(b, stmt.kind, nameCore, init)
        if nameCore != nil && nameCore.kind == nkTupleLit:
            return lowerDestructureTuple(b, stmt.kind, nameCore, typeNode, init)
        if nameCore != nil && nameCore.kind == nkCall:
            return lowerDestructureObject(b, stmt.kind, nameCore, init)
        if nameCore != nil && (nameCore.kind == nkIntLit || nameCore.kind == nkBoolLit ||
                               nameCore.kind == nkCharLit || nameCore.kind == nkNilLit):
            if init == nil || init.kind == nkEmpty:
                return Err[bool]("uirCore_builder: literal pattern expects init")
            let tmpName: str = blockBuilderNextTemp(b, "__pat_lit")
            let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
            uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
            let initRes: Result[UirCoreExpr] = lowerExprValue(b, init, uirCoreTypeI64())
            if !IsOk[UirCoreExpr](initRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](initRes))
            add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, Value[UirCoreExpr](initRes)))
            var want: UirCoreExpr = uirCoreConstI64(0)
            if nameCore.kind == nkIntLit:
                want = uirCoreConstI64(nameCore.intVal)
            elif nameCore.kind == nkCharLit:
                if nameCore.strVal != nil && len(nameCore.strVal) > 0:
                    want = uirCoreConstI64(int64(nameCore.strVal[0]))
            elif nameCore.kind == nkBoolLit:
                let nameLit: str = backendStripSpaces(nameCore.ident)
                want = uirCoreConstI64((nameLit == "true") ? 1 : 0)
            # nkNilLit stays 0
            let cond: UirCoreExpr = uirCoreCmp(mcEq, uirCoreLocal(tmpSlot), want)
            var args: UirCoreExpr[]
            add(args, cond)
            let msgLabel: str = uirCoreAddCString(b.module, "literal pattern mismatch")
            add(args, uirCoreGlobalAddr(msgLabel))
            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("assert", args)))
            return Ok[bool](false)
        if nameCore == nil ||(nameCore.kind != nkIdent && nameCore.kind != nkSymbol):
            let line: str = (nameNode != nil) ? intToStr(nameNode.pos.line) : "0"
            let col: str = (nameNode != nil) ? intToStr(nameNode.pos.col) : "0"
            return Err[bool]("uirCore_builder: let/var expects identifier @" + line + ":" + col)
        nameNode = nameCore
        let name: str = plainName(nameNode)
        if (getEnv "BACKEND_DEBUG_LET" == "1") &&
           ((backendStripSpaces(name) == "snapRes") || (backendStripSpaces(name) == "tlv")):
            var fnNm: str = ""
            var fp: str = ""
            if b != nil && b.func != nil:
                let fDbg: UirCoreFunc = b.func
                fnNm = fDbg.name
                fp = fDbg.originFile
            let initKind: str = (init != nil) ? intToStr(int32(init.kind)) : "nil"
            let tKind: str = (typeNode != nil) ? intToStr(int32(typeNode.kind)) : "nil"
            echo("[backend] debugLet: fn=" + fnNm + " file=" + fp + " name='" + name + "'" +
                 " stmtKids=" + intToStr(kidCount(stmt)) + " typeKind=nk#" + tKind + " initKind=nk#" + initKind +
                 " @" + intToStr(stmt.pos.line) + ":" + intToStr(stmt.pos.col))
        var declType: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, typeNode)
        if typeNode == nil || typeNode.kind == nkEmpty:
            declType = inferExprTypeWithGlobals(b.env, b.module, b.func, init, declType)
        elif isAddrCall(init) && declType.kind == mtI32:
            declType = uirCoreTypeI64()
        var objTypeName: str = typeNodeObjTypeName(b.module, typeNode)
        var isObjValue: bool = typeNodeIsObjValue(b.module, typeNode)
        if len(objTypeName) == 0 && init != nil:
            var initCore0: Node = init
            while initCore0 != nil && initCore0.kind == nkPar && kidCount(initCore0) > 0:
                initCore0 = kid(initCore0, 0)
            if initCore0 != nil && initCore0.typeCacheValid && initCore0.typeCache != nil:
                objTypeName = typeNodeObjTypeName(b.module, initCore0.typeCache)
                isObjValue = typeNodeIsObjValue(b.module, initCore0.typeCache)
            if len(objTypeName) == 0 && initCore0 != nil:
                var initKey: str = caseInferExprTypeKey(b, initCore0)
                if initKey == nil || len(initKey) == 0:
                    initKey = uirCoreInferNodeTypeKeyForOverload(b, initCore0)
                if (initKey == nil || len(initKey) == 0) && initCore0.kind == nkCall:
                    initKey = uirCoreInferValueCallInnerKey(b, initCore0)
                if initKey != nil && len(initKey) > 0:
                    var key3: str = initKey
                    if uirCoreStrStartsWith(key3, "ref_"):
                        key3 = str(ptr_add(void*(key3), 4))
                    elif uirCoreStrStartsWith(key3, "var_ref_"):
                        key3 = str(ptr_add(void*(key3), 8))
                    elif uirCoreStrStartsWith(key3, "var_"):
                        key3 = str(ptr_add(void*(key3), 4))
                    if uirCoreStrStartsWith(key3, "ptr_"):
                        key3 = str(ptr_add(void*(key3), 4))
                    if key3 != nil && len(key3) > 0:
                        let canon3: str = uirCoreObjAliasCanon(key3)
                        if canon3 != nil && len(canon3) > 0:
                            key3 = canon3
                        let objFromKey3: str = uirCoreObjTypeFromTypeKey(b.module, key3)
                        if objFromKey3 != nil && len(objFromKey3) > 0:
                            objTypeName = objFromKey3
                            let aliasTy2: UirCoreType = uirCoreTryGetTypeAlias(b.module, key3)
                            isObjValue = aliasTy2.kind == mtVoid
                            if objTypeName == "seq" || objTypeName == "Table":
                                isObjValue = true
        if len(objTypeName) > 0:
            declType = uirCoreTypeI64()
        let slot: int32 = localAdd(b.env, name, declType)
        uirCoreSetLocalType(b.func, slot, declType)
        var declKey: str = ""
        if typeNode != nil && typeNode.kind != nkEmpty:
            declKey = uirCoreTypeKeyFromNodeLoose(typeNode)
        elif init != nil:
            var initCoreKey: Node = init
            while initCoreKey != nil && initCoreKey.kind == nkPar && kidCount(initCoreKey) > 0:
                initCoreKey = kid(initCoreKey, 0)
            if initCoreKey != nil && initCoreKey.typeCacheValid && initCoreKey.typeCache != nil:
                declKey = uirCoreTypeKeyFromNodeLoose(initCoreKey.typeCache)
            if declKey == nil || len(declKey) == 0:
                declKey = caseInferExprTypeKey(b, initCoreKey)
            if declKey == nil || len(declKey) == 0:
                declKey = uirCoreInferNodeTypeKeyForOverload(b, initCoreKey)
            if (declKey == nil || len(declKey) == 0) && initCoreKey != nil && initCoreKey.kind == nkCall:
                declKey = uirCoreInferValueCallInnerKey(b, initCoreKey)
            if declKey != nil && len(declKey) > 0:
                # Normalize away `var/ref` wrappers; keep `ptr_` when present.
                if uirCoreStrStartsWith(declKey, "ref_"):
                    declKey = str(ptr_add(void*(declKey), 4))
                elif uirCoreStrStartsWith(declKey, "var_ref_"):
                    declKey = str(ptr_add(void*(declKey), 8))
                elif uirCoreStrStartsWith(declKey, "var_"):
                    declKey = str(ptr_add(void*(declKey), 4))
        if declKey != nil && len(declKey) > 0:
            localSetTypeKey(b.env, slot, declKey)
        if (getEnv "BACKEND_DEBUG_LET" == "1") && (backendStripSpaces(name) == "tlv"):
            var fnNm2: str = ""
            if b != nil && b.func != nil:
                let fDbg2: UirCoreFunc = b.func
                fnNm2 = fDbg2.name
            let caseKeyDbg: str = caseInferExprTypeKey(b, init)
            let inferKeyDbg: str = uirCoreInferNodeTypeKeyForOverload(b, init)
            echo("[backend] debugLetInfer: fn=" + fnNm2 + " name='" + name +
                 "' declTy=nk#" + intToStr(int32(declType.kind)) +
                 " objTypeName='" + objTypeName + "' isObjValue=" + (isObjValue ? "1" : "0") +
                 " declKey='" + declKey + "' caseKey='" + caseKeyDbg + "' inferKey='" + inferKeyDbg + "'")
        if len(objTypeName) > 0:
            if isObjValue:
                let allocRes: Result[bool] = allocObjValueLocal(b, slot, objTypeName)
                if ! IsOk[bool](allocRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](allocRes))
            else:
                funcSetObjLocal(b.func, slot, objTypeName, -1)
            var kLocal: str = declKey
            if len(kLocal) == 0:
                kLocal = objTypeName
            if objTypeName != nil && !(objTypeName == "seq") && (len(kLocal) == 0 || !uirCoreHasObjType(b.module, kLocal)):
                kLocal = objTypeName
            if len(kLocal) > 0:
                funcSetObjTypeKey(b.func, slot, kLocal)
        if init == nil || init.kind == nkEmpty:
            if isObjValue:
                let initRes2: Result[bool] = emitObjDefaultInit(b, slot, objTypeName)
                if ! IsOk[bool](initRes2):
                    return ErrInfo[bool](ErrorInfoOf[bool](initRes2))
                let sfi: SeqFixedInit = seqFixedInitInfo(typeNode)
                if sfi.elemType != nil && sfi.capExpr != nil:
                    let seqInitRes: Result[bool] = emitSeqFixedReserveInitToPtr(b, uirCoreLocal(slot), sfi)
                    if !IsOk[bool](seqInitRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](seqInitRes))
                return Ok[bool](false)
            if declKey == "str" || declKey == "string" || declKey == "cstring":
                let label0: str = uirCoreAddCString(b.module, "")
                if stmt.kind == nkLet:
                    add(b.currentStmts, uirCoreStmtLet(name, slot, uirCoreGlobalAddr(label0)))
                else:
                    add(b.currentStmts, uirCoreStmtVar(name, slot, uirCoreGlobalAddr(label0)))
                return Ok[bool](false)
            if stmt.kind == nkLet:
                add(b.currentStmts, uirCoreStmtLet(name, slot, uirCoreConstI64(0)))
            else:
                add(b.currentStmts, uirCoreStmtVar(name, slot, uirCoreConstI64(0)))
            return Ok[bool](false)
        if isControlExpr(init):
            if isObjValue:
                var initCore3: Node = init
                while initCore3 != nil && initCore3.kind == nkPar && kidCount(initCore3) > 0:
                    initCore3 = kid(initCore3, 0)
                if initCore3 != nil && initCore3.kind == nkIf:
                    let ifRes: Result[bool] = lowerIfAssignObjValue(b, initCore3, name, slot)
                    if !IsOk[bool](ifRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](ifRes))
                    return Ok[bool](false)
                var fnName: str = ""
                var fp: str = ""
                if b != nil && b.func != nil:
                    let f0: UirCoreFunc = b.func
                    fnName = f0.name
                    fp = f0.originFile
                let line: str = intToStr(stmt.pos.line)
                let col: str = intToStr(stmt.pos.col)
                return Err[bool]("uirCore_builder: object init via control expr not supported: " + name +
                                 " (fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")
            let assignRes: Result[bool] = lowerAssignValue(b, init, name, slot)
            if ! IsOk[bool](assignRes):
                return ErrInfo[bool](ErrorInfoOf[bool](assignRes))
            return Ok[bool](false)
        if isObjValue:
            let assignRes2: Result[bool] = lowerAssignValue(b, init, name, slot)
            if ! IsOk[bool](assignRes2):
                return ErrInfo[bool](ErrorInfoOf[bool](assignRes2))
            return Ok[bool](false)
        let initRes: Result[UirCoreExpr] = lowerExprValue(b, init, declType)
        if ! IsOk[UirCoreExpr](initRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](initRes))
        var initCore2: Node = init
        while initCore2 != nil && initCore2.kind == nkPar && kidCount(initCore2) > 0:
            initCore2 = kid(initCore2, 0)
        if initCore2 != nil && (initCore2.kind == nkIdent || initCore2.kind == nkSymbol):
            let initName: str = plainName(initCore2)
            if moduleHasFuncByBase(b.module, initName):
                let f1: UirCoreFunc = moduleFindFuncByBaseUnique(b.module, initName)
                if f1 != nil:
                    localSetCallTarget(b.env, slot, f1.name)
        if stmt.kind == nkLet:
            add(b.currentStmts, uirCoreStmtLet(name, slot, Value[UirCoreExpr](initRes)))
        else:
            add(b.currentStmts, uirCoreStmtVar(name, slot, Value[UirCoreExpr](initRes)))
        return Ok[bool](false)
    of nkAsgn:
        if kidCount(stmt) < 2:
            return Err[bool]("uirCore_builder: assignment expects lhs/rhs")
        let lhs: Node = kid(stmt, 0)
        let rhs: Node = kid(stmt, 1)
        let seqCapAssignRes: Result[bool] = lowerSeqCapAssignFallback(b, lhs, rhs)
        if !IsOk[bool](seqCapAssignRes):
            return ErrInfo[bool](ErrorInfoOf[bool](seqCapAssignRes))
        if Value[bool](seqCapAssignRes):
            return Ok[bool](false)
        if lhs != nil && lhs.kind == nkBracketExpr:
            if kidCount(lhs) == 1:
                let addrNode: Node = kid(lhs, 0)
                let ptrKey0: str = exprTypeKeyShallow(b, addrNode)
                var elemKey0: str = ""
                if lhs.typeCacheValid && lhs.typeCache != nil:
                    elemKey0 = backendStripSpaces(typeKey lhs.typeCache)
                    if uirCoreStrStartsWith(elemKey0, "ptr_"):
                        elemKey0 = backendStripSpaces(str(ptr_add(void*(elemKey0), 4)))
                let addrRes: Result[UirCoreExpr] = lowerExprPtrValue(b, addrNode)
                if ! IsOk[UirCoreExpr](addrRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](addrRes))
                if (getEnv "BACKEND_DEBUG_DEREF_STORE" == "1") && b != nil && b.func != nil:
                    let fDbg0: UirCoreFunc = b.func
                    let fpDbg0: str = fDbg0.originFile
                    let fpDbg1: str = (fpDbg0 != nil) ? fpDbg0 : ""
                    echo("[backend] debugBracketStore: fn=" + fDbg0.name + " @" + fpDbg1 + ":" +
                         intToStr(lhs.pos.line) + ":" + intToStr(lhs.pos.col) + " lhsKind=nk#" +
                         intToStr(int32(lhs.kind)) + " ptrKey0='" + ptrKey0 + "' elemKey0='" + elemKey0 + "'")
                if isByteTypeKey(elemKey0) || isBytePtrTypeKey(ptrKey0):
                    let valRes0: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI32())
                    if ! IsOk[UirCoreExpr](valRes0):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes0))
                    let storeTy: UirCoreType = byteUirTypeFromElemOrPtrKey(elemKey0, ptrKey0)
                    lowerByteStoreNilChecked(b, Value[UirCoreExpr](addrRes), Value[UirCoreExpr](valRes0), uirCoreTypeI32(), storeTy)
                else:
                    if uirCoreStrStartsWith(ptrKey0, "ptr_"):
                        let baseKey0: str = str(ptr_add(void*(ptrKey0), 4))
                        let objTypeName0: str = uirCorePtrBaseObjTypeName(b.module, baseKey0)
                        if objTypeName0 != nil && len(objTypeName0) > 0:
                            let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(b.module, objTypeName0)
                            if aliasTy0.kind == mtVoid:
                                let dstPtr: UirCoreExpr = Value[UirCoreExpr](addrRes)
                                var rhs0: Node = rhs
                                while rhs0 != nil && rhs0.kind == nkPar && kidCount(rhs0) > 0:
                                    rhs0 = kid(rhs0, 0)
                                if rhs0 != nil && rhs0.kind == nkCall:
                                    let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, rhs0, dstPtr)
                                    if !IsOk[UirCoreExpr](callRes):
                                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
                                    return Ok[bool](false)
                                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                                if !IsOk[UirCoreExpr](srcRes):
                                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                                let copyRes: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName0, Value[UirCoreExpr](srcRes))
                                if !IsOk[bool](copyRes):
                                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                                return Ok[bool](false)
                    let storeType: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, rhs, uirCoreTypeI32())
                    let valRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, storeType)
                    if ! IsOk[UirCoreExpr](valRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
                    add(b.currentStmts,
                                    uirCoreStmtStore(Value[UirCoreExpr](addrRes),
                                                 Value[UirCoreExpr](valRes),
                                                 storeType))
                return Ok[bool](false)
            if kidCount(lhs) == 2:
                let base0: Node = kid(lhs, 0)
                var idx0: Node = kid(lhs, 1)
                while idx0 != nil && idx0.kind == nkPar && kidCount(idx0) > 0:
                    idx0 = kid(idx0, 0)

                var baseObj: str = ""
                var baseKey2: str = ""
                if base0 != nil && base0.typeCacheValid && base0.typeCache != nil:
                    baseKey2 = typeKey base0.typeCache
                    baseObj = typeNodeObjTypeName(b.module, base0.typeCache)
                if base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol):
                    let nm: str = plainName(base0)
                    let slot0: int32 = localIndex(b.env, nm)
                    if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
                        baseObj = funcObjTypeName(b.func, slot0)
                        baseKey2 = funcObjTypeKey(b.func, slot0)
                    elif slot0 >= 0 && len(baseKey2) == 0:
                        baseKey2 = localTypeKey(b.env, slot0)
                    if len(baseObj) == 0:
                        let gObj0: str = uirCoreGlobalObjTypeGet(nm)
                        if gObj0 != nil && len(gObj0) > 0:
                            baseObj = gObj0
                    if len(baseKey2) == 0:
                        let gKey0: str = uirCoreGlobalTypeKeyGet(nm)
                        if gKey0 != nil && len(gKey0) > 0:
                            baseKey2 = gKey0

                var basePtrOverride: UirCoreExpr = uirCoreConstI64(0)
                var haveBasePtrOverride: bool = false
                if base0 != nil && base0.kind == nkDotExpr:
                    let daRes: Result[DotAccess] = lowerDotAccess(b, base0)
                    if IsOk[DotAccess](daRes):
                        let da: DotAccess = Value[DotAccess](daRes)
                        if da.fieldTy.kind == mtVoid && da.objTypeName != nil && len(da.objTypeName) > 0:
                            haveBasePtrOverride = true
                            basePtrOverride = da.addr
                            if len(baseObj) == 0:
                                baseObj = da.objTypeName
                            if len(baseKey2) == 0:
                                baseKey2 = da.objTypeName
                    # Some stage1 pipelines omit typeCache on dot expressions. Recover a stable
                    # generic type key (e.g. `seq_T`) so indexed assignment can be lowered as a
                    # builtin seq store instead of falling back to `[]=` overload resolution.
                    let inferredKey2: str = caseInferExprTypeKey(b, base0)
                    if inferredKey2 != nil && len(inferredKey2) > 0:
                        if uirCoreStrStartsWith(inferredKey2, "seq_") && !uirCoreStrStartsWith(baseKey2, "seq_"):
                            baseKey2 = inferredKey2
                        elif uirCoreStrStartsWith(inferredKey2, "seq_fixed_") && !uirCoreStrStartsWith(baseKey2, "seq_fixed_"):
                            baseKey2 = inferredKey2
                        elif uirCoreStrStartsWith(inferredKey2, "Table_") && !uirCoreStrStartsWith(baseKey2, "Table_"):
                            baseKey2 = inferredKey2
                        elif len(baseKey2) == 0:
                            baseKey2 = inferredKey2

                var objName: str = baseObj
                if len(objName) == 0:
                    objName = baseKey2
                if uirCoreStrStartsWith(objName, "var_ref_"):
                    objName = str(ptr_add(void*(objName), 8))
                elif uirCoreStrStartsWith(objName, "var_") || uirCoreStrStartsWith(objName, "ref_"):
                    objName = str(ptr_add(void*(objName), 4))

                if uirCoreStrStartsWith(objName, "array_") && b.module != nil && uirCoreHasObjType(b.module, objName):
                    var basePtrRes: Result[UirCoreExpr]
                    if haveBasePtrOverride:
                        basePtrRes = Ok[UirCoreExpr](basePtrOverride)
                    else:
                        basePtrRes = lowerExprValue(b, base0, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](basePtrRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](basePtrRes))
                    let idxRes32: Result[UirCoreExpr] = lowerExprValue(b, idx0, uirCoreTypeI32())
                    if !IsOk[UirCoreExpr](idxRes32):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](idxRes32))
                    let basePtr: UirCoreExpr = Value[UirCoreExpr](basePtrRes)
                    let ot: UirCoreObjType = uirCoreGetObjType(b.module, objName)
                    if ot.fields.len == 0:
                        return Err[bool]("uirCore_builder: array type has no fields: " + objName)
                    let idx32: UirCoreExpr = Value[UirCoreExpr](idxRes32)
                    let arrLen32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreConstI64(int64(ot.fields.len)))
                    var bcArgs: UirCoreExpr[]
                    add(bcArgs, arrLen32)
                    add(bcArgs, idx32)
                    add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("cheng_bounds_check", bcArgs)))
                    let idx64: UirCoreExpr = uirCoreCast(uirCoreTypeI64(), idx32)
                    let f0: UirCoreObjField = ot.fields[0]
                    let elemTy: UirCoreType = f0.ty
                    let elemSize: int32 = uirCoreTypeSize(elemTy)
                    if elemSize <= 0:
                        return Err[bool]("uirCore_builder: array element size unsupported: " + objName)
                    var stride: int64 = int64(alignUpPow2(elemSize, uirCoreTypeAlignPow2(elemTy)))
                    if ot.fields.len > 1:
                        let f1: UirCoreObjField = ot.fields[1]
                        let d: int32 = f1.offset - f0.offset
                        if d > 0:
                            stride = int64(d)
                    let off: UirCoreExpr = (stride == 1) ? idx64 : uirCoreBin(mbMul, idx64, uirCoreConstI64(stride))
                    let addr: UirCoreExpr = uirCoreBin(mbAdd, basePtr, off)
                    # `array[T]` currently uses pointer slots when `T` is an object value.
                    # Store via owned backing memory to avoid dangling stack pointers from
                    # assignments like `arr[i] = localObj`.
                    var elemObjName: str = ""
                    if rhs != nil && (rhs.kind == nkIdent || rhs.kind == nkSymbol):
                        let srcNm0: str = plainName(rhs)
                        let srcSlot0: int32 = localIndex(b.env, srcNm0)
                        if srcSlot0 >= 0 && funcFindObjLocal(b.func, srcSlot0) >= 0:
                            elemObjName = funcObjTypeName(b.func, srcSlot0)
                    if (elemObjName == nil || len(elemObjName) == 0) &&
                       rhs != nil && rhs.typeCacheValid && rhs.typeCache != nil:
                        elemObjName = typeNodeObjTypeName(b.module, rhs.typeCache)
                    if elemObjName == nil || len(elemObjName) == 0:
                        var rhsKey0: str = caseInferExprTypeKey(b, rhs)
                        if rhsKey0 == nil || len(rhsKey0) == 0:
                            rhsKey0 = exprTypeKeyShallow(b, rhs)
                        if rhsKey0 != nil && len(rhsKey0) > 0:
                            if uirCoreStrStartsWith(rhsKey0, "var_ref_"):
                                rhsKey0 = str(ptr_add(void*(rhsKey0), 8))
                            elif uirCoreStrStartsWith(rhsKey0, "var_") || uirCoreStrStartsWith(rhsKey0, "ref_"):
                                rhsKey0 = str(ptr_add(void*(rhsKey0), 4))
                            if uirCoreStrStartsWith(rhsKey0, "ptr_"):
                                rhsKey0 = str(ptr_add(void*(rhsKey0), 4))
                            elemObjName = uirCoreObjTypeFromTypeKey(b.module, rhsKey0)
                    if elemObjName != nil && len(elemObjName) > 0 && uirCoreHasObjType(b.module, elemObjName):
                        let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](srcRes0):
                            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes0))
                        let otElem: UirCoreObjType = uirCoreGetObjType(b.module, elemObjName)
                        if otElem.size <= 0:
                            return Err[bool]("uirCore_builder: array object element has invalid size: " + elemObjName)
                        let oldPtr: UirCoreExpr = uirCoreLoad(addr, uirCoreTypeI64())
                        var allocArgs: UirCoreExpr[]
                        add(allocArgs, oldPtr)
                        add(allocArgs, uirCoreConstI64(int64(otElem.size)))
                        let newPtrName: str = blockBuilderNextTemp(b, "__arr_obj_ptr")
                        let newPtrSlot: int32 = localAdd(b.env, newPtrName, uirCoreTypeI64())
                        uirCoreSetLocalType(b.func, newPtrSlot, uirCoreTypeI64())
                        add(b.currentStmts, uirCoreStmtLet(newPtrName, newPtrSlot, uirCoreCall("realloc", allocArgs)))
                        let newPtr: UirCoreExpr = uirCoreLocal(newPtrSlot)
                        add(b.currentStmts, uirCoreStmtStore(addr, newPtr, uirCoreTypeI64()))
                        let copyLabel: str = blockBuilderNextLabel(b, "arr_obj_copy")
                        let joinLabel: str = blockBuilderNextLabel(b, "arr_obj_join")
                        let hasPtr: UirCoreExpr = uirCoreCmp(mcNe, newPtr, uirCoreConstI64(0))
                        blockBuilderFinish(b, uirCoreTermCbr(hasPtr, copyLabel, joinLabel))
                        blockBuilderStart(b, copyLabel)
                        let copyResObj: Result[bool] = emitObjCopyPtrs(b, newPtr, elemObjName, Value[UirCoreExpr](srcRes0))
                        if !IsOk[bool](copyResObj):
                            return ErrInfo[bool](ErrorInfoOf[bool](copyResObj))
                        blockBuilderFinish(b, uirCoreTermBr(joinLabel))
                        blockBuilderStart(b, joinLabel)
                        return Ok[bool](false)
                    let valRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, elemTy)
                    if !IsOk[UirCoreExpr](valRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
                    add(b.currentStmts, uirCoreStmtStore(addr, Value[UirCoreExpr](valRes), elemTy))
                    return Ok[bool](false)

                # Index assignment for dynamic `seq[T]`: lower to runtime `cheng_seq_set`.
                var seqKey: str = baseKey2
                if uirCoreStrStartsWith(seqKey, "var_ref_"):
                    seqKey = str(ptr_add(void*(seqKey), 8))
                elif uirCoreStrStartsWith(seqKey, "var_") || uirCoreStrStartsWith(seqKey, "ref_"):
                    seqKey = str(ptr_add(void*(seqKey), 4))
                if uirCoreStrStartsWith(seqKey, "ptr_"):
                    seqKey = str(ptr_add(void*(seqKey), 4))
                if uirCoreStrStartsWith(seqKey, "seq_") && b.module != nil:
                    let elemKey: str = str(ptr_add(void*(seqKey), 4))
                    if elemKey == nil || len(elemKey) == 0:
                        return Err[bool]("uirCore_builder: seq index store missing element type")
                    let elemTypeNode: Node = newIdent(elemKey, lhs.pos)
                    let sizeRes: Result[int32] = uirCoreSizeOfTypeNode(b.module, elemTypeNode)
                    if !IsOk[int32](sizeRes):
                        return ErrInfo[bool](ErrorInfoOf[int32](sizeRes))
                    let elemSize: int32 = Value[int32](sizeRes)
                    let elemTy: UirCoreType = uirCoreTypeFromNodeWithModule(b.module, elemTypeNode)

                    var baseRes3: Result[UirCoreExpr]
                    if haveBasePtrOverride:
                        baseRes3 = Ok[UirCoreExpr](basePtrOverride)
                    else:
                        baseRes3 = lowerExprValue(b, base0, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](baseRes3):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](baseRes3))
                    let seqName: str = blockBuilderNextTemp(b, "__seq_base")
                    let seqSlot: int32 = localAdd(b.env, seqName, uirCoreTypeI64())
                    uirCoreSetLocalType(b.func, seqSlot, uirCoreTypeI64())
                    add(b.currentStmts, uirCoreStmtLet(seqName, seqSlot, Value[UirCoreExpr](baseRes3)))
                    let seqPtr: UirCoreExpr = uirCoreLocal(seqSlot)

                    let idxRes3: Result[UirCoreExpr] = lowerExprValue(b, idx0, uirCoreTypeI32())
                    if !IsOk[UirCoreExpr](idxRes3):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](idxRes3))
                    let elemSize32: UirCoreExpr = uirCoreCast(uirCoreTypeI32(), uirCoreConstI64(int64(elemSize)))
                    var args3: UirCoreExpr[]
                    add(args3, seqPtr)
                    add(args3, Value[UirCoreExpr](idxRes3))
                    add(args3, elemSize32)
                    let ptrExpr: UirCoreExpr = uirCoreCall("cheng_seq_set_grow", args3)
                    if (elemKey == "bool"):
                        let valResB: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI32())
                        if !IsOk[UirCoreExpr](valResB):
                            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valResB))
                        lowerByteStoreNilChecked(b, ptrExpr, Value[UirCoreExpr](valResB), uirCoreTypeI32(), uirCoreTypeU8())
                        return Ok[bool](false)
                    let elemObjName: str = typeNodeObjTypeName(b.module, elemTypeNode)
                    if len(elemObjName) > 0 && typeNodeIsObjValue(b.module, elemTypeNode):
                        let srcRes0: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                        if !IsOk[UirCoreExpr](srcRes0):
                            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes0))
                        let copyRes0: Result[bool] = emitObjCopyPtrs(b, ptrExpr, elemObjName, Value[UirCoreExpr](srcRes0))
                        if !IsOk[bool](copyRes0):
                            return ErrInfo[bool](ErrorInfoOf[bool](copyRes0))
                        return Ok[bool](false)
                    let valRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, elemTy)
                    if !IsOk[UirCoreExpr](valRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
                    add(b.currentStmts, uirCoreStmtStore(ptrExpr, Value[UirCoreExpr](valRes), elemTy))
                    return Ok[bool](false)
            if kidCount(lhs) == 2:
                let base1: Node = kid(lhs, 0)
                let idx1: Node = kid(lhs, 1)
                let callNode: Node = newNode(nkCall, lhs.pos)
                callNode.typeCache = lhs.typeCache
                callNode.typeCacheValid = lhs.typeCacheValid
                addSon(callNode, newIdent("[]=", lhs.pos))
                addSon(callNode, base1)
                addSon(callNode, idx1)
                addSon(callNode, rhs)
                let callRes: Result[UirCoreExpr] = lowerExprValue(b, callNode, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](callRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
                add(b.currentStmts, uirCoreStmtExpr(Value[UirCoreExpr](callRes)))
                return Ok[bool](false)
            var fnName2: str = ""
            var fp3: str = ""
            if b != nil && b.func != nil:
                let bf2: UirCoreFunc = b.func
                fnName2 = bf2.name
                fp3 = bf2.originFile
            let line2: str = intToStr(lhs.pos.line)
            let col2: str = intToStr(lhs.pos.col)
            return Err[bool]("uirCore_builder: indexed assignment not supported (fn=" + fnName2 +
                             " " + fp3 + ":" + line2 + ":" + col2 + ")")
        if lhs != nil && (lhs.kind == nkHiddenDeref || lhs.kind == nkDerefExpr) && kidCount(lhs) > 0:
            let addrNode2: Node = kid(lhs, 0)
            # Prefer local type keys for deref stores; typeCache can be incomplete for ptr locals.
            var ptrKey1: str = ""
            if addrNode2 != nil && (addrNode2.kind == nkIdent || addrNode2.kind == nkSymbol):
                let slot0: int32 = localIndex(b.env, plainName(addrNode2))
                if slot0 >= 0:
                    ptrKey1 = localTypeKey(b.env, slot0)
            if ptrKey1 == nil || len(ptrKey1) == 0:
                ptrKey1 = exprTypeKeyShallow(b, addrNode2)
            var elemKey1: str = ""
            if lhs.typeCacheValid && lhs.typeCache != nil:
                elemKey1 = backendStripSpaces(typeKey lhs.typeCache)
                if uirCoreStrStartsWith(elemKey1, "ptr_"):
                    elemKey1 = backendStripSpaces(str(ptr_add(void*(elemKey1), 4)))
            if (getEnv "BACKEND_DEBUG_DEREF_STORE" == "1") && b != nil && b.func != nil:
                let fDbg: UirCoreFunc = b.func
                let fpDbg: str = fDbg.originFile
                let fpDbg2: str = (fpDbg != nil) ? fpDbg : ""
                echo("[backend] debugDerefStore: fn=" + fDbg.name + " @" + fpDbg2 + ":" +
                     intToStr(lhs.pos.line) + ":" + intToStr(lhs.pos.col) + " lhsKind=nk#" +
                     intToStr(int32(lhs.kind)) + " ptrKey1='" + ptrKey1 + "' elemKey1='" + elemKey1 + "'")
            let addrRes2: Result[UirCoreExpr] = lowerExprPtrValue(b, addrNode2)
            if ! IsOk[UirCoreExpr](addrRes2):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](addrRes2))
            if isByteTypeKey(elemKey1) || isBytePtrTypeKey(ptrKey1):
                let valRes2a: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI32())
                if ! IsOk[UirCoreExpr](valRes2a):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes2a))
                let storeTy2: UirCoreType = byteUirTypeFromElemOrPtrKey(elemKey1, ptrKey1)
                lowerByteStoreNilChecked(b, Value[UirCoreExpr](addrRes2), Value[UirCoreExpr](valRes2a), uirCoreTypeI32(), storeTy2)
            else:
                var storeType2: UirCoreType = uirCoreTypeVoid()
                # Some stage1 pipelines may keep a bare `ptr` key without an inner type.
                # Treat it as pointer-sized to avoid truncating pointer values.
                if (ptrKey1 == "ptr"):
                    storeType2 = uirCoreTypeI64()
                if uirCoreStrStartsWith(ptrKey1, "ptr_"):
                    let baseKey1: str = str(ptr_add(void*(ptrKey1), 4))
                    let objTypeName1: str = uirCorePtrBaseObjTypeName(b.module, baseKey1)
                    if objTypeName1 != nil && len(objTypeName1) > 0:
                        let aliasTy1: UirCoreType = uirCoreTryGetTypeAlias(b.module, objTypeName1)
                        if aliasTy1.kind == mtVoid:
                            let dstPtr: UirCoreExpr = Value[UirCoreExpr](addrRes2)
                            var rhs0: Node = rhs
                            while rhs0 != nil && rhs0.kind == nkPar && kidCount(rhs0) > 0:
                                rhs0 = kid(rhs0, 0)
                            if rhs0 != nil && rhs0.kind == nkCall:
                                let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, rhs0, dstPtr)
                                if !IsOk[UirCoreExpr](callRes):
                                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
                                return Ok[bool](false)
                            let srcRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                            if !IsOk[UirCoreExpr](srcRes):
                                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                            let copyRes: Result[bool] = emitObjCopyPtrs(b, dstPtr, objTypeName1, Value[UirCoreExpr](srcRes))
                            if !IsOk[bool](copyRes):
                                return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                            return Ok[bool](false)
                    if baseKey1 != nil && len(baseKey1) > 0:
                        let baseKey1Trim: str = backendStripSpaces(baseKey1)
                        if uirCoreStrStartsWith(baseKey1Trim, "ptr_") || uirCoreStrStartsWith(baseKey1Trim, "ref_") ||
                           uirCoreStrStartsWith(baseKey1Trim, "var_") || uirCoreStrStartsWith(baseKey1Trim, "var_ref_") ||
                           (baseKey1Trim == "ptr") || (baseKey1Trim == "ref") || (baseKey1Trim == "var"):
                            storeType2 = uirCoreTypeI64()
                        else:
                            let baseTypeNode: Node = newIdent(baseKey1Trim, lhs.pos)
                            storeType2 = uirCoreTypeFromNodeWithModule(b.module, baseTypeNode)
                            if storeType2.kind == mtVoid:
                                storeType2 = uirCoreTypeI64()
                    else:
                        storeType2 = uirCoreTypeI64()
                if storeType2.kind == mtVoid:
                    storeType2 = inferExprTypeWithGlobals(b.env, b.module, b.func, rhs, uirCoreTypeI32())
                let valRes2: Result[UirCoreExpr] = lowerExprValue(b, rhs, storeType2)
                if ! IsOk[UirCoreExpr](valRes2):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes2))
                add(b.currentStmts,
                                uirCoreStmtStore(Value[UirCoreExpr](addrRes2),
                                             Value[UirCoreExpr](valRes2),
                                             storeType2))
            return Ok[bool](false)
        if lhs != nil && lhs.kind == nkDotExpr:
            let daRes: Result[DotAccess] = lowerDotAccess(b, lhs)
            if ! IsOk[DotAccess](daRes):
                return ErrInfo[bool](ErrorInfoOf[DotAccess](daRes))
            let da: DotAccess = Value[DotAccess](daRes)
            if da.fieldTy.kind == mtVoid:
                # Composite (inlined) object field assignment: copy from rhs pointer to dst field storage.
                var objNm: str = da.objTypeName
                if rhs != nil && (rhs.kind == nkIdent || rhs.kind == nkSymbol):
                    let srcSlot0: int32 = localIndex(b.env, plainName(rhs))
                    if srcSlot0 >= 0:
                        objNm = funcObjTypeName(b.func, srcSlot0)
                if len(objNm) == 0 && rhs != nil && rhs.typeCacheValid && rhs.typeCache != nil:
                    objNm = typeNodeObjTypeName(b.module, rhs.typeCache)
                if len(objNm) == 0:
                    return Err[bool]("uirCore_builder: object field assignment missing type")
                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                let copyRes: Result[bool] = emitObjCopyPtrs(b, da.addr, objNm, Value[UirCoreExpr](srcRes))
                if !IsOk[bool](copyRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                return Ok[bool](false)
            if lhs.typeCacheValid && lhs.typeCache != nil:
                let objNm: str = typeNodeObjTypeName(b.module, lhs.typeCache)
                if len(objNm) > 0 && typeNodeIsObjValue(b.module, lhs.typeCache):
                    let srcRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                    if !IsOk[UirCoreExpr](srcRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                    let copyRes: Result[bool] = emitObjCopyPtrs(b, da.addr, objNm, Value[UirCoreExpr](srcRes))
                    if !IsOk[bool](copyRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                    return Ok[bool](false)
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, da.fieldTy)
            if ! IsOk[UirCoreExpr](valRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
            add(b.currentStmts, uirCoreStmtStore(da.addr, Value[UirCoreExpr](valRes), da.fieldTy))
            return Ok[bool](false)
        if lhs == nil ||(lhs.kind != nkIdent && lhs.kind != nkSymbol):
            let k: str = (lhs != nil) ? intToStr(int32(lhs.kind)) : "0"
            let line: str = (lhs != nil) ? intToStr(lhs.pos.line) : "0"
            let col: str = (lhs != nil) ? intToStr(lhs.pos.col) : "0"
            return Err[bool]("uirCore_builder: assignment expects identifier (lhs nk#" + k + " @" + line + ":" + col + ")")
        let name2: str = backendStripSpaces(plainName(lhs))
        let slot2: int32 = localIndex(b.env, name2)
        if slot2 < 0:
            let mod: UirCoreModule = b.module
            var gName: str = name2
            var gi: int32 = moduleGlobalIndex(mod, gName)
            if gi < 0 && b.func != nil && uirCoreDupGlobalNamesHas(name2):
                let f2: UirCoreFunc = b.func
                let g2: str = uirCoreMaybeMangleDupGlobalName(name2, f2.originFile)
                if g2 != nil && len(g2) > 0:
                    gName = g2
                    gi = moduleGlobalIndex(mod, gName)
            if gi < 0 && uirCoreDupGlobalNamesHas(name2):
                let gi2: int32 = moduleFindGlobalIndexByBaseUnique(mod, name2)
                if gi2 >= 0 && gi2 < mod.globals.len:
                    let g2: UirCoreGlobal = mod.globals[gi2]
                    if g2.name != nil && len(g2.name) > 0:
                        gName = g2.name
                        gi = gi2
            if gi < 0 && uirCoreStrStartsWith(name2, "__cheng_"):
                var declTy: UirCoreType = inferExprTypeWithGlobals(b.env, mod, b.func, rhs, uirCoreTypeI32())
                if declTy.kind == mtVoid:
                    declTy = uirCoreTypeI32()
                var originFile2: str = ""
                if b.func != nil:
                    let f2: UirCoreFunc = b.func
                    originFile2 = f2.originFile
                uirCoreAddGlobal(mod, name2, declTy, 0, false, originFile2)
                gName = name2
                gi = moduleGlobalIndex(mod, gName)
            if gi < 0:
                let line: str = (lhs != nil) ? intToStr(lhs.pos.line) : "0"
                let col: str = (lhs != nil) ? intToStr(lhs.pos.col) : "0"
                return Err[bool]("uirCore_builder: assignment to unknown local/global: " + name2 + " @" + line + ":" + col)
            let g: UirCoreGlobal = mod.globals[gi]
            let gObj: str = uirCoreGlobalObjTypeGet(gName)
            if len(gObj) > 0:
                let dstPtr: UirCoreExpr = uirCoreLoad(uirCoreGlobalAddr(gName), uirCoreTypeI64())
                if isControlExpr(rhs):
                    let tmpName: str = blockBuilderNextTemp(b, "__global_obj_assign")
                    let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                    uirCoreSetLocalType(b.func, tmpSlot, uirCoreTypeI64())
                    localSetTypeKey(b.env, tmpSlot, gObj)
                    let allocRes: Result[bool] = allocObjValueLocal(b, tmpSlot, gObj)
                    if !IsOk[bool](allocRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](allocRes))
                    let tmpRes: Result[bool] = lowerAssignValue(b, rhs, tmpName, tmpSlot)
                    if !IsOk[bool](tmpRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](tmpRes))
                    let copyRes: Result[bool] = emitObjCopyPtrs(b, dstPtr, gObj, uirCoreLocal(tmpSlot))
                    if !IsOk[bool](copyRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                    return Ok[bool](false)
                var rhs0: Node = rhs
                while rhs0 != nil && rhs0.kind == nkPar && kidCount(rhs0) > 0:
                    rhs0 = kid(rhs0, 0)
                if rhs0 != nil && rhs0.kind == nkCall:
                    let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, rhs0, dstPtr)
                    if !IsOk[UirCoreExpr](callRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
                    return Ok[bool](false)
                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, uirCoreTypeI64())
                if !IsOk[UirCoreExpr](srcRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                let copyRes2: Result[bool] = emitObjCopyPtrs(b, dstPtr, gObj, Value[UirCoreExpr](srcRes))
                if !IsOk[bool](copyRes2):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes2))
                return Ok[bool](false)
            if isControlExpr(rhs):
                let tmpName: str = blockBuilderNextTemp(b, "__global_assign")
                let tmpSlot: int32 = localAdd(b.env, tmpName, g.ty)
                uirCoreSetLocalType(b.func, tmpSlot, g.ty)
                let tmpRes: Result[bool] = lowerAssignValue(b, rhs, tmpName, tmpSlot)
                if !IsOk[bool](tmpRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](tmpRes))
                add(b.currentStmts, uirCoreStmtStore(uirCoreGlobalAddr(gName), uirCoreLocal(tmpSlot), g.ty))
                return Ok[bool](false)
            let valRes: Result[UirCoreExpr] = lowerExprValue(b, rhs, g.ty)
            if ! IsOk[UirCoreExpr](valRes):
                return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](valRes))
            add(b.currentStmts, uirCoreStmtStore(uirCoreGlobalAddr(gName), Value[UirCoreExpr](valRes), g.ty))
            return Ok[bool](false)

        # For object-value locals, allow a user-defined `=` overload (compile-time resolved).
        let olIdxAssign: int32 = funcFindObjLocal(b.func, slot2)
        if olIdxAssign >= 0 && b.module != nil && b.func != nil:
            let frefAssign: UirCoreFunc = b.func
            let dstOlAssign: UirCoreObjLocal = frefAssign.objLocals[olIdxAssign]
            if dstOlAssign.frameOff >= 0:
                let aliasTyAssign: UirCoreType = uirCoreTryGetTypeAlias(b.module, dstOlAssign.objTypeName)
                if aliasTyAssign.kind == mtVoid:
                    var argNodesAssign: Node[2]
                    add(argNodesAssign, lhs)
                    add(argNodesAssign, rhs)
                    var candEq: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, "=", argNodesAssign, "")
                    if candEq != nil:
                        # Assignment overloads must not require an implicit `__ret` and must take `var` as the first arg.
                        if candEq.params.len > 0:
                            let pFirst: UirCoreParam = candEq.params[0]
                            if (pFirst.name == "__ret"):
                                candEq = nil
                        if candEq != nil && candEq.params.len > 0:
                            let p0: UirCoreParam = candEq.params[0]
                            if !uirCoreStrStartsWith(p0.typeKey, "var_") && !(p0.typeKey == "var"):
                                candEq = nil
                        if candEq != nil && candEq.retType.kind == mtVoid:
                            var argsEq: UirCoreExpr[]
                            for aiEq in 0..<argNodesAssign.len:
                                let argNode: Node = argNodesAssign[aiEq]
                                var wantVarAddr: bool = false
                                if candEq != nil && aiEq >= 0 && aiEq < candEq.params.len:
                                    let pEq: UirCoreParam = candEq.params[aiEq]
                                    if uirCoreStrStartsWith(pEq.typeKey, "var_"):
                                        let baseKey: str = str(ptr_add(void*(pEq.typeKey), 4))
                                        if baseKey == nil || len(baseKey) == 0:
                                            wantVarAddr = true
                                        elif uirCoreHasObjType(b.module, baseKey):
                                            # Ref-like types have an object layout but are represented as pointer aliases.
                                            # `var RefType` expects a pointer-to-pointer (i.e. take the slot address).
                                            let aliasTy0: UirCoreType = uirCoreTryGetTypeAlias(b.module, baseKey)
                                            wantVarAddr = aliasTy0.kind != mtVoid
                                        elif uirCoreStrStartsWith(baseKey, "seq_") && uirCoreHasObjType(b.module, "seq"):
                                            wantVarAddr = false
                                        else:
                                            wantVarAddr = true
                                    elif (pEq.typeKey == "var"):
                                        wantVarAddr = true
                                if wantVarAddr:
                                    let addrRes: Result[UirCoreExpr] = lowerVarArgAddr(b, argNode)
                                    if !IsOk[UirCoreExpr](addrRes):
                                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](addrRes))
                                    add(argsEq, Value[UirCoreExpr](addrRes))
                                else:
                                    # Call argument lowering should not depend on the call's return type.
                                    let argRes: Result[UirCoreExpr] = lowerExprValue(b, argNode, uirCoreTypeI64())
                                    if !IsOk[UirCoreExpr](argRes):
                                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](argRes))
                                    add(argsEq, Value[UirCoreExpr](argRes))
                            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall(candEq.name, argsEq)))
                            return Ok[bool](false)
        let rhsAssignRes: Result[bool] = lowerAssignValue(b, rhs, name2, slot2)
        if ! IsOk[bool](rhsAssignRes):
            return ErrInfo[bool](ErrorInfoOf[bool](rhsAssignRes))
        return Ok[bool](false)
    of nkReturn:
        let fref2: UirCoreFunc = b.func
        let retType2: UirCoreType = fref2.retType
        var exprNode: Node = nil
        if kidCount(stmt) > 0:
            exprNode = kid(stmt, 0)
        if retType2.kind == mtVoid:
            if exprNode != nil && exprNode.kind != nkEmpty:
                return Err[bool]("uirCore_builder: void return cannot have a value")
            let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
            if ! IsOk[bool](deferRes):
                return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
            blockBuilderFinish(b, uirCoreTermRet(nil))
            return Ok[bool](true)
        let retSlot3: int32 = localIndex(b.env, "__ret")
        if retSlot3 >= 0:
            let objRetName: str = funcObjTypeName(fref2, retSlot3)
            if len(objRetName) > 0:
                if exprNode == nil || exprNode.kind == nkEmpty:
                    return Err[bool]("uirCore_builder: return expects value")
                var expr0: Node = exprNode
                while expr0 != nil && expr0.kind == nkPar && kidCount(expr0) > 0:
                    expr0 = kid(expr0, 0)
                if expr0 != nil && expr0.kind == nkSeqLit && uirCoreStrStartsWith(funcObjTypeKey(fref2, retSlot3), "seq_"):
                    let key: str = funcObjTypeKey(fref2, retSlot3)
                    let litRes: Result[bool] = emitSeqLitToPtr(b, uirCoreLocal(retSlot3), key, expr0)
                    if ! IsOk[bool](litRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](litRes))
                    let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
                    if ! IsOk[bool](deferRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
                    blockBuilderFinish(b, uirCoreTermRet(uirCoreLocal(retSlot3)))
                    return Ok[bool](true)
                if expr0 != nil && expr0.kind == nkComprehension && uirCoreStrStartsWith(funcObjTypeKey(fref2, retSlot3), "seq_"):
                    let key2: str = funcObjTypeKey(fref2, retSlot3)
                    let compRes: Result[bool] = emitSeqComprehensionToPtr(b, "__ret", uirCoreLocal(retSlot3), key2, expr0)
                    if !IsOk[bool](compRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](compRes))
                    let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
                    if ! IsOk[bool](deferRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
                    blockBuilderFinish(b, uirCoreTermRet(uirCoreLocal(retSlot3)))
                    return Ok[bool](true)
                if expr0 != nil && expr0.kind == nkCall:
                    let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, expr0, uirCoreLocal(retSlot3))
                    if ! IsOk[UirCoreExpr](callRes):
                        return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](callRes))
                    let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
                    if ! IsOk[bool](deferRes):
                        return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
                    blockBuilderFinish(b, uirCoreTermRet(Value[UirCoreExpr](callRes)))
                    return Ok[bool](true)
                if expr0 != nil && (expr0.kind == nkIdent || expr0.kind == nkSymbol):
                    let srcName: str = plainName(expr0)
                    let srcSlot: int32 = localIndex(b.env, srcName)
                    if srcSlot >= 0:
                        let copyRes: Result[bool] = emitObjCopy(b, retSlot3, objRetName, srcSlot)
                        if ! IsOk[bool](copyRes):
                            return ErrInfo[bool](ErrorInfoOf[bool](copyRes))
                        let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
                        if ! IsOk[bool](deferRes):
                            return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
                        blockBuilderFinish(b, uirCoreTermRet(uirCoreLocal(retSlot3)))
                        return Ok[bool](true)
                let srcRes: Result[UirCoreExpr] = lowerExprValue(b, expr0, uirCoreTypeI64())
                if ! IsOk[UirCoreExpr](srcRes):
                    return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](srcRes))
                let tmpName: str = blockBuilderNextTemp(b, "__ret_src")
                let tmpSlot: int32 = localAdd(b.env, tmpName, uirCoreTypeI64())
                uirCoreSetLocalType(fref2, tmpSlot, uirCoreTypeI64())
                add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, Value[UirCoreExpr](srcRes)))
                let copyRes2: Result[bool] = emitObjCopy(b, retSlot3, objRetName, tmpSlot)
                if ! IsOk[bool](copyRes2):
                    return ErrInfo[bool](ErrorInfoOf[bool](copyRes2))
                let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
                if ! IsOk[bool](deferRes):
                    return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
                blockBuilderFinish(b, uirCoreTermRet(uirCoreLocal(retSlot3)))
                return Ok[bool](true)
        if exprNode == nil || exprNode.kind == nkEmpty:
            return Err[bool]("uirCore_builder: return expects value")
        if isControlExpr(exprNode):
            let retName: str = blockBuilderNextTemp(b, "__ret")
            let slot: int32 = localAdd(b.env, retName, retType2)
            uirCoreSetLocalType(fref2, slot, retType2)
            let assignRes: Result[bool] = lowerAssignValue(b, exprNode, retName, slot)
            if ! IsOk[bool](assignRes):
                return ErrInfo[bool](ErrorInfoOf[bool](assignRes))
            let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
            if ! IsOk[bool](deferRes):
                return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
            blockBuilderFinish(b, uirCoreTermRet(uirCoreLocal(slot)))
            return Ok[bool](true)
        let retRes: Result[UirCoreExpr] = lowerExprValue(b, exprNode, retType2)
        if ! IsOk[UirCoreExpr](retRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](retRes))
        let deferRes: Result[bool] = blockBuilderEmitDefers(b, 0)
        if ! IsOk[bool](deferRes):
            return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
        blockBuilderFinish(b, uirCoreTermRet(Value[UirCoreExpr](retRes)))
        return Ok[bool](true)
    of nkIf:
        let ifRes: Result[bool] = lowerIfStmt(b, stmt)
        if ! IsOk[bool](ifRes):
            return ErrInfo[bool](ErrorInfoOf[bool](ifRes))
        return ifRes
    of nkWhile:
        let whileRes: Result[bool] = lowerWhileStmt(b, stmt)
        if ! IsOk[bool](whileRes):
            return ErrInfo[bool](ErrorInfoOf[bool](whileRes))
        return whileRes
    of nkFor:
        let forRes: Result[bool] = lowerForStmt(b, stmt)
        if ! IsOk[bool](forRes):
            return ErrInfo[bool](ErrorInfoOf[bool](forRes))
        return forRes
    of nkCase:
        let caseRes: Result[bool] = lowerCaseStmt(b, stmt)
        if !IsOk[bool](caseRes):
            return ErrInfo[bool](ErrorInfoOf[bool](caseRes))
        return caseRes
    of nkBreak:
        let ctx: LoopContext = blockBuilderPeekLoop(b)
        if ctx == nil:
            return Err[bool]("uirCore_builder: break outside loop")
        let deferRes: Result[bool] = blockBuilderEmitDefers(b, ctx.deferDepth)
        if ! IsOk[bool](deferRes):
            return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
        blockBuilderFinish(b, uirCoreTermBr(ctx.breakLabel))
        return Ok[bool](true)
    of nkContinue:
        let ctx2: LoopContext = blockBuilderPeekLoop(b)
        if ctx2 == nil:
            return Err[bool]("uirCore_builder: continue outside loop")
        let deferRes: Result[bool] = blockBuilderEmitDefers(b, ctx2.deferDepth)
        if ! IsOk[bool](deferRes):
            return ErrInfo[bool](ErrorInfoOf[bool](deferRes))
        blockBuilderFinish(b, uirCoreTermBr(ctx2.continueLabel))
        return Ok[bool](true)
    of nkDefer:
        let frame: DeferFrame = blockBuilderPeekDefer(b)
        if frame == nil:
            return Err[bool]("uirCore_builder: defer outside stmt list")
        if kidCount(stmt) < 1:
            return Err[bool]("uirCore_builder: invalid defer")
        let body: Node = kid(stmt, 0)
        if body == nil || body.kind != nkStmtList:
            return Err[bool]("uirCore_builder: defer expects stmt list body")
        add(frame.bodies, body)
        return Ok[bool](false)
    of nkBlock:
        if kidCount(stmt) < 2:
            return Err[bool]("uirCore_builder: invalid block")
        let body: Node = kid(stmt, 1)
        let blockRes: Result[bool] = lowerStmtList(b, body)
        if ! IsOk[bool](blockRes):
            return ErrInfo[bool](ErrorInfoOf[bool](blockRes))
        return blockRes
    else:
        # Expression statements discard the value; lower as pointer-sized.
        let exprRes2: Result[UirCoreExpr] = lowerExprValue(b, stmt, uirCoreTypeI64())
        if ! IsOk[UirCoreExpr](exprRes2):
            return ErrInfo[bool](ErrorInfoOf[UirCoreExpr](exprRes2))
        add(b.currentStmts, uirCoreStmtExpr(Value[UirCoreExpr](exprRes2)))
        return Ok[bool](false)

fn lowerStmtList(b: BlockBuilder, listNode: Node): Result[bool] =
    if listNode == nil || listNode.kind != nkStmtList:
        return Err[bool]("uirCore_builder: expected stmt list")
    if b != nil && b.env != nil:
        localEnvPushScope(b.env)
    blockBuilderPushDefer(b)
    for i in 0..<kidCount(listNode):
        let stmt: Node = kid(listNode, i)
        let termRes: Result[bool] = lowerStmt(b, stmt)
        if ! IsOk[bool](termRes):
            blockBuilderPopDefer(b)
            if b != nil && b.env != nil:
                localEnvPopScope(b.env)
            return ErrInfo[bool](ErrorInfoOf[bool](termRes))
        let terminated: bool = Value[bool](termRes)
        if terminated:
            # It's legal (but unreachable) to have trailing statements after a terminator.
            # Stop lowering at the first terminator.
            blockBuilderPopDefer(b)
            if b != nil && b.env != nil:
                localEnvPopScope(b.env)
            return Ok[bool](true)
    let frame: DeferFrame = blockBuilderPopDefer(b)
    if frame != nil && frame.bodies.len > 0:
        var frames: DeferFrame[1]
        add(frames, frame)
        let emitRes: Result[bool] = emitDeferFrames(b, frames)
        if ! IsOk[bool](emitRes):
            if b != nil && b.env != nil:
                localEnvPopScope(b.env)
            return ErrInfo[bool](ErrorInfoOf[bool](emitRes))
    if b != nil && b.env != nil:
        localEnvPopScope(b.env)
    return Ok[bool](false)

fn uirCoreParseImportcAnnotation(ann: Node, hasImportc: bool*, importcLinkName: str*): bool =
    if ann == nil || ann.kind != nkAnnotation || kidCount(ann) == 0:
        return false
    let annName: str = backendStripSpaces(plainName(kid(ann, 0)))
    if annName != "importc":
        return false
    if kidCount(ann) < 2:
        return false
    let arg0: Node = kid(ann, 1)
    if arg0 == nil || arg0.kind != nkStrLit:
        return false
    if hasImportc != nil:
        *hasImportc = true
    if importcLinkName != nil:
        *importcLinkName = arg0.strVal
    return true

fn uirCoreParseImportcLinkName(funcNode: Node, hasImportc: bool*, importcLinkName: str*) =
    if hasImportc != nil:
        *hasImportc = false
    if importcLinkName != nil:
        *importcLinkName = ""
    if funcNode == nil:
        return
    for ki in 0..<kidCount(funcNode):
        let kidNode: Node = kid(funcNode, ki)
        if kidNode != nil:
            if kidNode.kind == nkAnnotation:
                if uirCoreParseImportcAnnotation(kidNode, hasImportc, importcLinkName):
                    return
            elif kidNode.kind == nkPragma:
                for pi in 0..<kidCount(kidNode):
                    let ann2: Node = kid(kidNode, pi)
                    if uirCoreParseImportcAnnotation(ann2, hasImportc, importcLinkName):
                        return

fn uirCoreStage1AddDiag(diags: Diagnostic[]*, n: Node, msg: str) =
    if diags == nil:
        return
    var filePath: str = ""
    var line: int32 = 1
    var col: int32 = 1
    if n != nil:
        if n.strVal != nil && len(n.strVal) > 0:
            filePath = n.strVal
        line = n.pos.line
        col = n.pos.col
    addDiag(diags, svError, filePath, line, col, msg)

fn uirCoreTupleTypeCoreNode(typeNode0: Node): Node =
    var typeNode: Node = typeNode0
    while typeNode != nil && typeNode.kind == nkPar && kidCount(typeNode) > 0:
        typeNode = kid(typeNode, 0)
    if typeNode != nil && typeNode.kind == nkVarTy && kidCount(typeNode) > 0:
        typeNode = kid(typeNode, 0)
    return typeNode

fn uirCoreTupleTypeElemCount(typeNode0: Node): int32 =
    let typeNode: Node = uirCoreTupleTypeCoreNode(typeNode0)
    if typeNode == nil || typeNode.kind != nkTupleTy:
        return 0
    return kidCount(typeNode)

fn uirCoreTupleTypeElemType(typeNode0: Node, idx: int32): Node =
    let typeNode: Node = uirCoreTupleTypeCoreNode(typeNode0)
    if typeNode == nil || typeNode.kind != nkTupleTy:
        return nil
    if idx < 0 || idx >= kidCount(typeNode):
        return nil
    let elem: Node = kid(typeNode, idx)
    if elem == nil:
        return nil
    if elem.kind == nkIdentDefs:
        if kidCount(elem) < 2:
            return nil
        return kid(elem, 1)
    return elem

fn uirCoreFfiOutPtrFindOrderByPos(outPhysPos: int32[], pos: int32): int32 =
    for i in 0..<outPhysPos.len:
        if outPhysPos[i] == pos:
            return i
    return -1

fn uirCoreParseFfiOutPtrArgIndex(argNode: Node, outIdx: int32*): bool =
    if outIdx != nil:
        *outIdx = -1
    if argNode == nil:
        return false
    var raw: str = backendStripSpaces(plainName(argNode))
    if (raw == nil || len(raw) == 0) && argNode.kind == nkStrLit:
        raw = backendStripSpaces(argNode.strVal)
    if raw == nil || len(raw) < 4:
        return false
    if !strHasPrefix(raw, "arg"):
        return false
    var value: int32 = 0
    for i in 3..<len(raw):
        let ch: char = raw[i]
        if ch < '0' || ch > '9':
            return false
        value = value * 10 + (int32(ch) - int32('0'))
    if outIdx != nil:
        *outIdx = value
    return true

fn uirCoreClonePragmasFiltered(pragmas: Node, dropImportc: bool, dropFfiOutPtrs: bool): Node =
    if pragmas == nil || pragmas.kind != nkPragma:
        return emptyNode(zeroPos())
    var outPragmas: Node = newNode(nkPragma, pragmas.pos)
    for i in 0..<kidCount(pragmas):
        let ann: Node = kid(pragmas, i)
        if ann != nil && ann.kind == nkAnnotation && kidCount(ann) > 0:
            let annName: str = backendStripSpaces(plainName(kid(ann, 0)))
            if dropImportc && annName == "importc":
                continue
            if dropFfiOutPtrs && annName == "ffi_out_ptrs":
                continue
        addSon(outPragmas, cloneTree(ann))
    if kidCount(outPragmas) == 0:
        return emptyNode(pragmas.pos)
    return outPragmas

fn uirCoreMakeParamDef(name: str, typeNode: Node, pos: SourcePos): Node =
    var defs: Node = newNode(nkIdentDefs, pos)
    addSon(defs, newIdent(name, pos))
    if typeNode != nil:
        addSon(defs, cloneTree(typeNode))
    else:
        addSon(defs, emptyNode(pos))
    addSon(defs, emptyNode(pos))
    return defs

fn uirCoreRewriteFfiOutPtrFunc(n: Node, synthId: int32*, diags: Diagnostic[]*, outNodes: Node[]*): bool =
    if outNodes == nil:
        return false
    if n == nil || (n.kind != nkFnDecl && n.kind != nkIteratorDecl):
        add(outNodes, n)
        return false

    var pragmas: Node = nil
    if kidCount(n) > 5:
        pragmas = kid(n, 5)
    if pragmas == nil || pragmas.kind != nkPragma:
        add(outNodes, n)
        return false

    var importcAnn: Node = nil
    var outPtrAnn: Node = nil
    for i in 0..<kidCount(pragmas):
        let ann: Node = kid(pragmas, i)
        if ann == nil || ann.kind != nkAnnotation || kidCount(ann) == 0:
            continue
        let annName: str = backendStripSpaces(plainName(kid(ann, 0)))
        var hasImportc: bool = false
        var importcLinkName: str = ""
        if uirCoreParseImportcAnnotation(ann, &hasImportc, &importcLinkName) && hasImportc:
            importcAnn = ann
        if annName == "ffi_out_ptrs":
            outPtrAnn = ann

    if importcAnn == nil || outPtrAnn == nil:
        add(outNodes, n)
        return false

    if n.kind != nkFnDecl:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs only supports fn declarations")
        add(outNodes, n)
        return false

    let bodyNode: Node = kid(n, 3)
    if bodyNode != nil && bodyNode.kind != nkEmpty:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs importc declaration must not define a body")
        add(outNodes, n)
        return false

    let genericsNode: Node = kid(n, 4)
    if genericsNode != nil && genericsNode.kind != nkEmpty && kidCount(genericsNode) > 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs does not support generic importc declarations")
        add(outNodes, n)
        return false

    var outPhysPos: int32[]
    for ai in 1..<kidCount(outPtrAnn):
        let argNode: Node = kid(outPtrAnn, ai)
        var argIdx: int32 = -1
        if !uirCoreParseFfiOutPtrArgIndex(argNode, &argIdx):
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs expects arguments like arg0,arg1,...")
            add(outNodes, n)
            return false
        if argIdx < 0:
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs argument index must be >= 0")
            add(outNodes, n)
            return false
        if uirCoreFfiOutPtrFindOrderByPos(outPhysPos, argIdx) >= 0:
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs has duplicate physical argument index: arg" + intToStr(argIdx))
            add(outNodes, n)
            return false
        add(outPhysPos, argIdx)
    if outPhysPos.len == 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires at least one out argument marker")
        add(outNodes, n)
        return false

    let retNode: Node = kid(n, 2)
    let tupleElemCount: int32 = uirCoreTupleTypeElemCount(retNode)
    if tupleElemCount <= 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires tuple return type")
        add(outNodes, n)
        return false

    var hasStatus: bool = false
    if tupleElemCount == outPhysPos.len:
        hasStatus = false
    elif tupleElemCount == outPhysPos.len + 1:
        hasStatus = true
    else:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs tuple arity mismatch: expected tuple size " +
                             intToStr(outPhysPos.len) + " or " + intToStr(outPhysPos.len + 1))
        add(outNodes, n)
        return false

    var userParamNames: str[]
    var userParamTypes: Node[]
    let paramsNode: Node = kid(n, 1)
    if paramsNode != nil && paramsNode.kind == nkFormalParams:
        for pi in 0..<kidCount(paramsNode):
            let defs: Node = kid(paramsNode, pi)
            if defs == nil || defs.kind != nkIdentDefs:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires canonical parameter declarations")
                add(outNodes, n)
                return false
            let nameCount: int32 = identDefsNameCount(defs)
            if nameCount != 1:
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires one identifier per parameter")
                add(outNodes, n)
                return false
            let nameNode: Node = kid(defs, 0)
            if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires identifier parameters")
                add(outNodes, n)
                return false
            let typeNode: Node = identDefsType(defs)
            if typeNode == nil || typeNode.kind == nkEmpty:
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires explicit parameter types")
                add(outNodes, n)
                return false
            add(userParamNames, backendStripSpaces(plainName(nameNode)))
            add(userParamTypes, typeNode)

    let physCount: int32 = userParamNames.len + outPhysPos.len
    var outByPhys: int32[]
    outByPhys.len = physCount
    for i in 0..<outByPhys.len:
        outByPhys[i] = -1
    for oi in 0..<outPhysPos.len:
        let pos: int32 = outPhysPos[oi]
        if pos < 0 || pos >= physCount:
            uirCoreStage1AddDiag(diags, outPtrAnn, "ffi_out_ptrs argument index out of range: arg" + intToStr(pos))
            add(outNodes, n)
            return false
        if outByPhys[pos] >= 0:
            uirCoreStage1AddDiag(diags, outPtrAnn, "ffi_out_ptrs duplicate physical argument index: arg" + intToStr(pos))
            add(outNodes, n)
            return false
        outByPhys[pos] = oi
    var nonOutCount: int32 = 0
    for pos in 0..<physCount:
        if outByPhys[pos] < 0:
            nonOutCount = nonOutCount + 1
    if nonOutCount != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs physical argument mapping does not match function parameters")
        add(outNodes, n)
        return false

    var outTupleTypes: Node[]
    for oi in 0..<outPhysPos.len:
        let elemIdx: int32 = hasStatus ? (oi + 1) : oi
        let elemType: Node = uirCoreTupleTypeElemType(retNode, elemIdx)
        if elemType == nil || elemType.kind == nkEmpty:
            uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs tuple element type missing at index " + intToStr(elemIdx))
            add(outNodes, n)
            return false
        add(outTupleTypes, elemType)
    var statusType: Node = nil
    if hasStatus:
        statusType = uirCoreTupleTypeElemType(retNode, 0)
        if statusType == nil || statusType.kind == nkEmpty:
            uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs status return type is missing")
            add(outNodes, n)
            return false

    let nameNode: Node = kid(n, 0)
    let baseName: str = backendStripSpaces(plainName(nameNode))
    var sid: int32 = 0
    if synthId != nil:
        sid = *synthId
        *synthId = sid + 1
    let rawName: str = "__cheng_ffi_outptr_raw_" + intToStr(sid) + "_" + baseName

    var rawParams: Node = newNode(nkFormalParams, n.pos)
    var userCursor: int32 = 0
    for pos in 0..<physCount:
        let outOrder: int32 = outByPhys[pos]
        if outOrder >= 0:
            let outTy: Node = outTupleTypes[outOrder]
            var varTy: Node = newNode(nkVarTy, outTy.pos)
            addSon(varTy, cloneTree(outTy))
            let outName: str = "__ffi_out_" + intToStr(outOrder)
            addSon(rawParams, uirCoreMakeParamDef(outName, varTy, n.pos))
        else:
            if userCursor < 0 || userCursor >= userParamNames.len:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs parameter mapping overflow")
                add(outNodes, n)
                return false
            addSon(rawParams, uirCoreMakeParamDef(userParamNames[userCursor], userParamTypes[userCursor], n.pos))
            userCursor = userCursor + 1
    if userCursor != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs parameter mapping underflow")
        add(outNodes, n)
        return false

    var rawRet: Node = emptyNode(n.pos)
    if hasStatus:
        rawRet = cloneTree(statusType)
    let rawPragmas: Node = uirCoreClonePragmasFiltered(pragmas, false, true)
    let wrapPragmas: Node = uirCoreClonePragmasFiltered(pragmas, true, true)

    var rawFn: Node = newNode(nkFnDecl, n.pos)
    addSon(rawFn, newIdent(rawName, n.pos))
    addSon(rawFn, rawParams)
    addSon(rawFn, rawRet)
    addSon(rawFn, emptyNode(n.pos))
    if genericsNode != nil:
        addSon(rawFn, cloneTree(genericsNode))
    else:
        addSon(rawFn, emptyNode(n.pos))
    addSon(rawFn, rawPragmas)
    if n.strVal != nil && len(n.strVal) > 0:
        nodeSetStrVal(rawFn, n.strVal)

    var body: Node = newNode(nkStmtList, n.pos)
    for oi in 0..<outTupleTypes.len:
        let outName: str = "__ffi_out_" + intToStr(oi)
        var outDecl: Node = newNode(nkVar, n.pos)
        addSon(outDecl, newIdent(outName, n.pos))
        addSon(outDecl, cloneTree(outTupleTypes[oi]))
        addSon(outDecl, emptyNode(n.pos))
        addSon(outDecl, emptyNode(n.pos))
        addSon(body, outDecl)

    var callNode: Node = newNode(nkCall, n.pos)
    addSon(callNode, newIdent(rawName, n.pos))
    var userArgCursor: int32 = 0
    for pos in 0..<physCount:
        let outOrder: int32 = outByPhys[pos]
        if outOrder >= 0:
            addSon(callNode, newIdent("__ffi_out_" + intToStr(outOrder), n.pos))
        else:
            if userArgCursor < 0 || userArgCursor >= userParamNames.len:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs wrapper argument mapping overflow")
                add(outNodes, n)
                return false
            addSon(callNode, newIdent(userParamNames[userArgCursor], n.pos))
            userArgCursor = userArgCursor + 1
    if userArgCursor != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs wrapper argument mapping underflow")
        add(outNodes, n)
        return false

    var statusName: str = ""
    if hasStatus:
        statusName = "__ffi_status"
        var statusDecl: Node = newNode(nkLet, n.pos)
        addSon(statusDecl, newIdent(statusName, n.pos))
        addSon(statusDecl, cloneTree(statusType))
        addSon(statusDecl, callNode)
        addSon(statusDecl, emptyNode(n.pos))
        addSon(body, statusDecl)
    else:
        addSon(body, callNode)

    var tupleRet: Node = newNode(nkTupleLit, n.pos)
    if hasStatus:
        addSon(tupleRet, newIdent(statusName, n.pos))
    for oi in 0..<outTupleTypes.len:
        addSon(tupleRet, newIdent("__ffi_out_" + intToStr(oi), n.pos))
    var retStmt: Node = newNode(nkReturn, n.pos)
    addSon(retStmt, tupleRet)
    addSon(body, retStmt)

    var wrapperFn: Node = newNode(nkFnDecl, n.pos)
    addSon(wrapperFn, cloneTree(nameNode))
    addSon(wrapperFn, cloneTree(paramsNode))
    addSon(wrapperFn, cloneTree(retNode))
    addSon(wrapperFn, body)
    if genericsNode != nil:
        addSon(wrapperFn, cloneTree(genericsNode))
    else:
        addSon(wrapperFn, emptyNode(n.pos))
    addSon(wrapperFn, wrapPragmas)
    if n.strVal != nil && len(n.strVal) > 0:
        nodeSetStrVal(wrapperFn, n.strVal)

    add(outNodes, rawFn)
    add(outNodes, wrapperFn)
    return true

fn uirCoreLowerFfiOutPtrAnnotations(root: Node, diags: Diagnostic[]*): bool =
    if root == nil:
        return false
    if root.kind != nkModule && root.kind != nkStmtList:
        return false
    var loweredKids: Node[]
    loweredKids.cap = kidCount(root) + 8
    var changed: bool = false
    var synthId: int32 = 0
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if uirCoreRewriteFfiOutPtrFunc(n, &synthId, diags, &loweredKids):
            changed = true
    if changed:
        root.kids = loweredKids
    return changed

fn uirCoreBuildFuncHeader(module: UirCoreModule, funcNode: Node, originFile: str = "",
                      overloaded: hashsets.HashSetStr* = nil): Result[UirCoreFunc] =
    if funcNode == nil || (funcNode.kind != nkFnDecl && funcNode.kind != nkIteratorDecl):
        return Err[UirCoreFunc]("uirCore_builder: invalid func node")
    let nameNode: Node = kid(funcNode, 0)
    if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
        return Err[UirCoreFunc]("uirCore_builder: function name expected")
    let funcName: str = backendStripSpaces(plainName(nameNode))
    var symName: str = funcName
    var baseSym: str = backendSanitizeLinkName(symName)
    let paramsNode: Node = kid(funcNode, 1)
    let retNode: Node = kid(funcNode, 2)
    var retType: UirCoreType = uirCoreTypeVoid()
    if retNode != nil && retNode.kind != nkEmpty:
        retType = uirCoreTypeFromNodeWithModule(module, retNode)
    var retTypeKey: str = ""
    if retNode != nil && retNode.kind != nkEmpty:
        retTypeKey = uirCoreTypeKeyFromNodeLoose(retNode)
    var objRetTypeName: str = ""
    if retNode != nil && retNode.kind != nkEmpty:
        let nm: str = typeNodeObjTypeName(module, retNode)
        if len(nm) > 0 && typeNodeIsObjValue(module, retNode):
            objRetTypeName = nm
            # Object returns use an implicit `__ret` pointer.
            retType = uirCoreTypeI64()

    var body: Node = kid(funcNode, 3)
    if body != nil && body.kind == nkBlock && kidCount(body) > 1:
        let inner: Node = kid(body, 1)
        if inner != nil && inner.kind == nkStmtList:
            body = inner
    var hasImportc: bool = false
    var importcLinkName: str = ""
    uirCoreParseImportcLinkName(funcNode, &hasImportc, &importcLinkName)

    if !hasImportc:
        symName = uirCoreMaybeMangleDupFnBase(funcName, originFile)
        baseSym = backendSanitizeLinkName(symName)

    var isExtern: bool = false
    if body == nil || body.kind == nkEmpty:
        if (funcName == "main"):
            return Err[UirCoreFunc]("uirCore_builder: main must have a body")
        if !hasImportc:
            # Forward decl (no body, no importc). Ignore; a later definition will provide the body.
            return Ok[UirCoreFunc](nil)
        if len(objRetTypeName) > 0:
            return Err[UirCoreFunc]("uirCore_builder: extern object return is not supported: " + funcName +
                                " -> " + objRetTypeName + " (file: " + originFile + ")")
        isExtern = true

    let f: UirCoreFunc = uirCoreNewFunc(symName, retType)
    f.retTypeKey = uirCoreOwnStr(retTypeKey)
    f.originFile = uirCoreOwnStr(originFile)
    f.isExtern = isExtern

    var sigParamKeys: str[]
    var paramBase: int32 = 0
    if len(objRetTypeName) > 0:
        let retSlot: int32 = 0
        funcSetObjLocal(f, retSlot, objRetTypeName, -1)
        if retNode != nil && retNode.kind != nkEmpty:
            let kret: str = typeKey(retNode)
            if len(kret) > 0:
                funcSetObjTypeKey(f, retSlot, kret)
        uirCoreAddParam(f, "__ret", retSlot, uirCoreTypeI64(), "")
        paramBase = 1

    if paramsNode != nil && paramsNode.kind == nkFormalParams:
        for pi in 0..<kidCount(paramsNode):
            let defs: Node = kid(paramsNode, pi)
            if defs == nil || defs.kind != nkIdentDefs || kidCount(defs) < 2:
                return Err[UirCoreFunc]("uirCore_builder: invalid param")
            let pnameNode: Node = kid(defs, 0)
            if pnameNode == nil || (pnameNode.kind != nkIdent && pnameNode.kind != nkSymbol):
                return Err[UirCoreFunc]("uirCore_builder: param expects identifier")
            let typeNode: Node = kid(defs, 1)
            let objTypeName: str = typeNodeObjTypeName(module, typeNode)
            var ptype: UirCoreType = uirCoreTypeFromNodeWithModule(module, typeNode)
            if len(objTypeName) > 0:
                # Represent object values as pointers to storage in MIR.
                ptype = uirCoreTypeI64()
            let pname: str = plainName(pnameNode)
            let slot: int32 = paramBase + pi
            let pk2: str = typeKey(typeNode)
            add(sigParamKeys, pk2)
            if len(objTypeName) > 0:
                funcSetObjLocal(f, slot, objTypeName, -1)
                if len(pk2) > 0:
                    funcSetObjTypeKey(f, slot, pk2)
            # Default args are lowered by stage1 C-profile lowering (call-site expansion).
            uirCoreAddParam(f, pname, slot, ptype, pk2)

    if funcName != nil && !(funcName == "main") && overloaded != nil && hashsets.hashSetStrHas(*overloaded, funcName):
        f.name = uirCoreOwnStr(uirCoreMangleOverloadName(baseSym, retTypeKey, sigParamKeys))
        if !hasImportc:
            f.linkName = uirCoreOwnStr(f.name)
    else:
        f.name = uirCoreOwnStr(symName)
        if hasImportc:
            f.linkName = uirCoreOwnStr(importcLinkName)
        else:
            f.linkName = uirCoreOwnStr(baseSym)
    if hasImportc:
        f.linkName = uirCoreOwnStr(importcLinkName)
    return Ok[UirCoreFunc](f)

fn uirCoreBuildFunc(module: UirCoreModule, funcNode: Node, originFile: str = "",
                overloaded: hashsets.HashSetStr* = nil): Result[UirCoreFunc] =
    if funcNode == nil || (funcNode.kind != nkFnDecl && funcNode.kind != nkIteratorDecl):
        return Err[UirCoreFunc]("uirCore_builder: invalid func node")
    let nameNode: Node = kid(funcNode, 0)
    if nameNode == nil ||(nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
        return Err[UirCoreFunc]("uirCore_builder: function name expected")
    let funcName: str = backendStripSpaces(plainName(nameNode))
    var symName: str = funcName
    var baseSym: str = backendSanitizeLinkName(symName)
    let paramsNode: Node = kid(funcNode, 1)
    let retNode: Node = kid(funcNode, 2)
    var retType: UirCoreType = uirCoreTypeVoid()
    if retNode != nil && retNode.kind != nkEmpty:
        retType = uirCoreTypeFromNodeWithModule(module, retNode)
    var retTypeKey: str = ""
    if retNode != nil && retNode.kind != nkEmpty:
        retTypeKey = typeKey(retNode)
    var objRetTypeName: str = ""
    if retNode != nil && retNode.kind != nkEmpty:
        let nm: str = typeNodeObjTypeName(module, retNode)
        if len(nm) > 0 && len(retTypeKey) > 0:
            # Type keys may include module prefixes (e.g. `json_JsonNode`) that differ from the
            # canonical object type name (`JsonNode`). Preserve var/ref/ptr wrappers for overloads.
            var aliasKey: str = retTypeKey
            var step: int32 = 0
            while aliasKey != nil && len(aliasKey) > 0 && step < 4:
                if uirCoreStrStartsWith(aliasKey, "var_ref_"):
                    aliasKey = str(ptr_add(void*(aliasKey), 8))
                elif uirCoreStrStartsWith(aliasKey, "var_"):
                    aliasKey = str(ptr_add(void*(aliasKey), 4))
                elif uirCoreStrStartsWith(aliasKey, "ref_"):
                    aliasKey = str(ptr_add(void*(aliasKey), 4))
                elif uirCoreStrStartsWith(aliasKey, "ptr_"):
                    aliasKey = str(ptr_add(void*(aliasKey), 4))
                else:
                    break
                step = step + 1
            if aliasKey != nil && len(aliasKey) > 0 && !(aliasKey == nm):
                if !uirCoreStrStartsWith(aliasKey, "seq_") && !uirCoreStrStartsWith(aliasKey, "seq_fixed_") &&
                   !uirCoreStrStartsWith(aliasKey, "Table_") && !uirCoreStrStartsWith(aliasKey, "set_"):
                    uirCoreObjAliasPut(aliasKey, nm)
        if len(nm) > 0 && typeNodeIsObjValue(module, retNode):
            objRetTypeName = nm
            # Object returns use an implicit `__ret` pointer.
            retType = uirCoreTypeI64()
    var body: Node = kid(funcNode, 3)
    if body != nil && body.kind == nkBlock && kidCount(body) > 1:
        let inner: Node = kid(body, 1)
        if inner != nil && inner.kind == nkStmtList:
            body = inner
    var hasImportc: bool = false
    var importcLinkName: str = ""
    uirCoreParseImportcLinkName(funcNode, &hasImportc, &importcLinkName)
    if !hasImportc:
        symName = uirCoreMaybeMangleDupFnBase(funcName, originFile)
        baseSym = backendSanitizeLinkName(symName)
    if body == nil || body.kind == nkEmpty:
        if (funcName == "main"):
            return Err[UirCoreFunc]("uirCore_builder: main must have a body")
        if !hasImportc:
            # Forward decl (no body, no importc). Ignore; a later definition will provide the body.
            return Ok[UirCoreFunc](nil)
        if len(objRetTypeName) > 0:
            return Err[UirCoreFunc]("uirCore_builder: extern object return is not supported: " + funcName +
                                " -> " + objRetTypeName + " (file: " + originFile + ")")
        let envExtern: LocalEnv = localEnvNew()
        let fExtern: UirCoreFunc = uirCoreNewFunc(symName, retType)
        fExtern.retTypeKey = uirCoreOwnStr(retTypeKey)
        fExtern.originFile = uirCoreOwnStr(originFile)
        fExtern.isExtern = true
        var sigParamKeys: str[]
        if paramsNode != nil && paramsNode.kind == nkFormalParams:
            for pi in 0..<kidCount(paramsNode):
                let defs: Node = kid(paramsNode, pi)
                if defs == nil || defs.kind != nkIdentDefs || kidCount(defs) < 2:
                    return Err[UirCoreFunc]("uirCore_builder: invalid param")
                let pnameNode: Node = kid(defs, 0)
                if pnameNode == nil ||(pnameNode.kind != nkIdent && pnameNode.kind != nkSymbol):
                    return Err[UirCoreFunc]("uirCore_builder: param expects identifier")
                let ptype: UirCoreType = uirCoreTypeFromNodeWithModule(module, kid(defs, 1))
                let pname: str = plainName(pnameNode)
                let slot: int32 = localAdd(envExtern, pname, ptype)
                let pk: str = uirCoreTypeKeyFromNodeLoose(kid(defs, 1))
                add(sigParamKeys, pk)
                if len(pk) > 0:
                    localSetTypeKey(envExtern, slot, pk)
                # Default args are lowered by stage1 C-profile lowering (call-site expansion).
                uirCoreAddParam(fExtern, pname, slot, ptype, pk)
        if funcName != nil && !(funcName == "main") && overloaded != nil && hashsets.hashSetStrHas(*overloaded, funcName):
            fExtern.name = uirCoreOwnStr(uirCoreMangleOverloadName(baseSym, retTypeKey, sigParamKeys))
            if !hasImportc:
                fExtern.linkName = uirCoreOwnStr(fExtern.name)
        else:
            fExtern.name = uirCoreOwnStr(symName)
            if hasImportc:
                fExtern.linkName = uirCoreOwnStr(importcLinkName)
            else:
                fExtern.linkName = uirCoreOwnStr(baseSym)
        if hasImportc:
            fExtern.linkName = uirCoreOwnStr(importcLinkName)
        return Ok[UirCoreFunc](fExtern)
    if body != nil && body.kind != nkStmtList:
        let wrapped: Node = newNode(nkStmtList, body.pos)
        addSon(wrapped, body)
        body = wrapped
    let env: LocalEnv = localEnvNew()
    let f: UirCoreFunc = uirCoreNewFunc(symName, retType)
    f.retTypeKey = uirCoreOwnStr(retTypeKey)
    f.originFile = uirCoreOwnStr(originFile)
    let bb: BlockBuilder = blockBuilderNew(env, module, f)
    var sigParamKeys2: str[]
    var paramBase: int32 = 0
    if len(objRetTypeName) > 0:
        let retSlot: int32 = localAdd(env, "__ret", uirCoreTypeI64())
        funcSetObjLocal(f, retSlot, objRetTypeName, -1)
        if retNode != nil && retNode.kind != nkEmpty:
            let kret: str = uirCoreTypeKeyFromNodeLoose(retNode)
            if len(kret) > 0:
                funcSetObjTypeKey(f, retSlot, kret)
        uirCoreAddParam(f, "__ret", retSlot, uirCoreTypeI64(), "")
        add(bb.currentStmts, uirCoreStmtParam("__ret", retSlot, 0))
        paramBase = 1
    if paramsNode != nil && paramsNode.kind == nkFormalParams:
        for pi in 0..<kidCount(paramsNode):
            let defs: Node = kid(paramsNode, pi)
            if defs == nil || defs.kind != nkIdentDefs || kidCount(defs) < 2:
                return Err[UirCoreFunc]("uirCore_builder: invalid param")
            let pnameNode: Node = kid(defs, 0)
            if pnameNode == nil ||(pnameNode.kind != nkIdent && pnameNode.kind != nkSymbol):
                return Err[UirCoreFunc]("uirCore_builder: param expects identifier")
            let typeNode: Node = kid(defs, 1)
            let objTypeName: str = typeNodeObjTypeName(module, typeNode)
            var ptype: UirCoreType = uirCoreTypeFromNodeWithModule(module, typeNode)
            if len(objTypeName) > 0:
                # Represent object values as pointers to storage in MIR.
                ptype = uirCoreTypeI64()
            let pname: str = plainName(pnameNode)
            let slot: int32 = localAdd(env, pname, ptype)
            let pk2: str = uirCoreTypeKeyFromNodeLoose(typeNode)
            add(sigParamKeys2, pk2)
            if len(pk2) > 0:
                localSetTypeKey(env, slot, pk2)
            if len(objTypeName) > 0:
                if len(pk2) > 0:
                    var aliasKey2: str = pk2
                    var step2: int32 = 0
                    while aliasKey2 != nil && len(aliasKey2) > 0 && step2 < 4:
                        if uirCoreStrStartsWith(aliasKey2, "var_ref_"):
                            aliasKey2 = str(ptr_add(void*(aliasKey2), 8))
                        elif uirCoreStrStartsWith(aliasKey2, "var_"):
                            aliasKey2 = str(ptr_add(void*(aliasKey2), 4))
                        elif uirCoreStrStartsWith(aliasKey2, "ref_"):
                            aliasKey2 = str(ptr_add(void*(aliasKey2), 4))
                        elif uirCoreStrStartsWith(aliasKey2, "ptr_"):
                            aliasKey2 = str(ptr_add(void*(aliasKey2), 4))
                        else:
                            break
                        step2 = step2 + 1
                    if aliasKey2 != nil && len(aliasKey2) > 0 && !(aliasKey2 == objTypeName):
                        if !uirCoreStrStartsWith(aliasKey2, "seq_") && !uirCoreStrStartsWith(aliasKey2, "seq_fixed_") &&
                           !uirCoreStrStartsWith(aliasKey2, "Table_") && !uirCoreStrStartsWith(aliasKey2, "set_"):
                            uirCoreObjAliasPut(aliasKey2, objTypeName)
                funcSetObjLocal(f, slot, objTypeName, -1)
                if len(pk2) > 0:
                    funcSetObjTypeKey(f, slot, pk2)
            # Default args are lowered by stage1 C-profile lowering (call-site expansion).
            uirCoreAddParam(f, pname, slot, ptype, pk2)
            add(bb.currentStmts, uirCoreStmtParam(pname, slot, paramBase + pi))

    if funcName != nil && !(funcName == "main") && overloaded != nil && hashsets.hashSetStrHas(*overloaded, funcName):
        f.name = uirCoreOwnStr(uirCoreMangleOverloadName(baseSym, retTypeKey, sigParamKeys2))
        if !hasImportc:
            f.linkName = uirCoreOwnStr(f.name)
    else:
        f.name = uirCoreOwnStr(symName)
        if hasImportc:
            f.linkName = uirCoreOwnStr(importcLinkName)
        else:
            f.linkName = uirCoreOwnStr(baseSym)
    if hasImportc:
        f.linkName = uirCoreOwnStr(importcLinkName)

    # Multi-statement function body can implicitly return its last expression.
    if body != nil && body.kind == nkStmtList && kidCount(body) > 1 && retType.kind != mtVoid:
        let lastIdx: int32 = kidCount(body) - 1
        let lastStmt: Node = kid(body, lastIdx)
        if isImplicitReturnExpr(lastStmt):
            let body2: Node = newNode(nkStmtList, body.pos)
            for si in 0..<lastIdx:
                addSon(body2, kid(body, si))
            let retStmt2: Node = newNode(nkReturn, lastStmt.pos)
            addSon(retStmt2, lastStmt)
            addSon(body2, retStmt2)
            body = body2

    # Single-expression function body can implicitly return its value.
    if body != nil && body.kind == nkStmtList && kidCount(body) == 1 && retType.kind != mtVoid:
        let onlyStmt: Node = kid(body, 0)
        if isImplicitReturnExpr(onlyStmt):
            var retStmt: Node = newNode(nkReturn, onlyStmt.pos)
            addSon(retStmt, onlyStmt)
            let termRes: Result[bool] = lowerStmt(bb, retStmt)
            if ! IsOk[bool](termRes):
                return ErrInfo[UirCoreFunc](ErrorInfoOf[bool](termRes))
            if ! Value[bool](termRes):
                return Err[UirCoreFunc]("uirCore_builder: implicit return did not terminate")
            return Ok[UirCoreFunc](f)

    if (getEnv "BACKEND_DEBUG_SCOPE" == "1") && (funcName == "verifyLockAgainstRegistry"):
        let bp: SourcePos = body.pos
        echo("[backend] debugFuncBody: fn=" + funcName + " bodyKind=nk#" + intToStr(int32(body.kind)) +
             " kids=" + intToStr(kidCount(body)) + " @" + intToStr(bp.line) + ":" + intToStr(bp.col))
        for di2 in 0..<kidCount(body):
            let st2: Node = kid(body, di2)
            let k2: str = (st2 != nil) ? intToStr(int32(st2.kind)) : "nil"
            let l2: str = (st2 != nil) ? intToStr(st2.pos.line) : "0"
            let c2: str = (st2 != nil) ? intToStr(st2.pos.col) : "0"
            echo("[backend] debugFuncStmt: i=" + intToStr(di2) + " kind=nk#" + k2 + " @" + l2 + ":" + c2)

    let bodyRes: Result[bool] = lowerStmtList(bb, body)
    if ! IsOk[bool](bodyRes):
        return ErrInfo[UirCoreFunc](ErrorInfoOf[bool](bodyRes))
    let terminated: bool = Value[bool](bodyRes)
    if ! terminated && retType.kind == mtVoid:
        blockBuilderFinish(bb, uirCoreTermRet(nil))
        return Ok[UirCoreFunc](f)
    if ! terminated:
        let line: str = intToStr(nameNode.pos.line)
        let col: str = intToStr(nameNode.pos.col)
        let loc: str = (originFile != nil && len(originFile) > 0) ? (" " + originFile + ":" + line + ":" + col) : ""
        return Err[UirCoreFunc]("uirCore_builder: missing return: " + funcName + loc)
    return Ok[UirCoreFunc](f)

fn uirCoreFindMain(root: Node): Node =
    if root == nil:
        return nil
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if n != nil && n.kind == nkFnDecl:
            let nameNode: Node = kid(n, 0)
            if plainName(nameNode) == "main":
                return n
    return nil

fn seqContainsStr(xs: str[], s: str): bool =
    if s == nil || xs.buffer == nil:
        return false
    for i in 0..<xs.len:
        if (xs[i] == s):
            return true
    return false

fn uirCore_buildFuncIndexCache(mod: UirCoreModule) =
    if mod == nil:
        uirCore_funcIndex_cache_module = nil
        uirCore_funcIndex_cache_ready = false
        uirCore_funcIndex_cache_len = 0
        return
    uirCore_funcIndex_cache_module = mod
    uirCore_funcIndex_cache = hashmaps.hashMapStrIntInit(mod.funcs.len * 2 + 8)
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        if f != nil && f.name != nil && len(f.name) > 0:
            hashmaps.hashMapStrIntPut(uirCore_funcIndex_cache, f.name, i)
    uirCore_funcIndex_cache_len = mod.funcs.len
    uirCore_funcIndex_cache_ready = true

fn uirCore_ensureFuncIndexCache(mod: UirCoreModule) =
    if mod == nil:
        uirCore_funcIndex_cache_module = nil
        uirCore_funcIndex_cache_ready = false
        uirCore_funcIndex_cache_len = 0
        return
    if mod.funcs.len < 32:
        return
    if uirCore_funcIndex_cache_module != mod || !uirCore_funcIndex_cache_ready:
        uirCore_buildFuncIndexCache(mod)
        return
    if uirCore_funcIndex_cache_len > mod.funcs.len:
        uirCore_buildFuncIndexCache(mod)
        return
    if uirCore_funcIndex_cache_len < mod.funcs.len:
        for i in uirCore_funcIndex_cache_len..<mod.funcs.len:
            let f: UirCoreFunc = mod.funcs[i]
            if f != nil && f.name != nil && len(f.name) > 0:
                hashmaps.hashMapStrIntPut(uirCore_funcIndex_cache, f.name, i)
        uirCore_funcIndex_cache_len = mod.funcs.len

fn moduleFuncIndex(mod: UirCoreModule, name: str): int32 =
    if mod == nil || name == nil:
        return -1
    if mod.funcs.len >= 32:
        uirCore_ensureFuncIndexCache(mod)
        if uirCore_funcIndex_cache_ready && uirCore_funcIndex_cache_module == mod:
            var found: bool = false
            let idx: int32 = uirCoreHashMapStrIntGetCompat(uirCore_funcIndex_cache, name, found)
            if !found:
                return -1
            if idx >= 0 && idx < mod.funcs.len:
                let f0: UirCoreFunc = mod.funcs[idx]
                if f0 != nil && (f0.name == name):
                    return idx
            # Cache mismatch (unexpected): fall back to linear scan.
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        if f != nil && (f.name == name):
            return i
    return -1

fn moduleHasFunc(mod: UirCoreModule, name: str): bool =
    return moduleFuncIndex(mod, name) >= 0

fn moduleFindFunc(mod: UirCoreModule, name: str): UirCoreFunc =
    let idx: int32 = moduleFuncIndex(mod, name)
    if idx >= 0 && mod != nil && idx < mod.funcs.len:
        return mod.funcs[idx]
    return nil

fn uirCoreTypeKeyIsVarargs(typeKey: str): bool =
    if typeKey == nil || len(typeKey) == 0:
        return false
    if (typeKey == "varargs"):
        return true
    return uirCoreStrStartsWith(typeKey, "varargs_")

fn moduleHasFuncByBase(mod: UirCoreModule, base0: str): bool =
    if mod == nil || base0 == nil || len(base0) == 0:
        return false
    if moduleHasFunc(mod, base0):
        return true
    let baseSym: str = backendSanitizeLinkName(base0)
    let prefix: str = baseSym + uirCoreFuncSigMarker()
    let dupPrefix: str = baseSym + "__cheng_mod_"
    let instPrefix: str = baseSym + "_"
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        if f != nil && ((f.name == base0) ||
                        uirCoreStrStartsWith(f.name, prefix) ||
                        uirCoreStrStartsWith(f.name, dupPrefix) ||
                        uirCoreStrStartsWith(f.name, instPrefix)):
            return true
    return false

fn moduleFindGlobalIndexByBaseUnique(mod: UirCoreModule, base0: str): int32 =
    if mod == nil || base0 == nil || len(base0) == 0:
        return -1
    let exactIdx: int32 = moduleGlobalIndex(mod, base0)
    if exactIdx >= 0 && exactIdx < mod.globals.len:
        return exactIdx
    let dupPrefix: str = base0 + "__cheng_mod_"
    var foundIdx: int32 = -1
    for i in 0..<mod.globals.len:
        let g: UirCoreGlobal = mod.globals[i]
        if g.name == nil || len(g.name) == 0:
            continue
        if uirCoreStrStartsWith(g.name, dupPrefix):
            if foundIdx >= 0:
                return -1
            foundIdx = i
    return foundIdx

fn uirCoreGlobalTypeKeyByBaseUnique(mod: UirCoreModule, base0: str): str =
    if base0 == nil || len(base0) == 0:
        return ""
    let idx: int32 = moduleFindGlobalIndexByBaseUnique(mod, base0)
    if idx >= 0 && idx < mod.globals.len:
        let g: UirCoreGlobal = mod.globals[idx]
        if g.name != nil && len(g.name) > 0:
            let gk1: str = uirCoreGlobalTypeKeyGet(g.name)
            if gk1 != nil && len(gk1) > 0:
                return gk1
    let gk0: str = uirCoreGlobalTypeKeyGet(base0)
    if gk0 != nil && len(gk0) > 0:
        return gk0
    return ""

fn moduleFindFuncByBaseUnique(mod: UirCoreModule, base0: str): UirCoreFunc =
    if mod == nil || base0 == nil || len(base0) == 0:
        return nil
    let exact: UirCoreFunc = moduleFindFunc(mod, base0)
    if exact != nil:
        return exact
    let baseSym: str = backendSanitizeLinkName(base0)
    let prefix: str = baseSym + uirCoreFuncSigMarker()
    let dupPrefix: str = baseSym + "__cheng_mod_"
    let instPrefix: str = baseSym + "_"
    var found: UirCoreFunc = nil
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        if f != nil && ((f.name == base0) ||
                        uirCoreStrStartsWith(f.name, prefix) ||
                        uirCoreStrStartsWith(f.name, dupPrefix) ||
                        uirCoreStrStartsWith(f.name, instPrefix)):
            if found != nil:
                return nil
            found = f
    return found

fn moduleFindFuncByBasePreferOrigin(mod: UirCoreModule, base0: str, originFile0: str): UirCoreFunc =
    if mod == nil || base0 == nil || len(base0) == 0:
        return nil
    let originFile: str = (originFile0 != nil) ? originFile0 : ""
    if originFile != nil && len(originFile) > 0:
        let direct: UirCoreFunc = moduleFindFunc(mod, base0)
        if direct != nil && direct.originFile == originFile:
            return direct
        let baseSym: str = backendSanitizeLinkName(base0)
        let prefix: str = baseSym + uirCoreFuncSigMarker()
        let dupPrefix: str = baseSym + "__cheng_mod_"
        let instPrefix: str = baseSym + "_"
        var found: UirCoreFunc = nil
        for i in 0..<mod.funcs.len:
            let f: UirCoreFunc = mod.funcs[i]
            if f == nil || f.originFile != originFile:
                continue
            if (f.name == base0) || uirCoreStrStartsWith(f.name, prefix) ||
               uirCoreStrStartsWith(f.name, dupPrefix) || uirCoreStrStartsWith(f.name, instPrefix):
                if found != nil:
                    if found.name == f.name:
                        continue
                    return nil
                found = f
        if found != nil:
            return found
    return moduleFindFuncByBaseUnique(mod, base0)

fn uirCoreInferNodeTypeKeyForOverload(b: BlockBuilder, n0: Node): str =
    if b == nil:
        return ""
    var n: Node = n0
    while n != nil && n.kind == nkPar && kidCount(n) > 0:
        n = kid(n, 0)
    if n == nil:
        return ""
    if n.typeCacheValid && n.typeCache != nil:
        return typeKey n.typeCache
    if n.kind == nkStrLit:
        return "str"
    if n.kind == nkFloatLit:
        return "float64"
    if n.kind == nkBoolLit:
        return "bool"
    if n.kind == nkCharLit:
        return "char"
    if n.kind == nkIntLit:
        # Integer literals are treated as platform-sized `int` for overload resolution.
        # The scorer allows `NI` to match sized ints when needed.
        return "NI"
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = plainName(n)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0:
            if b.func != nil && funcFindObjLocal(b.func, slot0) >= 0:
                let ok0: str = funcObjTypeKey(b.func, slot0)
                if ok0 != nil && len(ok0) > 0:
                    return ok0
            let lk0: str = localTypeKey(b.env, slot0)
            if lk0 != nil && len(lk0) > 0:
                return lk0
        if uirCoreDupGlobalNamesHas(nm) && b.func != nil:
            let f0: UirCoreFunc = b.func
            let sym0: str = uirCoreMaybeMangleDupGlobalName(nm, f0.originFile)
            let gk1: str = uirCoreGlobalTypeKeyGet(sym0)
            if gk1 != nil && len(gk1) > 0:
                return gk1
        let gk0: str = uirCoreGlobalTypeKeyByBaseUnique(b.module, nm)
        if gk0 != nil && len(gk0) > 0:
            return gk0
    if n.kind == nkCall && kidCount(n) > 0:
        let calleeNode: Node = kid(n, 0)
        if calleeNode != nil && (calleeNode.kind == nkIdent || calleeNode.kind == nkSymbol):
            var tn: str = backendStripSpaces(plainName(calleeNode))
            if (tn == "string"):
                tn = "str"
            elif (tn == "int"):
                tn = "NI"
            elif (tn == "uint"):
                tn = "NU"
            elif (tn == "i64"):
                tn = "int64"
            elif (tn == "u64"):
                tn = "uint64"
            elif (tn == "i32"):
                tn = "int32"
            elif (tn == "u32"):
                tn = "uint32"
            elif (tn == "i16"):
                tn = "int16"
            elif (tn == "u16"):
                tn = "uint16"
            elif (tn == "i8"):
                tn = "int8"
            elif (tn == "u8"):
                tn = "uint8"
            if tn == "int64" || tn == "uint64" || tn == "NI" || tn == "NU" ||
               tn == "int32" || tn == "uint32" ||
               tn == "int16" || tn == "uint16" ||
               tn == "int8" || tn == "uint8" ||
               tn == "bool" || tn == "char" || tn == "str" || tn == "cstring":
                return tn
            if tn == "ptr" || tn == "void*":
                return "ptr"
    if n.kind == nkCall && b.module != nil && kidCount(n) > 0:
        let calleeNode: Node = kid(n, 0)
        var name: str = ""
        var typeArgs: Node[]
        if calleeNode != nil && calleeNode.kind == nkBracketExpr && kidCount(calleeNode) > 0:
            let base: Node = kid(calleeNode, 0)
            name = backendStripSpaces(plainName(base))
            for ti in 1..<kidCount(calleeNode):
                let t: Node = kid(calleeNode, ti)
                if t != nil && t.kind != nkEmpty:
                    add(typeArgs, t)
        else:
            name = backendStripSpaces(plainName(calleeNode))
        var callName: str = name
        if typeArgs.len > 0:
            callName = mangleInstance(name, typeArgs)
        var argNodes: Node[]
        for ai in 1..<kidCount(n):
            var argNode: Node = kid(n, ai)
            if argNode != nil && argNode.kind == nkCallArg && kidCount(argNode) > 1:
                argNode = kid(argNode, 1)
            add(argNodes, argNode)
        let callee0: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, callName, argNodes, "")
        if callee0 != nil:
            if callee0.params.len > 0:
                let p0: UirCoreParam = callee0.params[0]
                if (p0.name == "__ret"):
                    return funcObjTypeKey(callee0, p0.slot)
            if callee0.retTypeKey != nil && len(callee0.retTypeKey) > 0:
                return callee0.retTypeKey
    if n.kind == nkInfix && kidCount(n) >= 3:
        let opNode: Node = kid(n, 0)
        let op: str = backendOpName(opNode)
        let lhsNode: Node = kid(n, 1)
        let rhsNode: Node = kid(n, 2)
        let lk: str = uirCoreInferNodeTypeKeyForOverload(b, lhsNode)
        let rk: str = uirCoreInferNodeTypeKeyForOverload(b, rhsNode)
        if op == "+":
            if (lk == "str") || (rk == "str") || lhsNode.kind == nkStrLit || rhsNode.kind == nkStrLit:
                return "str"
        if op == "==" || op == "!=" || op == "<" || op == ">" || op == "<=" || op == ">=":
            return "bool"
        if lk != nil && len(lk) > 0 && (rk == nil || len(rk) == 0):
            return lk
        if rk != nil && len(rk) > 0 && (lk == nil || len(lk) == 0):
            return rk
        if lk != nil && rk != nil && len(lk) > 0 && len(rk) > 0:
            if (lk == rk):
                return lk
            if ((lk == "int") || (lk == "NI")) &&
               ((rk == "int8") || (rk == "int16") || (rk == "int32") || (rk == "int64")):
                return rk
            if ((rk == "int") || (rk == "NI")) &&
               ((lk == "int8") || (lk == "int16") || (lk == "int32") || (lk == "int64")):
                return lk
            if ((lk == "uint") || (lk == "NU")) &&
               ((rk == "uint8") || (rk == "uint16") || (rk == "uint32") || (rk == "uint64")):
                return rk
            if ((rk == "uint") || (rk == "NU")) &&
               ((lk == "uint8") || (lk == "uint16") || (lk == "uint32") || (lk == "uint64")):
                return lk
    if n.kind == nkIdent || n.kind == nkSymbol:
        let nm: str = plainName(n)
        let slot0: int32 = localIndex(b.env, nm)
        if slot0 >= 0 && funcFindObjLocal(b.func, slot0) >= 0:
            return funcObjTypeKey(b.func, slot0)
        if slot0 >= 0:
            return localTypeKey(b.env, slot0)
        let gObj: str = uirCoreGlobalObjTypeGet(nm)
        if len(gObj) > 0:
            return gObj
    if n.kind == nkBracketExpr && kidCount(n) > 0:
        let base0: Node = kid(n, 0)
        if kidCount(n) > 1:
            var idx0: Node = kid(n, 1)
            while idx0 != nil && idx0.kind == nkPar && kidCount(idx0) > 0:
                idx0 = kid(idx0, 0)
            if idx0 != nil && idx0.kind == nkInfix && kidCount(idx0) >= 3:
                let opNode: Node = kid(idx0, 0)
                let op: str = backendOpName(opNode)
                if op == ".." || op == "..<":
                    return uirCoreInferNodeTypeKeyForOverload(b, base0)
        let baseKey0: str = uirCoreInferNodeTypeKeyForOverload(b, base0)
        if baseKey0 != nil && len(baseKey0) > 0:
            if uirCoreStrStartsWith(baseKey0, "seq_"):
                return str(ptr_add(void*(baseKey0), 4))
            if uirCoreStrStartsWith(baseKey0, "seq_fixed_"):
                return str(ptr_add(void*(baseKey0), 10))
            if uirCoreStrStartsWith(baseKey0, "Table_"):
                return str(ptr_add(void*(baseKey0), 6))
            if uirCoreStrStartsWith(baseKey0, "array_") && b.module != nil:
                for i0 in 6..<len(baseKey0):
                    if baseKey0[i0] == '_':
                        let suffix: str = str(ptr_add(void*(baseKey0), i0 + 1))
                        if suffix != nil && len(suffix) > 0:
                            if isBuiltinTypeName(suffix) || uirCoreHasObjType(b.module, suffix) ||
                               uirCoreStrStartsWith(suffix, "seq_") || uirCoreStrStartsWith(suffix, "seq_fixed_") ||
                               uirCoreStrStartsWith(suffix, "Table_"):
                                return suffix
    if n.kind == nkDotExpr && b.module != nil && b.func != nil:
        let dbgOverDot: bool = (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1")
        # Composite (inlined) object field access: `obj.field` may not exist as a single field in the
        # lowered layout (it becomes `field.subfield` entries). Try to recover the field object type
        # key for overload resolution (e.g. `bytesGet(frame.payload, i)` where `payload` is Bytes).
        if kidCount(n) == 2:
            let base0: Node = kid(n, 0)
            let field0: Node = kid(n, 1)
            if base0 != nil && (base0.kind == nkIdent || base0.kind == nkSymbol) &&
               field0 != nil && (field0.kind == nkIdent || field0.kind == nkSymbol):
                let baseName0: str = plainName(base0)
                let slot1: int32 = localIndex(b.env, baseName0)
                if dbgOverDot:
                    let lk0: str = (slot1 >= 0) ? localTypeKey(b.env, slot1) : ""
                    let fok0: str = (slot1 >= 0) ? funcObjTypeKey(b.func, slot1) : ""
                    let fon0: str = (slot1 >= 0) ? funcObjTypeName(b.func, slot1) : ""
                    echo("[backend] debugOverloadDot: base='" + baseName0 + "' slot=" + intToStr(slot1) +
                         " localKey='" + lk0 + "' funcObjKey='" + fok0 + "' funcObjName='" + fon0 + "'")
                if slot1 >= 0:
                    let parentObj: str = funcObjTypeName(b.func, slot1)
                    if len(parentObj) > 0:
                        let ot0: UirCoreObjType = uirCoreGetObjType(b.module, parentObj)
                        let fieldName0: str = backendStripSpaces(plainName(field0))
                        let prefix: str = fieldName0 + "."
                        var baseOff: int32 = -1
                        for fi0 in 0..<ot0.fields.len:
                            let f0: UirCoreObjField = ot0.fields[fi0]
                            if uirCoreStrStartsWith(f0.name, prefix):
                                if baseOff < 0 || f0.offset < baseOff:
                                    baseOff = f0.offset
                        if baseOff >= 0:
                            let objKey0: str = inferInlineObjFieldTypeName(b.module, ot0, fieldName0, baseOff)
                            if objKey0 != nil && len(objKey0) > 0:
                                if dbgOverDot:
                                    echo("[backend] debugOverloadDot: direct parentObj='" + parentObj +
                                         "' field='" + fieldName0 + "' objKey='" + objKey0 + "'")
                                return objKey0
            if field0 != nil && (field0.kind == nkIdent || field0.kind == nkSymbol):
                let fieldName1: str = backendStripSpaces(plainName(field0))
                let baseKey1: str = uirCoreInferNodeTypeKeyForOverload(b, base0)
                if baseKey1 != nil && len(baseKey1) > 0:
                    var key: str = baseKey1
                    if uirCoreStrStartsWith(key, "ref_"):
                        key = str(ptr_add(void*(key), 4))
                    elif uirCoreStrStartsWith(key, "var_ref_"):
                        key = str(ptr_add(void*(key), 8))
                    elif uirCoreStrStartsWith(key, "var_"):
                        key = str(ptr_add(void*(key), 4))
                    if uirCoreStrStartsWith(key, "ptr_"):
                        key = str(ptr_add(void*(key), 4))
                    let parentObj2: str = uirCorePtrBaseObjTypeName(b.module, key)
                    if dbgOverDot:
                        echo("[backend] debugOverloadDot: fallback field='" + fieldName1 + "' baseKey='" + baseKey1 +
                             "' stripped='" + key + "' parentObj2='" + parentObj2 + "'")
                    if parentObj2 != nil && len(parentObj2) > 0:
                        let ot1: UirCoreObjType = uirCoreGetObjType(b.module, parentObj2)
                        let prefix1: str = fieldName1 + "."
                        var baseOff1: int32 = -1
                        for fi1 in 0..<ot1.fields.len:
                            let f1: UirCoreObjField = ot1.fields[fi1]
                            if uirCoreStrStartsWith(f1.name, prefix1):
                                if baseOff1 < 0 || f1.offset < baseOff1:
                                    baseOff1 = f1.offset
                        if baseOff1 >= 0:
                            let objKey1: str = inferInlineObjFieldTypeName(b.module, ot1, fieldName1, baseOff1)
                            if objKey1 != nil && len(objKey1) > 0:
                                if dbgOverDot:
                                    echo("[backend] debugOverloadDot: fallback resolved objKey='" + objKey1 + "'")
                                return objKey1
        let dk: str = caseInferExprTypeKey(b, n)
        if dbgOverDot:
            echo("[backend] debugOverloadDot: caseInfer key='" + dk + "'")
        if dk != nil && len(dk) > 0:
            return dk
        let t: UirCoreType = inferExprTypeWithGlobals(b.env, b.module, b.func, n, uirCoreTypeI32())
        if t.kind == mtI64:
            return t.isUnsigned ? "uint64" : "int64"
        if t.kind == mtI32:
            return t.isUnsigned ? "uint32" : "int32"
        if t.kind == mtF64:
            return "float64"
        if t.kind == mtF32:
            return "float32"
    return ""

fn uirCoreInferCallRetKeyHint(callNode: Node): str =
    if callNode != nil && callNode.typeCacheValid && callNode.typeCache != nil:
        return typeKey callNode.typeCache
    return ""

fn uirCoreScoreCalleeForCall(callee: UirCoreFunc, argKeys: str[], retKeyHint: str): int32 =
    if callee == nil:
        return -1
    var paramStart: int32 = 0
    if callee.params.len > 0:
        let p0: UirCoreParam = callee.params[0]
        if (p0.name == "__ret"):
            paramStart = 1
    let argCount: int32 = argKeys.len
    var paramCount: int32 = callee.params.len - paramStart
    var hasVarargs: bool = false
    var fixedCount: int32 = paramCount
    if callee.isExtern && paramCount > 0:
        let lastP: UirCoreParam = callee.params[callee.params.len - 1]
        if uirCoreTypeKeyIsVarargs(lastP.typeKey):
            hasVarargs = true
            fixedCount = paramCount - 1
    if !hasVarargs && argCount != paramCount:
        return -1
    if hasVarargs && argCount < fixedCount:
        return -1
    var score: int32 = 0
    for i in 0..<fixedCount:
        let pk0: UirCoreParam = callee.params[paramStart + i]
        let paramKey: str = (pk0.typeKey != nil) ? pk0.typeKey : ""
        let argKey0: str = argKeys[i]
        let argKey: str = (argKey0 != nil) ? argKey0 : ""
        if paramKey == nil || len(paramKey) == 0 || argKey == nil || len(argKey) == 0:
            continue
        let paramCanon: str = uirCoreObjAliasCanon(paramKey)
        let argCanon: str = uirCoreObjAliasCanon(argKey)
        if (paramKey == argKey) || (paramCanon == argCanon):
            score = score + 4
            continue
        # Allow platform-sized int/uint aliases to match sized integer args and vice versa.
        if ((paramKey == "int") || (paramKey == "NI")) &&
           ((argKey == "int32") || (argKey == "int64") || (argKey == "int") || (argKey == "NI")):
            score = score + 3
            continue
        if ((paramKey == "uint") || (paramKey == "NU")) &&
           ((argKey == "uint32") || (argKey == "uint64") || (argKey == "uint") || (argKey == "NU")):
            score = score + 3
            continue
        if ((argKey == "int") || (argKey == "NI")) &&
           ((paramKey == "int32") || (paramKey == "int64")):
            score = score + 3
            continue
        if ((argKey == "uint") || (argKey == "NU")) &&
           ((paramKey == "uint32") || (paramKey == "uint64")):
            score = score + 3
            continue
        if (paramKey == "var"):
            score = score + 1
            continue
        if uirCoreStrStartsWith(paramKey, "var_"):
            let baseKey: str = str(ptr_add(void*(paramKey), 4))
            let baseCanon: str = uirCoreObjAliasCanon(baseKey)
            if (baseKey == argKey) || (baseCanon == argCanon):
                score = score + 3
                continue
            if uirCoreStrStartsWith(argKey, "ptr_"):
                let argPtrBase: str = str(ptr_add(void*(argKey), 4))
                let argPtrCanon: str = uirCoreObjAliasCanon(argPtrBase)
                if (baseKey == argPtrBase) || (baseCanon == argPtrCanon):
                    score = score + 3
                    continue
        if uirCoreStrStartsWith(argKey, "var_"):
            let baseKey2: str = str(ptr_add(void*(argKey), 4))
            let baseCanon2: str = uirCoreObjAliasCanon(baseKey2)
            if ((baseKey2 == paramKey) || (baseCanon2 == paramCanon)) &&
               !uirCoreStrStartsWith(paramKey, "ref_") &&
               !uirCoreStrStartsWith(paramKey, "ptr_") &&
               !uirCoreStrStartsWith(paramKey, "fn_"):
                score = score + 3
                continue
        if uirCoreStrStartsWith(paramKey, "ptr_") && uirCoreStrStartsWith(argKey, "var_"):
            let paramPtrBase: str = str(ptr_add(void*(paramKey), 4))
            let paramPtrCanon: str = uirCoreObjAliasCanon(paramPtrBase)
            let argVarBase: str = str(ptr_add(void*(argKey), 4))
            let argVarCanon: str = uirCoreObjAliasCanon(argVarBase)
            if (paramPtrBase == argVarBase) || (paramPtrCanon == argVarCanon):
                score = score + 3
                continue
        return -1
    if retKeyHint != nil && len(retKeyHint) > 0 && callee.retTypeKey != nil && len(callee.retTypeKey) > 0:
        if !(callee.retTypeKey == retKeyHint):
            return -1
        score = score + 2
    return score

fn uirCoreCommonPrefixLen(a0: str, b0: str): int32 =
    if a0 == nil || b0 == nil:
        return 0
    let a: str = a0
    let b: str = b0
    var n: int32 = len(a)
    if len(b) < n:
        n = len(b)
    for i in 0..<n:
        if a[i] != b[i]:
            return i
    return n

fn uirCoreResolveCalleeFuncBestEffort(b: BlockBuilder, baseName: str, argNodes: Node[], retKeyHint: str): UirCoreFunc =
    if b == nil || b.module == nil || baseName == nil || len(baseName) == 0:
        return nil
    let mod: UirCoreModule = b.module
    let candIdxs: int32[] = uirCoreCalleeCandidatesGet(mod, baseName)
    for ciExact in 0..<candIdxs.len:
        let idx: int32 = candIdxs[ciExact]
        if idx >= 0 && idx < mod.funcs.len:
            let cand: UirCoreFunc = mod.funcs[idx]
            if cand != nil && (cand.name == baseName):
                return cand
    var argKeys: str[argNodes.len]
    argKeys.len = 0
    for ai in 0..<argNodes.len:
        add(argKeys, uirCoreInferNodeTypeKeyForOverload(b, argNodes[ai]))
    var debugResolve: bool = (getEnv "BACKEND_DEBUG_RESOLVE" == "1")
    if debugResolve:
        let dbgName: str = getEnv "BACKEND_DEBUG_RESOLVE_NAME"
        if dbgName != nil && len(dbgName) > 0:
            debugResolve = (baseName == dbgName)
        else:
            # Default to a small noisy builtin when no name filter is provided.
            debugResolve = (baseName == "Value")
    if debugResolve:
        var dbgFn: str = ""
        var dbgFile: str = ""
        if b != nil && b.func != nil:
            let dbgFunc0: UirCoreFunc = b.func
            dbgFn = dbgFunc0.name
            dbgFile = dbgFunc0.originFile
        var dbgArgPos: str = ""
        if argNodes.len > 0 && argNodes[0] != nil:
            let an0: Node = argNodes[0]
            dbgArgPos = intToStr(an0.pos.line) + ":" + intToStr(an0.pos.col)
        echo("[backend] debugResolve: base='" + baseName + "' retHint='" + retKeyHint + "'")
        echo("[backend] debugResolve: fn='" + dbgFn + "' file='" + dbgFile + "' arg0Pos='" + dbgArgPos + "'")
        echo("[backend] debugResolve: argc=" + intToStr(argKeys.len))
        if argKeys.len > 0:
            echo("[backend] debugResolve: arg0Key='" + argKeys[0] + "'")
        if argNodes.len > 0 && argNodes[0] != nil:
            let an0: Node = argNodes[0]
            var anName: str = backendStripSpaces(plainName(an0))
            if anName == nil:
                anName = ""
            var anTypeKey: str = ""
            if an0.typeCacheValid && an0.typeCache != nil:
                anTypeKey = typeKey(an0.typeCache)
            echo("[backend] debugResolve: arg0 kind=nk#" + intToStr(int32(an0.kind)) +
                 " name='" + anName + "' typeKey='" + anTypeKey + "' kids=" + intToStr(kidCount(an0)))
            if an0.kind == nkCallArg && kidCount(an0) > 0:
                let anKid0: Node = kid(an0, 0)
                var anKid0Name: str = backendStripSpaces(plainName(anKid0))
                if anKid0Name == nil:
                    anKid0Name = ""
                var anKid0TypeKey: str = ""
                if anKid0 != nil && anKid0.typeCacheValid && anKid0.typeCache != nil:
                    anKid0TypeKey = typeKey(anKid0.typeCache)
                var anKid0Kind: int32 = -1
                if anKid0 != nil:
                    anKid0Kind = int32(anKid0.kind)
                echo("[backend] debugResolve: arg0.k0 kind=nk#" + intToStr(anKid0Kind) +
                     " name='" + anKid0Name + "' typeKey='" + anKid0TypeKey + "'")
        if argKeys.len > 1:
            echo("[backend] debugResolve: arg1Key='" + argKeys[1] + "'")
    var dbgCandCount: int32 = 0
    var dbgPrinted: int32 = 0
    let dbgMax: int32 = 30
    var best: UirCoreFunc = nil
    var bestScore: int32 = -1
    var ambiguous: bool = false
    var ties: UirCoreFunc[4]
    for ci in 0..<candIdxs.len:
        let idx: int32 = candIdxs[ci]
        if idx < 0 || idx >= mod.funcs.len:
            continue
        let cand: UirCoreFunc = mod.funcs[idx]
        if cand == nil:
            continue
        let sc: int32 = uirCoreScoreCalleeForCall(cand, argKeys, retKeyHint)
        if debugResolve:
            dbgCandCount = dbgCandCount + 1
            var pk0: str = ""
            var paramStart: int32 = 0
            if cand.params.len > 0:
                let p0: UirCoreParam = cand.params[0]
                if (p0.name == "__ret"):
                    paramStart = 1
            if cand.params.len > paramStart:
                let p1: UirCoreParam = cand.params[paramStart]
                pk0 = p1.typeKey
            if dbgPrinted < dbgMax:
                echo("[backend] debugResolve: cand='" + cand.name + "' pk0='" + pk0 +
                    "' file='" + cand.originFile + "' score=" + intToStr(sc))
                dbgPrinted = dbgPrinted + 1
        if sc < 0:
            continue
        if sc > bestScore:
            best = cand
            bestScore = sc
            ambiguous = false
            ties.len = 0
        elif sc == bestScore:
            if best != nil && best.name == cand.name && best.originFile == cand.originFile:
                continue
            if !ambiguous:
                ambiguous = true
                if best != nil:
                    add(ties, best)
            var seenTie: bool = false
            for ti0 in 0..<ties.len:
                let t0: UirCoreFunc = ties[ti0]
                if t0 != nil && t0.name == cand.name && t0.originFile == cand.originFile:
                    seenTie = true
                    break
            if !seenTie:
                add(ties, cand)
    if ambiguous:
        var hasUnknownArg: bool = false
        for ai0 in 0..<argKeys.len:
            if argKeys[ai0] == nil || len(argKeys[ai0]) == 0:
                hasUnknownArg = true
                break
        if hasUnknownArg && ties.len > 0:
            return ties[0]
        if b.func != nil && uirCoreDupFnBasesHas(baseName):
            let fTmp: UirCoreFunc = b.func
            let prefer: str = uirCoreMaybeMangleDupFnBase(baseName, fTmp.originFile)
            if prefer != nil && len(prefer) > 0:
                let prefFunc: UirCoreFunc = moduleFindFunc(mod, prefer)
                if prefFunc != nil:
                    let sc2: int32 = uirCoreScoreCalleeForCall(prefFunc, argKeys, retKeyHint)
                    if sc2 == bestScore:
                        return prefFunc
        if b.func != nil && ties.len > 0:
            var callerFile: str = ""
            let callerFunc: UirCoreFunc = b.func
            if callerFunc != nil:
                callerFile = callerFunc.originFile
            if callerFile != nil && len(callerFile) > 0:
                var bestPref: UirCoreFunc = nil
                var bestLen: int32 = -1
                var bestCount: int32 = 0
                for ti in 0..<ties.len:
                    let cand: UirCoreFunc = ties[ti]
                    if cand != nil:
                        let candFile: str = cand.originFile
                        if candFile != nil && len(candFile) > 0:
                            let pl: int32 = uirCoreCommonPrefixLen(callerFile, candFile)
                            if pl > bestLen:
                                bestPref = cand
                                bestLen = pl
                                bestCount = 1
                            elif pl == bestLen:
                                bestCount = bestCount + 1
                if bestPref != nil && bestCount == 1 && bestLen > 0:
                    return bestPref
        return nil
    if best == nil:
        if b.func != nil && uirCoreDupFnBasesHas(baseName):
            let fTmp2: UirCoreFunc = b.func
            let prefer2: str = uirCoreMaybeMangleDupFnBase(baseName, fTmp2.originFile)
            if prefer2 != nil && len(prefer2) > 0:
                let prefFunc2: UirCoreFunc = moduleFindFunc(mod, prefer2)
                if prefFunc2 != nil:
                    return prefFunc2
        let uniq: UirCoreFunc = moduleFindFuncByBaseUnique(mod, baseName)
        if uniq != nil:
            return uniq
    if debugResolve:
        var bestNm: str = ""
        if best != nil:
            bestNm = best.name
        echo("[backend] debugResolve: done base='" + baseName + "' candCount=" + intToStr(dbgCandCount) +
             " best='" + bestNm + "' ambiguous=" + (ambiguous ? "1" : "0"))
    return best

fn uirCoreResolveCalleeFunc(b: BlockBuilder, callNode: Node, baseName: str, argNodes: Node[]): Result[UirCoreFunc] =
    let retKeyHint: str = uirCoreInferCallRetKeyHint(callNode)
    let f: UirCoreFunc = uirCoreResolveCalleeFuncBestEffort(b, baseName, argNodes, retKeyHint)
    if f != nil:
        return Ok[UirCoreFunc](f)
    var fnName: str = ""
    var fp: str = ""
    if b != nil && b.func != nil:
        let bf: UirCoreFunc = b.func
        fnName = bf.name
        fp = bf.originFile
    let line: str = (callNode != nil) ? intToStr(callNode.pos.line) : "0"
    let col: str = (callNode != nil) ? intToStr(callNode.pos.col) : "0"
    return Err[UirCoreFunc]("uirCore_builder: unresolved call target: " + baseName +
                        " (fn=" + fnName + " " + fp + ":" + line + ":" + col + ")")

fn moduleHasGlobal(mod: UirCoreModule, name: str): bool =
    return moduleGlobalIndex(mod, name) >= 0

fn strHasSuffix(s: str, suffix: str): bool =
    if s == nil || suffix == nil:
        return false
    let n: int32 = len(s)
    let m: int32 = len(suffix)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[n - m + i] != suffix[i]:
            return false
    return true

fn strHasPrefix(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    let n: int32 = len(s)
    let m: int32 = len(prefix)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[i] != prefix[i]:
            return false
    return true

fn strStripPrefix(s: str, prefix: str): str =
    if s == nil || prefix == nil:
        return ""
    let n: int32 = len(s)
    let m: int32 = len(prefix)
    if m == 0:
        return s
    if n < m:
        return ""
    for i in 0..<m:
        if s[i] != prefix[i]:
            return ""
    return str(ptr_add(void*(s), m))

fn indexOfChar(s: str, ch: char): int32 =
    if s == nil || len(s) == 0:
        return -1
    for i in 0..<len(s):
        if s[i] == ch:
            return i
    return -1

fn parseQuotedValue(line: str): str =
    if line == nil || len(line) == 0:
        return ""
    let first: int32 = indexOfChar(line, '"')
    if first < 0:
        return ""
    let second: int32 = indexOfChar(str(ptr_add(void*(line), first + 1)), '"')
    if second <= 0:
        return ""
    return os.sliceStr(line, first + 1, first + second)

fn importPathDropChengPrefix(path: str): str =
    if path == nil || len(path) == 0:
        return ""
    if strHasPrefix(path, "cheng/"):
        if len(path) <= 6:
            return ""
        return strStripPrefix(path, "cheng/")
    return path

fn packageNameFromRest(rest: str): str =
    let normalized: str = importPathDropChengPrefix(rest)
    if normalized == nil || len(normalized) == 0:
        return ""
    let slash: int32 = indexOfChar(normalized, '/')
    if slash <= 0:
        return ""
    let pkgName: str = os.sliceStr(normalized, 0, slash - 1)
    if pkgName == "std" || pkgName == "core" || pkgName == "system" ||
       pkgName == "ide" || pkgName == "gui":
        return ""
    return pkgName

fn packageIdFromRest(rest: str): str =
    let name: str = packageNameFromRest(rest)
    if name == nil || len(name) == 0:
        return ""
    if (name == "stdlib"):
        return ""
    return "pkg://cheng/" + name

fn packageIdFromManifest(manifestPath: str): str =
    if manifestPath == nil || len(manifestPath) == 0:
        return ""
    if ! frontend_lib.stage1_fileExists(manifestPath):
        return ""
    let content: str = frontend_lib.stage1_readFile(manifestPath)
    if content == nil || len(content) == 0:
        return ""
    let key: str = "package_id"
    var start: int32 = 0
    for i in 0..len(content):
        if i == len(content) || content[i] == '\n':
            if i > start:
                let line: str = os.sliceStr(content, start, i - 1)
                let trimmed: str = backendStripSpaces(line)
                if strHasPrefix(trimmed, key):
                    if len(trimmed) == len(key) || trimmed[len(key)] == '=' ||
                       trimmed[len(key)] == ':' || trimmed[len(key)] == ' ':
                        let value: str = parseQuotedValue(trimmed)
                        if value != nil && len(value) > 0:
                            return value
            start = i + 1
    return ""

fn packageIdMatches(manifestPath: str, expected: str): bool =
    if expected == nil || len(expected) == 0:
        return true
    let got: str = packageIdFromManifest manifestPath
    if got == nil || len(got) == 0:
        return false
    return (got == expected)

fn pkgRootsFromEnv(): str[] =
    var out: str[]
    let single: str = os.getEnvDefault("PKG_ROOT", "")
    if single != nil && len(single) > 0:
        add(out, backendStripSpaces(single))
    let raw: str = os.getEnvDefault("PKG_ROOTS", "")
    var hasCommaOrSemi: bool = false
    var k: int32 = 0
    while raw != nil && k < len(raw):
        let c0: char = raw[k]
        if c0 == ',' || c0 == ';':
            hasCommaOrSemi = true
            break
        k = k + 1
    let useColon: bool = !hasCommaOrSemi
    var start: int32 = 0
    var i: int32 = 0
    if raw != nil && len(raw) > 0:
        let __for_start_i_2 = i
        for __for_i_2 in __for_start_i_2..len(raw):
            i = __for_i_2
            let c: char = (i < len(raw)) ? raw[i] : char(int8(0))
            if i == len(raw) || c == ',' || c == ';' || (useColon && c == ':'):
                if i > start:
                    let part: str = os.sliceStr(raw, start, i - 1)
                    let trimmed: str = backendStripSpaces(part)
                    if trimmed != nil && len(trimmed) > 0:
                        add(out, trimmed)
                start = i + 1
            i = i + 1
    if out.len == 0:
        let home: str = os.getEnvDefault("HOME", "")
        if home != nil && len(home) > 0:
            add(out, os.joinPath(home, ".cheng-packages"))
    return out

fn resolvePkgCandidate(base: str): str =
    if base == nil || len(base) == 0:
        return ""
    var full: str = base
    if ! strHasSuffix(full, ".cheng"):
        full = full + ".cheng"
    if frontend_lib.stage1_fileExists(full):
        return full
    return ""

fn resolvePkgInRoot(pkgRoot: str, relInPkg: str, relForPkgRoot: str): str =
    if pkgRoot == nil || len(pkgRoot) == 0:
        return ""

    if relInPkg != nil && len(relInPkg) > 0:
        var candidate: str = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "src"), relInPkg))
        if len(candidate) > 0:
            return candidate
        candidate = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "cheng"), relInPkg))
        if len(candidate) > 0:
            return candidate
        candidate = resolvePkgCandidate(os.joinPath(pkgRoot, relInPkg))
        if len(candidate) > 0:
            return candidate

    if relForPkgRoot != nil && len(relForPkgRoot) > 0:
        var legacy: str = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "src"), relForPkgRoot))
        if len(legacy) > 0:
            return legacy
        legacy = resolvePkgCandidate(os.joinPath(os.joinPath(pkgRoot, "cheng"), relForPkgRoot))
        if len(legacy) > 0:
            return legacy
        legacy = resolvePkgCandidate(os.joinPath(pkgRoot, relForPkgRoot))
        if len(legacy) > 0:
            return legacy
    return ""

fn resolvePkgImport(root: str, rest: str): str =
    if root == nil || len(root) == 0 || rest == nil || len(rest) == 0:
        return ""
    let normalizedRest: str = importPathDropChengPrefix(rest)
    if normalizedRest == nil || len(normalizedRest) == 0:
        return ""
    let slash: int32 = indexOfChar(normalizedRest, '/')
    if slash <= 0 || slash >= len(normalizedRest) - 1:
        return ""
    let pkg: str = os.sliceStr(normalizedRest, 0, slash - 1)
    if (pkg == "stdlib"):
        return ""
    let expectedPkgId: str = packageIdFromRest(normalizedRest)
    let relInPkg: str = os.sliceStr(normalizedRest, slash + 1, len(normalizedRest) - 1)
    let manifest: str = os.joinPath(root, "cheng-package.toml")
    if frontend_lib.stage1_fileExists(manifest):
        if ! packageIdMatches(manifest, expectedPkgId):
            return ""
        return resolvePkgInRoot(root, relInPkg, normalizedRest)

    # Container root: try cheng-<pkg> and <pkg> subdirectories.
    let prefixedRoot: str = os.joinPath(root, "cheng-" + pkg)
    let plainRoot: str = os.joinPath(root, pkg)
    let prefManifest: str = os.joinPath(prefixedRoot, "cheng-package.toml")
    if frontend_lib.stage1_fileExists(prefManifest):
        if packageIdMatches(prefManifest, expectedPkgId):
            let resolvedPref: str = resolvePkgInRoot(prefixedRoot, relInPkg, normalizedRest)
            if len(resolvedPref) > 0:
                return resolvedPref
    else:
        let resolvedPrefLegacy: str = resolvePkgInRoot(prefixedRoot, relInPkg, normalizedRest)
        if len(resolvedPrefLegacy) > 0:
            return resolvedPrefLegacy

    let plainManifest: str = os.joinPath(plainRoot, "cheng-package.toml")
    if frontend_lib.stage1_fileExists(plainManifest):
        if packageIdMatches(plainManifest, expectedPkgId):
            let resolvedPlain: str = resolvePkgInRoot(plainRoot, relInPkg, normalizedRest)
            if len(resolvedPlain) > 0:
                return resolvedPlain
    else:
        let resolvedPlainLegacy: str = resolvePkgInRoot(plainRoot, relInPkg, normalizedRest)
        if len(resolvedPlainLegacy) > 0:
            return resolvedPlainLegacy
    return ""

fn resolveImportToFilePath(importPath: str, fromFilePath: str): Result[str] =
    if importPath == nil || len(importPath) == 0:
        return Err[str]("uirCore_builder: empty import path")
    var path: str = importPath
    let pluginResolved: str = uirCoreResolvePluginImportPath(path)
    if len(pluginResolved) > 0:
        return Ok[str](pluginResolved)
    if os.isAbsolute(path):
        if ! strHasSuffix(path, ".cheng"):
            path = path + ".cheng"
        return Ok[str](path)

    var fromDir: str = ""
    if fromFilePath != nil && len(fromFilePath) > 0:
        let parts: SplitFileResult = os.splitFile(fromFilePath)
        fromDir = parts.dir

    if strHasPrefix(path, "./") || strHasPrefix(path, "../") || strHasPrefix(path, "."):
        if ! strHasSuffix(path, ".cheng"):
            path = path + ".cheng"
        if fromDir != nil && len(fromDir) > 0:
            return Ok[str](os.joinPath(fromDir, path))
        return Ok[str](path)

    if strHasPrefix(path, "std/"):
        let rest: str = strStripPrefix(path, "std/")
        var localStd: str = "src/std/" + rest
        if ! strHasSuffix(localStd, ".cheng"):
            localStd = localStd + ".cheng"
        if frontend_lib.stage1_fileExists(localStd):
            return Ok[str](localStd)
        return Ok[str](localStd)

    let pkgPath: str = importPathDropChengPrefix(path)
    if pkgPath != nil && len(pkgPath) > 0:
        var localSrc: str = "src/" + pkgPath
        if ! strHasSuffix(localSrc, ".cheng"):
            localSrc = localSrc + ".cheng"
        if frontend_lib.stage1_fileExists(localSrc):
            return Ok[str](localSrc)
        let roots: str[] = pkgRootsFromEnv()
        for ri in 0..<roots.len:
            let resolved: str = resolvePkgImport(roots[ri], pkgPath)
            if resolved != nil && len(resolved) > 0:
                return Ok[str](resolved)
        if strHasPrefix(path, "cheng/"):
            if ! strHasSuffix(path, ".cheng"):
                path = path + ".cheng"
            return Ok[str](path)

    if ! strHasSuffix(path, ".cheng"):
        path = path + ".cheng"
    if fromDir != nil && len(fromDir) > 0:
        let local2: str = os.joinPath(fromDir, path)
        if frontend_lib.stage1_fileExists(local2):
            return Ok[str](local2)
    return Ok[str](path)

fn collectImportPaths(root: Node): str[] =
    var out: str[]
    if root == nil:
        return out
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if n == nil || n.kind != nkImportStmt || kidCount(n) == 0:
            continue
        let item: Node = kid(n, 0)
        if item == nil:
            continue
        if item.kind == nkStrLit:
            let v: str = item.strVal
            if v != nil && len(v) > 0:
                add(out, "" + v)
            continue
        if item.kind == nkImportAs && kidCount(item) > 0:
            let baseNode: Node = kid(item, 0)
            var base: str = plainName(baseNode)
            if baseNode != nil && baseNode.kind == nkStrLit:
                base = baseNode.strVal
            if len(base) > 0:
                add(out, "" + base)
            continue
        if item.kind == nkImportGroup && kidCount(item) > 0:
            let baseNode2: Node = kid(item, 0)
            var base: str = plainName(baseNode2)
            if baseNode2 != nil && baseNode2.kind == nkStrLit:
                base = baseNode2.strVal
            if len(base) > 0:
                for gi in 1..<kidCount(item):
                    let entryNode: Node = kid(item, gi)
                    var entry: str = plainName(entryNode)
                    if entryNode != nil && entryNode.kind == nkStrLit:
                        entry = entryNode.strVal
                    if len(entry) > 0:
                        add(out, base + "/" + entry)
            continue
        var base2: str = plainName(item)
        if item.kind == nkStrLit:
            base2 = item.strVal
        if len(base2) > 0:
            add(out, "" + base2)
    return out

fn isBuiltinTypeName(name: str): bool =
    if name == nil || len(name) == 0:
        return false
    if name == "void" || name == "bool" || name == "char":
        return true
    if name == "int8" || name == "uint8" || name == "i8" || name == "u8":
        return true
    if name == "int16" || name == "uint16" || name == "i16" || name == "u16":
        return true
    if name == "int32" || name == "uint32" || name == "i32" || name == "u32":
        return true
    if name == "int64" || name == "uint64" || name == "i64" || name == "u64":
        return true
    if name == "int" || name == "uint" || name == "NI" || name == "NU":
        return true
    if name == "float32" || name == "float64" || name == "float":
        return true
    if name == "str" || name == "string" || name == "cstring":
        return true
    if name == "ptr" || name == "void*":
        return true
    if name == "tuple" || uirCoreStrStartsWith(name, "tuple_"):
        return true
    if name == "seq" || uirCoreStrStartsWith(name, "seq_"):
        return true
    if name == "seq_fixed" || uirCoreStrStartsWith(name, "seq_fixed_"):
        return true
    if name == "Table" || uirCoreStrStartsWith(name, "Table_"):
        return true
    if uirCoreStrStartsWith(name, "set_"):
        return true
    return false

fn uirCoreConsumeTypeDecl(mod: UirCoreModule, td: Node): Result[bool] =
    if td == nil || td.kind != nkTypeDecl || kidCount(td) < 2:
        return Err[bool]("uirCore_builder: invalid type decl")
    let nameNode: Node = kid(td, 0)
    let defNode: Node = kid(td, 1)
    var defCore: Node = defNode
    var isRefLike: bool = false
    if defCore != nil && (defCore.kind == nkRefTy || defCore.kind == nkPtrTy) && kidCount(defCore) > 0:
        isRefLike = true
        defCore = kid(defCore, 0)
    if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
        return Err[bool]("uirCore_builder: type name expects identifier")
    let name: str = backendStripSpaces(plainName(nameNode))
    let traceTypes: bool = (getEnv "BACKEND_TRACE_TYPES" == "1")
    if traceTypes && (name == "__cheng_lambda_2_iter"):
        echo("[backend] trace: typeDecl " + name)
    if (getEnv "BACKEND_DEBUG_TYPES" == "1") && (name == "Node"):
        let dk0: str = (defNode != nil) ? intToStr(int32(defNode.kind)) : "nil"
        let dk1: str = (defCore != nil) ? intToStr(int32(defCore.kind)) : "nil"
        let rf: str = isRefLike ? "1" : "0"
        echo("[backend] debug: typeDecl Node defKind=nk#" + dk0 + " defCoreKind=nk#" + dk1 + " isRefLike=" + rf)
    if (getEnv "BACKEND_DEBUG_TYPES" == "1") && (name == "seq_string"):
        let k: int32 = int32(defNode.kind)
        var line: str = "[backend] debug: typeDecl seq_string defKind=" + intToStr(k)
        if defNode != nil && defNode.kind == nkBracketExpr:
            line = line + " kids=" + intToStr(kidCount(defNode))
            if kidCount(defNode) > 0:
                line = line + " base=" + backendStripSpaces(plainName(kid(defNode, 0)))
        line = line + " hasSeq=" + (uirCoreHasObjType(mod, "seq") ? "1" : "0")
        echo line
    if (getEnv "BACKEND_DEBUG_TYPES" == "1") && (name == "Table_string"):
        let k2: int32 = int32(defNode.kind)
        var line2: str = "[backend] debug: typeDecl Table_string defKind=" + intToStr(k2)
        if defNode != nil && defNode.kind == nkBracketExpr:
            line2 = line2 + " kids=" + intToStr(kidCount(defNode))
            if kidCount(defNode) > 0:
                line2 = line2 + " base=" + backendStripSpaces(plainName(kid(defNode, 0)))
        line2 = line2 + " hasTable=" + (uirCoreHasObjType(mod, "Table") ? "1" : "0")
        echo line2
    if moduleHasFunc(mod, name) || moduleHasGlobal(mod, name):
        return Err[bool]("uirCore_builder: type name conflicts with global")
    let existingObj: int32 = uirCoreFindObjType(mod, name)
    if existingObj >= 0:
        # Stage1 lowering may emit an alias first and the concrete object later.
        # Prefer the concrete object layout when available.
        if defCore == nil || defCore.kind != nkObjectDecl:
            return Ok[bool](false)
    let existingAlias: int32 = uirCoreFindTypeAlias(mod, name)
    if existingAlias >= 0:
        # Prefer object layouts over scalar aliases when a name collides.
        # This situation can happen when stage1 lowers an instantiation to an alias
        # and also keeps the concrete object definition.
        if defCore == nil || defCore.kind != nkObjectDecl:
            return Ok[bool](false)
    if kidCount(td) > 2:
        let generics: Node = kid(td, 2)
        if generics != nil && generics.kind != nkEmpty && kidCount(generics) > 0:
            # Generic types are expected to be eliminated (instantiated) by stage1 monomorphize.
            return Ok[bool](false)
    if isRefLike:
        # Ref/ptr types are represented as pointers; predeclare the scalar alias so
        # self-references and mutually-recursive ref types don't block layout construction.
        uirCoreAddTypeAlias(mod, name, uirCoreTypeI64())
    if defCore != nil && defCore.kind == nkObjectDecl:
        # `seq_fixed[T,N]` is used as an init-time reserve hint (cap hint) for `seq`.
        # Some stage1 pipelines may still surface partially-instantiated `seq_fixed_*_N` helper types.
        # Treat them as the builtin `seq` layout so these helpers don't block builds.
        if uirCoreStrStartsWith(name, "seq_fixed_") && uirCoreHasObjType(mod, "seq"):
            var rhs: UirCoreObjType = uirCoreGetObjType(mod, "seq")
            rhs.name = name
            uirCoreAddObjType(mod, rhs)
            return Ok[bool](false)
    if defCore != nil && defCore.kind == nkObjectDecl:
        if kidCount(defCore) < 2:
            return Err[bool]("uirCore_builder: invalid object type")
        let recList: Node = kid(defCore, 1)
        if recList == nil || recList.kind != nkRecList:
            return Err[bool]("uirCore_builder: invalid record list")
        if traceTypes && (name == "__cheng_lambda_2_iter"):
            echo("[backend] trace: recList count=" + intToStr(kidCount(recList)))
        var fields: UirCoreObjField[]
        var offset: int32 = 0
        var maxAlignPow2: int32 = 0
        for i in 0..<kidCount(recList):
            let item: Node = kid(recList, i)
            if item == nil:
                continue
            if item.kind == nkRecCase:
                return Err[bool]("uirCore_builder: record case not supported in backend")
            if item.kind != nkIdentDefs || kidCount(item) < 2:
                return Err[bool]("uirCore_builder: record field expects ident defs")
            let fieldNameNode: Node = kid(item, 0)
            let fieldTypeNode: Node = kid(item, 1)
            var fieldDefaultNode: Node = nil
            if kidCount(item) > 2:
                fieldDefaultNode = kid(item, 2)
            if fieldNameNode == nil || (fieldNameNode.kind != nkIdent && fieldNameNode.kind != nkSymbol):
                return Err[bool]("uirCore_builder: record field name expects identifier")
            if fieldTypeNode == nil || fieldTypeNode.kind == nkEmpty:
                return Err[bool]("uirCore_builder: record field requires type")
            if fieldDefaultNode != nil && fieldDefaultNode.kind != nkEmpty:
                return Err[bool]("uirCore_builder: record field default not supported in backend")
            let rawFieldName: str = plainName(fieldNameNode)
            let fieldName: str = backendStripSpaces(rawFieldName)
            if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && name == "ProtoBuffer" && fieldName == "out":
                let fNodeName0: str = backendStripSpaces(plainName(fieldTypeNode))
                let fNodeKey0: str = typeKey(fieldTypeNode)
                echo("[backend] debugOverloadDot: consumeTypeDecl type='ProtoBuffer' field='out' nodeKind=nk#" +
                     intToStr(int32(fieldTypeNode.kind)) + " plain='" + fNodeName0 + "' typeKey='" + fNodeKey0 + "'")
            if traceTypes && (name == "__cheng_lambda_2_iter"):
                var firstCode: int32 = -1
                if rawFieldName != nil && len(rawFieldName) > 0:
                    firstCode = int32(rawFieldName[0])
                echo("[backend] trace: field '" + fieldName + "' rawLen=" + intToStr(len(rawFieldName)) +
                    " firstChar=" + intToStr(firstCode))
            var fieldTypeKey: str = ""
            if fieldTypeNode != nil && fieldTypeNode.kind == nkDotExpr && kidCount(fieldTypeNode) > 1:
                fieldTypeKey = typeKey(kid(fieldTypeNode, 1))
            else:
                fieldTypeKey = typeKey(fieldTypeNode)
            if len(fieldTypeKey) == 0:
                fieldTypeKey = backendStripSpaces(plainName(fieldTypeNode))
            let sfiField: SeqFixedInit = seqFixedInitInfo(fieldTypeNode)
            if sfiField.elemType != nil && sfiField.capExpr != nil:
                # Keep explicit `seq_fixed[T,N]` key for init-time reserve hints.
                let explicitKey: str = typeKey(fieldTypeNode)
                if explicitKey != nil && len(explicitKey) > 0:
                    fieldTypeKey = explicitKey
            if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && name == "ProtoBuffer" && fieldName == "out":
                echo("[backend] debugOverloadDot: computed fieldTypeKey type='ProtoBuffer' field='out' key='" + fieldTypeKey +
                     "' len=" + intToStr(len(fieldTypeKey)))
            if len(fieldTypeKey) > 0:
                if (getEnv "BACKEND_DEBUG_OVERLOAD_DOT" == "1") && name == "ProtoBuffer" && fieldName == "out":
                    echo("[backend] debugOverloadDot: put fieldTypeKey type='ProtoBuffer' field='out' key='" + fieldTypeKey + "'")
                uirCoreObjFieldTypeKeyPut(name, fieldName, fieldTypeKey)
            let objFieldType: str = typeNodeObjTypeName(mod, fieldTypeNode)
            if (getEnv "BACKEND_DEBUG_TYPES" == "1") && (name == "EcKeyPair"):
                let isObjFieldValDbg: bool = typeNodeIsObjValue(mod, fieldTypeNode)
                echo("[backend] debugTypes: type=" + name + " field=" + fieldName +
                     " fieldTypeKey='" + fieldTypeKey + "' objFieldType='" + objFieldType +
                     "' isObjValue=" + (isObjFieldValDbg ? "1" : "0"))
            if len(objFieldType) > 0 && typeNodeIsObjValue(mod, fieldTypeNode) && uirCoreHasObjType(mod, objFieldType):
                uirCoreInlineObjFieldTypePut(name, fieldName, objFieldType)
                let inner: UirCoreObjType = uirCoreGetObjType(mod, objFieldType)
                if inner.size <= 0 || inner.fields.len == 0:
                    if (getEnv "BACKEND_DEBUG_TYPES" == "1"):
                        echo("[backend] debug: pending type " + name + " inline object unresolved: " + objFieldType)
                    return Ok[bool](true)
                let alignPow2: int32 = inner.alignPow2
                if alignPow2 > maxAlignPow2:
                    maxAlignPow2 = alignPow2
                offset = alignUpPow2(offset, alignPow2)
                for fi in 0..<inner.fields.len:
                    let innerF: UirCoreObjField = inner.fields[fi]
                    var f: UirCoreObjField
                    f.name = fieldName + "." + innerF.name
                    f.ty = innerF.ty
                    f.offset = offset + innerF.offset
                    add(fields, f)
                offset = offset + inner.size
                continue
            if fieldTypeNode != nil && (fieldTypeNode.kind == nkIdent || fieldTypeNode.kind == nkSymbol || fieldTypeNode.kind == nkBracketExpr ||
               fieldTypeNode.kind == nkDotExpr):
                # `typeKey(nkDotExpr)` is not stable (may fall back to "node"). Depend on the RHS name instead.
                var depKey: str = ""
                if fieldTypeNode.kind == nkDotExpr && kidCount(fieldTypeNode) > 1:
                    depKey = typeKey(kid(fieldTypeNode, 1))
                else:
                    depKey = typeKey(fieldTypeNode)
                let depName: str = (len(depKey) > 0) ? depKey : backendStripSpaces(plainName(fieldTypeNode))
                if len(depName) > 0 && !isBuiltinTypeName(depName):
                    let depAlias: UirCoreType = uirCoreTryGetTypeAlias(mod, depName)
                    if !uirCoreHasObjType(mod, depName) && depAlias.kind == mtVoid:
                        if !(uirCoreStrStartsWith(depName, "SeqUninit_") && ensureSeqUninitObjType(mod, depName)):
                            if (getEnv "BACKEND_DEBUG_TYPES" == "1"):
                                echo("[backend] debug: pending type " + name + " depends on " + depName)
                            return Ok[bool](true)
            let fieldTy: UirCoreType = uirCoreTypeFromNodeWithModule(mod, fieldTypeNode)
            let fieldSize: int32 = uirCoreTypeSize(fieldTy)
            if fieldSize <= 0:
                return Err[bool]("uirCore_builder: unsupported record field type")
            let alignPow2: int32 = uirCoreTypeAlignPow2(fieldTy)
            if alignPow2 > maxAlignPow2:
                maxAlignPow2 = alignPow2
            offset = alignUpPow2(offset, alignPow2)
            var f: UirCoreObjField
            f.name = fieldName
            f.ty = fieldTy
            f.offset = offset
            add(fields, f)
            offset = offset + fieldSize
        var ot: UirCoreObjType
        ot.name = name
        ot.alignPow2 = maxAlignPow2
        ot.size = alignUpPow2(offset, maxAlignPow2)
        ot.fields = fields
        if existingObj >= 0:
            mbWriteObjType(mod.objTypes, existingObj, ot)
        else:
            uirCoreAddObjType(mod, ot)
        if isRefLike:
            uirCoreAddTypeAlias(mod, name, uirCoreTypeI64())
        return Ok[bool](false)
    if defNode != nil && defNode.kind == nkEnumDecl:
        # Represent enums as int32 (matches stage1 C backend lowering).
        uirCoreAddTypeAlias(mod, name, uirCoreTypeI32())
        var nextVal: int64 = 0
        for fi in 0..<kidCount(defNode):
            let field: Node = kid(defNode, fi)
            if field == nil || field.kind == nkEmpty:
                continue
            if field.kind != nkEnumFieldDecl || kidCount(field) == 0:
                return Err[bool]("uirCore_builder: invalid enum field")
            let fieldNameNode: Node = kid(field, 0)
            if fieldNameNode == nil || (fieldNameNode.kind != nkIdent && fieldNameNode.kind != nkSymbol):
                return Err[bool]("uirCore_builder: enum field expects identifier")
            var valNode: Node = nil
            if kidCount(field) > 1:
                valNode = kid(field, 1)
            while valNode != nil && valNode.kind == nkPar && kidCount(valNode) > 0:
                valNode = kid(valNode, 0)
            var fieldVal: int64 = nextVal
            if valNode != nil && valNode.kind != nkEmpty:
                if valNode.kind == nkIntLit:
                    fieldVal = valNode.intVal
                elif valNode.kind == nkIdent || valNode.kind == nkSymbol:
                    let dep: str = plainName(valNode)
                    let gi: int32 = moduleGlobalIndex(mod, dep)
                    if gi >= 0:
                        let g: UirCoreGlobal = mod.globals[gi]
                        if g.hasInit:
                            fieldVal = g.init
                        else:
                            return Ok[bool](true)
                    else:
                        return Ok[bool](true)
                else:
                    return Err[bool]("uirCore_builder: enum field value expects int literal")
            let fieldName: str = backendStripSpaces(plainName(fieldNameNode))
            if len(fieldName) == 0:
                return Err[bool]("uirCore_builder: enum field expects name")
            if moduleHasFunc(mod, fieldName) || moduleHasGlobal(mod, fieldName):
                return Err[bool]("uirCore_builder: enum field conflicts with existing name")
            uirCoreAddGlobal(mod, fieldName, uirCoreTypeI32(), fieldVal, true, "")
            nextVal = fieldVal + 1
        return Ok[bool](false)
    if defNode != nil && (defNode.kind == nkTupleTy || defNode.kind == nkBracketExpr):
        let rhsObjName: str = typeNodeObjTypeName(mod, defNode)
        if len(rhsObjName) > 0 && uirCoreHasObjType(mod, rhsObjName):
            # Type aliases to object-like type expressions become a new name for the same layout.
            var rhs: UirCoreObjType = uirCoreGetObjType(mod, rhsObjName)
            rhs.name = name
            uirCoreAddObjType(mod, rhs)
            uirCoreObjAliasPut(name, rhsObjName)
            return Ok[bool](false)
        # Avoid producing scalar aliases to mtVoid for object-like type expressions.
        if (getEnv "BACKEND_DEBUG_TYPES" == "1"):
            echo("[backend] debug: pending alias " + name + " object-like rhs unresolved")
        return Ok[bool](true)
    if defNode == nil || defNode.kind == nkEmpty:
        return Err[bool]("uirCore_builder: type alias missing body")
    if defNode.kind == nkIdent || defNode.kind == nkSymbol:
        let rhsName: str = backendStripSpaces(plainName(defNode))
        let rhsObjName2: str = typeNodeObjTypeName(mod, defNode)
        if len(rhsObjName2) > 0 && uirCoreHasObjType(mod, rhsObjName2):
            var rhs: UirCoreObjType = uirCoreGetObjType(mod, rhsObjName2)
            rhs.name = name
            uirCoreAddObjType(mod, rhs)
            uirCoreObjAliasPut(name, rhsObjName2)
            return Ok[bool](false)
        let rhsAlias: UirCoreType = uirCoreTryGetTypeAlias(mod, rhsName)
        if len(rhsName) > 0 && !isBuiltinTypeName(rhsName) && rhsAlias.kind == mtVoid:
            if (getEnv "BACKEND_DEBUG_TYPES" == "1"):
                echo("[backend] debug: pending alias " + name + " depends on alias " + rhsName)
            return Ok[bool](true)
    let aliasTy: UirCoreType = uirCoreTypeFromNodeWithModule(mod, defNode)
    uirCoreAddTypeAlias(mod, name, aliasTy)
    return Ok[bool](false)

fn uirCoreConsumeTypeDecls(mod: UirCoreModule, root: Node): Result[bool] =
    if root == nil:
        return Ok[bool](false)
    var work: Node[]
    var queue: Node[]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil:
            continue
        if n.kind == nkTypeDecl:
            add(work, n)
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
    if work.len == 0:
        return Ok[bool](false)
    var pending: Node[] = work
    var pass: int32 = 0
    while pending.len > 0:
        if pass > work.len + 8:
            return Err[bool]("uirCore_builder: type dependency resolution exceeded iteration limit")
        var next: Node[]
        var progressed: bool = false
        for i2 in 0..<pending.len:
            let td: Node = pending[i2]
            let res: Result[bool] = uirCoreConsumeTypeDecl(mod, td)
            if !IsOk[bool](res):
                return ErrInfo[bool](ErrorInfoOf[bool](res))
            if Value[bool](res):
                add(next, td)
            else:
                progressed = true
        if !progressed:
            var msg: str = "uirCore_builder: unresolved type dependencies:"
            var shown: int32 = 0
            for i3 in 0..<pending.len:
                if !(shown < 32):
                    break
                let td2: Node = pending[i3]
                var nm2: str = ""
                if td2 != nil && kidCount(td2) > 0:
                    let nn: Node = kid(td2, 0)
                    if nn != nil && (nn.kind == nkIdent || nn.kind == nkSymbol):
                        nm2 = backendStripSpaces(plainName(nn))
                if nm2 != nil && len(nm2) > 0:
                    msg = msg + " " + nm2
                    shown = shown + 1
            return Err[bool](msg)
        pending = next
        pass = pass + 1
    return Ok[bool](false)

type
    UirCoreBuildCtx = ref
        foundMain: bool
        traceEnabled: bool
        traceFnCount: int32
        traceGlobalCount: int32
        overloadedFnBases: hashsets.HashSetStr
        globalInits: UirCoreGlobalInit[]

    UirCoreGlobalInit = ref
        name: str
        ty: UirCoreType
        objTypeName: str
        initNode: Node
        filePath: str
        seqFixedElemType: Node
        seqFixedCapExpr: Node

fn uirCorePredeclareGlobalsForTypes(mod: UirCoreModule, root: Node) =
    # Array type expressions like `array[ConstLen, T]` require the length constant
    # to be available during type dependency resolution. Predeclare simple scalar
    # globals (int/bool/nil literals) so `tryResolveArrayCount` can resolve them.
    if mod == nil || root == nil:
        return
    let preFile: str = "<predeclared>"
    var queue: Node[]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
            continue
        if n.kind != nkConst && n.kind != nkLet && n.kind != nkVar:
            continue
        var pat: Node = nil
        if kidCount(n) > 0:
            pat = kid(n, 0)
        var init: Node = nil
        if kidCount(n) > 2:
            init = kid(n, 2)
        var nameNode: Node = pat
        var typeNode: Node = nil
        if kidCount(n) > 1:
            typeNode = kid(n, 1)
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
            if kidCount(pat) > 1:
                typeNode = kid(pat, 1)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let name: str = plainName(nameNode)
        if moduleHasFunc(mod, name) || moduleHasGlobal(mod, name) ||
           uirCoreFindTypeAlias(mod, name) >= 0 || uirCoreFindObjType(mod, name) >= 0:
            continue
        var initCore: Node = init
        while initCore != nil && initCore.kind == nkPar && kidCount(initCore) > 0:
            initCore = kid(initCore, 0)
        var hasInit: bool = false
        var initVal: int64 = 0
        if initCore != nil && initCore.kind != nkEmpty:
            if initCore.kind == nkIntLit:
                hasInit = true
                initVal = initCore.intVal
            elif initCore.kind == nkBoolLit:
                hasInit = true
                let v: str = backendStripSpaces(initCore.ident)
                initVal = (v == "true") ? 1 : 0
            elif initCore.kind == nkNilLit:
                hasInit = true
                initVal = 0
        var declTy: UirCoreType = uirCoreTypeFromNodeWithModule(mod, typeNode)
        if declTy.kind == mtVoid:
            if hasInit:
                if initCore != nil && initCore.kind == nkBoolLit:
                    declTy = uirCoreTypeU8()
                elif initCore != nil && initCore.kind == nkNilLit:
                    declTy = uirCoreTypeI64()
                else:
                    declTy = uirCoreTypeI32()
            else:
                declTy = uirCoreTypeI64()
        uirCoreAddGlobal(mod, name, declTy, initVal, hasInit, preFile)
        if typeNode != nil && typeNode.kind != nkEmpty:
            uirCoreGlobalTypeKeyPut(name, typeKey(typeNode))

fn uirCorePredeclareGlobalsForLowering(mod: UirCoreModule, root: Node) =
    if mod == nil || root == nil:
        return
    let preFile: str = "<predeclared>"
    var queue: Node[]
    add(queue, root)
    while queue.len > 0:
        let n: Node = queue[queue.len - 1]
        queue.len = queue.len - 1
        if n == nil || n.kind == nkEmpty:
            continue
        if n.kind == nkStmtList || n.kind == nkModule:
            for i in 0..<kidCount(n):
                add(queue, kid(n, i))
            continue
        if n.kind != nkConst && n.kind != nkLet && n.kind != nkVar:
            continue
        var pat: Node = nil
        if kidCount(n) > 0:
            pat = kid(n, 0)
        var init: Node = nil
        if kidCount(n) > 2:
            init = kid(n, 2)
        var nameNode: Node = pat
        var typeNode: Node = nil
        if kidCount(n) > 1:
            typeNode = kid(n, 1)
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
            if kidCount(pat) > 1:
                typeNode = kid(pat, 1)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            continue
        let rawName: str = backendStripSpaces(plainName(nameNode))
        if rawName == nil || len(rawName) == 0:
            continue
        let debugDot: bool = (getEnv "BACKEND_DEBUG_DOT" == "1")
        let filePath: str = (n.strVal != nil && len(n.strVal) > 0) ? n.strVal : preFile
        if debugDot && rawName == "baseIdentity":
            var typeKindDbg: str = "nil"
            if typeNode != nil:
                typeKindDbg = intToStr(int32(typeNode.kind))
            echo("[backend] debugDot: predeclareLowering rawName='" + rawName +
                 "' file='" + filePath + "' typeKind=nk#" + typeKindDbg + "'")
        let name: str = uirCoreMaybeMangleDupGlobalName(rawName, filePath)
        if moduleHasFunc(mod, name) || moduleHasGlobal(mod, name) ||
           uirCoreFindTypeAlias(mod, name) >= 0 || uirCoreFindObjType(mod, name) >= 0:
            continue

        var declType: UirCoreType = uirCoreTypeFromNodeWithModule(mod, typeNode)
        var objTypeName: str = ""
        var objTypeNode: Node = typeNode
        if (objTypeNode == nil || objTypeNode.kind == nkEmpty) && init != nil && init.kind != nkEmpty &&
           init.typeCacheValid && init.typeCache != nil:
            objTypeNode = init.typeCache
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            objTypeName = typeNodeObjTypeName(mod, objTypeNode)
        let isObj: bool = len(objTypeName) > 0 && objTypeNode != nil && typeNodeIsObjValue(mod, objTypeNode)
        if debugDot && rawName == "baseIdentity":
            let objNodeKindDbg: str = (objTypeNode != nil) ? intToStr(int32(objTypeNode.kind)) : "nil"
            echo("[backend] debugDot: predeclareLowering name='" + name +
                 "' objTypeName='" + objTypeName + "' isObj=" + (isObj ? "1" : "0") +
                 " objNodeKind=nk#" + objNodeKindDbg + "'")
        if isObj:
            uirCoreGlobalObjTypePut(name, objTypeName)
            declType = uirCoreTypeI64()
        elif typeNode == nil || typeNode.kind == nkEmpty:
            declType = inferExprTypeWithGlobals(nil, mod, nil, init, declType)
        if declType.kind == mtVoid:
            declType = uirCoreTypeI64()
        if !isObj && (declType.kind == mtI8 || declType.kind == mtI16):
            let wasUnsigned: bool = declType.isUnsigned
            declType = uirCoreTypeI32()
            declType.isUnsigned = wasUnsigned

        var initCore: Node = init
        while initCore != nil && initCore.kind == nkPar && kidCount(initCore) > 0:
            initCore = kid(initCore, 0)
        var hasInit: bool = false
        var initVal: int64 = 0
        if !isObj && initCore != nil && initCore.kind != nkEmpty:
            if initCore.kind == nkIntLit:
                hasInit = true
                initVal = initCore.intVal
            elif initCore.kind == nkBoolLit:
                hasInit = true
                let v: str = backendStripSpaces(initCore.ident)
                initVal = (v == "true") ? 1 : 0
            elif initCore.kind == nkNilLit:
                hasInit = true
                initVal = 0
        uirCoreAddGlobal(mod, name, declType, initVal, hasInit, preFile)

        var keyOut: str = ""
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            keyOut = typeKey(objTypeNode)
            if keyOut == nil || len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(objTypeNode)
        elif typeNode != nil && typeNode.kind != nkEmpty:
            keyOut = typeKey(typeNode)
            if keyOut == nil || len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(typeNode)
        if keyOut != nil && len(keyOut) > 0:
            uirCoreGlobalTypeKeyPut(name, keyOut)

fn ctxAddGlobalInit(ctx: UirCoreBuildCtx, name: str, ty: UirCoreType, objTypeName: str, initNode: Node, filePath: str,
                    seqFixedElemType: Node = nil, seqFixedCapExpr: Node = nil) =
    if ctx == nil || name == nil || len(name) == 0:
        return
    if ctx.globalInits.buffer == nil:
        ctx.globalInits = []
    var gi: UirCoreGlobalInit
    new gi
    gi.name = uirCoreOwnStr(name)
    gi.ty = ty
    gi.objTypeName = uirCoreOwnStr(objTypeName)
    gi.initNode = initNode
    gi.filePath = uirCoreOwnStr(filePath)
    gi.seqFixedElemType = seqFixedElemType
    gi.seqFixedCapExpr = seqFixedCapExpr
    add(ctx.globalInits, gi)

fn uirCoreParseModuleWithLoweredTypes(filePath: str, content: str, outRoot: Node*): bool =
    if outRoot == nil:
        return false
    let tokens: Token[] = lexTokens(content, filePath)
    let parsedRoot0: Node = parseModule(tokens, filePath)
    let parsedRoot1: Node = uirCoreApplyAstPluginHooks(filePath, parsedRoot0)
    if parsedRoot1 == nil:
        return false
    let root: Node = uirCoreApplyMirPluginHooks(filePath, parsedRoot1)
    if root == nil:
        return false
    var diags: Diagnostic[]
    diags.buffer = nil
    diags.len = 0
    diags.cap = 16
    type_syntax_lowering.lowerTypeSyntax(root, &diags, filePath)
    if hasError diags:
        printDiagnostics diags
        return false
    *outRoot = root
    return true

fn uirCoreConsumeFile(mod: UirCoreModule, ctx: UirCoreBuildCtx, filePath: str): Result[str[]] =
    if filePath == nil || len(filePath) == 0:
        return Err[str[]]("uirCore_builder: empty file path")
    if ! frontend_lib.stage1_fileExists(filePath):
        return Err[str[]]("uirCore_builder: import file not found")
    let content: str = frontend_lib.stage1_readFile(filePath)
    var root: Node = nil
    if !uirCoreParseModuleWithLoweredTypes(filePath, content, &root):
        releaseNodeArena()
        return Err[str[]]("uirCore_builder: stage1 errors")
    let rawImports: str[] = collectImportPaths(root)
    var imports: str[]
    for ii in 0..<rawImports.len:
        let impPath: str = rawImports[ii]
        let resolvedRes: Result[str] = resolveImportToFilePath(impPath, filePath)
        if ! IsOk[str](resolvedRes):
            releaseNodeArena()
            return ErrInfo[str[]](ErrorInfoOf[str](resolvedRes))
        add(imports, Value[str](resolvedRes))
    let tdRes: Result[bool] = uirCoreConsumeTypeDecls(mod, root)
    if ! IsOk[bool](tdRes):
        releaseNodeArena()
        return ErrInfo[str[]](ErrorInfoOf[bool](tdRes))
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if n != nil && (n.kind == nkVar || n.kind == nkLet || n.kind == nkConst):
            var pat: Node = nil
            if kidCount(n) > 0:
                pat = kid(n, 0)
            var init: Node = nil
            if kidCount(n) > 2:
                init = kid(n, 2)
            var nameNode: Node = pat
            var typeNode: Node = nil
            if kidCount(n) > 1:
                typeNode = kid(n, 1)
            if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
                nameNode = kid(pat, 0)
                if kidCount(pat) > 1:
                    typeNode = kid(pat, 1)
            if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
                releaseNodeArena()
                return Err[str[]]("uirCore_builder: global expects identifier")
            let name: str = plainName(nameNode)
            if moduleHasFunc(mod, name) || moduleHasGlobal(mod, name) ||
               uirCoreFindTypeAlias(mod, name) >= 0 || uirCoreFindObjType(mod, name) >= 0:
                releaseNodeArena()
                return Err[str[]]("uirCore_builder: duplicate global name")
            var declType: UirCoreType = uirCoreTypeFromNodeWithModule(mod, typeNode)
            if typeNode == nil || typeNode.kind == nkEmpty:
                declType = inferExprTypeWithGlobals(nil, mod, nil, init, declType)
            var hasInit: bool = false
            var initVal: int64 = 0
            if init != nil && init.kind != nkEmpty:
                hasInit = true
                if init.kind == nkIntLit:
                    initVal = init.intVal
                elif init.kind == nkBoolLit:
                    let v: str = backendStripSpaces(init.ident)
                    initVal = (v == "true") ? 1 : 0
                elif init.kind == nkNilLit:
                    initVal = 0
                else:
                    releaseNodeArena()
                    return Err[str[]]("uirCore_builder: unsupported global initializer")
            uirCoreAddGlobal(mod, name, declType, initVal, hasInit, filePath)
            continue
        if n != nil && n.kind == nkFnDecl:
            let fRes: Result[UirCoreFunc] = uirCoreBuildFunc(mod, n, filePath)
            if ! IsOk[UirCoreFunc](fRes):
                releaseNodeArena()
                return ErrInfo[str[]](ErrorInfoOf[UirCoreFunc](fRes))
            let f: UirCoreFunc = Value[UirCoreFunc](fRes)
            if f == nil:
                continue
            if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
               uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
                var sameFile: bool = false
                for di in 0..<mod.funcs.len:
                    let ex: UirCoreFunc = mod.funcs[di]
                    if ex != nil && (ex.name == f.name) && (ex.originFile == f.originFile):
                        sameFile = true
                        break
                if sameFile:
                    continue
                releaseNodeArena()
                return Err[str[]]("uirCore_builder: duplicate function name: " + f.name)
            if (f.name == "main"):
                if ctx != nil && ctx.foundMain:
                    releaseNodeArena()
                    return Err[str[]]("uirCore_builder: multiple main functions")
                if ctx != nil:
                    ctx.foundMain = true
            uirCoreAddFunc(mod, f)
    releaseNodeArena()
    return Ok[str[]](imports)

fn uirCoreBuildModuleFromFile(path: str): Result[UirCoreModule] =
    if len(path) == 0:
        return Err[UirCoreModule]("uirCore_builder: empty path")
    uirCoreGlobalObjTypesReset()
    uirCoreGlobalTypeKeysReset()
    uirCoreInlineObjFieldTypesReset()
    uirCoreObjFieldTypeKeysReset()
    uirCoreTupleFieldIndicesReset()
    uirCoreObjAliasesReset()
    uirCoreDupFnBasesReset()
    uirCoreDupGlobalNamesReset()
    let mod: UirCoreModule = uirCoreNewModule("arm64-apple-darwin")
    ensureBuiltinObjTypes(mod)
    var ctx: UirCoreBuildCtx
    new ctx
    ctx.foundMain = false
    ctx.traceEnabled = stage1TraceEnabled()
    ctx.traceFnCount = 0
    ctx.traceGlobalCount = 0
    ctx.globalInits = []

    # Pass 1: collect full import closure.
    var queue: str[]
    add(queue, path)
    var files: str[]
    var fileImportStart: int32[]
    var fileImportLen: int32[]
    var fileImportPool: str[]
    var fileIndex: hashmaps.HashMapStrInt = hashmaps.hashMapStrIntInit(128)
    var dupGlobalNameIndex: hashmaps.HashMapStrInt = hashmaps.hashMapStrIntInit(2048)
    var dupGlobalNames: str[]
    var dupGlobalCounts: int32[]
    for qi in 0..<queue.len:
        let filePath: str = queue[qi]
        if filePath == nil || len(filePath) == 0:
            return Err[UirCoreModule]("uirCore_builder: empty file path")
        var seen: bool = false
        let seenIdx: int32 = uirCoreHashMapStrIntGetCompat(fileIndex, filePath, seen)
        if seen && seenIdx >= 0:
            continue
        add(files, filePath)
        hashmaps.hashMapStrIntPut(fileIndex, filePath, files.len - 1)
        if ! frontend_lib.stage1_fileExists(filePath):
            return Err[UirCoreModule]("uirCore_builder: import file not found")
        let content: str = frontend_lib.stage1_readFile(filePath)
        var root: Node = nil
        if !uirCoreParseModuleWithLoweredTypes(filePath, content, &root):
            releaseNodeArena()
            return Err[UirCoreModule]("uirCore_builder: stage1 errors")
        let rawImports: str[] = collectImportPaths(root)
        var declScanQueue: Node[]
        add(declScanQueue, root)
        while declScanQueue.len > 0:
            let n0: Node = declScanQueue[declScanQueue.len - 1]
            declScanQueue.len = declScanQueue.len - 1
            if n0 == nil || n0.kind == nkEmpty:
                continue
            if n0.kind == nkStmtList || n0.kind == nkModule:
                for ni in 0..<kidCount(n0):
                    add(declScanQueue, kid(n0, ni))
                continue
            if n0.kind != nkVar && n0.kind != nkLet && n0.kind != nkConst:
                continue
            var pat0: Node = nil
            if kidCount(n0) > 0:
                pat0 = kid(n0, 0)
            var nameNode0: Node = pat0
            if pat0 != nil && pat0.kind == nkPattern && kidCount(pat0) > 0:
                nameNode0 = kid(pat0, 0)
            if nameNode0 == nil || (nameNode0.kind != nkIdent && nameNode0.kind != nkSymbol):
                continue
            let globalName0: str = backendStripSpaces(plainName(nameNode0))
            if globalName0 == nil || len(globalName0) == 0:
                continue
            var foundDupG: bool = false
            let rawG: int32 = uirCoreHashMapStrIntGetCompat(dupGlobalNameIndex, globalName0, foundDupG)
            let gIdx0: int32 = rawG - 1
            if foundDupG && rawG > 0 && gIdx0 >= 0 && gIdx0 < dupGlobalCounts.len:
                dupGlobalCounts[gIdx0] = dupGlobalCounts[gIdx0] + 1
            else:
                let newG: int32 = dupGlobalNames.len
                add(dupGlobalNames, globalName0)
                add(dupGlobalCounts, 1)
                hashmaps.hashMapStrIntPut(dupGlobalNameIndex, globalName0, newG + 1)
        var imports: str[]
        for ii0 in 0..<rawImports.len:
            let impPath: str = rawImports[ii0]
            let resolvedRes: Result[str] = resolveImportToFilePath(impPath, filePath)
            if ! IsOk[str](resolvedRes):
                releaseNodeArena()
                return ErrInfo[UirCoreModule](ErrorInfoOf[str](resolvedRes))
            add(imports, Value[str](resolvedRes))
        let importStart: int32 = fileImportPool.len
        add(fileImportStart, importStart)
        add(fileImportLen, imports.len)
        for ii in 0..<imports.len:
            add(fileImportPool, imports[ii])
        releaseNodeArena()
        for ii in 0..<imports.len:
            add(queue, imports[ii])

    for gi in 0..<dupGlobalNames.len:
        if dupGlobalCounts[gi] > 1:
            hashsets.hashSetStrAdd(uirCoreDupGlobalNames, dupGlobalNames[gi])

    # Pass 1b: consume type declarations in import order (imports before importers).
    # This avoids spurious "unresolved type dependencies" when a file's type decls
    # reference imported aliases/object types (e.g. HashMapStrInt, ByteReader, UirCoreModule).
    var indeg: int32[]
    indeg.len = files.len
    var depHead: int32[]
    depHead.len = files.len
    for hi in 0..<depHead.len:
        depHead[hi] = -1
    var depTo: int32[]
    var depNext: int32[]
    for fi0 in 0..<files.len:
        let impStart: int32 = fileImportStart[fi0]
        let impLen: int32 = fileImportLen[fi0]
        for ji in 0..<impLen:
            let impPath: str = fileImportPool[impStart + ji]
            var found: bool = false
            let impIdx: int32 = uirCoreHashMapStrIntGetCompat(fileIndex, impPath, found)
            if found && impIdx >= 0 && impIdx < files.len && impIdx != fi0:
                indeg[fi0] = indeg[fi0] + 1
                let edgeIdx: int32 = depTo.len
                add(depTo, fi0)
                add(depNext, depHead[impIdx])
                depHead[impIdx] = edgeIdx

    var ready: int32[]
    for i0 in 0..<files.len:
        if indeg[i0] == 0:
            add(ready, i0)

    var typeFiles: str[]
    while ready.len > 0:
        let idx0: int32 = ready[ready.len - 1]
        ready.len = ready.len - 1
        add(typeFiles, files[idx0])
        var edge: int32 = depHead[idx0]
        while edge >= 0:
            let depIdx: int32 = depTo[edge]
            let newDeg: int32 = indeg[depIdx] - 1
            indeg[depIdx] = newDeg
            if newDeg == 0:
                add(ready, depIdx)
            edge = depNext[edge]

    # Cycles should not exist in a well-formed program, but keep building a best-effort
    # order to avoid crashing; type resolution may still fail later with a real error.
    if typeFiles.len < files.len:
        for ci0 in 0..<files.len:
            let fp0: str = files[ci0]
            if !seqContainsStr(typeFiles, fp0):
                add(typeFiles, fp0)

    for tf0 in 0..<typeFiles.len:
        let filePath: str = typeFiles[tf0]
        if filePath == nil || len(filePath) == 0:
            return Err[UirCoreModule]("uirCore_builder: empty file path")
        if ! frontend_lib.stage1_fileExists(filePath):
            return Err[UirCoreModule]("uirCore_builder: import file not found")
        let content: str = frontend_lib.stage1_readFile(filePath)
        var root: Node = nil
        if !uirCoreParseModuleWithLoweredTypes(filePath, content, &root):
            releaseNodeArena()
            return Err[UirCoreModule]("uirCore_builder: stage1 errors")
        uirCorePredeclareGlobalsForTypes(mod, root)
        let tdRes: Result[bool] = uirCoreConsumeTypeDecls(mod, root)
        if ! IsOk[bool](tdRes):
            releaseNodeArena()
            return ErrInfo[UirCoreModule](ErrorInfoOf[bool](tdRes))
        releaseNodeArena()

    # Pass 2: predeclare function signatures across all files first.
    for fi in 0..<files.len:
        let filePath: str = files[fi]
        if filePath == nil || len(filePath) == 0:
            return Err[UirCoreModule]("uirCore_builder: empty file path")
        if ! frontend_lib.stage1_fileExists(filePath):
            return Err[UirCoreModule]("uirCore_builder: import file not found")
        let content: str = frontend_lib.stage1_readFile(filePath)
        var root: Node = nil
        if !uirCoreParseModuleWithLoweredTypes(filePath, content, &root):
            releaseNodeArena()
            return Err[UirCoreModule]("uirCore_builder: stage1 errors")
        for pi in 0..<kidCount(root):
            let n: Node = kid(root, pi)
            let stmtPath: str = (n != nil && n.strVal != nil && len(n.strVal) > 0) ? n.strVal : root.strVal
            let res: Result[bool] = uirCorePredeclareTopLevelFromRoot(mod, root, stmtPath, n, nil)
            if !IsOk[bool](res):
                releaseNodeArena()
                return ErrInfo[UirCoreModule](ErrorInfoOf[bool](res))
        releaseNodeArena()

    # Pass 3: lower all top-level declarations now that types + signatures exist.
    for fi2 in 0..<files.len:
        let filePath: str = files[fi2]
        if filePath == nil || len(filePath) == 0:
            return Err[UirCoreModule]("uirCore_builder: empty file path")
        if ! frontend_lib.stage1_fileExists(filePath):
            return Err[UirCoreModule]("uirCore_builder: import file not found")
        let content: str = frontend_lib.stage1_readFile(filePath)
        var root: Node = nil
        if !uirCoreParseModuleWithLoweredTypes(filePath, content, &root):
            releaseNodeArena()
            return Err[UirCoreModule]("uirCore_builder: stage1 errors")
        for ti in 0..<kidCount(root):
            let n: Node = kid(root, ti)
            let stmtPath: str = (n != nil && n.strVal != nil && len(n.strVal) > 0) ? n.strVal : root.strVal
            let res: Result[bool] = uirCoreConsumeTopLevelFromRoot(mod, ctx, root, stmtPath, n, nil)
            if ! IsOk[bool](res):
                releaseNodeArena()
                return ErrInfo[UirCoreModule](ErrorInfoOf[bool](res))
        releaseNodeArena()
    let allowNoMain: bool = envIsTrue "BACKEND_ALLOW_NO_MAIN" || backendAllowNoMainByEmit()
    if ! ctx.foundMain && !allowNoMain:
        return Err[UirCoreModule]("uirCore_builder: main not found")

    if ctx.globalInits.len > 0 && !backendSkipGlobalInit():
        let initRes: Result[UirCoreFunc] = uirCoreBuildGlobalInitFunc(mod, ctx)
        if !IsOk[UirCoreFunc](initRes):
            return ErrInfo[UirCoreModule](ErrorInfoOf[UirCoreFunc](initRes))
        uirCoreAddFunc(mod, Value[UirCoreFunc](initRes))
        if ctx.foundMain:
            uirCoreInjectGlobalInitCall(mod, "__cheng_global_init")

    uirCoreApplyUirPluginHooks(path, mod)
    uirCoreNormalizeModule(mod)
    return Ok[UirCoreModule](mod)

fn uirCoreConsumeTopLevelFromRoot(mod: UirCoreModule, ctx: UirCoreBuildCtx, root: Node, filePath: str, n: Node,
                              reachable: hashsets.HashSetStr* = nil,
                              overloaded: hashsets.HashSetStr* = nil): Result[bool] =
    if n == nil || n.kind == nkEmpty:
        return Ok[bool](false)
    if n.kind == nkStmtList || n.kind == nkModule:
        let fallback: str = (filePath != nil && len(filePath) > 0) ? filePath : (root != nil ? root.strVal : "")
        for j in 0..<kidCount(n):
            let nn: Node = kid(n, j)
            let stmtPath: str = (nn != nil && nn.strVal != nil && len(nn.strVal) > 0) ? nn.strVal : fallback
            let res: Result[bool] = uirCoreConsumeTopLevelFromRoot(mod, ctx, root, stmtPath, nn, reachable, overloaded)
            if ! IsOk[bool](res):
                return res
        return Ok[bool](true)
    if n.kind == nkVar || n.kind == nkLet || n.kind == nkConst:
        var pat: Node = nil
        if kidCount(n) > 0:
            pat = kid(n, 0)
        var init: Node = nil
        if kidCount(n) > 2:
            init = kid(n, 2)
        var nameNode: Node = pat
        var typeNode: Node = nil
        if kidCount(n) > 1:
            typeNode = kid(n, 1)
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
            if kidCount(pat) > 1:
                typeNode = kid(pat, 1)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            return Err[bool]("uirCore_builder: global expects identifier")
        let rawName: str = backendStripSpaces(plainName(nameNode))
        let name: str = uirCoreMaybeMangleDupGlobalName(rawName, filePath)
        let debugDot: bool = (getEnv "BACKEND_DEBUG_DOT" == "1")
        if debugDot && rawName == "baseIdentity":
            var typeKindDbg: str = "nil"
            if typeNode != nil:
                typeKindDbg = intToStr(int32(typeNode.kind))
            echo("[backend] debugDot: consumeGlobal rawName='" + rawName +
                 "' file='" + filePath + "' typeKind=nk#" + typeKindDbg + "'")
        let existingGi: int32 = moduleGlobalIndex(mod, name)
        var allowDupGlobal: bool = false
        if existingGi >= 0:
            let g0: UirCoreGlobal = mod.globals[existingGi]
            allowDupGlobal = (g0.originFile == "<predeclared>")
        var declType: UirCoreType = uirCoreTypeFromNodeWithModule(mod, typeNode)
        var objTypeName: str = ""
        var objTypeNode: Node = typeNode
        if (objTypeNode == nil || objTypeNode.kind == nkEmpty) && init != nil && init.kind != nkEmpty &&
           init.typeCacheValid && init.typeCache != nil:
            objTypeNode = init.typeCache
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            objTypeName = typeNodeObjTypeName(mod, objTypeNode)
        let isObj: bool = len(objTypeName) > 0 && objTypeNode != nil && typeNodeIsObjValue(mod, objTypeNode)
        if debugDot && rawName == "baseIdentity":
            let objNodeKindDbg: str = (objTypeNode != nil) ? intToStr(int32(objTypeNode.kind)) : "nil"
            echo("[backend] debugDot: consumeGlobal name='" + name +
                 "' objTypeName='" + objTypeName + "' isObj=" + (isObj ? "1" : "0") +
                 " objNodeKind=nk#" + objNodeKindDbg + "'")
        if isObj:
            uirCoreGlobalObjTypePut(name, objTypeName)
            if debugDot && rawName == "baseIdentity":
                let chkObj: str = uirCoreGlobalObjTypeGet(name)
                echo("[backend] debugDot: consumeGlobal putObj name='" + name + "' objTypeName='" +
                     objTypeName + "' chkObj='" + chkObj + "'")
        if isObj:
            declType = uirCoreTypeI64()
        elif typeNode == nil || typeNode.kind == nkEmpty:
            declType = inferExprTypeWithGlobals(nil, mod, nil, init, declType)
        # Match stage1 C backend's global layout: store sub-32-bit scalars as i32 slots.
        # This keeps the MVP backend's global pipeline simple and avoids i8/i16-only data sections.
        if !isObj && (declType.kind == mtI8 || declType.kind == mtI16):
            let wasUnsigned: bool = declType.isUnsigned
            declType = uirCoreTypeI32()
            declType.isUnsigned = wasUnsigned

        if existingGi >= 0 && !allowDupGlobal && n.kind == nkConst && !isObj:
            var init0: Node = init
            while init0 != nil && init0.kind == nkPar && kidCount(init0) > 0:
                init0 = kid(init0, 0)
            let isLiteralInit: bool = init0 != nil &&
                (init0.kind == nkIntLit || init0.kind == nkBoolLit || init0.kind == nkNilLit)
            if isLiteralInit:
                let g0: UirCoreGlobal = mod.globals[existingGi]
                let prevFile: str = g0.originFile
                let prevSyntheticOrStd: bool = (prevFile != nil && len(prevFile) > 0) &&
                    (prevFile[0] == '<' || __cheng_string_contains_str(prevFile, "/src/std/") ||
                     __cheng_string_contains_str(prevFile, "/src/core/") || __cheng_string_contains_str(prevFile, "/src/system/"))
                let curSyntheticOrStd: bool = (filePath != nil && len(filePath) > 0) &&
                    (filePath[0] == '<' || __cheng_string_contains_str(filePath, "/src/std/") ||
                     __cheng_string_contains_str(filePath, "/src/core/") || __cheng_string_contains_str(filePath, "/src/system/"))
                if (prevSyntheticOrStd || curSyntheticOrStd) &&
                   g0.ty.kind == declType.kind && g0.ty.isUnsigned == declType.isUnsigned:
                    allowDupGlobal = true

        if moduleHasFunc(mod, name) || (existingGi >= 0 && !allowDupGlobal) ||
           uirCoreFindTypeAlias(mod, name) >= 0 || uirCoreFindObjType(mod, name) >= 0:
            let line0: str = intToStr(nameNode.pos.line)
            let col0: str = intToStr(nameNode.pos.col)
            var prevFile: str = ""
            if existingGi >= 0:
                let gPrev: UirCoreGlobal = mod.globals[existingGi]
                prevFile = gPrev.originFile
            return Err[bool]("uirCore_builder: duplicate global name: " + name +
                             " (prev=" + prevFile + " cur=" + filePath + ":" + line0 + ":" + col0 + ")")

        var hasInit: bool = false
        var initVal: int64 = 0

        if isObj:
            # Object globals are represented as pointers to heap storage; initialize at runtime.
            hasInit = false
            initVal = 0
            let sfi: SeqFixedInit = seqFixedInitInfo(typeNode)
            ctxAddGlobalInit(ctx, name, declType, objTypeName, init, filePath, sfi.elemType, sfi.capExpr)
        elif init != nil && init.kind != nkEmpty:
            # Scalar globals: allow static init for simple literals; otherwise defer to runtime init.
            if init.kind == nkIntLit:
                hasInit = true
                initVal = init.intVal
            elif init.kind == nkBoolLit:
                hasInit = true
                let v: str = backendStripSpaces(init.ident)
                initVal = (v == "true") ? 1 : 0
            elif init.kind == nkNilLit:
                hasInit = true
                initVal = 0
            else:
                hasInit = false
                initVal = 0
                ctxAddGlobalInit(ctx, name, declType, "", init, filePath)

        if existingGi >= 0 && allowDupGlobal:
            var gOut: UirCoreGlobal
            gOut.name = uirCoreOwnStr(name)
            gOut.ty = declType
            gOut.init = initVal
            gOut.hasInit = hasInit
            gOut.originFile = uirCoreOwnStr(filePath)
            mbWriteGlobal(mod.globals, existingGi, gOut)
        else:
            uirCoreAddGlobal(mod, name, declType, initVal, hasInit, filePath)

        var keyOut: str = ""
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            keyOut = typeKey(objTypeNode)
            if keyOut == nil || len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(objTypeNode)
        if len(keyOut) == 0 && typeNode != nil && typeNode.kind != nkEmpty:
            keyOut = typeKey(typeNode)
            if keyOut == nil || len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(typeNode)
        if len(keyOut) == 0 && init != nil && init.kind != nkEmpty:
            var initKeyNode: Node = init
            while initKeyNode != nil && initKeyNode.kind == nkPar && kidCount(initKeyNode) > 0:
                initKeyNode = kid(initKeyNode, 0)
            if initKeyNode != nil && initKeyNode.typeCacheValid && initKeyNode.typeCache != nil:
                keyOut = typeKey initKeyNode.typeCache
            elif initKeyNode != nil && initKeyNode.kind == nkStrLit:
                keyOut = "str"
            elif initKeyNode != nil && initKeyNode.kind == nkFloatLit:
                keyOut = "float64"
            elif initKeyNode != nil && initKeyNode.kind == nkBoolLit:
                keyOut = "bool"
            elif initKeyNode != nil && initKeyNode.kind == nkCharLit:
                keyOut = "char"
            elif initKeyNode != nil && initKeyNode.kind == nkIntLit:
                if declType.kind == mtI64:
                    keyOut = declType.isUnsigned ? "uint64" : "int64"
                elif declType.kind == mtI32:
                    keyOut = declType.isUnsigned ? "uint32" : "int32"
                elif declType.kind == mtF64:
                    keyOut = "float64"
                elif declType.kind == mtF32:
                    keyOut = "float32"
                elif declType.kind == mtI16:
                    keyOut = declType.isUnsigned ? "uint16" : "int16"
                elif declType.kind == mtI8:
                    keyOut = declType.isUnsigned ? "uint8" : "int8"
        if keyOut != nil && len(keyOut) > 0:
            uirCoreGlobalTypeKeyPut(name, keyOut)
            if debugDot && rawName == "baseIdentity":
                let chkKey: str = uirCoreGlobalTypeKeyGet(name)
                echo("[backend] debugDot: consumeGlobal putKey name='" + name +
                     "' keyOut='" + keyOut + "' chkKey='" + chkKey + "'")
        if ctx != nil && ctx.traceEnabled:
            ctx.traceGlobalCount = ctx.traceGlobalCount + 1
            if (ctx.traceGlobalCount % 200) == 0:
                stage1Trace("backend: uir globals=" + intToStr(ctx.traceGlobalCount) + " last=" + name)
        return Ok[bool](true)
    if n.kind == nkFnDecl || n.kind == nkIteratorDecl:
        if reachable != nil:
            let nameNode: Node = kid(n, 0)
            if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                let nm: str = backendStripSpaces(plainName(nameNode))
                if !hashsets.hashSetStrHas(*reachable, nm):
                    return Ok[bool](false)
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            return Ok[bool](false)
        let fRes: Result[UirCoreFunc] = uirCoreBuildFunc(mod, n, filePath, overloaded)
        if ! IsOk[UirCoreFunc](fRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreFunc](fRes))
        let f: UirCoreFunc = Value[UirCoreFunc](fRes)
        if f == nil:
            return Ok[bool](false)
        # Predeclare pass inserts header-only entries first. Always try
        # same-file replacement before duplicate-name checks so stale caches
        # cannot leave body-less declarations in the final module.
        var sameFileIdx: int32 = -1
        for di in 0..<mod.funcs.len:
            let ex: UirCoreFunc = mod.funcs[di]
            if ex != nil && (ex.name == f.name) && (ex.originFile == f.originFile):
                sameFileIdx = di
                break
        if sameFileIdx >= 0:
            let ex2: UirCoreFunc = mod.funcs[sameFileIdx]
            if ex2 == nil || ex2.blocks.len == 0:
                mbWriteFunc(mod.funcs, sameFileIdx, f)
                if (f.name == "main"):
                    if ctx != nil && ctx.foundMain:
                        return Err[bool]("uirCore_builder: multiple main functions")
                    if ctx != nil:
                        ctx.foundMain = true
                if ctx != nil && ctx.traceEnabled:
                    ctx.traceFnCount = ctx.traceFnCount + 1
                    if (ctx.traceFnCount % 50) == 0:
                        stage1Trace("backend: uir funcs=" + intToStr(ctx.traceFnCount) + " last=" + f.name)
                return Ok[bool](true)
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name)
        if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
           uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name)
        if (f.name == "main"):
            if ctx != nil && ctx.foundMain:
                return Err[bool]("uirCore_builder: multiple main functions")
            if ctx != nil:
                ctx.foundMain = true
        uirCoreAddFunc(mod, f)
        if ctx != nil && ctx.traceEnabled:
            ctx.traceFnCount = ctx.traceFnCount + 1
            if (ctx.traceFnCount % 50) == 0:
                stage1Trace("backend: uir funcs=" + intToStr(ctx.traceFnCount) + " last=" + f.name)
        return Ok[bool](true)
    return Ok[bool](false)

fn uirCorePredeclareTopLevelFromRoot(mod: UirCoreModule, root: Node, filePath: str, n: Node,
                                 reachable: hashsets.HashSetStr* = nil,
                                 overloaded: hashsets.HashSetStr* = nil): Result[bool] =
    if mod == nil || n == nil || n.kind == nkEmpty:
        return Ok[bool](false)
    if n.kind == nkStmtList || n.kind == nkModule:
        let fallback: str = (filePath != nil && len(filePath) > 0) ? filePath : (root != nil ? root.strVal : "")
        for j in 0..<kidCount(n):
            let nn: Node = kid(n, j)
            let stmtPath: str = (nn != nil && nn.strVal != nil && len(nn.strVal) > 0) ? nn.strVal : fallback
            let res: Result[bool] = uirCorePredeclareTopLevelFromRoot(mod, root, stmtPath, nn, reachable, overloaded)
            if !IsOk[bool](res):
                return res
        return Ok[bool](true)
    if n.kind == nkFnDecl || n.kind == nkIteratorDecl:
        if reachable != nil:
            let nameNode: Node = kid(n, 0)
            if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                let nm: str = backendStripSpaces(plainName(nameNode))
                if !hashsets.hashSetStrHas(*reachable, nm):
                    return Ok[bool](false)
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            return Ok[bool](false)
        let fRes: Result[UirCoreFunc] = uirCoreBuildFuncHeader(mod, n, filePath, overloaded)
        if !IsOk[UirCoreFunc](fRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreFunc](fRes))
        let f: UirCoreFunc = Value[UirCoreFunc](fRes)
        if f == nil:
            return Ok[bool](false)
        if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
           uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
            var sameFile: bool = false
            var prevFile: str = ""
            for di in 0..<mod.funcs.len:
                let ex: UirCoreFunc = mod.funcs[di]
                if ex != nil && (ex.name == f.name):
                    if (ex.originFile == f.originFile):
                        sameFile = true
                        break
                    let exFile: str = ex.originFile
                    if len prevFile == 0 && exFile != nil && len exFile > 0:
                        prevFile = exFile
            if sameFile:
                return Ok[bool](false)
            if len prevFile > 0:
                return Err[bool]("uirCore_builder: duplicate function name: " + f.name + " (files: " + prevFile + ", " + f.originFile + ")")
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name + " (file: " + f.originFile + ")")
        uirCoreAddFunc(mod, f)
        return Ok[bool](true)
    return Ok[bool](false)

fn uirCoreBuildGlobalInitFunc(mod: UirCoreModule, ctx: UirCoreBuildCtx): Result[UirCoreFunc] =
    if mod == nil || ctx == nil || ctx.globalInits.len == 0:
        return Err[UirCoreFunc]("uirCore_builder: no global init work")
    let initName: str = "__cheng_global_init"
    if moduleHasFunc(mod, initName) || moduleHasGlobal(mod, initName) ||
       uirCoreFindTypeAlias(mod, initName) >= 0 || uirCoreFindObjType(mod, initName) >= 0:
        return Err[UirCoreFunc]("uirCore_builder: global init name conflicts: " + initName)
    let f: UirCoreFunc = uirCoreNewFunc(initName, uirCoreTypeVoid())
    f.originFile = uirCoreOwnStr("<global_init>")
    let env: LocalEnv = localEnvNew()
    let b: BlockBuilder = blockBuilderNew(env, mod, f)

    # 1) Scalar globals: store value to the global slot.
    for i in 0..<ctx.globalInits.len:
        let gi: UirCoreGlobalInit = ctx.globalInits[i]
        if gi != nil && (gi.objTypeName == nil || len(gi.objTypeName) == 0):
            let init0: Node = gi.initNode
            if init0 != nil && init0.kind != nkEmpty:
                let valRes: Result[UirCoreExpr] = lowerExprValue(b, init0, gi.ty)
                if !IsOk[UirCoreExpr](valRes):
                    return ErrInfo[UirCoreFunc](ErrorInfoOf[UirCoreExpr](valRes))
                add(b.currentStmts, uirCoreStmtStore(uirCoreGlobalAddr(gi.name), Value[UirCoreExpr](valRes), gi.ty))

    # 2) Object globals: allocate heap storage, zero it, and store the pointer.
    for i in 0..<ctx.globalInits.len:
        let gi2: UirCoreGlobalInit = ctx.globalInits[i]
        if gi2 != nil && gi2.objTypeName != nil && len(gi2.objTypeName) > 0:
            let ot: UirCoreObjType = uirCoreGetObjType(mod, gi2.objTypeName)
            if ot.size <= 0:
                return Err[UirCoreFunc]("uirCore_builder: global init missing object layout: " + gi2.objTypeName)
            let tmpName: str = blockBuilderNextTemp(b, "__gobj")
            let tmpSlot: int32 = localAdd(env, tmpName, uirCoreTypeI64())
            uirCoreSetLocalType(f, tmpSlot, uirCoreTypeI64())
            var allocArgs: UirCoreExpr[]
            add(allocArgs, uirCoreConstI64(int64(ot.size)))
            add(b.currentStmts, uirCoreStmtLet(tmpName, tmpSlot, uirCoreCall("alloc", allocArgs)))
            var zeroArgs: UirCoreExpr[]
            add(zeroArgs, uirCoreLocal(tmpSlot))
            add(zeroArgs, uirCoreConstI64(0))
            add(zeroArgs, uirCoreConstI64(int64(ot.size)))
            add(b.currentStmts, uirCoreStmtExpr(uirCoreCall("setMem", zeroArgs)))
            if gi2.seqFixedElemType != nil && gi2.seqFixedCapExpr != nil:
                var sfi: SeqFixedInit
                sfi.elemType = gi2.seqFixedElemType
                sfi.capExpr = gi2.seqFixedCapExpr
                let seqInitRes: Result[bool] = emitSeqFixedReserveInitToPtr(b, uirCoreLocal(tmpSlot), sfi)
                if !IsOk[bool](seqInitRes):
                    return ErrInfo[UirCoreFunc](ErrorInfoOf[bool](seqInitRes))
            add(b.currentStmts, uirCoreStmtStore(uirCoreGlobalAddr(gi2.name), uirCoreLocal(tmpSlot), uirCoreTypeI64()))

    # 3) Object globals: run initializer calls (if any) into the allocated storage.
    for i in 0..<ctx.globalInits.len:
        let gi3: UirCoreGlobalInit = ctx.globalInits[i]
        if gi3 != nil && gi3.objTypeName != nil && len(gi3.objTypeName) > 0:
            let init1: Node = gi3.initNode
            if init1 != nil && init1.kind != nkEmpty:
                var initCore: Node = init1
                while initCore != nil && initCore.kind == nkPar && kidCount(initCore) > 0:
                    initCore = kid(initCore, 0)
                if initCore == nil || initCore.kind != nkCall:
                    return Err[UirCoreFunc]("uirCore_builder: global object init expects call: " + gi3.name)
                let lead: UirCoreExpr = uirCoreLoad(uirCoreGlobalAddr(gi3.name), uirCoreTypeI64())
                let callRes: Result[UirCoreExpr] = lowerCallWithLeadingArg(b, initCore, lead)
                if !IsOk[UirCoreExpr](callRes):
                    return ErrInfo[UirCoreFunc](ErrorInfoOf[UirCoreExpr](callRes))

    blockBuilderFinish(b, uirCoreTermRet(nil))
    return Ok[UirCoreFunc](f)

fn uirCoreInjectGlobalInitCall(mod: UirCoreModule, initName: str) =
    if mod == nil || initName == nil || len(initName) == 0:
        return
    let dbgGlobalInit: bool = (getEnv "BACKEND_DEBUG_GLOBAL_INIT" == "1")
    for i in 0..<mod.funcs.len:
        let f: UirCoreFunc = mod.funcs[i]
        let nameNorm: str = backendStripSpaces((f != nil) ? f.name : "")
        let linkNorm: str = backendStripSpaces((f != nil) ? f.linkName : "")
        let nameIsMain: bool = (nameNorm != nil && len(nameNorm) == 4 &&
                                nameNorm[0] == 'm' && nameNorm[1] == 'a' &&
                                nameNorm[2] == 'i' && nameNorm[3] == 'n')
        let linkIsMain: bool = (linkNorm != nil && len(linkNorm) == 4 &&
                                linkNorm[0] == 'm' && linkNorm[1] == 'a' &&
                                linkNorm[2] == 'i' && linkNorm[3] == 'n')
        if dbgGlobalInit && f != nil &&
           (uirCoreStrIndexOf(f.name, "main") >= 0 ||
            (f.linkName != nil && uirCoreStrIndexOf(f.linkName, "main") >= 0)):
            echo("[backend] debugGlobalInit: cand name='" + f.name +
                 "' link='" + f.linkName +
                 "' extern=" + (f.isExtern ? "1" : "0") +
                 " blocks=" + intToStr(f.blocks.len) +
                 " nameIsMain=" + (nameIsMain ? "1" : "0") +
                 " linkIsMain=" + (linkIsMain ? "1" : "0"))
        if f != nil && !f.isExtern &&
           (nameIsMain || linkIsMain) &&
           f.blocks.len > 0:
            let entry: UirCoreBlock = f.blocks[0]
            if entry == nil:
                if dbgGlobalInit:
                    echo("[backend] debugGlobalInit: main entry nil")
                return

            # Insert after initial parameter loads so argc/argv survive the init call.
            for insertAt in 0..<entry.stmts.len:
                let st: UirCoreStmt = entry.stmts[insertAt]
                if st.kind != msParam:
                    break

            if insertAt < entry.stmts.len:
                let s0: UirCoreStmt = entry.stmts[insertAt]
                if s0.kind == msExpr:
                    let e0: UirCoreExpr = s0.expr
                    if e0 != nil && e0.kind == meCall && (e0.callee == initName):
                        if dbgGlobalInit:
                            echo("[backend] debugGlobalInit: already inserted at=" + intToStr(insertAt))
                        return

            var args: UirCoreExpr[]
            let call: UirCoreExpr = uirCoreCall(initName, args)
            let stmt: UirCoreStmt = uirCoreStmtExpr(call)
            var out: UirCoreStmt[]
            for si in 0..<entry.stmts.len:
                if si == insertAt:
                    add(out, stmt)
                add(out, entry.stmts[si])
            if insertAt == entry.stmts.len:
                add(out, stmt)
            entry.stmts = out
            if dbgGlobalInit:
                echo("[backend] debugGlobalInit: inserted at=" + intToStr(insertAt) +
                     " total=" + intToStr(entry.stmts.len))
            return
    if dbgGlobalInit:
        echo("[backend] debugGlobalInit: main not found")

fn uirCoreBuildModuleFromRoot(rootInput: Node): Result[UirCoreModule] =
    if rootInput == nil:
        return Err[UirCoreModule]("uirCore_builder: empty root")
    var root: Node = rootInput
    let rootTag: str = rootInput.strVal
    let astRoot: Node = uirCoreApplyAstPluginHooks(rootTag, root)
    if astRoot == nil:
        return Err[UirCoreModule]("uirCore_builder: ast plugin rejected root module")
    let pluginRoot: Node = uirCoreApplyMirPluginHooks(rootTag, astRoot)
    if pluginRoot == nil:
        return Err[UirCoreModule]("uirCore_builder: mir plugin rejected root module")
    root = pluginRoot
    let prof: UirCoreProfileState = uirCoreProfileInit()
    let dbgLower: bool = (os.getEnvDefault("BACKEND_DEBUG_MIR_LOWER", "") == "1")
    let dbgSummary: bool = (os.getEnvDefault("BACKEND_DEBUG_MODULE_SUMMARY", "") == "1")
    uirCoreGlobalObjTypesReset()
    uirCoreGlobalTypeKeysReset()
    uirCoreInlineObjFieldTypesReset()
    uirCoreObjFieldTypeKeysReset()
    uirCoreTupleFieldIndicesReset()
    uirCoreObjAliasesReset()
    uirCoreCalleeCandidatesReset()
    let mod: UirCoreModule = uirCoreNewModule("arm64-apple-darwin")
    uirCoreProfileStep(prof, "reset")
    var ctx: UirCoreBuildCtx
    new ctx
    ctx.foundMain = false
    ctx.traceEnabled = stage1TraceEnabled()
    ctx.traceFnCount = 0
    ctx.traceGlobalCount = 0
    if ctx.traceEnabled:
        stage1Trace("backend: uir build start files=" + intToStr(kidCount(root)))
    ctx.overloadedFnBases = uirCoreComputeOverloadedFnBases(root)
    uirCoreDupFnBases = uirCoreComputeDuplicateFnBases(root, &ctx.overloadedFnBases)
    uirCoreDupFnBasesReady = true
    uirCoreDupGlobalNames = uirCoreComputeDuplicateGlobalNames(root)
    uirCoreDupGlobalNamesReady = true
    uirCoreProfileStep(prof, "dups")
    ctx.globalInits = []
    ensureBuiltinObjTypes(mod)
    if (getEnv "BACKEND_DEBUG_TYPES" == "1"):
        let hs: str = uirCoreHasObjType(mod, "seq") ? "1" : "0"
        let ht: str = uirCoreHasObjType(mod, "Table") ? "1" : "0"
        echo("[backend] debug: builtin_obj_after_ensure seq=" + hs + " table=" + ht)
    uirCorePredeclareGlobalsForTypes(mod, root)
    uirCoreProfileStep(prof, "predeclare_globals_for_types")
    let tdRes: Result[bool] = uirCoreConsumeTypeDecls(mod, root)
    if ! IsOk[bool](tdRes):
        return ErrInfo[UirCoreModule](ErrorInfoOf[bool](tdRes))
    uirCoreProfileStep(prof, "consume_type_decls")
    uirCorePredeclareGlobalsForLowering(mod, root)
    uirCoreProfileStep(prof, "predeclare_globals_for_lowering")
    var reachable: hashsets.HashSetStr
    var reachablePtr: hashsets.HashSetStr* = nil
    let wholeProgramRaw: str = lowerAscii(backendStripSpaces(os.getEnvDefault("BACKEND_WHOLE_PROGRAM", "1")))
    let wholeProgram: bool = !(wholeProgramRaw == "0" || wholeProgramRaw == "false" ||
                               wholeProgramRaw == "no" || wholeProgramRaw == "off")
    if !wholeProgram:
        reachable = uirCoreComputeReachableFns(mod, root)
        reachablePtr = &reachable
    uirCoreProfileStep(prof, "reachable")
    # Predeclare function signatures so lowering can infer object returns across order boundaries.
    var lastFilePath: str = root.strVal
    let rootKidCount: int32 = kidCount(root)
    for pi in 0..<kidCount(root):
        let n: Node = kid(root, pi)
        let ownPath: str = (n != nil && n.strVal != nil && len(n.strVal) > 0) ? n.strVal : ""
        if ownPath != nil && len(ownPath) > 0:
            lastFilePath = ownPath
        let filePath: str = (ownPath != nil && len(ownPath) > 0) ? ownPath : lastFilePath
        if ctx.traceEnabled:
            stage1Trace("backend: uir predeclare " + intToStr(pi + 1) + "/" + intToStr(rootKidCount) + " file=" + filePath)
        let res: Result[bool] = uirCorePredeclareTopLevelFromRoot(mod, root, filePath, n, reachablePtr, &ctx.overloadedFnBases)
        if !IsOk[bool](res):
            return ErrInfo[UirCoreModule](ErrorInfoOf[bool](res))
    uirCoreProfileStep(prof, "predeclare_top_level")
    if dbgSummary:
        echo("[uir] predeclare funcs=" + intToStr(mod.funcs.len) +
             " globals=" + intToStr(mod.globals.len) +
             " cstrs=" + intToStr(mod.cstrs.len))
    lastFilePath = root.strVal
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        let ownPath2: str = (n != nil && n.strVal != nil && len(n.strVal) > 0) ? n.strVal : ""
        if ownPath2 != nil && len(ownPath2) > 0:
            lastFilePath = ownPath2
        let filePath: str = (ownPath2 != nil && len(ownPath2) > 0) ? ownPath2 : lastFilePath
        if dbgLower:
            var nameDbg: str = ""
            var kindDbg: int32 = -1
            if n != nil:
                kindDbg = int32(n.kind)
                if (n.kind == nkFnDecl || n.kind == nkIteratorDecl || n.kind == nkTypeDecl ||
                    n.kind == nkConceptDecl || n.kind == nkTraitDecl) && kidCount(n) > 0:
                    let nameNode: Node = kid(n, 0)
                    if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                        nameDbg = backendStripSpaces(plainName(nameNode))
            let fDbg: os.File = os.get_stderr()
            os.write(fDbg, "uirCore_lower_dbg\t")
            os.write(fDbg, intToStr(i + 1))
            os.write(fDbg, "/")
            os.write(fDbg, intToStr(rootKidCount))
            os.write(fDbg, "\tfile=")
            os.write(fDbg, filePath)
            os.write(fDbg, "\tkind=nk#")
            os.write(fDbg, intToStr(kindDbg))
            if len(nameDbg) > 0:
                os.write(fDbg, "\tname=")
                os.write(fDbg, nameDbg)
            os.writeLine(fDbg, "")
            os.c_fflush fDbg
        if ctx.traceEnabled:
            stage1Trace("backend: uir lower " + intToStr(i + 1) + "/" + intToStr(rootKidCount) + " file=" + filePath)
        let res: Result[bool] = uirCoreConsumeTopLevelFromRoot(mod, ctx, root, filePath, n, reachablePtr, &ctx.overloadedFnBases)
        if ! IsOk[bool](res):
            let info0: ErrorInfo = ErrorInfoOf[bool](res)
            let msg0: str = ErrorFormat(info0)
            if msg0 == nil || len(msg0) == 0 || msg0 == "error":
                var kindDbg: int32 = -1
                var nameDbg: str = ""
                var lineDbg: str = "0"
                var colDbg: str = "0"
                if n != nil:
                    kindDbg = int32(n.kind)
                    lineDbg = intToStr(n.pos.line)
                    colDbg = intToStr(n.pos.col)
                    if kidCount(n) > 0:
                        let nameNodeDbg: Node = kid(n, 0)
                        if nameNodeDbg != nil && (nameNodeDbg.kind == nkIdent || nameNodeDbg.kind == nkSymbol):
                            nameDbg = backendStripSpaces(plainName(nameNodeDbg))
                return Err[UirCoreModule]("uirCore_builder: lower top-level failed file=" + filePath +
                    " idx=" + intToStr(i + 1) + "/" + intToStr(rootKidCount) +
                    " kind=nk#" + intToStr(kindDbg) +
                    " name=" + nameDbg +
                    " @" + lineDbg + ":" + colDbg)
            return ErrInfo[UirCoreModule](info0)
    uirCoreProfileStep(prof, "lower_top_level")
    if dbgSummary:
        echo("[uir] lower funcs=" + intToStr(mod.funcs.len) +
             " globals=" + intToStr(mod.globals.len) +
             " cstrs=" + intToStr(mod.cstrs.len))
    if ctx.traceEnabled:
        stage1Trace("backend: uir lower done funcs=" + intToStr(ctx.traceFnCount) +
            " globals=" + intToStr(ctx.traceGlobalCount) + " inits=" + intToStr(ctx.globalInits.len))
    let allowNoMain: bool = envIsTrue "BACKEND_ALLOW_NO_MAIN" || backendAllowNoMainByEmit()
    if ! ctx.foundMain && !allowNoMain:
        return Err[UirCoreModule]("uirCore_builder: main not found")

    if ctx.globalInits.len > 0 && !backendSkipGlobalInit():
        if ctx.traceEnabled:
            stage1Trace("backend: uir global_init build start")
        let initRes: Result[UirCoreFunc] = uirCoreBuildGlobalInitFunc(mod, ctx)
        if !IsOk[UirCoreFunc](initRes):
            return ErrInfo[UirCoreModule](ErrorInfoOf[UirCoreFunc](initRes))
        uirCoreAddFunc(mod, Value[UirCoreFunc](initRes))
        if ctx.foundMain:
            uirCoreInjectGlobalInitCall(mod, "__cheng_global_init")
        if ctx.traceEnabled:
            stage1Trace("backend: uir global_init build done")
    uirCoreProfileStep(prof, "global_init")
    if dbgSummary:
        echo("[uir] global_init funcs=" + intToStr(mod.funcs.len) +
             " globals=" + intToStr(mod.globals.len) +
             " cstrs=" + intToStr(mod.cstrs.len))

    if ctx.traceEnabled:
        stage1Trace("backend: uir fixups start")
    let fixRes: Result[bool] = uirCoreBuildMissingRoutinesFromUir(mod, root, &ctx.overloadedFnBases)
    if ! IsOk[bool](fixRes):
        return ErrInfo[UirCoreModule](ErrorInfoOf[bool](fixRes))
    if ctx.traceEnabled:
        stage1Trace("backend: uir fixups done")
        stage1Trace("backend: uir normalize start")
    uirCoreProfileStep(prof, "fixups")
    if dbgSummary:
        echo("[uir] fixups funcs=" + intToStr(mod.funcs.len) +
             " globals=" + intToStr(mod.globals.len) +
             " cstrs=" + intToStr(mod.cstrs.len))
    uirCoreApplyUirPluginHooks(rootTag, mod)
    uirCoreNormalizeModule(mod)
    if dbgSummary:
        echo("[uir] normalize funcs=" + intToStr(mod.funcs.len) +
             " globals=" + intToStr(mod.globals.len) +
             " cstrs=" + intToStr(mod.cstrs.len))
    if ctx.traceEnabled:
        stage1Trace("backend: uir normalize done")
    uirCoreProfileStep(prof, "normalize")
    # Optional memory-pressure release for selfhost bootstrap bring-up.
    # Keep default off because some stage0/compat combinations still depend on
    # arena-backed string lifetimes during downstream codegen.
    if envIsTrue "STAGE1_RELEASE_ARENA_AFTER_BUILD":
        releaseNodeArena()
        releaseLexStrings()
    return Ok[UirCoreModule](mod)

fn uirCoreBuildModuleFromFileStage1(inPath: str): Result[UirCoreModule] =
    if len(inPath) == 0:
        return Err[UirCoreModule]("uirCore_builder: empty path")
    let dbgPipe: bool = (os.getEnvDefault("BACKEND_DEBUG_STAGE1_PIPE", "") == "1")
    var dbgFile: os.File = nil
    if dbgPipe:
        dbgFile = os.get_stderr()
        os.writeLine(dbgFile, "[backend] stage1: enter")
        os.c_fflush dbgFile
    # Keep node/lex pools alive for MIR/codegen string ownership.
    releaseNodeArena()
    releaseLexStrings()
    initNodeArena()
    initLexStringPool()
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: pools_ready")
        os.c_fflush dbgFile

    if ! frontend_lib.stage1_fileExists(inPath):
        return Err[UirCoreModule]("uirCore_builder: input file not found")
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: file_exists_ok")
        os.c_fflush dbgFile

    let profOn: bool = envIsTrue "STAGE1_PROFILE"
    var profStart: int64 = 0
    if profOn:
        profStart = cheng_monotime_ns()
    var profMark: int64 = 0
    var profLex: int64 = 0
    var profLoad: int64 = 0
    var profSem: int64 = 0
    var profMono: int64 = 0
    var profOwn: int64 = 0

    if profOn:
        profMark = cheng_monotime_ns()
    # Avoid unconditional string concat during bootstrap (stage0-built stage1 can miscompile
    # large init-time concatenations and crash before any diagnostics).
    stage1Trace "internal: lex+parse"
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: lex_parse_start")
        os.c_fflush dbgFile
    let size: int64 = fileSize inPath
    let mtime: int64 = fileMtime inPath
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: file_meta_ok")
        os.c_fflush dbgFile
    var tokens: Token[]
    var lexDiags: Diagnostic[]
    lexDiags.buffer = nil
    lexDiags.len = 0
    lexDiags.cap = 0
    let cacheRes: TokenCacheResult = loadTokenCache(inPath, size, mtime)
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: token_cache_checked")
        os.c_fflush dbgFile
    if cacheRes.hit:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: token_cache_hit")
            os.c_fflush dbgFile
        tokens = cacheRes.tokens
    else:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: token_cache_miss")
            os.c_fflush dbgFile
        let content: str = frontend_lib.stage1_readFile(inPath)
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: file_read_done")
            os.c_fflush dbgFile
        if (content == ""):
            return Err[UirCoreModule]("uirCore_builder: unable to read input file")
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: lex_start")
            os.c_fflush dbgFile
        let lexRes: LexResult = lex(content, inPath)
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: lex_done")
            os.c_fflush dbgFile
        releaseString content
        tokens = lexRes.tokens
        lexDiags = lexRes.diagnostics
    var diags: Diagnostic[]
    diags.buffer = nil
    diags.len = 0
    diags.cap = 16
    if lexDiags.len > 0:
        appendDiagnostics(&diags, lexDiags)
    else:
        if ! cacheRes.hit:
            writeTokenCache(inPath, size, mtime, tokens)
    dumpTokens(inPath, tokens)
    let userRoot: Node = parseModuleWithDiagnostics(tokens, inPath, &diags)
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: parsed_user_module")
        os.c_fflush dbgFile
    tokens = []
    lexDiags = []

    if userRoot != nil:
        let inPathTag: str = normalizeImportPath inPath
        if envIsTrue "STAGE1_TRACE_IMPORTS":
            stage1Trace("import: inPathTag=" + inPathTag)
            stage1Trace("import: repoRoot=" + os.getCurrentDir())
        var tagPath: str = inPath
        if len inPathTag > 0:
            tagPath = inPathTag
        if len inPathTag > 0:
            nodeSetStrVal(userRoot, inPathTag)
        tagModuleChildren(userRoot, tagPath)

    if profOn:
        profLex = cheng_monotime_ns() - profMark
        profMark = cheng_monotime_ns()

    stage1Trace "internal: load system/imports"
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: imports_start")
        os.c_fflush dbgFile
    let repoRoot: str = os.getCurrentDir()
    var importVisited: StrSetList = strSetListInit(16)
    var importCache: NodeCache = nodeCacheInit(128)
    let sysRoot: Node = loadSystemModule(inPath, &diags)
    if sysRoot != nil:
        let sysResolved: str = resolveImportPath("system", "", repoRoot)
        if len sysResolved > 0:
            let sysCanon: str = canonicalizeResolvedPath(sysResolved, repoRoot)
            var sysTag: str = sysResolved
            if len sysCanon > 0:
                sysTag = sysCanon
            setAddStr(&importVisited, sysTag)
            tagModuleChildren(sysRoot, sysTag)
        else:
            tagModuleChildren(sysRoot, "src/std/system.cheng")
        var sysAliases: str[]
        sysAliases.buffer = nil
        sysAliases.len = 0
        sysAliases.cap = 8
        collectImportAliases(sysRoot, &sysAliases)
        if sysAliases.len > 0:
            lowerModuleQualifiers(sysRoot, sysAliases)
        let sysImported: Node[] = loadImports(sysRoot, "src/std", repoRoot, &diags, &importVisited,
            &importCache)
        for si in 0..<sysImported.len:
            addSon(sysRoot, sysImported[si])

    var root0: Node = nil
    if userRoot == nil:
        root0 = mergeModules(sysRoot, userRoot)
    else:
        let inParts: SplitFileResult = splitFile inPath
        let userDir: str = inParts.dir
        let imported: Node[] = loadImports(userRoot, userDir, repoRoot, &diags, &importVisited, &importCache)
        var aliases: str[]
        aliases.buffer = nil
        aliases.len = 0
        aliases.cap = 8
        collectImportAliases(userRoot, &aliases)
        if aliases.len > 0:
            lowerModuleQualifiers(userRoot, aliases)
        root0 = newNode(nkModule, userRoot.pos)
        nodeSetStrVal(root0, userRoot.strVal)
        nodeSetIdent(root0, userRoot.ident)
        if sysRoot != nil:
            for sj in 0..<kidCount sysRoot:
                addSon(root0, kid(sysRoot, sj))
        for ii in 0..<imported.len:
            addSon(root0, imported[ii])
        for ui in 0..<kidCount(userRoot):
            addSon(root0, kid(userRoot, ui))
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: imports_done")
        os.c_fflush dbgFile

    if profOn:
        profLoad = cheng_monotime_ns() - profMark
        profMark = cheng_monotime_ns()

    if uirCoreStage1StdNoPointerPrecheck(root0, inPath, diags):
        if hasError diags:
            printDiagnostics diags
        else:
            echo "std policy: pointer types are forbidden in standard library"
        return Err[UirCoreModule]("uirCore_builder: stage1 errors")
    if uirCoreStage1NoPointerNonCAbiPrecheck(root0, inPath, diags):
        if hasError diags:
            printDiagnostics diags
        else:
            echo "no-pointer policy: pointer types are forbidden outside C ABI modules"
        return Err[UirCoreModule]("uirCore_builder: stage1 errors")
    if uirCoreFileLikelyUsesRawSpawn(inPath):
        echo "spawn raw function pointer is forbidden in default API; use std/async_rt_legacy.spawn"
        return Err[UirCoreModule]("uirCore_builder: stage1 errors")
    type_syntax_lowering.lowerTypeSyntax(root0, &diags, inPath)
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: type_syntax_done")
        os.c_fflush dbgFile

    let ffiOutPtrLowered: bool = uirCoreLowerFfiOutPtrAnnotations(root0, &diags)
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: ffi_out_ptrs_lowered=" + (ffiOutPtrLowered ? "1" : "0"))
        os.c_fflush dbgFile
    if hasError diags:
        printDiagnostics diags
        return Err[UirCoreModule]("uirCore_builder: stage1 ffi_out_ptrs lowering failed")

    let mm0: str = memMode()
    let strictOn0: bool = orcStrictEnabled()
    let ownDiags: bool = ownershipDiagnosticsEnabled()
    let borrowIrMode: str = uirCoreBorrowIrNormalized()
    let genericLoweringMode: str = uirCoreGenericLoweringNormalized()
    if !uirCoreBorrowIrSupported(borrowIrMode):
        return Err[UirCoreModule]("uirCore_builder: invalid BORROW_IR (expected mir|stage1): " + borrowIrMode)
    if !uirCoreGenericLoweringSupported(genericLoweringMode):
        return Err[UirCoreModule]("uirCore_builder: invalid GENERIC_LOWERING (expected mir_hybrid|mir_dict): " + genericLoweringMode)
    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: borrow_ir=" + borrowIrMode)
        os.writeLine(dbgFile, "[backend] stage1: generic_lowering=" + genericLoweringMode)
        os.c_fflush dbgFile
    if envIsTrue "STAGE1_TRACE_IMPORTS":
        stage1Trace("import: mm=" + mm0)
        stage1Trace("import: mm_strict=" + (strictOn0 ? "1" : "0"))
        stage1Trace("import: own_diags=" + (ownDiags ? "1" : "0"))
        stage1Trace("import: borrow_ir=" + borrowIrMode)
        stage1Trace("import: generic_lowering=" + genericLoweringMode)
    let skipSem: bool = uirCoreIsOne(getEnv "STAGE1_SKIP_SEM")
    let skipMono: bool = uirCoreShouldSkipMonoPass()
    let mmIsOrc: bool = uirCoreIsOrcMode(mm0)
    if ! skipSem:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: semantics_start")
            os.c_fflush dbgFile
            os.writeLine(dbgFile, "[backend] stage1: semantics_pretrace")
            os.c_fflush dbgFile
        stage1Trace "internal: semantics"
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: semantics_precheck")
            os.c_fflush dbgFile
        checkSemantics(root0, diags, ownDiags, mmIsOrc && strictOn0)
        if profOn:
            profSem = cheng_monotime_ns() - profMark
            profMark = cheng_monotime_ns()
        if ownDiags && ownershipHintsEnabled() && mmIsOrc && strictOn0:
            if hasHint diags:
                printHints diags
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: semantics_done")
            os.c_fflush dbgFile
    else:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: semantics_skipped")
            os.c_fflush dbgFile

    stage1Trace "internal: monomorphize"
    var root: Node = root0
    if ! skipMono:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: mono_start")
            os.c_fflush dbgFile
        root = monomorphize(root0, &diags)
        if profOn:
            profMono = cheng_monotime_ns() - profMark
            profMark = cheng_monotime_ns()
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: mono_done")
            os.c_fflush dbgFile
    else:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: mono_skipped")
            os.c_fflush dbgFile
    if dbgPipe:
        let errFlag: bool = hasError(diags)
        os.writeLine(dbgFile, "[backend] stage1: mono_diag_count=" + intToStr(diags.len) +
                     " has_error=" + (errFlag ? "1" : "0"))
        if diags.len > 0:
            let d0: Diagnostic = diags[0]
            os.writeLine(dbgFile, "[backend] stage1: mono_diag0 sev=" + intToStr(int32(d0.severity)) +
                         " file='" + d0.filename +
                         "' line=" + intToStr(d0.line) +
                         " col=" + intToStr(d0.col) +
                         " msg='" + d0.message + "'")
        if root != nil && ! errFlag:
            var seenMonoNames: hashmaps.HashMapStrInt = hashmaps.hashMapStrIntInit(512)
            var dupMonoNames: int32 = 0
            for di in 0..<kidCount(root):
                let dn: Node = kid(root, di)
                if dn == nil || (dn.kind != nkFnDecl && dn.kind != nkIteratorDecl):
                    continue
                if kidCount(dn) <= 0:
                    continue
                let dname: str = backendStripSpaces(plainName(kid(dn, 0)))
                if dname == nil || len(dname) == 0:
                    continue
                var foundCnt: bool = false
                let rawCnt: int32 = uirCoreHashMapStrIntGetCompat(seenMonoNames, dname, foundCnt)
                let nextCnt: int32 = (foundCnt ? rawCnt : 0) + 1
                hashmaps.hashMapStrIntPut(seenMonoNames, dname, nextCnt)
                if foundCnt && rawCnt == 1 && dupMonoNames < 12:
                    os.writeLine(dbgFile, "[backend] stage1: mono_dup_fn '" + dname + "'")
                    dupMonoNames = dupMonoNames + 1
            os.writeLine(dbgFile, "[backend] stage1: mono_dup_fn_count=" + intToStr(dupMonoNames))
        os.c_fflush dbgFile
    if hasError diags:
        printDiagnostics diags
        return Err[UirCoreModule]("uirCore_builder: stage1 errors")

    let skipCProfile: bool = envIsTrue "STAGE1_SKIP_CPROFILE"
    if skipCProfile:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: c_profile_skipped")
            os.c_fflush dbgFile
    else:
        stage1Trace "internal: c-profile lowering"
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: c_profile_start")
            os.c_fflush dbgFile
        root = lowerCProfile(root, &diags)
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: c_profile_done")
            os.c_fflush dbgFile
        if hasError diags:
            printDiagnostics diags
            return Err[UirCoreModule]("uirCore_builder: c-profile lowering failed")
    let genericMode: str = uirCoreGenericModeNormalized()
    let genericBudget: int32 = uirCoreGenericSpecBudget()
    let forceMonoDict: bool = envIsTrue "STAGE1_FORCE_MONO_DICT"
    let forceMonoHybrid: bool = envIsTrue "STAGE1_FORCE_MONO_HYBRID"
    var monoAfterCProfile: bool = false
    if genericMode == "hybrid":
        monoAfterCProfile = forceMonoHybrid || genericBudget > 0
    elif genericMode == "dict" || genericMode == "dictionary":
        monoAfterCProfile = forceMonoDict
    else:
        # Keep non-standard mode behavior conservative for direct builder callers.
        monoAfterCProfile = true
    if !skipMono && !skipCProfile && monoAfterCProfile:
        # c_profile lowering can introduce new generic helper callsites
        # (e.g. Result/Option helpers). Run a second mono pass to ensure
        # all late-introduced generic calls are fully instantiated.
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: mono_after_cprofile_start")
            os.c_fflush dbgFile
        root = monomorphize(root, &diags)
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: mono_after_cprofile_done")
            os.c_fflush dbgFile
        if hasError diags:
            printDiagnostics diags
            return Err[UirCoreModule]("uirCore_builder: stage1 errors")
    elif dbgPipe && !skipMono:
        os.writeLine(dbgFile, "[backend] stage1: mono_after_cprofile_skipped")
        os.c_fflush dbgFile

    let arcOn: bool = arcEnabled()
    let skipOwnershipEnv: str = getEnv "STAGE1_SKIP_OWNERSHIP"
    # Ownership path currently remains unstable in stage0/driver bootstrap paths;
    # keep default skip-on unless caller explicitly sets STAGE1_SKIP_OWNERSHIP=0.
    let skipOwnership: bool = skipOwnershipEnv == nil || len(skipOwnershipEnv) == 0 || uirCoreIsOne(skipOwnershipEnv)
    let ownershipEngine: str = uirCoreOwnershipEngineNormalized()
    let borrowStageLabel: str = borrowIrMode == "mir" ? "mir_borrow" : "ownership"
    stage1Trace("internal: " + borrowStageLabel)
    if skipOwnership:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: " + borrowStageLabel + "_skipped")
            os.c_fflush dbgFile
        stage1Trace("internal: " + borrowStageLabel + " skipped")
        setOwnershipEnabled false
    else:
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: " + borrowStageLabel + "_start")
            os.writeLine(dbgFile, "[backend] stage1: " + borrowStageLabel + "_engine=" + ownershipEngine)
            os.c_fflush dbgFile
        if ownershipEngine == "legacy":
            setOwnershipEnabled arcOn
            ownershipAnalyze root
            setOwnershipEnabled false
            if profOn:
                profOwn = cheng_monotime_ns() - profMark
                profMark = cheng_monotime_ns()
        else:
            setOwnershipEnabled false
        if dbgPipe:
            os.writeLine(dbgFile, "[backend] stage1: " + borrowStageLabel + "_done")
            os.c_fflush dbgFile

    if profOn:
        var msg: str = "profile: lex="
        msg = msg + int64ToStr(profLex / 1000000)
        msg = msg + "ms load="
        msg = msg + int64ToStr(profLoad / 1000000)
        msg = msg + "ms sem="
        msg = msg + int64ToStr(profSem / 1000000)
        msg = msg + "ms mono="
        msg = msg + int64ToStr(profMono / 1000000)
        msg = msg + "ms ownership="
        msg = msg + int64ToStr(profOwn / 1000000)
        msg = msg + "ms borrow_ir="
        msg = msg + borrowIrMode
        msg = msg + " generic_lowering="
        msg = msg + genericLoweringMode
        msg = msg + " total="
        msg = msg + int64ToStr((cheng_monotime_ns() - profStart) / 1000000)
        msg = msg + "ms"
        let profLine: str = "[stage1] " + msg
        echo profLine

    if dbgPipe:
        os.writeLine(dbgFile, "[backend] stage1: uirCore_build_start")
        os.c_fflush dbgFile
    let uirCoreRes: Result[UirCoreModule] = uirCoreBuildModuleFromRoot(root)
    if !IsOk[UirCoreModule](uirCoreRes):
        let info0: ErrorInfo = ErrorInfoOf[UirCoreModule](uirCoreRes)
        let msg0: str = ErrorFormat(info0)
        if msg0 == nil || len(msg0) == 0 || msg0 == "error":
                return Err[UirCoreModule]("uirCore_builder: stage1 uir build failed (empty error) input=" + inPath)
    let mod: UirCoreModule = Value[UirCoreModule](uirCoreRes)
    let phaseStats: UirCorePhaseContractStats =
        uirCoreApplyOwnershipPhaseContract(mod, skipOwnership, borrowIrMode)
    if dbgPipe:
        let highChecked: int32 = uirCoreModuleCountHighUirCheckedFuncs(mod)
        let lowLowered: int32 = uirCoreModuleCountLowUirLoweredFuncs(mod)
        os.writeLine(dbgFile, "[backend] stage1: phase_contract_done high_uir_checked_funcs=" + intToStr(highChecked) +
                     " low_uir_lowered_funcs=" + intToStr(lowLowered) +
                     " high_uir_fallback_funcs=" + intToStr(phaseStats.highFallbackFuncs) +
                     " high_uir_unmapped_funcs=" + intToStr(phaseStats.highUnmappedFuncs) +
                     " high_uir_no_proof_funcs=" + intToStr(phaseStats.highNoProofFuncs))
        os.c_fflush dbgFile
    return Ok[UirCoreModule](mod)
