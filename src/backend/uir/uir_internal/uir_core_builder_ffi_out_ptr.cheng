# UIR core builder ffi_out_ptr lowering helpers (split from uir_core_builder).
import std/strutils
import stage1/ast
import stage1/diagnostics

fn ffiStripSpaces(s: str): str =
    if s == nil:
        return ""
    return strutils.strip(s)

fn ffiHasPrefix(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    let n: int32 = len(s)
    let m: int32 = len(prefix)
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[i] != prefix[i]:
            return false
    return true

fn uirCoreParseImportcAnnotation(ann: Node, hasImportc: bool*, importcLinkName: str*): bool =
    if ann == nil || ann.kind != nkAnnotation || kidCount(ann) == 0:
        return false
    let annName: str = ffiStripSpaces(plainName(kid(ann, 0)))
    if annName != "importc":
        return false
    if kidCount(ann) < 2:
        return false
    let arg0: Node = kid(ann, 1)
    if arg0 == nil || arg0.kind != nkStrLit:
        return false
    if hasImportc != nil:
        *hasImportc = true
    if importcLinkName != nil:
        *importcLinkName = arg0.strVal
    return true

fn uirCoreParseImportcLinkName(funcNode: Node, hasImportc: bool*, importcLinkName: str*) =
    if hasImportc != nil:
        *hasImportc = false
    if importcLinkName != nil:
        *importcLinkName = ""
    if funcNode == nil:
        return
    for ki in 0..<kidCount(funcNode):
        let kidNode: Node = kid(funcNode, ki)
        if kidNode != nil:
            if kidNode.kind == nkAnnotation:
                if uirCoreParseImportcAnnotation(kidNode, hasImportc, importcLinkName):
                    return
            elif kidNode.kind == nkPragma:
                for pi in 0..<kidCount(kidNode):
                    let ann2: Node = kid(kidNode, pi)
                    if uirCoreParseImportcAnnotation(ann2, hasImportc, importcLinkName):
                        return

fn uirCoreStage1AddDiag(diags: Diagnostic[]*, n: Node, msg: str) =
    if diags == nil:
        return
    var filePath: str = ""
    var line: int32 = 1
    var col: int32 = 1
    if n != nil:
        if n.strVal != nil && len(n.strVal) > 0:
            filePath = n.strVal
        line = n.pos.line
        col = n.pos.col
    addDiag(diags, svError, filePath, line, col, msg)

fn uirCoreTupleTypeCoreNode(typeNode0: Node): Node =
    var typeNode: Node = typeNode0
    while typeNode != nil && typeNode.kind == nkPar && kidCount(typeNode) > 0:
        typeNode = kid(typeNode, 0)
    if typeNode != nil && typeNode.kind == nkVarTy && kidCount(typeNode) > 0:
        typeNode = kid(typeNode, 0)
    return typeNode

fn uirCoreTupleTypeElemCount(typeNode0: Node): int32 =
    let typeNode: Node = uirCoreTupleTypeCoreNode(typeNode0)
    if typeNode == nil || typeNode.kind != nkTupleTy:
        return 0
    return kidCount(typeNode)

fn uirCoreTupleTypeElemType(typeNode0: Node, idx: int32): Node =
    let typeNode: Node = uirCoreTupleTypeCoreNode(typeNode0)
    if typeNode == nil || typeNode.kind != nkTupleTy:
        return nil
    if idx < 0 || idx >= kidCount(typeNode):
        return nil
    let elem: Node = kid(typeNode, idx)
    if elem == nil:
        return nil
    if elem.kind == nkIdentDefs:
        if kidCount(elem) < 2:
            return nil
        return kid(elem, 1)
    return elem

fn uirCoreFfiOutPtrFindOrderByPos(outPhysPos: int32[], pos: int32): int32 =
    for i in 0..<outPhysPos.len:
        if outPhysPos[i] == pos:
            return i
    return -1

fn uirCoreParseFfiOutPtrArgIndex(argNode: Node, outIdx: int32*): bool =
    if outIdx != nil:
        *outIdx = -1
    if argNode == nil:
        return false
    var raw: str = ffiStripSpaces(plainName(argNode))
    if (raw == nil || len(raw) == 0) && argNode.kind == nkStrLit:
        raw = ffiStripSpaces(argNode.strVal)
    if raw == nil || len(raw) < 4:
        return false
    if !ffiHasPrefix(raw, "arg"):
        return false
    var value: int32 = 0
    for i in 3..<len(raw):
        let ch: char = raw[i]
        if ch < '0' || ch > '9':
            return false
        value = value * 10 + (int32(ch) - int32('0'))
    if outIdx != nil:
        *outIdx = value
    return true

fn uirCoreClonePragmasFiltered(pragmas: Node, dropImportc: bool, dropFfiOutPtrs: bool): Node =
    if pragmas == nil || pragmas.kind != nkPragma:
        return emptyNode(zeroPos())
    var outPragmas: Node = newNode(nkPragma, pragmas.pos)
    for i in 0..<kidCount(pragmas):
        let ann: Node = kid(pragmas, i)
        if ann != nil && ann.kind == nkAnnotation && kidCount(ann) > 0:
            let annName: str = ffiStripSpaces(plainName(kid(ann, 0)))
            if dropImportc && annName == "importc":
                continue
            if dropFfiOutPtrs && annName == "ffi_out_ptrs":
                continue
        addSon(outPragmas, cloneTree(ann))
    if kidCount(outPragmas) == 0:
        return emptyNode(pragmas.pos)
    return outPragmas

fn uirCoreMakeParamDef(name: str, typeNode: Node, pos: SourcePos): Node =
    var defs: Node = newNode(nkIdentDefs, pos)
    addSon(defs, newIdent(name, pos))
    if typeNode != nil:
        addSon(defs, cloneTree(typeNode))
    else:
        addSon(defs, emptyNode(pos))
    addSon(defs, emptyNode(pos))
    return defs

fn uirCoreRewriteFfiOutPtrFunc(n: Node, synthId: int32*, diags: Diagnostic[]*, outNodes: Node[]*): bool =
    if outNodes == nil:
        return false
    if n == nil || (n.kind != nkFnDecl && n.kind != nkIteratorDecl):
        add(outNodes, n)
        return false

    var pragmas: Node = nil
    if kidCount(n) > 5:
        pragmas = kid(n, 5)
    if pragmas == nil || pragmas.kind != nkPragma:
        add(outNodes, n)
        return false

    var importcAnn: Node = nil
    var outPtrAnn: Node = nil
    var importcLinkNameRaw: str = ""
    for i in 0..<kidCount(pragmas):
        let ann: Node = kid(pragmas, i)
        if ann == nil || ann.kind != nkAnnotation || kidCount(ann) == 0:
            continue
        let annName: str = ffiStripSpaces(plainName(kid(ann, 0)))
        var hasImportc: bool = false
        var importcLinkName: str = ""
        if uirCoreParseImportcAnnotation(ann, &hasImportc, &importcLinkName) && hasImportc:
            importcAnn = ann
            importcLinkNameRaw = importcLinkName
        if annName == "ffi_out_ptrs":
            outPtrAnn = ann

    if importcAnn == nil || outPtrAnn == nil:
        add(outNodes, n)
        return false
    if importcLinkNameRaw == nil || len(importcLinkNameRaw) == 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs importc annotation requires explicit link name")
        add(outNodes, n)
        return false

    if n.kind != nkFnDecl:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs only supports fn declarations")
        add(outNodes, n)
        return false

    let bodyNode: Node = kid(n, 3)
    if bodyNode != nil && bodyNode.kind != nkEmpty:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs importc declaration must not define a body")
        add(outNodes, n)
        return false

    let genericsNode: Node = kid(n, 4)
    if genericsNode != nil && genericsNode.kind != nkEmpty && kidCount(genericsNode) > 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs does not support generic importc declarations")
        add(outNodes, n)
        return false

    var outPhysPos: int32[]
    for ai in 1..<kidCount(outPtrAnn):
        let argNode: Node = kid(outPtrAnn, ai)
        var argIdx: int32 = -1
        if !uirCoreParseFfiOutPtrArgIndex(argNode, &argIdx):
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs expects arguments like arg0,arg1,...")
            add(outNodes, n)
            return false
        if argIdx < 0:
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs argument index must be >= 0")
            add(outNodes, n)
            return false
        if uirCoreFfiOutPtrFindOrderByPos(outPhysPos, argIdx) >= 0:
            uirCoreStage1AddDiag(diags, argNode, "ffi_out_ptrs has duplicate physical argument index: arg" + intToStr(argIdx))
            add(outNodes, n)
            return false
        add(outPhysPos, argIdx)
    if outPhysPos.len == 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires at least one out argument marker")
        add(outNodes, n)
        return false

    let retNode: Node = kid(n, 2)
    let tupleElemCount: int32 = uirCoreTupleTypeElemCount(retNode)
    if tupleElemCount <= 0:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires tuple return type")
        add(outNodes, n)
        return false

    var hasStatus: bool = false
    if tupleElemCount == outPhysPos.len:
        hasStatus = false
    elif tupleElemCount == outPhysPos.len + 1:
        hasStatus = true
    else:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs tuple arity mismatch: expected tuple size " +
                             intToStr(outPhysPos.len) + " or " + intToStr(outPhysPos.len + 1))
        add(outNodes, n)
        return false

    var userParamNames: str[]
    var userParamTypes: Node[]
    let paramsNode: Node = kid(n, 1)
    if paramsNode != nil && paramsNode.kind == nkFormalParams:
        for pi in 0..<kidCount(paramsNode):
            let defs: Node = kid(paramsNode, pi)
            if defs == nil || defs.kind != nkIdentDefs:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs requires canonical parameter declarations")
                add(outNodes, n)
                return false
            let nameCount: int32 = identDefsNameCount(defs)
            if nameCount != 1:
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires one identifier per parameter")
                add(outNodes, n)
                return false
            let nameNode: Node = kid(defs, 0)
            if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires identifier parameters")
                add(outNodes, n)
                return false
            let typeNode: Node = identDefsType(defs)
            if typeNode == nil || typeNode.kind == nkEmpty:
                uirCoreStage1AddDiag(diags, defs, "ffi_out_ptrs requires explicit parameter types")
                add(outNodes, n)
                return false
            add(userParamNames, ffiStripSpaces(plainName(nameNode)))
            add(userParamTypes, typeNode)

    let physCount: int32 = userParamNames.len + outPhysPos.len
    var outByPhys: int32[]
    outByPhys.len = physCount
    for i in 0..<outByPhys.len:
        outByPhys[i] = -1
    for oi in 0..<outPhysPos.len:
        let pos: int32 = outPhysPos[oi]
        if pos < 0 || pos >= physCount:
            uirCoreStage1AddDiag(diags, outPtrAnn, "ffi_out_ptrs argument index out of range: arg" + intToStr(pos))
            add(outNodes, n)
            return false
        if outByPhys[pos] >= 0:
            uirCoreStage1AddDiag(diags, outPtrAnn, "ffi_out_ptrs duplicate physical argument index: arg" + intToStr(pos))
            add(outNodes, n)
            return false
        outByPhys[pos] = oi
    var nonOutCount: int32 = 0
    for pos in 0..<physCount:
        if outByPhys[pos] < 0:
            nonOutCount = nonOutCount + 1
    if nonOutCount != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs physical argument mapping does not match function parameters")
        add(outNodes, n)
        return false

    var outTupleTypes: Node[]
    for oi in 0..<outPhysPos.len:
        let elemIdx: int32 = hasStatus ? (oi + 1) : oi
        let elemType: Node = uirCoreTupleTypeElemType(retNode, elemIdx)
        if elemType == nil || elemType.kind == nkEmpty:
            uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs tuple element type missing at index " + intToStr(elemIdx))
            add(outNodes, n)
            return false
        add(outTupleTypes, elemType)
    var statusType: Node = nil
    if hasStatus:
        statusType = uirCoreTupleTypeElemType(retNode, 0)
        if statusType == nil || statusType.kind == nkEmpty:
            uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs status return type is missing")
            add(outNodes, n)
            return false

    let nameNode: Node = kid(n, 0)
    var sid: int32 = 0
    if synthId != nil:
        sid = *synthId
        *synthId = sid + 1
    let rawName: str = importcLinkNameRaw

    var rawParams: Node = newNode(nkFormalParams, n.pos)
    var userCursor: int32 = 0
    for pos in 0..<physCount:
        let outOrder: int32 = outByPhys[pos]
        if outOrder >= 0:
            let outTy: Node = outTupleTypes[outOrder]
            var varTy: Node = newNode(nkVarTy, outTy.pos)
            addSon(varTy, cloneTree(outTy))
            let outName: str = "__ffi_out_" + intToStr(outOrder)
            addSon(rawParams, uirCoreMakeParamDef(outName, varTy, n.pos))
        else:
            if userCursor < 0 || userCursor >= userParamNames.len:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs parameter mapping overflow")
                add(outNodes, n)
                return false
            addSon(rawParams, uirCoreMakeParamDef(userParamNames[userCursor], userParamTypes[userCursor], n.pos))
            userCursor = userCursor + 1
    if userCursor != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs parameter mapping underflow")
        add(outNodes, n)
        return false

    var rawRet: Node = emptyNode(n.pos)
    if hasStatus:
        rawRet = cloneTree(statusType)
    var rawPragmas: Node = uirCoreClonePragmasFiltered(pragmas, true, true)
    if rawPragmas == nil || rawPragmas.kind != nkPragma:
        rawPragmas = newNode(nkPragma, n.pos)
    var rawImportcAnn: Node = newNode(nkAnnotation, n.pos)
    addSon(rawImportcAnn, newIdent("importc", n.pos))
    addSon(rawImportcAnn, newStrLit(importcLinkNameRaw, n.pos))
    addSon(rawPragmas, rawImportcAnn)
    let wrapPragmas: Node = uirCoreClonePragmasFiltered(pragmas, true, true)

    var rawFn: Node = newNode(nkFnDecl, n.pos)
    addSon(rawFn, newIdent(rawName, n.pos))
    addSon(rawFn, rawParams)
    addSon(rawFn, rawRet)
    addSon(rawFn, emptyNode(n.pos))
    if genericsNode != nil:
        addSon(rawFn, cloneTree(genericsNode))
    else:
        addSon(rawFn, emptyNode(n.pos))
    addSon(rawFn, rawPragmas)
    if n.strVal != nil && len(n.strVal) > 0:
        nodeSetStrVal(rawFn, n.strVal)

    var body: Node = newNode(nkStmtList, n.pos)
    for oi in 0..<outTupleTypes.len:
        let outName: str = "__ffi_out_" + intToStr(oi)
        var outDecl: Node = newNode(nkVar, n.pos)
        addSon(outDecl, newIdent(outName, n.pos))
        addSon(outDecl, cloneTree(outTupleTypes[oi]))
        addSon(outDecl, emptyNode(n.pos))
        addSon(outDecl, emptyNode(n.pos))
        addSon(body, outDecl)

    var callNode: Node = newNode(nkCall, n.pos)
    addSon(callNode, newIdent(rawName, n.pos))
    var userArgCursor: int32 = 0
    for pos in 0..<physCount:
        let outOrder: int32 = outByPhys[pos]
        if outOrder >= 0:
            addSon(callNode, newIdent("__ffi_out_" + intToStr(outOrder), n.pos))
        else:
            if userArgCursor < 0 || userArgCursor >= userParamNames.len:
                uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs wrapper argument mapping overflow")
                add(outNodes, n)
                return false
            addSon(callNode, newIdent(userParamNames[userArgCursor], n.pos))
            userArgCursor = userArgCursor + 1
    if userArgCursor != userParamNames.len:
        uirCoreStage1AddDiag(diags, n, "ffi_out_ptrs wrapper argument mapping underflow")
        add(outNodes, n)
        return false

    var statusName: str = ""
    if hasStatus:
        statusName = "__ffi_status"
        var statusDecl: Node = newNode(nkLet, n.pos)
        addSon(statusDecl, newIdent(statusName, n.pos))
        addSon(statusDecl, cloneTree(statusType))
        addSon(statusDecl, callNode)
        addSon(statusDecl, emptyNode(n.pos))
        addSon(body, statusDecl)
    else:
        addSon(body, callNode)

    var tupleRet: Node = newNode(nkTupleLit, n.pos)
    # Keep tuple literal layout aligned with declared return type.
    # Without an explicit type cache, tuple element inference may widen ints
    # and produce mismatched field offsets in ABI copies.
    tupleRet.typeCacheValid = true
    tupleRet.typeCache = cloneTree(retNode)
    if hasStatus:
        addSon(tupleRet, newIdent(statusName, n.pos))
    for oi in 0..<outTupleTypes.len:
        addSon(tupleRet, newIdent("__ffi_out_" + intToStr(oi), n.pos))
    var retStmt: Node = newNode(nkReturn, n.pos)
    addSon(retStmt, tupleRet)
    addSon(body, retStmt)

    var wrapperFn: Node = newNode(nkFnDecl, n.pos)
    addSon(wrapperFn, cloneTree(nameNode))
    addSon(wrapperFn, cloneTree(paramsNode))
    addSon(wrapperFn, cloneTree(retNode))
    addSon(wrapperFn, body)
    if genericsNode != nil:
        addSon(wrapperFn, cloneTree(genericsNode))
    else:
        addSon(wrapperFn, emptyNode(n.pos))
    addSon(wrapperFn, wrapPragmas)
    if n.strVal != nil && len(n.strVal) > 0:
        nodeSetStrVal(wrapperFn, n.strVal)

    add(outNodes, rawFn)
    add(outNodes, wrapperFn)
    return true

fn uirCoreLowerFfiOutPtrAnnotations(root: Node, diags: Diagnostic[]*): bool =
    if root == nil:
        return false
    if root.kind != nkModule && root.kind != nkStmtList:
        return false
    var loweredKids: Node[]
    loweredKids.cap = kidCount(root) + 8
    var changed: bool = false
    var synthId: int32 = 0
    for i in 0..<kidCount(root):
        let n: Node = kid(root, i)
        if uirCoreRewriteFfiOutPtrFunc(n, &synthId, diags, &loweredKids):
            changed = true
    if changed:
        root.kids = loweredKids
    return changed
