# UIR core builder top-level predeclare/consume passes (split from uir_core_builder).
import std/result
import std/hashsets
import stage1/ast
import backend/uir/uir_internal/uir_core_types
import backend/uir/uir_internal/uir_core_builder_types

fn uirCoreConsumeTopLevelFromRoot(mod: UirCoreModule, ctx: UirCoreBuildCtx, root: Node, filePath: str, n: Node,
                              reachable: hashsets.HashSetStr* = nil,
                              overloaded: hashsets.HashSetStr* = nil): Result[bool] =
    if n == nil || n.kind == nkEmpty:
        return Ok[bool](false)
    if n.kind == nkStmtList || n.kind == nkModule:
        let fallback: str = (len(filePath) > 0) ? filePath : (root != nil ? root.strVal : "")
        for j in 0..<kidCount(n):
            let nn: Node = kid(n, j)
            let stmtPath: str = (nn != nil && len(nn.strVal) > 0) ? nn.strVal : fallback
            let res: Result[bool] = uirCoreConsumeTopLevelFromRoot(mod, ctx, root, stmtPath, nn, reachable, overloaded)
            if ! IsOk[bool](res):
                return res
        return Ok[bool](true)
    if n.kind == nkVar || n.kind == nkLet || n.kind == nkConst:
        var pat: Node = nil
        if kidCount(n) > 0:
            pat = kid(n, 0)
        var init: Node = nil
        if kidCount(n) > 2:
            init = kid(n, 2)
        var nameNode: Node = pat
        var typeNode: Node = nil
        if kidCount(n) > 1:
            typeNode = kid(n, 1)
        if pat != nil && pat.kind == nkPattern && kidCount(pat) > 0:
            nameNode = kid(pat, 0)
            if kidCount(pat) > 1:
                typeNode = kid(pat, 1)
        if nameNode == nil || (nameNode.kind != nkIdent && nameNode.kind != nkSymbol):
            return Err[bool]("uirCore_builder: global expects identifier")
        let rawName: str = backendStripSpaces(plainName(nameNode))
        let name: str = uirCoreMaybeMangleDupGlobalName(rawName, filePath)
        let debugDot: bool = (getEnv "BACKEND_DEBUG_DOT" == "1")
        if debugDot && rawName == "baseIdentity":
            var typeKindDbg: str = "nil"
            if typeNode != nil:
                typeKindDbg = intToStr(int32(typeNode.kind))
            echo("[backend] debugDot: consumeGlobal rawName='" + rawName +
                 "' file='" + filePath + "' typeKind=nk#" + typeKindDbg + "'")
        let existingGi: int32 = moduleGlobalIndex(mod, name)
        var allowDupGlobal: bool = false
        if existingGi >= 0:
            let g0: UirCoreGlobal = mod.globals[existingGi]
            allowDupGlobal = (g0.originFile == "<predeclared>")
        var declType: UirCoreType = uirCoreTypeFromNodeWithModule(mod, typeNode)
        var objTypeName: str = ""
        var objTypeNode: Node = typeNode
        if (objTypeNode == nil || objTypeNode.kind == nkEmpty) && init != nil && init.kind != nkEmpty &&
           init.typeCacheValid && init.typeCache != nil:
            objTypeNode = init.typeCache
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            objTypeName = typeNodeObjTypeName(mod, objTypeNode)
        let isObj: bool = len(objTypeName) > 0 && objTypeNode != nil && typeNodeIsObjValue(mod, objTypeNode)
        if debugDot && rawName == "baseIdentity":
            let objNodeKindDbg: str = (objTypeNode != nil) ? intToStr(int32(objTypeNode.kind)) : "nil"
            echo("[backend] debugDot: consumeGlobal name='" + name +
                 "' objTypeName='" + objTypeName + "' isObj=" + (isObj ? "1" : "0") +
                 " objNodeKind=nk#" + objNodeKindDbg + "'")
        if isObj:
            uirCoreGlobalObjTypePut(name, objTypeName)
            if debugDot && rawName == "baseIdentity":
                let chkObj: str = uirCoreGlobalObjTypeGet(name)
                echo("[backend] debugDot: consumeGlobal putObj name='" + name + "' objTypeName='" +
                     objTypeName + "' chkObj='" + chkObj + "'")
        if isObj:
            declType = uirCoreTypeI64()
        elif typeNode == nil || typeNode.kind == nkEmpty:
            declType = inferExprTypeWithGlobals(nil, mod, nil, init, declType)
        # Match stage1 C backend's global layout: store sub-32-bit scalars as i32 slots.
        # This keeps the MVP backend's global pipeline simple and avoids i8/i16-only data sections.
        if !isObj && (declType.kind == mtI8 || declType.kind == mtI16):
            let wasUnsigned: bool = declType.isUnsigned
            declType = uirCoreTypeI32()
            declType.isUnsigned = wasUnsigned

        if existingGi >= 0 && !allowDupGlobal && n.kind == nkConst && !isObj:
            var init0: Node = init
            while init0 != nil && init0.kind == nkPar && kidCount(init0) > 0:
                init0 = kid(init0, 0)
            let isLiteralInit: bool = init0 != nil &&
                (init0.kind == nkIntLit || init0.kind == nkBoolLit || init0.kind == nkNilLit)
            if isLiteralInit:
                let g0: UirCoreGlobal = mod.globals[existingGi]
                let prevFile: str = g0.originFile
                let prevSyntheticOrStd: bool = (len(prevFile) > 0) &&
                    (prevFile[0] == '<' || __cheng_string_contains_str(prevFile, "/src/std/") ||
                     __cheng_string_contains_str(prevFile, "/src/core/") || __cheng_string_contains_str(prevFile, "/src/system/"))
                let curSyntheticOrStd: bool = (len(filePath) > 0) &&
                    (filePath[0] == '<' || __cheng_string_contains_str(filePath, "/src/std/") ||
                     __cheng_string_contains_str(filePath, "/src/core/") || __cheng_string_contains_str(filePath, "/src/system/"))
                if (prevSyntheticOrStd || curSyntheticOrStd) &&
                   g0.ty.kind == declType.kind && g0.ty.isUnsigned == declType.isUnsigned:
                    allowDupGlobal = true
        if existingGi >= 0 && !allowDupGlobal && uirCoreSkipSemStdDuplicateRelaxEnabled():
            let g0: UirCoreGlobal = mod.globals[existingGi]
            let prevFile2: str = g0.originFile
            if (uirCorePathSyntheticOrStd(prevFile2) || uirCorePathSyntheticOrStd(filePath)) &&
               g0.ty.kind == declType.kind && g0.ty.isUnsigned == declType.isUnsigned:
                allowDupGlobal = true

        if moduleHasFunc(mod, name) || (existingGi >= 0 && !allowDupGlobal) ||
           uirCoreFindTypeAlias(mod, name) >= 0 || uirCoreFindObjType(mod, name) >= 0:
            let line0: str = intToStr(nameNode.pos.line)
            let col0: str = intToStr(nameNode.pos.col)
            var prevFile: str = ""
            if existingGi >= 0:
                let gPrev: UirCoreGlobal = mod.globals[existingGi]
                prevFile = gPrev.originFile
            return Err[bool]("uirCore_builder: duplicate global name: " + name +
                             " (prev=" + prevFile + " cur=" + filePath + ":" + line0 + ":" + col0 + ")")

        var hasInit: bool = false
        var initVal: int64 = 0

        if isObj:
            # Object globals are represented as pointers to heap storage; initialize at runtime.
            hasInit = false
            initVal = 0
            let sfi: SeqFixedInit = seqFixedInitInfo(typeNode)
            ctxAddGlobalInit(ctx, name, declType, objTypeName, init, filePath, sfi.elemType, sfi.capExpr)
        elif init != nil && init.kind != nkEmpty:
            # Scalar globals: allow static init for simple literals; otherwise defer to runtime init.
            if init.kind == nkIntLit:
                hasInit = true
                initVal = init.intVal
            elif init.kind == nkBoolLit:
                hasInit = true
                let v: str = backendStripSpaces(init.ident)
                initVal = (v == "true") ? 1 : 0
            elif init.kind == nkNilLit:
                hasInit = true
                initVal = 0
            else:
                hasInit = false
                initVal = 0
                ctxAddGlobalInit(ctx, name, declType, "", init, filePath)

        if existingGi >= 0 && allowDupGlobal:
            var gOut: UirCoreGlobal
            gOut.name = uirCoreOwnStr(name)
            gOut.ty = declType
            gOut.init = initVal
            gOut.hasInit = hasInit
            gOut.originFile = uirCoreOwnStr(filePath)
            mbWriteGlobal(mod.globals, existingGi, gOut)
        else:
            uirCoreAddGlobal(mod, name, declType, initVal, hasInit, filePath)

        var keyOut: str = ""
        if objTypeNode != nil && objTypeNode.kind != nkEmpty:
            keyOut = typeKey(objTypeNode)
            if len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(objTypeNode)
        if len(keyOut) == 0 && typeNode != nil && typeNode.kind != nkEmpty:
            keyOut = typeKey(typeNode)
            if len(keyOut) == 0:
                keyOut = uirCoreTypeKeyFromNodeLoose(typeNode)
        if len(keyOut) == 0 && init != nil && init.kind != nkEmpty:
            var initKeyNode: Node = init
            while initKeyNode != nil && initKeyNode.kind == nkPar && kidCount(initKeyNode) > 0:
                initKeyNode = kid(initKeyNode, 0)
            if initKeyNode != nil && initKeyNode.typeCacheValid && initKeyNode.typeCache != nil:
                keyOut = typeKey initKeyNode.typeCache
            elif initKeyNode != nil && initKeyNode.kind == nkStrLit:
                keyOut = "str"
            elif initKeyNode != nil && initKeyNode.kind == nkFloatLit:
                keyOut = "float64"
            elif initKeyNode != nil && initKeyNode.kind == nkBoolLit:
                keyOut = "bool"
            elif initKeyNode != nil && initKeyNode.kind == nkCharLit:
                keyOut = "char"
            elif initKeyNode != nil && initKeyNode.kind == nkIntLit:
                if declType.kind == mtI64:
                    keyOut = declType.isUnsigned ? "uint64" : "int64"
                elif declType.kind == mtI32:
                    keyOut = declType.isUnsigned ? "uint32" : "int32"
                elif declType.kind == mtF64:
                    keyOut = "float64"
                elif declType.kind == mtF32:
                    keyOut = "float32"
                elif declType.kind == mtI16:
                    keyOut = declType.isUnsigned ? "uint16" : "int16"
                elif declType.kind == mtI8:
                    keyOut = declType.isUnsigned ? "uint8" : "int8"
        if len(keyOut) > 0:
            uirCoreGlobalTypeKeyPut(name, keyOut)
            if debugDot && rawName == "baseIdentity":
                let chkKey: str = uirCoreGlobalTypeKeyGet(name)
                echo("[backend] debugDot: consumeGlobal putKey name='" + name +
                     "' keyOut='" + keyOut + "' chkKey='" + chkKey + "'")
        if ctx != nil && ctx.traceEnabled:
            ctx.traceGlobalCount = ctx.traceGlobalCount + 1
            if (ctx.traceGlobalCount % 200) == 0:
                stage1Trace("backend: uir globals=" + intToStr(ctx.traceGlobalCount) + " last=" + name)
        return Ok[bool](true)
    if n.kind == nkFnDecl || n.kind == nkIteratorDecl:
        if reachable != nil:
            var entryPathProbe: str = backendStripSpaces(filePath)
            if n != nil && len(n.strVal) > 0:
                entryPathProbe = backendStripSpaces(n.strVal)
            let keepByEntryFile: bool = uirCoreIsEntryFilePath(entryPathProbe)
            if !keepByEntryFile:
                let nameNode: Node = kid(n, 0)
                if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                    let nm: str = backendStripSpaces(plainName(nameNode))
                    if !hashsets.hashSetStrHas(*reachable, nm):
                        return Ok[bool](false)
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            return Ok[bool](false)
        let fRes: Result[UirCoreFunc] = uirCoreBuildFunc(mod, n, filePath, overloaded)
        if ! IsOk[UirCoreFunc](fRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreFunc](fRes))
        let f: UirCoreFunc = Value[UirCoreFunc](fRes)
        if f == nil:
            return Ok[bool](false)
        # Predeclare pass inserts header-only entries first. Always try
        # same-file replacement before duplicate-name checks so stale caches
        # cannot leave body-less declarations in the final module.
        var sameFileIdx: int32 = -1
        let exIdx: int32 = moduleFuncIndex(mod, f.name)
        if exIdx >= 0:
            let ex: UirCoreFunc = mod.funcs[exIdx]
            if ex != nil && ex.originFile == f.originFile:
                sameFileIdx = exIdx
        if sameFileIdx >= 0:
            let ex2: UirCoreFunc = mod.funcs[sameFileIdx]
            if ex2 == nil || ex2.blocks.len == 0:
                mbWriteFunc(mod.funcs, sameFileIdx, f)
                if (f.name == "main"):
                    if ctx != nil && ctx.foundMain:
                        return Err[bool]("uirCore_builder: multiple main functions")
                    if ctx != nil:
                        ctx.foundMain = true
                if ctx != nil && ctx.traceEnabled:
                    ctx.traceFnCount = ctx.traceFnCount + 1
                    if (ctx.traceFnCount % 50) == 0:
                        stage1Trace("backend: uir funcs=" + intToStr(ctx.traceFnCount) + " last=" + f.name)
                return Ok[bool](true)
            if uirCoreSkipSemStdDuplicateRelaxEnabled() &&
               (uirCorePathSyntheticOrStd(ex2.originFile) || uirCorePathSyntheticOrStd(f.originFile)):
                return Ok[bool](false)
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name)
        if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
           uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
            if uirCoreSkipSemStdDuplicateRelaxEnabled():
                var prevFile: str = ""
                let exIdx2: int32 = moduleFuncIndex(mod, f.name)
                if exIdx2 >= 0:
                    let ex2: UirCoreFunc = mod.funcs[exIdx2]
                    if ex2 != nil:
                        prevFile = ex2.originFile
                if uirCorePathSyntheticOrStd(prevFile) || uirCorePathSyntheticOrStd(f.originFile):
                    return Ok[bool](false)
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name)
        if (f.name == "main"):
            if ctx != nil && ctx.foundMain:
                return Err[bool]("uirCore_builder: multiple main functions")
            if ctx != nil:
                ctx.foundMain = true
        uirCoreAddFunc(mod, f)
        if ctx != nil && ctx.traceEnabled:
            ctx.traceFnCount = ctx.traceFnCount + 1
            if (ctx.traceFnCount % 50) == 0:
                stage1Trace("backend: uir funcs=" + intToStr(ctx.traceFnCount) + " last=" + f.name)
        return Ok[bool](true)
    return Ok[bool](false)

fn uirCorePredeclareTopLevelFromRoot(mod: UirCoreModule, root: Node, filePath: str, n: Node,
                                 reachable: hashsets.HashSetStr* = nil,
                                 overloaded: hashsets.HashSetStr* = nil): Result[bool] =
    if mod == nil || n == nil || n.kind == nkEmpty:
        return Ok[bool](false)
    if n.kind == nkStmtList || n.kind == nkModule:
        let fallback: str = (len(filePath) > 0) ? filePath : (root != nil ? root.strVal : "")
        for j in 0..<kidCount(n):
            let nn: Node = kid(n, j)
            let stmtPath: str = (nn != nil && len(nn.strVal) > 0) ? nn.strVal : fallback
            let res: Result[bool] = uirCorePredeclareTopLevelFromRoot(mod, root, stmtPath, nn, reachable, overloaded)
            if !IsOk[bool](res):
                return res
        return Ok[bool](true)
    if n.kind == nkFnDecl || n.kind == nkIteratorDecl:
        if reachable != nil:
            var entryPathProbe: str = backendStripSpaces(filePath)
            if n != nil && len(n.strVal) > 0:
                entryPathProbe = backendStripSpaces(n.strVal)
            let keepByEntryFile: bool = uirCoreIsEntryFilePath(entryPathProbe)
            if !keepByEntryFile:
                let nameNode: Node = kid(n, 0)
                if nameNode != nil && (nameNode.kind == nkIdent || nameNode.kind == nkSymbol):
                    let nm: str = backendStripSpaces(plainName(nameNode))
                    if !hashsets.hashSetStrHas(*reachable, nm):
                        return Ok[bool](false)
        if uirCoreFuncSigHasUnresolvedGenerics(n):
            return Ok[bool](false)
        let fRes: Result[UirCoreFunc] = uirCoreBuildFuncHeader(mod, n, filePath, overloaded)
        if !IsOk[UirCoreFunc](fRes):
            return ErrInfo[bool](ErrorInfoOf[UirCoreFunc](fRes))
        let f: UirCoreFunc = Value[UirCoreFunc](fRes)
        if f == nil:
            return Ok[bool](false)
        if moduleHasFunc(mod, f.name) || moduleHasGlobal(mod, f.name) ||
           uirCoreFindTypeAlias(mod, f.name) >= 0 || uirCoreFindObjType(mod, f.name) >= 0:
            var sameFile: bool = false
            var prevFile: str = ""
            let exIdx: int32 = moduleFuncIndex(mod, f.name)
            if exIdx >= 0:
                let ex: UirCoreFunc = mod.funcs[exIdx]
                if ex != nil:
                    if ex.originFile == f.originFile:
                        sameFile = true
                    else:
                        let exFile: str = ex.originFile
                        if len prevFile == 0 && len(exFile) > 0:
                            prevFile = exFile
            if sameFile:
                return Ok[bool](false)
            if uirCoreSkipSemStdDuplicateRelaxEnabled() &&
               (uirCorePathSyntheticOrStd(prevFile) || uirCorePathSyntheticOrStd(f.originFile)):
                return Ok[bool](false)
            if len prevFile > 0:
                return Err[bool]("uirCore_builder: duplicate function name: " + f.name + " (files: " + prevFile + ", " + f.originFile + ")")
            return Err[bool]("uirCore_builder: duplicate function name: " + f.name + " (file: " + f.originFile + ")")
        uirCoreAddFunc(mod, f)
        return Ok[bool](true)
    return Ok[bool](false)
