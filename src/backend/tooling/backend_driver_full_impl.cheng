# Backend UIR driver: build UIR -> machine obj/exe (AArch64/x86_64/riscv64 subsets).
import std/[cmdline, seqs, strings, os, result, hashmaps, monotimes, bytes, tables]
import cheng/backend/uir/uir_types
import cheng/backend/uir/uir_builder
import cheng/backend/uir/uir_codegen
import cheng/backend/obj/macho_linker
import cheng/backend/obj/macho_linker_x86_64
import cheng/backend/obj/elf_linker
import cheng/backend/obj/elf_linker_riscv64
import cheng/backend/obj/coff_linker

@importc("exit")
fn driver_exit(code: int32)
@importc("puts")
fn driver_puts(text: str): int32
@importc("ptr_add")
fn driver_ptr_add(p: void*, offset: int32): void*
@importc("memcpy")
fn driver_memcpy(dest: void*, src: void*, n: int64): void*
@importc("memset")
fn driver_memset(dest: void*, val: int32, n: int64): void*
@importc("cheng_malloc")
fn driver_c_alloc(size: int32): void*
@importc("cheng_file_exists")
fn driver_file_exists(path: str): int32
@importc("cheng_file_mtime")
fn driver_file_mtime(path: str): int64
@importc("cheng_file_size")
fn driver_file_size(path: str): int64
@importc("getenv")
fn driver_c_getenv(name: str): str

fn driver_panic(msg: str) =
    if !driver_strIsEmpty(msg):
        driver_puts(msg)
    driver_exit(1)

fn driver_copy_mem(dest: void*, src: void*, count: int32) =
    if dest == nil || src == nil || count <= 0:
        return
    driver_memcpy(dest, src, int64(count))

fn driver_new_string(n: int32): str =
    if n <= 0:
        return ""
    let bytes: int32 = n + 1
    let p: void* = driver_c_alloc(bytes)
    if p == nil:
        return ""
    driver_memset(p, 0, int64(bytes))
    return str(p)

@importc("fork")
fn driver_c_fork(): int64
@importc("waitpid")
fn driver_c_waitpid(pid: int64, status: int32*, options: int32): int64

type
    DriverSeqInt32 = int32[]
    DriverRowInt32 = ref
        values: DriverSeqInt32
    DriverSeqSeqInt32 = DriverRowInt32[]
    DriverSeqU64 = uint64[]
    DriverRowU64 = ref
        values: DriverSeqU64
    DriverSeqSeqU64 = DriverRowU64[]
    # Stage0 compatibility: keep table helper shape local instead of relying on
    # generic `tables.Table[...]` field resolution in old seed compilers.
    DriverTableInt64 =
        keys: str[]
        vals: int64[]
        states: uint8[]
        len: int32
    # Stage0 compatibility: keep string-int map local to avoid std/hashmaps surface.
    DriverMapStrInt = DriverTableInt64

type
    DriverUnitIndex = ref
        unitFiles: str[]
        unitIndex: DriverMapStrInt
        # Only non-extern (definition) items are indexed here.
        unitFuncIdx: DriverSeqSeqInt32
        unitGlobalIdx: DriverSeqSeqInt32
        nameToFuncIdx: DriverMapStrInt
    DriverModuleCache = ref
        # Stored as raw pointer to avoid frontend type-decl dependency on `UirModule`.
        module: void*
        unitFiles: str[]
        unitFuncIdx: DriverSeqSeqInt32
        unitGlobalIdx: DriverSeqSeqInt32
        nameToFuncIdx: DriverMapStrInt
    DriverCacheStrTab = ref
        items: str[]
        index: DriverMapStrInt

fn driver_strHasPrefix(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    let n: int32 = len s
    let m: int32 = len prefix
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[i] != prefix[i]:
            return false
    return true

fn driver_strHasSuffix(s: str, suffix: str): bool =
    if s == nil || suffix == nil:
        return false
    let n: int32 = len s
    let m: int32 = len suffix
    if m == 0:
        return true
    if n < m:
        return false
    for i in 0..<m:
        if s[n - m + i] != suffix[i]:
            return false
    return true

fn driver_pathLooksSame(a: str, b: str): bool =
    if driver_strIsEmpty(a) || driver_strIsEmpty(b):
        return false
    if a == b:
        return true
    if driver_strHasSuffix(a, "/" + b):
        return true
    if driver_strHasSuffix(b, "/" + a):
        return true
    return false

fn driver_bootMode(): str =
    let modeRaw: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("BACKEND_DRIVER_BOOT_MODE", "native")))
    if driver_strEq(modeRaw, "delegate"):
        return "delegate"
    return "native"

fn driver_delegateEmergencyAllowed(): bool =
    return driver_envBoolDefault("BACKEND_DRIVER_ALLOW_DELEGATE_EMERGENCY", false)

fn driver_resolveStage0ForDelegate(): str =
    let selfDriver: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_DRIVER", ""))
    var stage0: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_BUILD_DRIVER_STAGE0", ""))
    if driver_strIsEmpty(stage0):
        stage0 = driver_trimAsciiSpace(driver_envDefault("BACKEND_STAGE0", ""))
    if driver_strIsEmpty(stage0):
        stage0 = driver_trimAsciiSpace(driver_envDefault("BACKEND_DRIVER_STAGE0", ""))
    if driver_strIsEmpty(stage0):
        stage0 = "/Users/lbcheng/cheng-lang/dist/releases/current/cheng"
    if driver_pathLooksSame(stage0, selfDriver):
        stage0 = "/Users/lbcheng/cheng-lang/artifacts/backend_selfhost_self_obj/cheng.stage2"
    if driver_pathLooksSame(stage0, selfDriver):
        stage0 = "/Users/lbcheng/cheng-lang/artifacts/backend_seed/cheng.stage2"
    if driver_pathLooksSame(stage0, selfDriver):
        stage0 = "./cheng"
    if driver_strIsEmpty(stage0):
        stage0 = "./cheng"
    return stage0

fn driver_runCmdExitCode(command: str): int32 =
    let res: os.ExecCmdResult = driver_execCmd(command)
    let rc: int32 = os.execCmdResultExitCode(res)
    if rc != 0:
        let out: str = os.execCmdResultOutput(res)
        if driver_strNonEmpty(out):
            driver_puts(out)
    return rc

fn driver_isExecutable(path: str): bool =
    if driver_strIsEmpty(path):
        return false
    return driver_runCmdExitCode("test -x " + driver_shellQuote(path)) == 0

fn driver_strContains(hay: str, needle: str): bool =
    if hay == nil || needle == nil:
        return false
    let n: int32 = len hay
    let m: int32 = len needle
    if m == 0:
        return true
    if m > n:
        return false
    for i in 0..n - m:
        for j in 0..<m:
            if !(hay[i + j] == needle[j]):
                break
        if j == m:
            return true
    return false

fn driver_isIdentChar(c: char): bool =
    return (c >= 'a' && c <= 'z') ||
           (c >= 'A' && c <= 'Z') ||
           (c >= '0' && c <= '9') ||
           c == '_'

fn driver_strContainsToken(hay: str, token: str): bool =
    if hay == nil || token == nil:
        return false
    let n: int32 = len(hay)
    let m: int32 = len(token)
    if m <= 0 || m > n:
        return false
    for i in 0..n - m:
        for j in 0..<m:
            if !(hay[i + j] == token[j]):
                break
        if j == m:
            let leftOk: bool = (i == 0) || !driver_isIdentChar(hay[i - 1])
            let rightPos: int32 = i + m
            let rightOk: bool = (rightPos >= n) || !driver_isIdentChar(hay[rightPos])
            if leftOk && rightOk:
                return true
    return false

fn driver_nativeContractSourceViolation(inputPath: str): str =
    if driver_strIsEmpty(inputPath) || !driver_fileExists(inputPath):
        return ""
    let content: str = os.readFile(inputPath)
    if driver_strIsEmpty(content):
        return ""
    let lower: str = lowerAscii(content)
    if driver_strContains(lower, "cheng_linux_syscall") || driver_strContains(lower, " syscall("):
        return "forbid syscall source symbol=cheng_linux_syscall"
    if driver_strContainsToken(lower, "float32") || driver_strContainsToken(lower, "float64") ||
       driver_strContainsToken(lower, "f32") || driver_strContainsToken(lower, "f64"):
        return "forbid float source token"
    return ""

fn driver_isSpaceChar(c: char): bool =
    return c == ' ' || c == '\t' || c == '\n' || c == '\r'

fn driver_strIsEmpty(s: str): bool =
    if s == nil:
        return true
    return s[0] == char(0)

fn driver_strNonEmpty(s: str): bool =
    return !driver_strIsEmpty(s)

fn driver_strSliceEq(s: str, start: int32, endExclusive: int32, needle: str): bool =
    if s == nil || needle == nil:
        return false
    if start < 0 || endExclusive < start:
        return false
    let n: int32 = endExclusive - start
    if n != len needle:
        return false
    for i in 0..<n:
        if s[start + i] != needle[i]:
            return false
    return true

# Stage1/self-link fallback symbols for concrete Table[int64] helpers.
fn tableReadStrSlot(keys: str[], idx: int32): str =
    if idx < 0 || idx >= keys.len || keys.buffer == nil:
        return ""
    let off: int32 = idx * int32(sizeof str)
    let p: str* = str*(driver_ptr_add(keys.buffer, off))
    return *p

fn tableWriteStrSlot(keys: str[]*, idx: int32, key: str) =
    if keys == nil || idx < 0 || idx >= keys->len || keys->buffer == nil:
        return
    let off: int32 = idx * int32(sizeof str)
    let p: str* = str*(driver_ptr_add(keys->buffer, off))
    *p = key

fn tableReadI64Slot(vals: int64[], idx: int32): int64 =
    if idx < 0 || idx >= vals.len || vals.buffer == nil:
        return int64(0)
    let off: int32 = idx * int32(sizeof int64)
    let p: int64* = int64*(driver_ptr_add(vals.buffer, off))
    return *p

fn tableWriteI64Slot(vals: int64[]*, idx: int32, val: int64) =
    if vals == nil || idx < 0 || idx >= vals->len || vals->buffer == nil:
        return
    let off: int32 = idx * int32(sizeof int64)
    let p: int64* = int64*(driver_ptr_add(vals->buffer, off))
    *p = val

fn tableReadStateSlot(states: uint8[], idx: int32): uint8 =
    if idx < 0 || idx >= states.len || states.buffer == nil:
        return uint8(0)
    let p: uint8* = uint8*(driver_ptr_add(states.buffer, idx))
    return *p

fn tableWriteStateSlot(states: uint8[]*, idx: int32, st: uint8) =
    if states == nil || idx < 0 || idx >= states->len || states->buffer == nil:
        return
    let p: uint8* = uint8*(driver_ptr_add(states->buffer, idx))
    *p = st

fn tableHashStr(s: str): int32 =
    var h: int32 = 0
    if s == nil:
        return 0
    let n: int32 = len(s)
    for i in 0..<n:
        let code: int32 = int32(s[i])
        h = h + code
        h = h + (h << 10)
        h = h ^ (h >> 6)
    h = h + (h << 3)
    h = h ^ (h >> 11)
    h = h + (h << 15)
    return h

fn tableRoundUpPow2(x0: int32): int32 =
    var x: int32 = x0
    if x <= 1:
        return 1
    x = x - 1
    x = x | (x >> 1)
    x = x | (x >> 2)
    x = x | (x >> 4)
    x = x | (x >> 8)
    x = x | (x >> 16)
    x = x + 1
    return x

fn tableInitCap(initialCap: int32): int32 =
    var cap: int32 = initialCap
    if cap < 8:
        cap = 8
    return tableRoundUpPow2(cap)

fn driver_hashMapStrIntInit(initialCap: int32 = 64): DriverMapStrInt =
    return TableInit_int64(initialCap)

fn driver_hashMapStrIntPut(m: var DriverMapStrInt, key: str, val: int32) =
    TablePut_int64(m, key, int64(val))

fn driver_hashMapStrIntGet(m: var DriverMapStrInt, key: str, found: var bool): int32 =
    found = TableHas_int64(m, key)
    if !found:
        return 0
    return int32(TableGet_int64(m, key))

fn TableInit_int64(initialCap: int32 = 64): DriverTableInt64 =
    let cap: int32 = tableInitCap(initialCap)
    var keys: str[cap]
    var vals: int64[cap]
    var states: uint8[cap]
    keys.len = cap
    vals.len = cap
    states.len = cap
    var out: DriverTableInt64
    out.keys = keys
    out.vals = vals
    out.states = states
    out.len = 0
    return out

fn tableFindSlotI64(t: DriverTableInt64, key: str, allowInsert: bool): int32 =
    let cap: int32 = t.keys.len
    if cap <= 0 || key == nil:
        return -1
    var probe: int32 = (tableHashStr(key) & 0x7fffffff) % cap
    for _ in 0..<cap:
        let st: uint8 = tableReadStateSlot(t.states, probe)
        if st == uint8(0):
            if allowInsert:
                return probe
            return -1
        if st == uint8(1) && tableReadStrSlot(t.keys, probe) == key:
            return probe
        probe = probe + 1
        if probe >= cap:
            probe = 0
    return -1

fn tableFindSlotMutI64(t: var DriverTableInt64, key: str, allowInsert: bool): int32 =
    let cap: int32 = t.keys.len
    if cap <= 0 || key == nil:
        return -1
    var probe: int32 = (tableHashStr(key) & 0x7fffffff) % cap
    for _ in 0..<cap:
        let st: uint8 = tableReadStateSlot(t.states, probe)
        if st == uint8(0):
            if allowInsert:
                return probe
            return -1
        if st == uint8(1) && tableReadStrSlot(t.keys, probe) == key:
            return probe
        probe = probe + 1
        if probe >= cap:
            probe = 0
    return -1

fn tableGrowI64(t: var DriverTableInt64) =
    let oldKeys: str[] = t.keys
    let oldVals: int64[] = t.vals
    let oldStates: uint8[] = t.states
    let oldCap: int32 = oldKeys.len

    var growCap: int32 = oldCap * 2
    if growCap < 8:
        growCap = 8
    var nt: DriverTableInt64 = TableInit_int64(growCap)

    for i in 0..<oldCap:
        if tableReadStateSlot(oldStates, i) == uint8(1):
            let k: str = tableReadStrSlot(oldKeys, i)
            let slot: int32 = tableFindSlotMutI64(nt, k, true)
            if slot >= 0:
                tableWriteStrSlot(&nt.keys, slot, k)
                tableWriteI64Slot(&nt.vals, slot, tableReadI64Slot(oldVals, i))
                tableWriteStateSlot(&nt.states, slot, uint8(1))
                nt.len = nt.len + 1

    t = nt

fn TableHas_int64(t: DriverTableInt64, key: str): bool =
    let slot: int32 = tableFindSlotI64(t, key, false)
    return slot >= 0

fn TableGet_int64(t: DriverTableInt64, key: str): int64 =
    let slot: int32 = tableFindSlotI64(t, key, false)
    if slot < 0:
        return int64(0)
    return tableReadI64Slot(t.vals, slot)

fn TablePut_int64(t: var DriverTableInt64, key: str, val: int64) =
    if key == nil:
        return
    if t.keys.len <= 0:
        t = TableInit_int64(64)
    if (t.len + 1) * 10 >= t.keys.len * 7:
        tableGrowI64(t)
    let slot: int32 = tableFindSlotMutI64(t, key, true)
    if slot < 0:
        return
    if tableReadStateSlot(t.states, slot) != uint8(1):
        t.len = t.len + 1
        tableWriteStateSlot(&t.states, slot, uint8(1))
    tableWriteStrSlot(&t.keys, slot, key)
    tableWriteI64Slot(&t.vals, slot, val)

fn driver_flagsHasToken(flags: str, token: str): bool =
    if flags == nil || token == nil:
        return false
    let n: int32 = len flags
    var i: int32 = 0
    for __for_guard_i in 0..<n:
        if !(i < n):
            break
        for __for_guard_i_ws in 0..<n:
            if !(i < n && driver_isSpaceChar(flags[i])):
                break
            i = i + 1
        if i >= n:
            break
        for j in i..<n:
            if !(! driver_isSpaceChar(flags[j])):
                break
        if driver_strSliceEq(flags, i, j, token):
            return true
        i = j
    return false

fn driver_flagsAppendToken(flags: str, token: str): str =
    if driver_strIsEmpty(token):
        return flags
    if driver_flagsHasToken(flags, token):
        return flags
    if driver_strIsEmpty(flags):
        return token
    return flags + " " + token

fn driver_strStripPrefix(s: str, prefix: str): str =
    if ! driver_strHasPrefix(s, prefix):
        return ""
    let off: int32 = len prefix
    return str(driver_ptr_add(void*(s), off))

fn driver_joinDir(dir: str, name: str): str =
    if dir == nil || len(dir) == 0:
        if name == nil || len(name) == 0:
            return ""
        return "" + name
    return dir + "/" + name

fn driver_shellQuote(s: str): str =
    if s == nil:
        return "\"\""
    return "\"" + s + "\""

fn driver_execCmdDefaultOptions(): uint64 =
    # Equivalent to os.poStdErrToStdOut | os.poUsePath | os.poEvalCommand.
    return uint64(7)

fn driver_runCmd(command: str) =
    let opts: uint64 = driver_execCmdDefaultOptions()
    var res: os.ExecCmdResult = os.execCmdEx(command, opts, "")
    if os.execCmdResultExitCode(res) != 0:
        driver_panic("" + os.execCmdResultOutput(res))

fn driver_execCmd(command: str): os.ExecCmdResult =
    let opts: uint64 = driver_execCmdDefaultOptions()
    var res: os.ExecCmdResult = os.execCmdEx(command, opts, "")
    return res

fn driver_writeLine(f: os.File, msg: str) =
    if msg == nil:
        os.write(f, "")
    else:
        os.write(f, msg)
    os.write(f, "\n")

fn driver_fileExists(path: str): bool =
    return driver_file_exists(path) != 0

fn driver_fileMtime(path: str): int64 =
    return driver_file_mtime(path)

fn driver_fileSize(path: str): int64 =
    return driver_file_size(path)

fn driver_panicResult(res: Result[T]) =
    let _unused: Result[T] = res
    driver_panic("backend_driver: result error")

fn driver_panicResult_UirModule(res: Result[UirModule]) =
    let _unused: Result[UirModule] = res
    driver_panic("backend_driver: failed to build UIR module")

fn driver_panicResult_bool(res: Result[bool]) =
    let _unused: Result[bool] = res
    driver_panic("backend_driver: bool result error")

fn driver_panicResult_seq_uint8(res: Result[uint8[]]) =
    let _unused: Result[uint8[]] = res
    driver_panic("backend_driver: bytes result error")

fn Err_DriverModuleCache(err: str): Result[DriverModuleCache] =
    return Err[DriverModuleCache](err)

fn driver_parseInt32Default(s: str, defaultValue: int32): int32 =
    if driver_strIsEmpty(s):
        return defaultValue
    let sLen: int32 = len s
    var neg: bool = false
    var i: int32 = 0
    if s[0] == '-':
        neg = true
        i = 1
    if i >= sLen:
        return defaultValue
    var v: int64 = 0
    for __for_guard_i in 0..<sLen:
        if !(i < sLen):
            break
        let c: char = s[i]
        if c < '0' || c > '9':
            return defaultValue
        v = v * 10 + int64(int32(c) - int32('0'))
        i = i + 1
    if neg:
        v = 0 - v
    return int32(v)

fn driver_parseBoolDefault(raw: str, defaultValue: bool): bool =
    let s: str = lowerAscii(driver_trimAsciiSpace(raw))
    if driver_strIsEmpty(s):
        return defaultValue
    if driver_strEq(s, "1"):
        return true
    if driver_strEq(s, "true"):
        return true
    if driver_strEq(s, "yes"):
        return true
    if driver_strEq(s, "on"):
        return true
    if driver_strEq(s, "0"):
        return false
    if driver_strEq(s, "false"):
        return false
    if driver_strEq(s, "no"):
        return false
    if driver_strEq(s, "off"):
        return false
    return defaultValue

fn driver_parseInt32Strict(raw: str, flagName: str): int32 =
    let s: str = driver_trimAsciiSpace(raw)
    if driver_strIsEmpty(s):
        driver_panic("backend_driver: missing value for " + flagName)
    var parsed: int32 = 0
    if cmdline.parseInt32(s, parsed):
        return parsed
    driver_panic("backend_driver: invalid integer for " + flagName + ": " + raw)

fn driver_parseBoolStrict(raw: str, flagName: str): bool =
    let s: str = lowerAscii(driver_trimAsciiSpace(raw))
    if driver_strEq(s, "1") || driver_strEq(s, "true") || driver_strEq(s, "yes") || driver_strEq(s, "on"):
        return true
    if driver_strEq(s, "0") || driver_strEq(s, "false") || driver_strEq(s, "no") || driver_strEq(s, "off"):
        return false
    driver_panic("backend_driver: invalid boolean for " + flagName +
                " (expected 0|1|true|false|yes|no|on|off): " + raw)

fn driver_cliReadValueAt(i: int32, key: str, outValue: var str, outNextIndex: var int32): bool =
    outValue = ""
    outNextIndex = i
    if driver_strIsEmpty(key):
        return false
    let count: int32 = cmdline.paramCount()
    if i < 1 || i > count:
        return false
    let arg: str = cmdline.paramStr(i)
    if strings.streq(arg, key):
        if i == count:
            driver_panic("backend_driver: missing value for " + key)
    return cmdline.readFlagValueAt(i, key, outValue, outNextIndex)

fn driver_cliReadValueAt2(i: int32, keyA: str, keyB: str, outValue: var str, outNextIndex: var int32): bool =
    if driver_cliReadValueAt(i, keyA, outValue, outNextIndex):
        return true
    if driver_strNonEmpty(keyB) && driver_cliReadValueAt(i, keyB, outValue, outNextIndex):
        return true
    return false

fn driver_cliTryReadBoolFlagAt(i: int32, trueName: str, falseName: str, valueName: str,
                               outValue: var bool, outNextIndex: var int32): bool =
    outNextIndex = i
    let count: int32 = cmdline.paramCount()
    if i < 1 || i > count:
        return false
    let arg: str = cmdline.paramStr(i)
    if strings.streq(arg, trueName):
        outValue = true
        return true
    if driver_strNonEmpty(falseName) && strings.streq(arg, falseName):
        outValue = false
        return true
    if driver_strIsEmpty(valueName):
        return false
    if strings.streq(arg, valueName) && i == count:
        driver_panic("backend_driver: missing value for " + valueName)
    var raw: str = ""
    var nextIndex: int32 = i
    if cmdline.readFlagValueAt(i, valueName, raw, nextIndex):
        outValue = driver_parseBoolStrict(raw, valueName)
        outNextIndex = nextIndex
        return true
    return false

fn driver_backendUsage() =
    driver_puts("Usage:")
    driver_puts("  backend_driver [--input:<file>|<file>] [--output:<out>] [options]")
    driver_puts("")
    driver_puts("Core options:")
    driver_puts("  --emit:<obj|exe> --target:<triple|auto> --frontend:<stage1>")
    driver_puts("  --linker:<self|system> --obj-writer:<auto|elf|macho|coff>")
    driver_puts("  --opt-level:<N> --opt2 --no-opt2 --opt --no-opt")
    driver_puts("  --multi --no-multi --multi-force --no-multi-force")
    driver_puts("  --incremental --no-incremental --allow-no-main --whole-program")
    driver_puts("  --skip-global-init --runtime-obj:<path> --runtime-c:<path> --no-runtime-c")
    driver_puts("  --generic-mode:<dict|dictionary|hybrid> --generic-spec-budget:<N>")
    driver_puts("  --borrow-ir:<mir|stage1> --generic-lowering:<mir_hybrid|mir_dict>")
    driver_puts("  --abi:<v2_noptr> --android-api:<N> --compile-stamp-out:<path>")
    driver_puts("  --native-contract --no-native-contract (hard-fail CNC mode)")
    driver_puts("  --profile --no-profile --uir-profile --no-uir-profile")
    driver_puts("  --uir-simd --no-uir-simd --uir-simd-max-width:<N> --uir-simd-policy:<name>")
    driver_puts("")
    driver_puts("Notes:")
    driver_puts("  - CLI options override BACKEND_* / GENERIC_* / ABI env values.")
    driver_puts("  - Value flags accept --k:v, --k=v, or --k v forms.")
    driver_puts("  - Unknown options are rejected.")

fn driver_parseLinkerSymtabAll(raw: str): bool =
    let s: str = lowerAscii(driver_trimAsciiSpace(raw))
    if driver_strIsEmpty(s):
        return false
    if driver_strEq(s, "0"):
        return false
    if driver_strEq(s, "minimal"):
        return false
    if driver_strEq(s, "min"):
        return false
    if driver_strEq(s, "1"):
        return true
    if driver_strEq(s, "all"):
        return true
    if driver_strEq(s, "full"):
        return true
    driver_panic("backend_driver: invalid BACKEND_LINKER_SYMTAB (expected minimal|all): " + raw)

fn driver_envDefault(name: str, defaultValue: str): str =
    if driver_strIsEmpty(name):
        return defaultValue
    let raw: str = driver_c_getenv(name)
    if driver_strIsEmpty(raw):
        return defaultValue
    return raw

fn driver_envBoolDefault(name: str, defaultValue: bool): bool =
    return driver_parseBoolDefault(driver_envDefault(name, ""), defaultValue)

fn driver_envIsTrue(name: str): bool =
    return driver_envBoolDefault(name, false)

fn driver_warnDeprecatedEnv(name: str, replacement: str) =
    let raw: str = driver_envDefault(name, "")
    if driver_strIsEmpty(raw):
        return
    let f: os.File = os.get_stderr()
    var msg: str = "backend_driver: deprecated env " + name
    if driver_strNonEmpty(replacement):
        msg = msg + " (use " + replacement + ")"
    driver_writeLine(f, msg)
    os.c_fflush f

fn driver_failRemovedEnv(name: str, replacement: str) =
    let raw: str = driver_envDefault(name, "")
    if driver_strIsEmpty(raw):
        return
    var msg: str = "backend_driver: removed env " + name
    if driver_strNonEmpty(replacement):
        msg = msg + ", use " + replacement
    driver_panic(msg)

fn driver_strEq(a: str, b: str): bool =
    if a == nil && b == nil:
        return true
    if a == nil || b == nil:
        return false
    let na: int32 = len(a)
    let nb: int32 = len(b)
    if na != nb:
        return false
    for i in 0..<na:
        if a[i] != b[i]:
            return false
    return true

type
    DriverProfileState =
        startNs: int64
        lastNs: int64
        enabled: bool
        prefix: str

fn driver_profileInit(enabled: bool, prefix: str): DriverProfileState =
    var st: DriverProfileState
    st.enabled = enabled
    if driver_strIsEmpty(prefix):
        st.prefix = "backend_profile"
    else:
        st.prefix = prefix
    let mt0: monotimes.MonoTime = monotimes.getMonoTime()
    let nowNs: int64 = monotimes.monoTimeNs(mt0)
    st.startNs = nowNs
    st.lastNs = nowNs
    return st

fn driver_profileStep(st: var DriverProfileState, label: str) =
    if ! st.enabled:
        return
    let mt1: monotimes.MonoTime = monotimes.getMonoTime()
    let nowNs: int64 = monotimes.monoTimeNs(mt1)
    let stepMs: int64 = (nowNs - st.lastNs) / 1000000
    let totalMs: int64 = (nowNs - st.startNs) / 1000000
    st.lastNs = nowNs
    let stepText: str = int64ToStr(stepMs)
    let totalText: str = int64ToStr(totalMs)
    let f: os.File = os.get_stderr()
    os.write(f, st.prefix)
    os.write(f, "\t")
    os.write(f, label)
    os.write(f, "\tstep_ms=")
    os.write(f, stepText)
    os.write(f, "\ttotal_ms=")
    driver_writeLine(f, totalText)
    os.c_fflush f

fn driver_profileStepBoth(primary: var DriverProfileState, secondary: var DriverProfileState, label: str) =
    driver_profileStep(primary, label)
    driver_profileStep(secondary, label)

fn driver_emitGenericsReport(enabled: bool, backendIr: str, genericMode: str, genericSpecBudget: int32,
                             borrowIr: str, genericLowering: str,
                             instancesTotal: int32, instancesReused: int32, instancesSpecialized: int32,
                             dictCalls: int32,
                             highUirCheckedFuncs: int32, lowUirLoweredFuncs: int32, highUirFallbackFuncs: int32,
                             elapsedMs: int64) =
    if !enabled:
        return
    let f: os.File = os.get_stderr()
    os.write(f, "generics_report\tir=")
    os.write(f, backendIr)
    os.write(f, "\tmode=")
    os.write(f, genericMode)
    os.write(f, "\tspec_budget=")
    os.write(f, intToStr(genericSpecBudget))
    os.write(f, "\tborrow_ir=")
    os.write(f, borrowIr)
    os.write(f, "\tgeneric_lowering=")
    os.write(f, genericLowering)
    os.write(f, "\tinstances_total=")
    os.write(f, intToStr(instancesTotal))
    os.write(f, "\tinstances_reused=")
    os.write(f, intToStr(instancesReused))
    os.write(f, "\tinstances_specialized=")
    os.write(f, intToStr(instancesSpecialized))
    os.write(f, "\tdict_calls=")
    os.write(f, intToStr(dictCalls))
    os.write(f, "\thigh_uir_checked_funcs=")
    os.write(f, intToStr(highUirCheckedFuncs))
    os.write(f, "\tlow_uir_lowered_funcs=")
    os.write(f, intToStr(lowUirLoweredFuncs))
    os.write(f, "\thigh_uir_fallback_funcs=")
    os.write(f, intToStr(highUirFallbackFuncs))
    os.write(f, "\tphase_contract_version=p4_phase_v1")
    os.write(f, "\tms=")
    os.write(f, int64ToStr(elapsedMs))
    driver_writeLine(f, "\tfrontend=stage1")
    os.c_fflush f

fn driver_emitUirSimdNotice(enabled: bool, maxWidth: int32, policy: str) =
    if !enabled:
        return
    let f: os.File = os.get_stderr()
    let policyText: str = driver_strIsEmpty(policy) ? "autovec" : policy
    os.write(f, "backend_driver: uir_simd status=")
    os.write(f, enabled ? "enabled" : "disabled")
    os.write(f, " policy=")
    os.write(f, policyText)
    os.write(f, " max_width=")
    os.write(f, intToStr(maxWidth))
    driver_writeLine(f, "")
    os.c_fflush f

fn driver_isKnownSimdPolicy(policy: str): bool =
    return driver_strEq(policy, "autovec") ||
           driver_strEq(policy, "copy") ||
           driver_strEq(policy, "loop") ||
           driver_strEq(policy, "slp") ||
           driver_strEq(policy, "none")

fn driver_isKnownGenericMode(mode: str): bool =
    if driver_strIsEmpty(mode):
        return false
    return driver_strEq(mode, "dict") || driver_strEq(mode, "dictionary") || driver_strEq(mode, "hybrid")

fn driver_isKnownBorrowIr(mode: str): bool =
    if driver_strIsEmpty(mode):
        return false
    return driver_strEq(mode, "mir") || driver_strEq(mode, "stage1")

fn driver_isKnownGenericLowering(mode: str): bool =
    if driver_strIsEmpty(mode):
        return false
    return driver_strEq(mode, "mir_hybrid") || driver_strEq(mode, "mir_dict")

fn driver_trimAsciiSpace(s: str): str =
    if driver_strIsEmpty(s):
        return ""
    let n: int32 = len s
    for start in 0..<n:
        if !(driver_isSpaceChar(s[start])):
            break
    var stop: int32 = n
    let __for_start_stop = stop
    for __for_rev_stop in 0..<(__for_start_stop - (start)):
        stop = __for_start_stop - __for_rev_stop
        if !(driver_isSpaceChar(s[stop - 1])):
            break
    if stop <= start:
        return ""
    if start == 0 && stop == n:
        return s
    return os.sliceStr(s, start, stop - 1)

fn driver_execCmdTrimmed(command: str): str =
    let opts: uint64 = driver_execCmdDefaultOptions()
    let res: os.ExecCmdResult = os.execCmdEx(command, opts, "")
    if os.execCmdResultExitCode(res) != 0:
        return ""
    return driver_trimAsciiSpace(os.execCmdResultOutput(res))

fn driver_detectHostTargetAuto(): str =
    let hostOs: str = driver_execCmdTrimmed("uname -s")
    let hostArch: str = driver_execCmdTrimmed("uname -m")
    if driver_strEq(hostOs, "Darwin"):
        if driver_strEq(hostArch, "arm64") || driver_strEq(hostArch, "aarch64"):
            return "arm64-apple-darwin"
        if driver_strEq(hostArch, "x86_64") || driver_strEq(hostArch, "amd64"):
            return "x86_64-apple-darwin"
        return ""
    if driver_strEq(hostOs, "Linux"):
        if driver_strEq(hostArch, "arm64") || driver_strEq(hostArch, "aarch64"):
            return "aarch64-unknown-linux-gnu"
        if driver_strEq(hostArch, "riscv64"):
            return "riscv64-unknown-linux-gnu"
        if driver_strEq(hostArch, "x86_64") || driver_strEq(hostArch, "amd64"):
            return "x86_64-unknown-linux-gnu"
        return ""
    if driver_strHasPrefix(hostOs, "MINGW") || driver_strHasPrefix(hostOs, "MSYS") || driver_strHasPrefix(hostOs, "CYGWIN"):
        if driver_strEq(hostArch, "arm64") || driver_strEq(hostArch, "aarch64"):
            return "aarch64-pc-windows-msvc"
        if driver_strEq(hostArch, "x86_64") || driver_strEq(hostArch, "amd64"):
            return "x86_64-pc-windows-msvc"
        return ""
    return ""

fn driver_detectHostJobsAuto(): int32 =
    var jobs: int32 = driver_parseInt32Default(driver_execCmdTrimmed("getconf _NPROCESSORS_ONLN 2>/dev/null"), 0)
    if jobs <= 0:
        jobs = driver_parseInt32Default(driver_execCmdTrimmed("nproc 2>/dev/null"), 0)
    if jobs <= 0:
        jobs = driver_parseInt32Default(driver_execCmdTrimmed("sysctl -n hw.logicalcpu 2>/dev/null"), 0)
    if jobs <= 0:
        jobs = driver_parseInt32Default(driver_execCmdTrimmed("sysctl -n hw.ncpu 2>/dev/null"), 0)
    if jobs <= 0:
        jobs = 4
    return jobs

fn driver_bool01(v: bool): str =
    return v ? "1" : "0"

fn driver_isPathLikeExe(s: str): bool =
    if driver_strIsEmpty(s):
        return false
    return driver_strContains(s, "/") || driver_strContains(s, "\\")

fn driver_pathIsAbsolute(path: str): bool =
    if path == nil || len(path) == 0:
        return false
    let c0: char = path[0]
    if c0 == '/' || c0 == '\\':
        return true
    if len(path) >= 2 && path[1] == ':':
        return true
    return false

fn driver_pathAbsolute(path: str): str =
    if path == nil || len(path) == 0:
        return ""
    if driver_pathIsAbsolute(path):
        return path
    let cwd: str = os.getCurrentDir()
    if driver_strIsEmpty(cwd):
        return path
    return os.joinPath(cwd, path)

fn driver_resolveSelfExeForParallel(raw: str): str =
    if raw == nil || len(raw) == 0:
        return ""
    if driver_isPathLikeExe(raw):
        let abs: str = driver_pathAbsolute(raw)
        if driver_fileExists(abs):
            return abs
        if driver_fileExists(raw):
            return raw
        return ""
    return raw

fn driver_fileStateStamp(path: str): str =
    if driver_strIsEmpty(path):
        return "file=<empty>\n"
    if driver_strEq(path, "<shared>"):
        return "shared_unit=" + path + "\n"
    if ! driver_fileExists(path):
        return "missing=" + path + "\n"
    let mtime: int64 = driver_fileMtime(path)
    let size: int64 = driver_fileSize(path)
    return "file=" + path +
           "\tmtime=" + int64ToStr(mtime) +
           "\tsize=" + int64ToStr(size) + "\n"

fn driver_buildModuleSourcesStamp(unitFiles: str[]): str =
    var out: str = ""
    for i in 0..<unitFiles.len:
        out = out + driver_fileStateStamp(unitFiles[i])
    return out

fn driver_hashCombine64(seed: int64, value: int64): int64 =
    let h: uint64 = uint64(seed) * uint64(1099511628211)
    return int64(h ^ uint64(value))

fn driver_buildUnitFileStateHashes(unitFiles: str[]): int64[] =
    var out: int64[]
    for i in 0..<unitFiles.len:
        let stamp: str = driver_fileStateStamp(unitFiles[i])
        add(out, uirFnv1a64(stamp))
    return out

fn driver_selfCompilerStamp(): str =
    let overrideId: str = driver_envDefault("BACKEND_COMPILER_ID", "")
    if driver_strNonEmpty(overrideId):
        return "compiler_id=" + overrideId + "\n"
    let raw: str = driver_envDefault("BACKEND_SELF_EXE", "")
    let resolved: str = driver_resolveSelfExeForParallel(raw)
    if driver_strNonEmpty(resolved) && driver_fileExists(resolved):
        return "compiler=" + resolved +
               "\tmtime=" + int64ToStr(driver_fileMtime(resolved)) +
               "\tsize=" + int64ToStr(driver_fileSize(resolved)) + "\n"
    if driver_strNonEmpty(raw):
        return "compiler=" + raw + "\n"
    return "compiler=<unknown>\n"

fn driver_buildObjCompileStamp(target: str, frontend: str, objWriter: str, inputPath: str,
                               allowNoMain: bool, wholeProgram: bool,
                               skipGlobalInit: bool, multi: bool, multiForce: bool,
                               multiLto: bool, abi: str, buildTrack: str, resolvedLinker: str,
                               noRuntimeC: bool, compilerStamp: str,
                               nativeContractEnabled: bool,
                               backendIr: str, genericMode: str, genericSpecBudget: int32,
                               opt2Enabled: bool, optEnabled: bool, optLevel: int32,
                               validateEnabled: bool,
                               uirSimdEnabled: bool, uirSimdMaxWidth: int32, uirSimdPolicy: str,
                               borrowIr: str, genericLowering: str,
                               pluginEnable: str, pluginPath: str, pluginPaths: str, meteringPlugin: str): str =
    let backendIrRaw0: str = lowerAscii(driver_trimAsciiSpace(backendIr))
    let backendIrRaw: str = driver_strIsEmpty(backendIrRaw0) ? "uir" : backendIrRaw0
    let genericModeRaw0: str = lowerAscii(driver_trimAsciiSpace(genericMode))
    let genericModeRaw: str = driver_strIsEmpty(genericModeRaw0) ? "dict" : genericModeRaw0
    let genericSpecBudgetRaw: str = intToStr(genericSpecBudget)
    let borrowIrRaw0: str = lowerAscii(driver_trimAsciiSpace(borrowIr))
    let borrowIrRaw: str = driver_strIsEmpty(borrowIrRaw0) ? "mir" : borrowIrRaw0
    let genericLoweringRaw0: str = lowerAscii(driver_trimAsciiSpace(genericLowering))
    let genericLoweringRaw: str = driver_strIsEmpty(genericLoweringRaw0) ? "mir_hybrid" : genericLoweringRaw0
    let buildTrackRaw0: str = lowerAscii(driver_trimAsciiSpace(buildTrack))
    let buildTrackRaw: str = driver_strIsEmpty(buildTrackRaw0) ? "dev" : buildTrackRaw0
    let resolvedLinkerRaw0: str = lowerAscii(driver_trimAsciiSpace(resolvedLinker))
    let resolvedLinkerRaw: str = driver_strIsEmpty(resolvedLinkerRaw0) ? "system" : resolvedLinkerRaw0
    let opt2Raw: str = driver_bool01(opt2Enabled)
    let optRaw: str = driver_bool01(optEnabled)
    let optLevelRaw: str = intToStr(optLevel)
    let validateRaw: str = driver_bool01(validateEnabled)
    let intBitsRaw: str = driver_envDefault("INTBITS", "")
    let mmRaw: str = driver_envDefault("MM", "")
    let mmStrictRaw: str = driver_envDefault("MM_STRICT", "")
    let noRealRaw: str = driver_envDefault("BACKEND_NO_REAL", "")
    let stdNoPtrRaw: str = driver_envDefault("STAGE1_STD_NO_POINTERS", "")
    let stdNoPtrStrictRaw: str = driver_envDefault("STAGE1_STD_NO_POINTERS_STRICT", "")
    let skipSemRaw: str = driver_trimAsciiSpace(driver_envDefault("STAGE1_SKIP_SEM", ""))
    let skipOwnershipRaw: str = driver_trimAsciiSpace(driver_envDefault("STAGE1_SKIP_OWNERSHIP", ""))
    let skipSemEffective: str = driver_bool01(driver_strEq(skipSemRaw, "1"))
    let skipOwnershipDefault: str = driver_bool01(driver_strIsEmpty(skipOwnershipRaw))
    let skipOwnershipEffective: str = driver_bool01(driver_strIsEmpty(skipOwnershipRaw) ||
                                                    driver_strEq(skipOwnershipRaw, "1"))
    let uirSimdRaw: str = driver_bool01(uirSimdEnabled)
    let uirSimdMaxWidthText: str = intToStr(uirSimdMaxWidth)
    let uirSimdPolicyRaw: str = driver_trimAsciiSpace(uirSimdPolicy)
    let nativeContractRaw: str = driver_bool01(nativeContractEnabled)
    let nativeContractChargeSymbol: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_NATIVE_CONTRACT_CHARGE_SYMBOL", "__cheng_contract_charge_block"))
    let nativeContractGasCounter: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_NATIVE_CONTRACT_GAS_COUNTER", "__cheng_contract_gas_used"))
    return "target=" + target + "\n" +
           "frontend=" + frontend + "\n" +
           "obj_writer=" + objWriter + "\n" +
           "input=" + inputPath + "\n" +
           "allow_no_main=" + driver_bool01(allowNoMain) + "\n" +
           "whole_program=" + driver_bool01(wholeProgram) + "\n" +
           "skip_global_init=" + driver_bool01(skipGlobalInit) + "\n" +
           "multi=" + driver_bool01(multi) + "\n" +
           "multi_force=" + driver_bool01(multiForce) + "\n" +
           "multi_lto=" + driver_bool01(multiLto) + "\n" +
           "backend_ir=" + backendIrRaw + "\n" +
           "generic_mode=" + genericModeRaw + "\n" +
           "generic_spec_budget=" + genericSpecBudgetRaw + "\n" +
           "native_contract=" + nativeContractRaw + "\n" +
           "native_contract_charge_symbol=" + nativeContractChargeSymbol + "\n" +
           "native_contract_gas_counter=" + nativeContractGasCounter + "\n" +
           "borrow_ir=" + borrowIrRaw + "\n" +
           "generic_lowering=" + genericLoweringRaw + "\n" +
           "abi=" + abi + "\n" +
           "build_track=" + buildTrackRaw + "\n" +
           "resolved_linker=" + resolvedLinkerRaw + "\n" +
           "no_runtime_c=" + driver_bool01(noRuntimeC) + "\n" +
           "opt2=" + opt2Raw + "\n" +
           "opt=" + optRaw + "\n" +
           "opt_level=" + optLevelRaw + "\n" +
           "validate=" + validateRaw + "\n" +
           "intbits=" + intBitsRaw + "\n" +
           "mm=" + mmRaw + "\n" +
           "mm_strict=" + mmStrictRaw + "\n" +
           "std_no_pointers=" + stdNoPtrRaw + "\n" +
           "std_no_pointers_strict=" + stdNoPtrStrictRaw + "\n" +
           "stage1_skip_sem_raw=" + skipSemRaw + "\n" +
           "stage1_skip_sem_effective=" + skipSemEffective + "\n" +
           "stage1_skip_ownership_raw=" + skipOwnershipRaw + "\n" +
           "stage1_skip_ownership_effective=" + skipOwnershipEffective + "\n" +
           "stage1_skip_ownership_default=" + skipOwnershipDefault + "\n" +
           "uir_phase_model=single_ir_dual_phase\n" +
           "uir_high_phase_contract=ownership_func_v1\n" +
           "uir_phase_contract_version=p4_phase_v1\n" +
           "no_real=" + noRealRaw + "\n" +
           "uir_simd=" + uirSimdRaw + "\n" +
           "uir_simd_max_width=" + uirSimdMaxWidthText + "\n" +
           "uir_simd_policy=" + uirSimdPolicyRaw + "\n" +
           "plugin_enable=" + pluginEnable + "\n" +
           "plugin_path=" + pluginPath + "\n" +
           "plugin_paths=" + pluginPaths + "\n" +
           "metering_plugin=" + meteringPlugin + "\n" +
           compilerStamp

fn driver_buildLinkStamp(target: str, linker: str, linkerSymtabAll: bool, ldCmd: str, cflags: str, ldflags: str,
                         runtimeObj: str, runtimeC: str, noRuntimeC: bool): str =
    var out: str = ""
    out = out + "target=" + target + "\n"
    out = out + "linker=" + linker + "\n"
    out = out + "linker_symtab_all=" + driver_bool01(linkerSymtabAll) + "\n"
    out = out + "ld=" + ldCmd + "\n"
    out = out + "cflags=" + cflags + "\n"
    out = out + "ldflags=" + ldflags + "\n"
    out = out + "no_runtime_c=" + driver_bool01(noRuntimeC) + "\n"
    out = out + driver_fileStateStamp(runtimeObj)
    if !noRuntimeC:
        out = out + driver_fileStateStamp(runtimeC)
    return out

fn driver_addRowInt32(rows: var DriverSeqSeqInt32, row: int32[]) =
    var cell: DriverRowInt32
    new cell
    cell.values = row
    add(rows, cell)

fn driver_addRowU64(rows: var DriverSeqSeqU64, row: uint64[]) =
    var cell: DriverRowU64
    new cell
    cell.values = row
    add(rows, cell)

fn driver_ptrBytes(): int32 =
    let intBitsRaw: str = driver_envDefault("INTBITS", "")
    if driver_strEq(intBitsRaw, "32"):
        return 4
    return 8

fn driver_readRowInt32Cell(rows: DriverSeqSeqInt32, i: int32): DriverRowInt32 =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowInt32* = DriverRowInt32*(driver_ptr_add(rows.buffer, off))
    return *p

fn driver_readRowInt32CellPtr(rows: DriverSeqSeqInt32*, i: int32): DriverRowInt32 =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowInt32* = DriverRowInt32*(driver_ptr_add(rows->buffer, off))
    return *p

fn driver_writeRowInt32Cell(rows: DriverSeqSeqInt32*, i: int32, cell: DriverRowInt32) =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowInt32* = DriverRowInt32*(driver_ptr_add(rows->buffer, off))
    *p = cell

fn driver_readRowU64Cell(rows: DriverSeqSeqU64, i: int32): DriverRowU64 =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowU64* = DriverRowU64*(driver_ptr_add(rows.buffer, off))
    return *p

fn driver_readRowU64CellPtr(rows: DriverSeqSeqU64*, i: int32): DriverRowU64 =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowU64* = DriverRowU64*(driver_ptr_add(rows->buffer, off))
    return *p

fn driver_writeRowU64Cell(rows: DriverSeqSeqU64*, i: int32, cell: DriverRowU64) =
    let off: int32 = i * driver_ptrBytes()
    let p: DriverRowU64* = DriverRowU64*(driver_ptr_add(rows->buffer, off))
    *p = cell

fn driver_getRowInt32(rows: DriverSeqSeqInt32, i: int32): int32[] =
    if i < 0 || i >= rows.len:
        panic "backend_driver: driver_getRowInt32 out of bounds"
    let cell: DriverRowInt32 = driver_readRowInt32Cell(rows, i)
    if cell == nil:
        var empty: int32[]
        return empty
    return cell.values

fn driver_setRowInt32(rows: var DriverSeqSeqInt32, i: int32, row: int32[]) =
    if i < 0 || i >= rows.len:
        panic "backend_driver: driver_setRowInt32 out of bounds"
    var cell: DriverRowInt32 = driver_readRowInt32CellPtr(&rows, i)
    if cell == nil:
        new cell
        driver_writeRowInt32Cell(&rows, i, cell)
    cell.values = row

fn driver_getRowU64(rows: DriverSeqSeqU64, i: int32): uint64[] =
    if i < 0 || i >= rows.len:
        panic "backend_driver: driver_getRowU64 out of bounds"
    let cell: DriverRowU64 = driver_readRowU64Cell(rows, i)
    if cell == nil:
        var empty: uint64[]
        return empty
    return cell.values

fn driver_setRowU64(rows: var DriverSeqSeqU64, i: int32, row: uint64[]) =
    if i < 0 || i >= rows.len:
        panic "backend_driver: driver_setRowU64 out of bounds"
    var cell: DriverRowU64 = driver_readRowU64CellPtr(&rows, i)
    if cell == nil:
        new cell
        driver_writeRowU64Cell(&rows, i, cell)
    cell.values = row

fn driver_newSeq2DInt(n: int32): DriverSeqSeqInt32 =
    var out: DriverSeqSeqInt32
    var empty: int32[]
    for i in 0..<n:
        driver_addRowInt32(out, empty)
    return out

fn driver_newSeq2DU64(rows: int32, words: int32): DriverSeqSeqU64 =
    var out: DriverSeqSeqU64
    for i in 0..<rows:
        var row: uint64[]
        row.len = words
        driver_addRowU64(out, row)
    return out

fn driver_setDepBit(depBits: DriverSeqSeqU64*, fromIdx: int32, toIdx: int32): bool =
    if depBits == nil || fromIdx < 0 || toIdx < 0:
        return false
    if fromIdx >= depBits->len:
        return false
    var row: uint64[] = driver_getRowU64(*depBits, fromIdx)
    let wordIdx: int32 = toIdx / 64
    if wordIdx < 0 || wordIdx >= row.len:
        return false
    let bit: int32 = toIdx % 64
    let mask: uint64 = uint64(1) << uint64(bit)
    let cur: uint64 = row[wordIdx]
    if (cur & mask) != uint64(0):
        return false
    row[wordIdx] = cur | mask
    driver_setRowU64(*depBits, fromIdx, row)
    return true

fn driver_collectExprUnitDeps(expr: UirExpr, ownerUnit: int32, depBits: DriverSeqSeqU64*,
                              fnOwners: var DriverMapStrInt,
                              globalOwners: var DriverMapStrInt) =
    if expr == nil:
        return
    if uirExprIsCall(expr):
        let callee: str = uirExprCalleeOf(expr)
        if driver_strNonEmpty(callee):
            var foundFn: bool = false
            let depFn: int32 = driver_hashMapStrIntGet(fnOwners, callee, foundFn)
            if foundFn && depFn >= 0 && depFn != ownerUnit:
                driver_setDepBit(depBits, ownerUnit, depFn)
        for ai in 0..<uirExprArgsLen(expr):
            driver_collectExprUnitDeps(uirExprArgAt(expr, ai), ownerUnit, depBits, fnOwners, globalOwners)
        return
    if uirExprIsGlobalAddr(expr):
        let globalName: str = uirExprGlobalNameOf(expr)
        if driver_strNonEmpty(globalName):
            var foundGlobal: bool = false
            let depGlobal: int32 = driver_hashMapStrIntGet(globalOwners, globalName, foundGlobal)
            if foundGlobal && depGlobal >= 0 && depGlobal != ownerUnit:
                driver_setDepBit(depBits, ownerUnit, depGlobal)
        return
    if uirExprIsBinOrCmp(expr):
        driver_collectExprUnitDeps(uirExprLhsOf(expr), ownerUnit, depBits, fnOwners, globalOwners)
        driver_collectExprUnitDeps(uirExprRhsOf(expr), ownerUnit, depBits, fnOwners, globalOwners)
        return
    if uirExprIsCast(expr):
        driver_collectExprUnitDeps(uirExprCastExprOf(expr), ownerUnit, depBits, fnOwners, globalOwners)
        return
    if uirExprIsAddrOrLoad(expr):
        driver_collectExprUnitDeps(uirExprAddrExprOf(expr), ownerUnit, depBits, fnOwners, globalOwners)
        return

fn driver_collectFuncUnitDeps(f: UirFunc, ownerUnit: int32, depBits: DriverSeqSeqU64*,
                              fnOwners: var DriverMapStrInt,
                              globalOwners: var DriverMapStrInt) =
    if f == nil:
        return
    for bi in 0..<uirFuncBlocksLen(f):
        let block: UirLowerBlock = uirFuncBlockAt(f, bi)
        if block != nil:
            for si in 0..<uirBlockStmtsLen(block):
                let st: UirStmt = uirBlockStmtAt(block, si)
                driver_collectExprUnitDeps(uirStmtExprOf(st), ownerUnit, depBits, fnOwners, globalOwners)
                driver_collectExprUnitDeps(uirStmtAddrExprOf(st), ownerUnit, depBits, fnOwners, globalOwners)
            driver_collectExprUnitDeps(uirBlockRetExprOf(block), ownerUnit, depBits, fnOwners, globalOwners)
            driver_collectExprUnitDeps(uirBlockCondExprOf(block), ownerUnit, depBits, fnOwners, globalOwners)

fn driver_callNameSetAdd(names: var DriverMapStrInt, callee: str) =
    if driver_strIsEmpty(callee):
        return
    var exists: bool = false
    let _v: int32 = driver_hashMapStrIntGet(names, callee, exists)
    if exists:
        return
    driver_hashMapStrIntPut(names, callee, 1)

fn driver_collectExprCallNames(expr: UirExpr, names: var DriverMapStrInt) =
    if expr == nil:
        return
    if uirExprIsCall(expr):
        driver_callNameSetAdd(names, uirExprCalleeOf(expr))
        for ai in 0..<uirExprArgsLen(expr):
            driver_collectExprCallNames(uirExprArgAt(expr, ai), names)
        return
    if uirExprIsBinOrCmp(expr):
        driver_collectExprCallNames(uirExprLhsOf(expr), names)
        driver_collectExprCallNames(uirExprRhsOf(expr), names)
        return
    if uirExprIsCast(expr):
        driver_collectExprCallNames(uirExprCastExprOf(expr), names)
        return
    if uirExprIsAddrOrLoad(expr):
        driver_collectExprCallNames(uirExprAddrExprOf(expr), names)
        return

fn driver_collectFuncCallNames(f: UirFunc, names: var DriverMapStrInt) =
    if f == nil:
        return
    for bi in 0..<uirFuncBlocksLen(f):
        let block: UirLowerBlock = uirFuncBlockAt(f, bi)
        if block != nil:
            for si in 0..<uirBlockStmtsLen(block):
                let st: UirStmt = uirBlockStmtAt(block, si)
                driver_collectExprCallNames(uirStmtExprOf(st), names)
                driver_collectExprCallNames(uirStmtAddrExprOf(st), names)
            driver_collectExprCallNames(uirBlockRetExprOf(block), names)
            driver_collectExprCallNames(uirBlockCondExprOf(block), names)

fn driver_collectExprGlobalNames(expr: UirExpr, names: var DriverMapStrInt) =
    if expr == nil:
        return
    if uirExprIsGlobalAddr(expr):
        driver_callNameSetAdd(names, uirExprGlobalNameOf(expr))
        return
    if uirExprIsCall(expr):
        for ai in 0..<uirExprArgsLen(expr):
            driver_collectExprGlobalNames(uirExprArgAt(expr, ai), names)
        return
    if uirExprIsBinOrCmp(expr):
        driver_collectExprGlobalNames(uirExprLhsOf(expr), names)
        driver_collectExprGlobalNames(uirExprRhsOf(expr), names)
        return
    if uirExprIsCast(expr):
        driver_collectExprGlobalNames(uirExprCastExprOf(expr), names)
        return
    if uirExprIsAddrOrLoad(expr):
        driver_collectExprGlobalNames(uirExprAddrExprOf(expr), names)
        return

fn driver_collectFuncGlobalNames(f: UirFunc, names: var DriverMapStrInt) =
    if f == nil:
        return
    for bi in 0..<uirFuncBlocksLen(f):
        let block: UirLowerBlock = uirFuncBlockAt(f, bi)
        if block != nil:
            for si in 0..<uirBlockStmtsLen(block):
                let st: UirStmt = uirBlockStmtAt(block, si)
                driver_collectExprGlobalNames(uirStmtExprOf(st), names)
                driver_collectExprGlobalNames(uirStmtAddrExprOf(st), names)
            driver_collectExprGlobalNames(uirBlockRetExprOf(block), names)
            driver_collectExprGlobalNames(uirBlockCondExprOf(block), names)

fn driver_buildUnitDependencyGraph(module: UirModule, unitFiles: str[]): DriverSeqSeqInt32 =
    let n: int32 = unitFiles.len
    var deps: DriverSeqSeqInt32 = driver_newSeq2DInt(n)
    if module == nil || n == 0:
        return deps
    let words: int32 =(n + 63) / 64
    var depBits: DriverSeqSeqU64 = driver_newSeq2DU64(n, words)
    var unitIndex: DriverMapStrInt = driver_hashMapStrIntInit(n * 2 + 8)
    for unitIdx in 0..<n:
        driver_hashMapStrIntPut(unitIndex, unitFiles[unitIdx], unitIdx)

    var fnOwners: DriverMapStrInt = driver_hashMapStrIntInit(uirModuleFuncsLen(module) * 2 + 8)
    for i in 0..<uirModuleFuncsLen(module):
        let f: UirFunc = uirModuleFuncAt(module, i)
        if f != nil && ! uirFuncIsExtern(f) && driver_strNonEmpty(uirFuncNameOf(f)):
            let ownerKey: str = driver_unitOwnerKey(uirFuncOriginFileOf(f))
            var foundOwner: bool = false
            let ownerIdx: int32 = driver_hashMapStrIntGet(unitIndex, ownerKey, foundOwner)
            if foundOwner:
                var exists: bool = false
                let _seenFnOwner: int32 = driver_hashMapStrIntGet(fnOwners, uirFuncNameOf(f), exists)
                if ! exists:
                    driver_hashMapStrIntPut(fnOwners, uirFuncNameOf(f), ownerIdx)

    var globalOwners: DriverMapStrInt = driver_hashMapStrIntInit(uirModuleGlobalsLen(module) * 2 + 8)
    for i in 0..<uirModuleGlobalsLen(module):
        let g: UirGlobal = uirModuleGlobalAt(module, i)
        if driver_strNonEmpty(uirGlobalNameOf(g)):
            let ownerKey2: str = driver_unitOwnerKey(uirGlobalOriginFileOf(g))
            var foundOwner2: bool = false
            let ownerIdx2: int32 = driver_hashMapStrIntGet(unitIndex, ownerKey2, foundOwner2)
            if foundOwner2:
                var exists2: bool = false
                let _seenGlobalOwner: int32 = driver_hashMapStrIntGet(globalOwners, uirGlobalNameOf(g), exists2)
                if ! exists2:
                    driver_hashMapStrIntPut(globalOwners, uirGlobalNameOf(g), ownerIdx2)

    for i in 0..<uirModuleFuncsLen(module):
        let f2: UirFunc = uirModuleFuncAt(module, i)
        if f2 != nil && ! uirFuncIsExtern(f2):
            let ownerKey3: str = driver_unitOwnerKey(uirFuncOriginFileOf(f2))
            var foundOwner3: bool = false
            let ownerIdx3: int32 = driver_hashMapStrIntGet(unitIndex, ownerKey3, foundOwner3)
            if foundOwner3:
                driver_collectFuncUnitDeps(f2, ownerIdx3, &depBits, fnOwners, globalOwners)
    for ui in 0..<n:
        var rowOut: int32[]
        let rowBits: uint64[] = driver_getRowU64(depBits, ui)
        for wi in 0..<rowBits.len:
            let word: uint64 = rowBits[wi]
            if word != uint64(0):
                for bi in 0..<64:
                    let idx: int32 = wi * 64 + bi
                    if idx >= n:
                        break
                    let mask: uint64 = uint64(1) << uint64(bi)
                    if (word & mask) != uint64(0):
                        add(rowOut, idx)
        driver_setRowInt32(deps, ui, rowOut)
    return deps

fn driver_buildUnitListStamp(unitFiles: str[]): str =
    var out: str = ""
    for i in 0..<unitFiles.len:
        out = out + unitFiles[i] + "\n"
    return out

fn driver_fnv1a64Update(h0: uint64, s0: str): uint64 =
    var h: uint64 = h0
    let s: str = (s0 != nil) ? s0 : ""
    for i in 0..<len(s):
        let c: char = s[i]
        h = h ^ uint64(int64(c) & int64(0xFF))
        h = h * uint64(1099511628211)
    return h

fn driver_fnv1a64UpdateChar(h0: uint64, c: char): uint64 =
    var h: uint64 = h0
    h = h ^ uint64(int64(c) & int64(0xFF))
    h = h * uint64(1099511628211)
    return h

fn driver_hashUnitList(unitFiles: str[]): int64 =
    var h: uint64 = uint64(1469598103934665603)
    for i in 0..<unitFiles.len:
        h = driver_fnv1a64Update(h, unitFiles[i])
        h = driver_fnv1a64UpdateChar(h, '\n')
    return int64(h)

fn driver_buildUnitDepClosureBits(unitDeps: DriverSeqSeqInt32, unitCount: int32): DriverSeqSeqU64 =
    if unitCount <= 0:
        var outNil: DriverSeqSeqU64
        return outNil
    let words: int32 = (unitCount + 63) / 64
    var closure: DriverSeqSeqU64 = driver_newSeq2DU64(unitCount, words)
    var revDeps: DriverSeqSeqInt32 = driver_newSeq2DInt(unitCount)
    for ui in 0..<unitCount:
        driver_setDepBit(&closure, ui, ui)
        if ui >= 0 && ui < unitDeps.len:
            let rowDeps: int32[] = driver_getRowInt32(unitDeps, ui)
            for di in 0..<rowDeps.len:
                let depIdx: int32 = rowDeps[di]
                if depIdx >= 0 && depIdx < unitCount:
                    driver_setDepBit(&closure, ui, depIdx)
                    var revRow: int32[] = driver_getRowInt32(revDeps, depIdx)
                    add(revRow, ui)
                    driver_setRowInt32(revDeps, depIdx, revRow)

    var queue: int32[]
    queue.cap = unitCount
    var queued: bool[]
    queued.cap = unitCount
    for ui in 0..<unitCount:
        add(queue, ui)
        add(queued, true)
    for qi in 0..<queue.len:
        let node: int32 = queue[qi]
        if node < 0 || node >= unitCount:
            continue
        queued[node] = false
        let nodeBits: uint64[] = driver_getRowU64(closure, node)
        let parents: int32[] = driver_getRowInt32(revDeps, node)
        for pi in 0..<parents.len:
            let parentIdx: int32 = parents[pi]
            if parentIdx >= 0 && parentIdx < unitCount:
                var parentBits: uint64[] = driver_getRowU64(closure, parentIdx)
                var changed: bool = false
                for wi in 0..<words:
                    let cur: uint64 = parentBits[wi]
                    let merged: uint64 = cur | nodeBits[wi]
                    if merged != cur:
                        parentBits[wi] = merged
                        changed = true
                if changed:
                    driver_setRowU64(closure, parentIdx, parentBits)
                    if ! queued[parentIdx]:
                        add(queue, parentIdx)
                        queued[parentIdx] = true
    return closure

fn driver_buildUnitDepClosureStamp(unitIdx: int32, unitFiles: str[], unitClosureBits: DriverSeqSeqU64,
                                   unitStateHashes: int64[], compileStampHash: int64): str =
    if unitIdx < 0 || unitIdx >= unitFiles.len:
        return ""
    let unitFile: str = unitFiles[unitIdx]
    var hash: int64 = driver_hashCombine64(compileStampHash, uirFnv1a64(unitFile))
    if unitIdx < 0 || unitIdx >= unitClosureBits.len:
        let fallbackHash: int64 = uirFnv1a64(driver_fileStateStamp(unitFile))
        hash = driver_hashCombine64(hash, fallbackHash)
        return "unit=" + unitFile + "\nclosure_hash=" + uirU64ToHex(hash) + "\n"
    let n: int32 = unitFiles.len
    let rowBits: uint64[] = driver_getRowU64(unitClosureBits, unitIdx)
    for wi in 0..<rowBits.len:
        let word: uint64 = rowBits[wi]
        if word != uint64(0):
            for bi in 0..<64:
                let idx: int32 = wi * 64 + bi
                if idx >= n:
                    break
                let mask: uint64 = uint64(1) << uint64(bi)
                if (word & mask) != uint64(0):
                    if idx >= 0 && idx < unitStateHashes.len:
                        hash = driver_hashCombine64(hash, unitStateHashes[idx])
                    elif idx >= 0 && idx < unitFiles.len:
                        hash = driver_hashCombine64(hash,
                                                    uirFnv1a64(driver_fileStateStamp(unitFiles[idx])))
    return "unit=" + unitFile + "\nclosure_hash=" + uirU64ToHex(hash) + "\n"

fn driver_parallelWorkerCount(pendingUnitsLen: int32, jobs: int32): int32 =
    if pendingUnitsLen <= 0:
        return 0
    var workerCount: int32 = int32(jobs)
    if workerCount <= 0:
        workerCount = 1
    let minBatchUnits: int32 = driver_parseInt32Default(
        driver_envDefault("BACKEND_MULTI_MIN_BATCH_UNITS", ""), 8)
    if minBatchUnits > 1:
        var maxWorkersByBatch: int32 = pendingUnitsLen / minBatchUnits
        if (pendingUnitsLen % minBatchUnits) != 0:
            maxWorkersByBatch = maxWorkersByBatch + 1
        if maxWorkersByBatch <= 0:
            maxWorkersByBatch = 1
        if workerCount > maxWorkersByBatch:
            workerCount = maxWorkersByBatch
    if workerCount > pendingUnitsLen:
        workerCount = pendingUnitsLen
    if workerCount <= 0:
        workerCount = 1
    return workerCount

fn driver_runParallelUnitBatches(selfExe: str, inputPath: str, target: str, frontend: str, objWriter: str,
                                 moduleCachePath: str,
                                 allowNoMain: bool, wholeProgram: bool, skipGlobalInit: bool,
                                 objDir: str, pendingUnits: str[], pendingObjs: str[], jobs: int32) =
    if pendingUnits.len == 0:
        return
    let workerCount: int32 = driver_parallelWorkerCount(pendingUnits.len, jobs)
    var batchLines: str[]
    for wi in 0..<workerCount:
        add(batchLines, "")
    for pi in 0..<pendingUnits.len:
        let bucket: int32 = pi % workerCount
        let line: str = pendingObjs[pi] + "\t" + pendingUnits[pi] + "\n"
        batchLines[bucket] = batchLines[bucket] + line

    let allowNoMainArg: str = allowNoMain ? " --allow-no-main" : " --no-allow-no-main"
    let wholeProgramArg: str = wholeProgram ? " --whole-program" : " --no-whole-program"
    let skipGlobalInitArg: str = skipGlobalInit ? " --skip-global-init" : " --no-skip-global-init"
    let parallelBuildFlags: str = allowNoMainArg + wholeProgramArg + skipGlobalInitArg

    var runCmd: str = "set -eu\n" +
                      "pids=\"\"\n"
    for wi in 0..<workerCount:
        let rows: str = batchLines[wi]
        if driver_strNonEmpty(rows):
            let batchPath: str = objDir + "/.build.batch." + intToStr(wi) + ".tsv"
            os.writeFile(batchPath, rows)
            var cmd: str = driver_shellQuote(selfExe) +
                           " --emit=exe --target=" + driver_shellQuote(target) +
                           " --frontend=" + driver_shellQuote(frontend)
            if driver_strNonEmpty(objWriter):
                cmd = cmd + " --obj-writer=" + driver_shellQuote(objWriter)
            if driver_strNonEmpty(moduleCachePath):
                cmd = cmd + " --module-cache=" + driver_shellQuote(moduleCachePath)
            cmd = cmd + " --unit-batch-file=" + driver_shellQuote(batchPath) +
                  parallelBuildFlags + " " + driver_shellQuote(inputPath)
            runCmd = runCmd + cmd + " &\n" +
                             "pids=\"$pids $!\"\n"
    runCmd = runCmd + "for pid in $pids; do\n" +
                      "  wait \"$pid\"\n" +
                      "done\n"
    driver_runCmd(runCmd)

fn driver_lockOwnerPid(): str =
    let pid: str = driver_execCmdTrimmed("sh -c 'echo $PPID'")
    if driver_strIsEmpty(pid):
        return "0"
    return pid

fn driver_acquireDirLock(lockDir: str, ownerPid: str) =
    if driver_strIsEmpty(lockDir):
        return
    let owner: str = (driver_strIsEmpty(ownerPid)) ? "0" : ownerPid
    let lockCmd: str = "set -eu\n" +
                       "lock_dir=" + driver_shellQuote(lockDir) + "\n" +
                       "owner_pid=" + driver_shellQuote(owner) + "\n" +
                       "owner_file=\"$lock_dir/owner.pid\"\n" +
                       "waits=0\n" +
                       "while ! mkdir \"$lock_dir\" 2>/dev/null; do\n" +
                       "  if [ -f \"$owner_file\" ]; then\n" +
                       "    owner=$(cat \"$owner_file\" 2>/dev/null || true)\n" +
                       "    if [ -n \"$owner\" ] && ! kill -0 \"$owner\" 2>/dev/null; then\n" +
                       "      rm -rf \"$lock_dir\" 2>/dev/null || true\n" +
                       "      continue\n" +
                       "    fi\n" +
                       "  fi\n" +
                       "  waits=$((waits + 1))\n" +
                       "  if [ \"$waits\" -ge 2400 ]; then\n" +
                       "    echo \"backend_driver: timeout waiting for lock: $lock_dir\" >&2\n" +
                       "    exit 1\n" +
                       "  fi\n" +
                       "  sleep 0.05\n" +
                       "done\n" +
                       "printf '%s\\n' \"$owner_pid\" > \"$owner_file\"\n"
    driver_runCmd(lockCmd)

fn driver_releaseDirLock(lockDir: str, ownerPid: str) =
    if driver_strIsEmpty(lockDir):
        return
    let owner: str = (driver_strIsEmpty(ownerPid)) ? "0" : ownerPid
    let unlockCmd: str = "set +e\n" +
                         "lock_dir=" + driver_shellQuote(lockDir) + "\n" +
                         "owner_pid=" + driver_shellQuote(owner) + "\n" +
                         "owner_file=\"$lock_dir/owner.pid\"\n" +
                         "if [ -f \"$owner_file\" ]; then\n" +
                         "  owner=$(cat \"$owner_file\" 2>/dev/null || true)\n" +
                         "  if [ \"$owner\" = \"$owner_pid\" ]; then\n" +
                         "    rm -rf \"$lock_dir\" 2>/dev/null || true\n" +
                         "  fi\n" +
                         "fi\n"
    driver_runCmd(unlockCmd)

fn driver_targetIsAndroid(target: str): bool =
    if driver_strIsEmpty(target):
        return false
    return driver_strContains(target, "android")

fn driver_targetIsDarwin(target: str): bool =
    if driver_strIsEmpty(target):
        return true
    return driver_strContains(target, "apple") || driver_strContains(target, "darwin") || driver_strContains(target, "ios")

fn driver_targetIsWindows(target: str): bool =
    if driver_strIsEmpty(target):
        return false
    return driver_strContains(target, "windows") || driver_strContains(target, "msvc")

fn driver_targetIsLinux(target: str): bool =
    if driver_strIsEmpty(target):
        return false
    if driver_targetIsAndroid(target):
        return false
    return driver_strContains(target, "linux")

fn driver_targetIsAarch64(target: str): bool =
    if driver_strIsEmpty(target):
        return true
    return driver_strContains(target, "aarch64") || driver_strContains(target, "arm64")

fn driver_targetIsX86_64(target: str): bool =
    if driver_strIsEmpty(target):
        return false
    return driver_strContains(target, "x86_64") || driver_strContains(target, "amd64")

fn driver_targetIsRiscv64(target: str): bool =
    if driver_strIsEmpty(target):
        return false
    return driver_strContains(target, "riscv64")

fn driver_defaultAndroidSdkRoot(): str =
    let sdk: str = driver_envDefault("ANDROID_SDK_ROOT", driver_envDefault("ANDROID_HOME", ""))
    if driver_strNonEmpty(sdk) && os.dirExists(sdk):
        return sdk
    let home: str = driver_envDefault("HOME", "")
    if driver_strIsEmpty(home):
        return ""
    # Android Studio default SDK locations.
    let mac: str = os.joinPath(home, "Library/Android/sdk")
    if os.dirExists(mac):
        return mac
    let linux: str = os.joinPath(home, "Android/Sdk")
    if os.dirExists(linux):
        return linux
    return ""

fn driver_defaultAndroidNdkRoot(): str =
    let ndk: str = driver_envDefault("ANDROID_NDK_HOME",
                                    driver_envDefault("ANDROID_NDK_ROOT", ""))
    if driver_strNonEmpty(ndk) && os.dirExists(ndk):
        return ndk
    let sdk: str = driver_defaultAndroidSdkRoot()
    if driver_strIsEmpty(sdk):
        return ""
    let bundle: str = os.joinPath(sdk, "ndk-bundle")
    if os.dirExists(bundle):
        return bundle
    let ndkBase: str = os.joinPath(sdk, "ndk")
    if ! os.dirExists(ndkBase):
        return ""
    let entries: os.seq_WalkDirEntry = os.walkDir(ndkBase)
    var bestPath: str = ""
    var bestName: str = ""
    for i in 0..<entries.len:
        let e: os.WalkDirEntry = os.os_get_WalkDirEntry(entries, i)
        if os.walkDirEntryKind(e) == os.pathComponentDir():
            let entryPath: str = os.walkDirEntryPath(e)
            let name: str = os.extractFilename(entryPath)
            if driver_strIsEmpty(bestPath):
                bestPath = entryPath
                bestName = name
            elif uirStrCmp(name, bestName) > 0:
                bestPath = entryPath
                bestName = name
    return bestPath

fn driver_defaultAndroidNdkClang(api: int32): str =
    let ndk: str = driver_defaultAndroidNdkRoot()
    if driver_strIsEmpty(ndk):
        return ""
    let prebuiltRoot: str = os.joinPath(ndk, "toolchains/llvm/prebuilt")
    var candidates: str[]
    add(candidates, "darwin-arm64")
    add(candidates, "darwin-x86_64")
    add(candidates, "linux-x86_64")
    add(candidates, "linux-arm64")
    add(candidates, "linux-aarch64")
    add(candidates, "windows-x86_64")
    add(candidates, "windows-x64")
    var prebuilt: str = ""
    for i in 0..<candidates.len:
        let candidate: str = candidates[i]
        let p: str = os.joinPath(prebuiltRoot, candidate)
        if os.dirExists(p):
            prebuilt = p
            break
    if driver_strIsEmpty(prebuilt):
        return ""
    let binDir: str = os.joinPath(prebuilt, "bin")
    let name: str = "aarch64-linux-android" + intToStr(api) + "-clang"
    let path: str = os.joinPath(binDir, name)
    if driver_fileExists(path):
        return path
    return ""

fn driver_seqContainsStr(items: str[], value: str): bool =
    for i in 0..<items.len:
        if (items[i] == value):
            return true
    return false

fn driver_stripLeadingUnderscores(raw: str): str =
    if driver_strIsEmpty(raw):
        return ""
    let n: int32 = len(raw)
    var i: int32 = 0
    while i < n && raw[i] == '_':
        i = i + 1
    if i <= 0:
        return raw
    if i >= n:
        return ""
    return str(driver_ptr_add(void*(raw), i))

fn driver_lineLastToken(line: str): str =
    if driver_strIsEmpty(line):
        return ""
    let n: int32 = len(line)
    var end: int32 = n
    let __for_start_trim = end
    for __for_rev_trim in 0..(__for_start_trim - (0)):
        end = __for_start_trim - __for_rev_trim
        if !(end > 0 && driver_isSpaceChar(line[end - 1])):
            break
    if end <= 0:
        return ""
    var start: int32 = end - 1
    let __for_start_scan = start
    for __for_rev_scan in 0..(__for_start_scan - (0)):
        start = __for_start_scan - __for_rev_scan
        if !(start > 0 && !driver_isSpaceChar(line[start - 1])):
            break
    if start < 0 || start >= end:
        return ""
    return os.sliceStr(line, start, end - 1)

fn driver_normalizeDictHelperSymbol(rawSym: str): str =
    let sym0: str = driver_trimAsciiSpace(rawSym)
    if driver_strIsEmpty(sym0):
        return ""
    let sym: str = driver_stripLeadingUnderscores(sym0)
    if driver_strIsEmpty(sym):
        return ""
    if driver_strEq(sym, "reserve"):
        return "reserve"
    if driver_strEq(sym, "setLen"):
        return "setLen"
    if driver_strEq(sym, "seqBytesOf"):
        return "__seqBytesOf"
    if driver_strHasPrefix(sym, "seqBytesOf_"):
        let sep: str = "_"
        return sep + sep + sym
    if driver_strHasPrefix(sym, "Ok_") ||
       driver_strHasPrefix(sym, "Err_") ||
       driver_strHasPrefix(sym, "ErrInfo_") ||
       driver_strHasPrefix(sym, "Some_") ||
       driver_strHasPrefix(sym, "None_") ||
       driver_strHasPrefix(sym, "IsOk_") ||
       driver_strHasPrefix(sym, "Value_") ||
       driver_strHasPrefix(sym, "ErrorInfoOf_") ||
       driver_strHasPrefix(sym, "driver_panicResult_"):
        return sym
    return ""

fn driver_collectDictHelperUndefSymbols(output: str, out: var str[], seen: var DriverMapStrInt) =
    if driver_strIsEmpty(output):
        return
    let n: int32 = len(output)
    var start: int32 = 0
    for i in 0..n:
        if i == n || output[i] == '\n':
            if i > start:
                let lineRaw: str = os.sliceStr(output, start, i - 1)
                let symRaw: str = driver_lineLastToken(lineRaw)
                let sym: str = driver_normalizeDictHelperSymbol(symRaw)
                if driver_strNonEmpty(sym):
                    driver_mapAddUniqueStr(out, seen, sym)
            start = i + 1

fn driver_collectDictHelperDefinedSymbols(output: str, out: var str[], seen: var DriverMapStrInt) =
    if driver_strIsEmpty(output):
        return
    let n: int32 = len(output)
    var start: int32 = 0
    for i in 0..n:
        if i == n || output[i] == '\n':
            if i > start:
                let lineRaw: str = os.sliceStr(output, start, i - 1)
                let line: str = driver_trimAsciiSpace(lineRaw)
                if driver_strNonEmpty(line):
                    let isUndef: bool = driver_strHasPrefix(line, "U ") || driver_strContains(line, " U ")
                    if !isUndef:
                        let symRaw: str = driver_lineLastToken(line)
                        let sym: str = driver_normalizeDictHelperSymbol(symRaw)
                        if driver_strNonEmpty(sym):
                            driver_mapAddUniqueStr(out, seen, sym)
            start = i + 1

fn driver_emitDictLinkClosureMissing(missing: str[]) =
    var miss: str[] = missing
    driver_sortStringsStable(miss)
    let maxShow: int32 = 20
    var msg: str = "backend_driver: dict_link_closure_missing"
    msg = msg + "\nhelpers="
    let shown: int32 = (miss.len > maxShow) ? maxShow : miss.len
    for i in 0..<shown:
        if i > 0:
            msg = msg + ", "
        msg = msg + miss[i]
    if miss.len > maxShow:
        msg = msg + ", ... +" + intToStr(miss.len - maxShow)
    driver_panic(msg)

fn driver_dictLinkClosureAllowSeqHelpers(): bool =
    # Stage0/stage1 bootstrap objects can surface `reserve`/`setLen` as
    # unresolved helper refs in per-unit objects even when runtime obj provides
    # concrete defs. Keep precheck permissive by default; explicit `0` restores
    # strict mode for diagnostics.
    return driver_envBoolDefault("DICT_LINK_PRECHECK_ALLOW_SEQ_HELPERS", true)

fn driver_dictLinkClosurePrecheck(objPaths: str[], runtimeObj: str, genericMode: str) =
    if driver_strIsEmpty(runtimeObj):
        return
    let gm: str = lowerAscii(driver_trimAsciiSpace(genericMode))
    if !driver_strEq(gm, "dict") && !driver_strEq(gm, "dictionary"):
        return
    var undefHelpers: str[]
    var undefSeen: DriverMapStrInt = driver_hashMapStrIntInit(256)
    var defHelpers: str[]
    var defSeen: DriverMapStrInt = driver_hashMapStrIntInit(256)

    for i in 0..<objPaths.len:
        let objPath: str = objPaths[i]
        if driver_strIsEmpty(objPath) || !driver_fileExists(objPath):
            continue
        let undefRes: os.ExecCmdResult = driver_execCmd("nm -u " + driver_shellQuote(objPath) + " 2>/dev/null")
        if os.execCmdResultExitCode(undefRes) == 0:
            driver_collectDictHelperUndefSymbols(os.execCmdResultOutput(undefRes), undefHelpers, undefSeen)
        let defRes: os.ExecCmdResult = driver_execCmd("nm -g " + driver_shellQuote(objPath) + " 2>/dev/null")
        if os.execCmdResultExitCode(defRes) == 0:
            driver_collectDictHelperDefinedSymbols(os.execCmdResultOutput(defRes), defHelpers, defSeen)

    if driver_strNonEmpty(runtimeObj) && driver_fileExists(runtimeObj):
        let runtimeDefRes: os.ExecCmdResult = driver_execCmd("nm -g " + driver_shellQuote(runtimeObj) + " 2>/dev/null")
        if os.execCmdResultExitCode(runtimeDefRes) == 0:
            driver_collectDictHelperDefinedSymbols(os.execCmdResultOutput(runtimeDefRes), defHelpers, defSeen)

    var missing: str[]
    var missingSeen: DriverMapStrInt = driver_hashMapStrIntInit(256)
    let allowSeqHelpers: bool = driver_dictLinkClosureAllowSeqHelpers()
    for i in 0..<undefHelpers.len:
        let sym: str = undefHelpers[i]
        var existsDef: bool = false
        let _defVal: int32 = driver_hashMapStrIntGet(defSeen, sym, existsDef)
        if !existsDef:
            if allowSeqHelpers && (driver_strEq(sym, "reserve") || driver_strEq(sym, "setLen")):
                continue
            driver_mapAddUniqueStr(missing, missingSeen, sym)
    if missing.len > 0:
        driver_emitDictLinkClosureMissing(missing)

fn driver_mapAddUniqueStr(items: var str[], seen: var DriverMapStrInt, value: str) =
    if driver_strIsEmpty(value):
        return
    var exists: bool = false
    let cur: int32 = driver_hashMapStrIntGet(seen, value, exists)
    if exists && cur != 0:
        return
    driver_hashMapStrIntPut(seen, value, 1)
    add(items, value)

fn driver_sortStringsStable(items: var str[]) =
    for i in 1..<items.len:
        let key: str = items[i]
        var j: int32 = i - 1
        let __for_start_j = j
        for __for_rev_j in 0..(__for_start_j - (0)):
            j = __for_start_j - __for_rev_j
            if !(uirStrCmp(items[j], key) > 0):
                break
            items[j + 1] = items[j]
        items[j + 1] = key

fn driver_sharedUnitFile(): str =
    return "<shared>"

fn driver_unitOwnerKey(originFile: str): str =
    if driver_strNonEmpty(originFile):
        return originFile
    return driver_sharedUnitFile()

fn driver_isSharedUnitFile(filePath: str): bool =
    return (filePath == driver_sharedUnitFile())

fn driver_collectUnitFiles(module: UirModule): str[] =
    var out: str[]
    if module == nil:
        return out
    let funcCount: int32 = uir_types.uirModuleFuncsLen(module)
    let globalCount: int32 = uir_types.uirModuleGlobalsLen(module)
    var seen: DriverMapStrInt = driver_hashMapStrIntInit(funcCount + globalCount + 16)
    var hasShared: bool = false
    for i in 0..<funcCount:
        let f: UirFunc = uir_types.uirModuleFuncAt(module, i)
        if f != nil && !uir_types.uirFuncIsExtern(f):
            let filePath: str = uir_types.uirFuncOriginFileOf(f)
            if driver_strNonEmpty(filePath):
                driver_mapAddUniqueStr(out, seen, filePath)
            else:
                hasShared = true
    for i in 0..<globalCount:
        let g: UirGlobal = uir_types.uirModuleGlobalAt(module, i)
        let filePath: str = uir_types.uirGlobalOriginFileOf(g)
        if driver_strNonEmpty(filePath):
            driver_mapAddUniqueStr(out, seen, filePath)
        else:
            hasShared = true
    if hasShared:
        driver_mapAddUniqueStr(out, seen, driver_sharedUnitFile())
    driver_sortStringsStable(out)
    return out

fn driver_cloneExternFunc(f: UirFunc): UirFunc =
    if f == nil:
        return nil
    let stub: UirFunc = uirNewFunc(uir_types.uirFuncNameOf(f), uir_types.uirFuncRetTypeOf(f))
    uir_types.uirFuncSetLinkName(stub, uir_types.uirFuncLinkNameOf(f))
    uir_types.uirFuncSetOriginFile(stub, uir_types.uirFuncOriginFileOf(f))
    uir_types.uirFuncSetExtern(stub, true)
    let paramCount: int32 = uir_types.uirFuncParamsLen(f)
    for pi in 0..<paramCount:
        uir_types.uirFuncAddParam(stub, uir_types.uirFuncParamAt(f, pi))
    return stub

fn driver_buildUnitIndex(full: UirModule, unitFiles: str[]): DriverUnitIndex =
    let dbg: bool = driver_envIsTrue("BACKEND_DEBUG_UNIT_INDEX")
    let nfuncs: int32 = (full != nil) ? uir_types.uirModuleFuncsLen(full) : 0
    let nglobs: int32 = (full != nil) ? uir_types.uirModuleGlobalsLen(full) : 0
    if dbg:
        let nfiles: int32 = unitFiles.len
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: unit_index start files=" + intToStr(nfiles) +
                       " funcs=" + intToStr(nfuncs) +
                       " globals=" + intToStr(nglobs))
        os.c_fflush f
    var out: DriverUnitIndex
    new out
    out.unitFiles = unitFiles
    var unitIndexMap: DriverMapStrInt = driver_hashMapStrIntInit(unitFiles.len * 2 + 8)
    out.unitFuncIdx = driver_newSeq2DInt(unitFiles.len)
    out.unitGlobalIdx = driver_newSeq2DInt(unitFiles.len)
    var nameToFuncIdxMap: DriverMapStrInt = driver_hashMapStrIntInit((nfuncs > 0) ? (nfuncs * 2 + 8) : 16)

    for ui in 0..<unitFiles.len:
        driver_hashMapStrIntPut(unitIndexMap, unitFiles[ui], ui)
    out.unitIndex = unitIndexMap
    if dbg:
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: unit_index map_ready")
        os.c_fflush f

    if full == nil:
        return out

    for fi in 0..<nfuncs:
        let f: UirFunc = uir_types.uirModuleFuncAt(full, fi)
        let fname: str = (f != nil) ? uir_types.uirFuncNameOf(f) : nil
        if fname != nil && len(fname) > 0:
            var exists: bool = false
            let _seenNameToFunc: int32 = driver_hashMapStrIntGet(nameToFuncIdxMap, fname, exists)
            if ! exists:
                driver_hashMapStrIntPut(nameToFuncIdxMap, fname, fi)
        let flink: str = (f != nil) ? uir_types.uirFuncLinkNameOf(f) : nil
        if flink != nil && len(flink) > 0:
            var hasLink: bool = false
            let _seenNameToFuncLink: int32 = driver_hashMapStrIntGet(nameToFuncIdxMap, flink, hasLink)
            if !hasLink:
                driver_hashMapStrIntPut(nameToFuncIdxMap, flink, fi)
    out.nameToFuncIdx = nameToFuncIdxMap
    if dbg:
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: unit_index name_to_func_ready")
        os.c_fflush f

    for gi in 0..<nglobs:
        let g: UirGlobal = uir_types.uirModuleGlobalAt(full, gi)
        let ownerKey: str = driver_unitOwnerKey(uir_types.uirGlobalOriginFileOf(g))
        var foundOwner: bool = false
        let ownerIdx: int32 = driver_hashMapStrIntGet(unitIndexMap, ownerKey, foundOwner)
        if foundOwner && ownerIdx >= 0 && ownerIdx < out.unitGlobalIdx.len:
            var row: int32[] = driver_getRowInt32(out.unitGlobalIdx, ownerIdx)
            add(row, gi)
            driver_setRowInt32(out.unitGlobalIdx, ownerIdx, row)
    if dbg:
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: unit_index globals_ready")
        os.c_fflush f

    for fi in 0..<nfuncs:
        let f2: UirFunc = uir_types.uirModuleFuncAt(full, fi)
        if f2 != nil && !uir_types.uirFuncIsExtern(f2):
            let ownerKey2: str = driver_unitOwnerKey(uir_types.uirFuncOriginFileOf(f2))
            var foundOwner2: bool = false
            let ownerIdx2: int32 = driver_hashMapStrIntGet(unitIndexMap, ownerKey2, foundOwner2)
            if foundOwner2 && ownerIdx2 >= 0 && ownerIdx2 < out.unitFuncIdx.len:
                var row2: int32[] = driver_getRowInt32(out.unitFuncIdx, ownerIdx2)
                add(row2, fi)
                driver_setRowInt32(out.unitFuncIdx, ownerIdx2, row2)
    if dbg:
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: unit_index funcs_ready")
        os.c_fflush f

    return out

fn driver_cacheStrTabInit(cap0: int32): DriverCacheStrTab =
    var tab: DriverCacheStrTab
    new tab
    tab.items = []
    var indexMap: DriverMapStrInt = driver_hashMapStrIntInit((cap0 > 0) ? cap0 : 16)
    # Index 0 is always empty string.
    add(tab.items, "")
    driver_hashMapStrIntPut(indexMap, "", 0)
    tab.index = indexMap
    return tab

fn driver_cacheStrTabIndex(tab: DriverCacheStrTab, s: str): int32 =
    if tab == nil:
        return 0
    if driver_strIsEmpty(s):
        return 0
    var found: bool = false
    var indexMap: DriverMapStrInt = tab.index
    let idx: int32 = driver_hashMapStrIntGet(indexMap, s, found)
    if found:
        return idx
    let newIdx: int32 = tab.items.len
    add(tab.items, s)
    driver_hashMapStrIntPut(indexMap, s, newIdx)
    tab.index = indexMap
    return newIdx

fn driver_cacheCollectExprStrings(expr: UirExpr, tab: DriverCacheStrTab) =
    return

fn driver_cacheCollectTermStrings(term: UirTerm, tab: DriverCacheStrTab) =
    return

fn driver_cacheCollectFuncStrings(f: UirFunc, tab: DriverCacheStrTab) =
    return

fn driver_cacheCollectModuleStrings(module: UirModule, idx: DriverUnitIndex, tab: DriverCacheStrTab) =
    return

fn driver_bufAddU8Ptr(buf: uint8[]*, v: uint8) =
    if buf == nil:
        return
    add(buf, v)

fn driver_cacheBufU8(buf: uint8[]*, v: int32) =
    if buf == nil:
        return
    driver_bufAddU8Ptr(buf, uint8(v & 255))

fn driver_cacheBufU32(buf: uint8[]*, v: uint32) =
    driver_cacheBufU8(buf, int32(v & uint32(255)))
    driver_cacheBufU8(buf, int32((v >> 8) & uint32(255)))
    driver_cacheBufU8(buf, int32((v >> 16) & uint32(255)))
    driver_cacheBufU8(buf, int32((v >> 24) & uint32(255)))

fn driver_cacheBufU64(buf: uint8[]*, v: uint64) =
    driver_cacheBufU32(buf, uint32(v & uint64(0xFFFFFFFF)))
    driver_cacheBufU32(buf, uint32((v >> 32) & uint64(0xFFFFFFFF)))

fn driver_cacheBufI32(buf: uint8[]*, v: int32) =
    driver_cacheBufU32(buf, uint32(v))

fn driver_cacheBufI64(buf: uint8[]*, v: int64) =
    driver_cacheBufU64(buf, uint64(v))

fn driver_cacheBufBool(buf: uint8[]*, b: bool) =
    driver_cacheBufU8(buf, b ? 1 : 0)

fn driver_cacheAppendBytes(buf: uint8[]*, data: void*, count: int32) =
    if buf == nil || data == nil || count <= 0:
        return
    let oldLen: int32 = buf->len
    buf->cap = oldLen + count
    buf->len = oldLen + count
    if buf->buffer == nil:
        panic "backend_driver: out of memory while building module cache"
    driver_copy_mem(driver_ptr_add(buf->buffer, oldLen), data, count)

fn driver_cacheBufStrBytes(buf: uint8[]*, s: str) =
    let n: int32 = driver_strIsEmpty(s) ? 0 : len(s)
    driver_cacheBufU32(buf, uint32(n))
    if n > 0:
        driver_cacheAppendBytes(buf, void*(s), n)

fn driver_cacheBufStrIdx(buf: uint8[]*, tab: DriverCacheStrTab, s: str) =
    let idx: int32 = driver_cacheStrTabIndex(tab, s)
    driver_cacheBufU32(buf, uint32(idx))

fn driver_cacheBufType(buf: uint8[]*, ty: UirLowerType) =
    return

fn driver_cacheBufExpr(buf: uint8[]*, tab: DriverCacheStrTab, expr: UirExpr) =
    return

fn driver_cacheBufStmt(buf: uint8[]*, tab: DriverCacheStrTab, stmt: UirStmt) =
    return

fn driver_cacheBufTerm(buf: uint8[]*, tab: DriverCacheStrTab, term: UirTerm) =
    return

fn driver_cacheBufBlock(buf: uint8[]*, tab: DriverCacheStrTab, block: UirLowerBlock) =
    return

fn driver_cacheBufFunc(buf: uint8[]*, tab: DriverCacheStrTab, f: UirFunc) =
    return

fn driver_cacheBufModule(buf: uint8[]*, tab: DriverCacheStrTab, module: UirModule) =
    return

fn driver_cacheBufUnitIndex(buf: uint8[]*, tab: DriverCacheStrTab, idx: DriverUnitIndex) =
    return

fn driver_writeModuleCache(path: str, module: UirModule, idx: DriverUnitIndex,
                           compileStampHash: int64, unitStateHashes: int64[]): bool =
    return false

type
    DriverCacheReader =
        bufData: void*
        bufLen: int32
        pos: int32
        ok: bool

fn driver_cacheReaderInit(buf: bytes.ByteBuffer): DriverCacheReader =
    DriverCacheReader(bufData: nil, bufLen: 0, pos: 0, ok: false)

fn driver_cacheReadU8(cr: DriverCacheReader*): int32 =
    if cr == nil || !cr->ok:
        return 0
    let pos0: int32 = cr->pos
    if pos0 + 1 > cr->bufLen:
        cr->ok = false
        return 0
    let p: void* = driver_ptr_add(cr->bufData, pos0)
    let p8: uint8* = uint8*(p)
    # Defensive: `uint8` may be represented as signed on some backends.
    let v: int32 = int32(*p8) & 255
    cr->pos = pos0 + 1
    return v

fn driver_cacheReadU32(cr: DriverCacheReader*): uint32 =
    let b0: uint32 = uint32(driver_cacheReadU8(cr))
    let b1: uint32 = uint32(driver_cacheReadU8(cr))
    let b2: uint32 = uint32(driver_cacheReadU8(cr))
    let b3: uint32 = uint32(driver_cacheReadU8(cr))
    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

fn driver_cacheReadU64(cr: DriverCacheReader*): uint64 =
    # Ensure zero-extension even if `uint32` is represented as signed.
    let lo: uint64 = uint64(driver_cacheReadU32(cr)) & uint64(0xFFFFFFFF)
    let hi: uint64 = uint64(driver_cacheReadU32(cr)) & uint64(0xFFFFFFFF)
    return lo | (hi << 32)

fn driver_cacheReadI32(cr: DriverCacheReader*): int32 =
    return int32(driver_cacheReadU32(cr))

fn driver_cacheReadI64(cr: DriverCacheReader*): int64 =
    return int64(driver_cacheReadU64(cr))

fn driver_cacheReadBool(cr: DriverCacheReader*): bool =
    return driver_cacheReadU8(cr) != 0

fn driver_cacheReadStringBytes(cr: DriverCacheReader*, n: int32): str =
    if cr == nil || !cr->ok:
        return ""
    if n < 0:
        cr->ok = false
        return ""
    let pos0: int32 = cr->pos
    if pos0 + n > cr->bufLen:
        cr->ok = false
        return ""
    let s: str = driver_new_string(n)
    if n > 0:
        driver_copy_mem(void*(s), driver_ptr_add(cr->bufData, pos0), n)
    cr->pos = pos0 + n
    return s

fn driver_cacheReadStringTable(cr: DriverCacheReader*): str[] =
    if cr == nil:
        var outNil: str[]
        return outNil
    let countU: uint32 = driver_cacheReadU32(cr)
    let count: int32 = int32(countU)
    if count <= 0 || count > 200000000:
        cr->ok = false
        var outBad: str[]
        return outBad
    var out: str[]
    out.len = int(count)
    for i in 0..<count:
        let n: int32 = int32(driver_cacheReadU32(cr))
        let s: str = driver_cacheReadStringBytes(cr, n)
        out[i] = s
    return out

fn driver_cacheGetStr(strings: str[], idx: int32): str =
    if idx <= 0:
        return ""
    if idx < 0 || idx >= strings.len:
        return ""
    return strings[idx]

fn driver_cacheReadType(cr: DriverCacheReader*): UirLowerType =
    return uirTypeI32()

fn driver_cacheReadExpr(cr: DriverCacheReader*, strings: str[]): UirExpr =
    return nil

fn driver_cacheReadStmt(cr: DriverCacheReader*, strings: str[]): UirStmt =
    var s: UirStmt
    return s

fn driver_cacheReadTerm(cr: DriverCacheReader*, strings: str[]): UirTerm =
    var t: UirTerm
    return t

fn driver_cacheReadBlock(cr: DriverCacheReader*, strings: str[]): UirLowerBlock =
    return nil

fn driver_cacheReadFunc(cr: DriverCacheReader*, strings: str[]): UirFunc =
    return nil

fn driver_cacheReadModule(cr: DriverCacheReader*, strings: str[]): UirModule =
    return nil

fn driver_cacheReadUnitIndex(cr: DriverCacheReader*, strings: str[], module: UirModule): DriverUnitIndex =
    return nil

fn driver_loadModuleCache(path: str, expectedCompileStampHash: int64): Result[DriverModuleCache] =
    return Err[DriverModuleCache]("module cache disabled")

fn driver_moduleCacheToUnitIndex(cache: DriverModuleCache): DriverUnitIndex =
    if cache == nil:
        return nil
    var out: DriverUnitIndex
    new out
    out.unitFiles = cache.unitFiles
    var unitIndexMap: DriverMapStrInt = driver_hashMapStrIntInit(cache.unitFiles.len * 2 + 8)
    for i in 0..<cache.unitFiles.len:
        driver_hashMapStrIntPut(unitIndexMap, cache.unitFiles[i], i)
    out.unitIndex = unitIndexMap
    out.unitFuncIdx = cache.unitFuncIdx
    out.unitGlobalIdx = cache.unitGlobalIdx
    out.nameToFuncIdx = cache.nameToFuncIdx
    return out

fn driver_buildUnitModuleFromIndex(full: UirModule, filePath: str, unitIdx: int32, idx: DriverUnitIndex): UirModule =
    return full

fn driver_buildUnitModule(full: UirModule, filePath: str): UirModule =
    return full

fn driver_isDeclOnlyExternName(name: str): bool =
    if driver_strIsEmpty(name):
        return false
    if driver_strHasPrefix(name, "SystemFunction") ||
       driver_strHasPrefix(name, "ExternFunction"):
        return true
    if driver_strHasPrefix(name, "cheng_") ||
       driver_strHasPrefix(name, "async") ||
       driver_strHasPrefix(name, "chan") ||
       driver_strHasPrefix(name, "sched"):
        return true
    if driver_strEq(name, "__addr") || driver_strEq(name, "_addr"):
        return true
    if driver_strEq(name, "get_stderr") || driver_strEq(name, "get_stdout") || driver_strEq(name, "get_stdin"):
        return true
    return false

fn driver_promoteDeclOnlyExternFuncs(module: UirModule): int32 =
    if module == nil:
        return 0
    return 0

fn driver_ensureParentDir(path: str) =
    if driver_strIsEmpty(path):
        return
    return

fn driver_emitObjBytesFromModule(module: UirModule, optLevel: int32, target: str, objWriter: str,
                                 uirSimdEnabled: bool, uirSimdMaxWidth: int32, uirSimdPolicy: str,
                                 validateOverride: int32 = -1): uint8[] =
    let dbgEmitPipe: bool = driver_envIsTrue("BACKEND_DEBUG_EMIT_PIPE")
    var dbgFile: os.File = nil
    if dbgEmitPipe:
        dbgFile = os.get_stderr()
        driver_writeLine(dbgFile, "[backend] emit: uir_start")
        os.c_fflush dbgFile
    var validate: bool = driver_strEq(driver_envDefault("BACKEND_VALIDATE", ""), "1")
    if validateOverride >= 0:
        validate = validateOverride != 0
    if dbgEmitPipe:
        driver_writeLine(dbgFile, "[backend] emit: uir_promote_decl")
        os.c_fflush dbgFile
    let patchedExternDecls: int32 = driver_promoteDeclOnlyExternFuncs(module)
    if patchedExternDecls > 0 && driver_envIsTrue("BACKEND_VALIDATE_DEBUG"):
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: promoted decl-only funcs to extern: " + intToStr(patchedExternDecls))

    let objBytes: uint8[] = uirEmitObjFromModuleOrPanic(module, optLevel, target, objWriter, validate,
                                                        uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy)
    if dbgEmitPipe:
        driver_writeLine(dbgFile, "[backend] emit: uir_done")
        os.c_fflush dbgFile
    let dbgObjMagic: bool = driver_envIsTrue("BACKEND_DEBUG_OBJ_MAGIC")
    if dbgObjMagic:
        let dbgObj: uint8[] = objBytes
        let fDbgObj: os.File = os.get_stderr()
        var b0: int32 = -1
        var b1: int32 = -1
        var b2: int32 = -1
        var b3: int32 = -1
        if dbgObj.len > 0:
            b0 = int32(dbgObj[0])
        if dbgObj.len > 1:
            b1 = int32(dbgObj[1])
        if dbgObj.len > 2:
            b2 = int32(dbgObj[2])
        if dbgObj.len > 3:
            b3 = int32(dbgObj[3])
        driver_writeLine(fDbgObj, "backend_driver: obj_magic len=" + intToStr(dbgObj.len) +
                     " b0=" + intToStr(b0) + " b1=" + intToStr(b1) +
                     " b2=" + intToStr(b2) + " b3=" + intToStr(b3))
        os.c_fflush fDbgObj
    return objBytes

fn driver_emitObjFromModule(module: UirModule, optLevel: int32, target: str, objWriter: str, outPath: str,
                           uirSimdEnabled: bool, uirSimdMaxWidth: int32, uirSimdPolicy: str,
                           validateOverride: int32 = -1) =
    driver_ensureParentDir(outPath)
    let dbgEmitPipe: bool = driver_envIsTrue("BACKEND_DEBUG_EMIT_PIPE")
    var dbgFile: os.File = nil
    if dbgEmitPipe:
        dbgFile = os.get_stderr()
    let objBytes: uint8[] = driver_emitObjBytesFromModule(module, optLevel, target, objWriter,
                                                          uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy,
                                                          validateOverride)
    if dbgEmitPipe:
        driver_writeLine(dbgFile, "[backend] emit: write_start")
        os.c_fflush dbgFile
    os.writeFileBytes(outPath, objBytes)
    if dbgEmitPipe:
        driver_writeLine(dbgFile, "[backend] emit: write_done")
        os.c_fflush dbgFile
    if ! driver_fileExists(outPath):
        driver_panic("backend_driver: failed to write object file: " + outPath)

fn driver_runParallelUnitBatchesFork(full: UirModule, optLevel: int32, unitIndex: DriverUnitIndex, target: str, objWriter: str,
                                     pendingUnits: str[], pendingObjs: str[],
                                     uirSimdEnabled: bool, uirSimdMaxWidth: int32, uirSimdPolicy: str,
                                     pendingUnitIdxs: int32[], jobs: int32): bool =
    if full == nil || unitIndex == nil || pendingUnits.len == 0:
        return false
    let workerCount: int32 = driver_parallelWorkerCount(pendingUnits.len, jobs)
    if workerCount <= 1:
        return false

    var buckets: DriverSeqSeqInt32
    var empty: int32[]
    for wi in 0..<workerCount:
        driver_addRowInt32(buckets, empty)
    for pi in 0..<pendingUnits.len:
        let bucket: int32 = pi % workerCount
        var row: int32[] = driver_getRowInt32(buckets, bucket)
        add(row, pi)
        driver_setRowInt32(buckets, bucket, row)

    var pids: int64[]
    for wi in 0..<workerCount:
        let row2: int32[] = driver_getRowInt32(buckets, wi)
        if row2.len > 0:
            let pid: int64 = driver_c_fork()
            if pid == 0:
                for ri in 0..<row2.len:
                        let idx: int32 = row2[ri]
                        if idx >= 0 && idx < pendingUnits.len && idx < pendingObjs.len:
                            let fp: str = pendingUnits[idx]
                            let objPath: str = pendingObjs[idx]
                            var u: UirModule
                            var built: bool = false
                            var unitIdx: int32 = -1
                            if idx < pendingUnitIdxs.len:
                                unitIdx = pendingUnitIdxs[idx]
                            if unitIdx >= 0:
                                let candByUnitIdx: UirModule = driver_buildUnitModuleFromIndex(full, fp, unitIdx, unitIndex)
                                if candByUnitIdx != nil:
                                    u = candByUnitIdx
                                    built = true
                            if !built:
                                var found: bool = false
                                var unitMap: DriverMapStrInt = unitIndex.unitIndex
                                let mappedIdx: int32 = driver_hashMapStrIntGet(unitMap, fp, found)
                                if found && mappedIdx >= 0:
                                    let candMapped: UirModule = driver_buildUnitModuleFromIndex(full, fp, mappedIdx, unitIndex)
                                    if candMapped != nil:
                                        u = candMapped
                                        built = true
                            if !built:
                                u = driver_buildUnitModule(full, fp)
                            driver_emitObjFromModule(u, optLevel, target, objWriter, objPath,
                                                    uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy)
                driver_exit 0
            if pid < 0:
                let fFork: os.File = os.get_stderr()
                driver_writeLine(fFork, "backend_driver: fork failed; fallback to serial multi compile")
                return false
            add(pids, pid)

    var status: int32 = 0
    var waitFailed: bool = false
    var workerFailed: bool = false
    var workerFailedSignal: bool = false
    var workerFailedCode: int32 = 0
    for pi2 in 0..<pids.len:
        let pid2: int64 = pids[pi2]
        status = 0
        let waited: int64 = driver_c_waitpid(pid2, &status, 0)
        if waited != pid2:
            waitFailed = true
        else:
            if (status & 127) != 0:
                workerFailed = true
                workerFailedSignal = true
                workerFailedCode = status & 127
            else:
                let code: int32 = status >> 8
                if code != 0:
                    workerFailed = true
                    workerFailedSignal = false
                    workerFailedCode = code
    if waitFailed:
        let fWait: os.File = os.get_stderr()
        driver_writeLine(fWait, "backend_driver: waitpid failed in fork worker path; fallback to serial multi compile")
        return false
    if workerFailed:
        let fWorker: os.File = os.get_stderr()
        if workerFailedSignal:
            driver_writeLine(fWorker, "backend_driver: fork worker terminated by signal=" + intToStr(workerFailedCode) +
                         "; fallback to serial multi compile")
        else:
            driver_writeLine(fWorker, "backend_driver: fork worker failed: exit_code=" + intToStr(workerFailedCode) +
                         "; fallback to serial multi compile")
        return false
    return true

fn driver_runSerialUnitBatches(full: UirModule, optLevel: int32, unitIndex: DriverUnitIndex, target: str, objWriter: str,
                               pendingUnits: str[], pendingObjs: str[],
                               uirSimdEnabled: bool, uirSimdMaxWidth: int32, uirSimdPolicy: str) =
    if full == nil || pendingUnits.len == 0:
        return
    for i in 0..<pendingUnits.len:
        let fp: str = pendingUnits[i]
        let objPath: str = pendingObjs[i]
        var u: UirModule
        var built: bool = false
        if unitIndex != nil:
            var found: bool = false
            var unitMap2: DriverMapStrInt = unitIndex.unitIndex
            let unitIdx: int32 = driver_hashMapStrIntGet(unitMap2, fp, found)
            if found:
                let byUnit: UirModule = driver_buildUnitModuleFromIndex(full, fp, unitIdx, unitIndex)
                if byUnit != nil:
                    u = byUnit
                    built = true
        if !built:
            u = driver_buildUnitModule(full, fp)
        driver_emitObjFromModule(u, optLevel, target, objWriter, objPath,
                                uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy)

fn driver_moduleHasOwnSymbols(module: UirModule, filePath: str): bool =
    if module == nil || driver_strIsEmpty(filePath):
        return false
    return true

fn driver_resolveUnitFile(module: UirModule, requested: str): str =
    if driver_strIsEmpty(requested):
        return ""
    let files: str[] = driver_collectUnitFiles(module)
    return driver_resolveUnitFileFromList(files, requested)

fn driver_resolveUnitFileFromList(unitFiles: str[], requested: str): str =
    if driver_strIsEmpty(requested):
        return ""
    if driver_seqContainsStr(unitFiles, requested):
        return requested
    let reqBase: str = os.extractFilename(requested)
    let reqTail: str = "/" + requested
    var found: str = ""
    for i in 0..<unitFiles.len:
        let cand: str = unitFiles[i]
        if (cand == requested):
            return cand
        if driver_strHasSuffix(cand, reqTail):
            return cand
        if (os.extractFilename(cand) == reqBase):
            if driver_strIsEmpty(found):
                found = cand
            else:
                driver_panic("backend_driver: ambiguous unit file: " + requested)
    if driver_strNonEmpty(found):
        return found
    return ""

fn driver_tryLinkExeMainObjMem(mainObjBytes: uint8[], target: str, linker: str, linkerSymtabAll: bool,
                               outputPath: str, runtimeObj: str): bool =
    if !driver_strEq(linker, "self"):
        return false
    if mainObjBytes == nil || mainObjBytes.len <= 0:
        driver_panic("backend_driver: empty main object bytes for in-memory self-link")
    var extraObjPaths: str[]
    if len(runtimeObj) > 0:
        if ! driver_fileExists(runtimeObj):
            driver_panic("backend_driver: runtime obj not found: " + runtimeObj)
        add(extraObjPaths, runtimeObj)
    if driver_targetIsDarwin(target) && driver_targetIsAarch64(target):
        let _linkedA64Mem: bool = machoLinkExeAarch64MainObjMem(mainObjBytes, extraObjPaths, outputPath,
                                                                 linkerSymtabAll, runtimeObj)
        if !_linkedA64Mem:
            driver_panic("backend_driver: in-memory link failed (darwin arm64)")
        driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
        if !driver_strEq(driver_envDefault("BACKEND_CODESIGN", "1"), "0"):
            driver_runCmd("codesign -s - " + driver_shellQuote(outputPath))
        return true
    if driver_targetIsDarwin(target) && driver_targetIsX86_64(target):
        let _linkedX64Mem: bool = machoLinkExeX86_64MainObjMem(mainObjBytes, extraObjPaths, outputPath,
                                                                linkerSymtabAll)
        if !_linkedX64Mem:
            driver_panic("backend_driver: in-memory link failed (darwin x86_64)")
        driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
        if !driver_strEq(driver_envDefault("BACKEND_CODESIGN", "1"), "0"):
            driver_runCmd("codesign -s - " + driver_shellQuote(outputPath))
        return true
    return false

fn driver_linkExeObjects(objPaths: str[], target: str, linker: str, linkerSymtabAll: bool,
                         ldCmd: str, cflags: str, ldflags: str,
                         outputPath: str, runtimeObj: str, runtimeC: str, noRuntimeC: bool,
                         genericMode: str) =
    if objPaths.len == 0:
        panic "backend_driver: no object files to link"
    driver_dictLinkClosurePrecheck(objPaths, runtimeObj, genericMode)
    if driver_strEq(linker, "self"):
        var linkObjs: str[]
        for i in 0..<objPaths.len:
            add(linkObjs, objPaths[i])
        if len(runtimeObj) > 0:
            if ! driver_fileExists(runtimeObj):
                driver_panic("backend_driver: runtime obj not found: " + runtimeObj)
            add(linkObjs, runtimeObj)
        if driver_targetIsDarwin(target) && driver_targetIsAarch64(target):
            let _linkedA64: bool = machoLinkExeAarch64(linkObjs, outputPath, linkerSymtabAll, runtimeObj)
            if !_linkedA64:
                driver_panic("backend_driver: self link failed (darwin arm64)")
            driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
            if !driver_strEq(driver_envDefault("BACKEND_CODESIGN", "1"), "0"):
                driver_runCmd("codesign -s - " + driver_shellQuote(outputPath))
            return
        if driver_targetIsDarwin(target) && driver_targetIsX86_64(target):
            let _linkedX64: bool = machoLinkExeX86_64(linkObjs, outputPath, linkerSymtabAll)
            if !_linkedX64:
                driver_panic("backend_driver: self link failed (darwin x86_64)")
            driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
            if !driver_strEq(driver_envDefault("BACKEND_CODESIGN", "1"), "0"):
                driver_runCmd("codesign -s - " + driver_shellQuote(outputPath))
            return
        if (driver_targetIsLinux(target) || driver_targetIsAndroid(target)) && driver_targetIsAarch64(target):
            let _linkedElfA64: bool = elfLinkExeAarch64(linkObjs, outputPath, target)
            if !_linkedElfA64:
                driver_panic("backend_driver: self link failed (elf aarch64)")
            driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
            return
        if (driver_targetIsLinux(target) || driver_targetIsAndroid(target)) && driver_targetIsRiscv64(target):
            let _linkedElfRv64: bool = elfLinkExeRiscv64(linkObjs, outputPath, target)
            if !_linkedElfRv64:
                driver_panic("backend_driver: self link failed (elf riscv64)")
            driver_runCmd("chmod +x " + driver_shellQuote(outputPath))
            return
        if driver_targetIsWindows(target) && driver_targetIsAarch64(target):
            let _linkedCoffA64: bool = coffLinkExeAarch64(linkObjs, outputPath, target)
            if !_linkedCoffA64:
                driver_panic("backend_driver: self link failed (coff aarch64)")
            return
        driver_panic("backend_driver: self linker unsupported target: " + target)

    var linkCmd: str = ldCmd
    for i2 in 0..<objPaths.len:
        linkCmd = linkCmd + " " + driver_shellQuote(objPaths[i2])
    if len(runtimeObj) > 0:
        if ! driver_fileExists(runtimeObj):
            driver_panic("backend_driver: runtime obj not found: " + runtimeObj)
        linkCmd = linkCmd + " " + driver_shellQuote(runtimeObj)
    elif ! noRuntimeC && driver_fileExists(runtimeC):
        linkCmd = linkCmd + " " + driver_shellQuote(runtimeC)
    if len(cflags) > 0:
        linkCmd = linkCmd + " " + cflags
    linkCmd = linkCmd + " -o " + driver_shellQuote(outputPath)
    if len(ldflags) > 0:
        linkCmd = linkCmd + " " + ldflags
    driver_runCmd(linkCmd)

fn driver_loadObjectList(path: str): str[] =
    var out: str[]
    if driver_strIsEmpty(path):
        return out
    if ! driver_fileExists(path):
        driver_panic("backend_driver: object list not found: " + path)
    let content: str = os.readFile(path)
    if driver_strIsEmpty(content):
        return out
    let n: int32 = len(content)
    var start: int32 = 0
    for i in 0..n:
        if i == n || content[i] == '\n':
            if i > start:
                let lineRaw: str = os.sliceStr(content, start, i - 1)
                let line: str = driver_trimAsciiSpace(lineRaw)
                if driver_strNonEmpty(line):
                    if line[0] != '#':
                        add(out, line)
            start = i + 1
    return out

fn driver_loadUnitBatchPairs(path: str): str[] =
    var out: str[]
    if driver_strIsEmpty(path):
        return out
    if ! driver_fileExists(path):
        driver_panic("backend_driver: unit batch file not found: " + path)
    let content: str = os.readFile(path)
    if driver_strIsEmpty(content):
        return out
    let n: int32 = len(content)
    var start: int32 = 0
    for i in 0..n:
        if i == n || content[i] == '\n':
            if i > start:
                let rawLine: str = os.sliceStr(content, start, i - 1)
                let line: str = driver_trimAsciiSpace(rawLine)
                if driver_strNonEmpty(line):
                    if line[0] != '#':
                        let ln: int32 = len(line)
                        var tabPos: int32 = -1
                        for ti in 0..<ln:
                            if line[ti] == '\t':
                                tabPos = ti
                                break
                        if tabPos <= 0 || tabPos >= ln - 1:
                            driver_panic("backend_driver: invalid batch line (expect '<obj>\\t<unit>'): " + line)
                        let objPathRaw: str = os.sliceStr(line, 0, tabPos - 1)
                        let unitRaw: str = os.sliceStr(line, tabPos + 1, ln - 1)
                        let objPath: str = driver_trimAsciiSpace(objPathRaw)
                        let unitPath: str = driver_trimAsciiSpace(unitRaw)
                        if driver_strIsEmpty(objPath) || driver_strIsEmpty(unitPath):
                            driver_panic("backend_driver: invalid batch line (empty obj/unit): " + line)
                        add(out, objPath)
                        add(out, unitPath)
            start = i + 1
    return out

fn backendMainNative(): int32 =
    var backendProfileEnabled: bool = driver_envBoolDefault("BACKEND_PROFILE", false)
    var uirProfileEnabled: bool = driver_envBoolDefault("UIR_PROFILE", false)
    var inputPath: str = driver_envDefault("BACKEND_INPUT", "")
    var outputPath: str = driver_envDefault("BACKEND_OUTPUT", "")
    var emitMode: str = driver_envDefault("BACKEND_EMIT", "exe")
    var target: str = driver_envDefault("BACKEND_TARGET", "auto")
    var backendIr: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("BACKEND_IR", "uir")))
    var frontend: str = "stage1"
    var genericMode: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("GENERIC_MODE", "dict")))
    var genericSpecBudget: int32 = driver_parseInt32Default(driver_envDefault("GENERIC_SPEC_BUDGET", ""), 0)
    var borrowIr: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("BORROW_IR", "mir")))
    var genericLowering: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("GENERIC_LOWERING", "mir_hybrid")))
    var compileStampOutPath: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_COMPILE_STAMP_OUT", ""))
    var uirSimdRaw: str = driver_trimAsciiSpace(driver_envDefault("UIR_SIMD", ""))
    var uirSimdEnabled: bool = false
    var uirSimdMaxWidth: int32 = driver_parseInt32Default(driver_envDefault("UIR_SIMD_MAX_WIDTH", ""), 0)
    var uirSimdPolicy: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("UIR_SIMD_POLICY", "autovec")))
    var opt2: bool = driver_strEq(driver_envDefault("BACKEND_OPT2", ""), "1")
    var optEnabled: bool = driver_strEq(driver_envDefault("BACKEND_OPT", ""), "1")
    let optLevelEnvRaw: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_OPT_LEVEL", ""))
    var optLevelExplicit: bool = driver_strNonEmpty(optLevelEnvRaw)
    var optDefault: int32 = opt2 ? 2 : (optEnabled ? 1 : 2)
    var optLevel: int32 = driver_parseInt32Default(optLevelEnvRaw, optDefault)
    var validateEnabled: bool = driver_envBoolDefault("BACKEND_VALIDATE", false)
    var ccCmd: str = driver_envDefault("BACKEND_CC", "cc")
    var ccExplicit: bool = false
    if len(driver_envDefault("BACKEND_CC", "")) > 0:
        ccExplicit = true
    var ldCmd: str = driver_envDefault("BACKEND_LD", "")
    var ldExplicit: bool = false
    if len(driver_envDefault("BACKEND_LD", "")) > 0:
        ldExplicit = true
    var cflags: str = driver_envDefault("BACKEND_CFLAGS", "")
    var ldflags: str = driver_envDefault("BACKEND_LDFLAGS", "")
    var linker: str = driver_envDefault("BACKEND_LINKER", "")
    var linkerSymtab: str = driver_envDefault("BACKEND_LINKER_SYMTAB", "")
    var objWriter: str = driver_envDefault("BACKEND_OBJ_WRITER", "")
    var elfProfile: str = driver_envDefault("BACKEND_ELF_PROFILE", "")
    if linker == nil:
        linker = ""
    var multi: bool = driver_envBoolDefault("BACKEND_MULTI", false)
    var multiForce: bool = driver_envBoolDefault("BACKEND_MULTI_FORCE", false)
    if multiForce:
        multi = true
    var multiLto: bool = driver_envBoolDefault("BACKEND_MULTI_LTO", false)
    var incremental: bool = driver_envBoolDefault("BACKEND_INCREMENTAL", false)
    var jobs: int32 = driver_parseInt32Default(driver_envDefault("BACKEND_JOBS", ""), 0)
    var unitFile: str = driver_envDefault("BACKEND_UNIT_FILE", "")
    var unitBatchFile: str = driver_envDefault("BACKEND_UNIT_BATCH_FILE", "")
    var moduleCachePath: str = driver_envDefault("BACKEND_MODULE_CACHE", "")
    var linkObjsFile: str = driver_envDefault("BACKEND_LINK_OBJS", "")
    var allowNoMain: bool = driver_envBoolDefault("BACKEND_ALLOW_NO_MAIN", false)
    var wholeProgram: bool = driver_envBoolDefault("BACKEND_WHOLE_PROGRAM", true)
    var skipGlobalInit: bool = driver_envBoolDefault("BACKEND_SKIP_GLOBAL_INIT", false)
    var runtimeObj: str = driver_envDefault("BACKEND_RUNTIME_OBJ", "")
    var runtimeC: str = driver_envDefault("BACKEND_RUNTIME_C", "src/runtime/native/system_helpers.c")
    var noRuntimeC: bool = driver_envBoolDefault("BACKEND_NO_RUNTIME_C", true)
    var nativeContractEnabled: bool = driver_envBoolDefault("BACKEND_NATIVE_CONTRACT", false)
    var androidApi: int32 = driver_parseInt32Default(driver_envDefault("ANDROID_API", ""), 21)
    var abi: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("ABI", "")))

    if driver_envBoolDefault("BACKEND_ENABLE_CLI", false):
        let argCount: int32 = cmdline.paramCount()
        if driver_envIsTrue("BACKEND_DEBUG_CMDLINE"):
            for di in 1..argCount:
                driver_writeLine(os.get_stderr(), "backend_driver.debug argv[" + intToStr(di) + "]=" + cmdline.paramStr(di))
        var i: int32 = 1
        var positionalInputConsumed: bool = false
        for __for_guard_i in 0..<argCount:
            if !(i <= argCount):
                break
            let arg: str = cmdline.paramStr(i)
            if driver_strIsEmpty(arg):
                i = i + 1
                continue
            if driver_strEq(arg, "--help") || driver_strEq(arg, "-h"):
                driver_backendUsage()
                return 0

            var raw: str = ""
            var nextIndex: int32 = i
            if driver_cliReadValueAt2(i, "--input", "--in", raw, nextIndex):
                inputPath = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt2(i, "--output", "--out", raw, nextIndex):
                outputPath = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--emit", raw, nextIndex):
                emitMode = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--target", raw, nextIndex):
                target = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--frontend", raw, nextIndex):
                frontend = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt2(i, "--ir", "--backend-ir", raw, nextIndex):
                backendIr = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--generic-mode", raw, nextIndex):
                genericMode = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--generic-spec-budget", raw, nextIndex):
                genericSpecBudget = driver_parseInt32Strict(raw, "--generic-spec-budget")
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--borrow-ir", raw, nextIndex):
                borrowIr = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--generic-lowering", raw, nextIndex):
                genericLowering = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--compile-stamp-out", raw, nextIndex):
                compileStampOutPath = driver_trimAsciiSpace(raw)
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--opt-level", raw, nextIndex):
                optLevel = driver_parseInt32Strict(raw, "--opt-level")
                optLevelExplicit = true
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--cc", raw, nextIndex):
                ccCmd = raw
                ccExplicit = true
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--ld", raw, nextIndex):
                ldCmd = raw
                ldExplicit = true
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--cflags", raw, nextIndex):
                cflags = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--ldflags", raw, nextIndex):
                ldflags = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--linker", raw, nextIndex):
                linker = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--linker-symtab", raw, nextIndex):
                linkerSymtab = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--obj-writer", raw, nextIndex):
                objWriter = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--elf-profile", raw, nextIndex):
                elfProfile = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--jobs", raw, nextIndex):
                jobs = driver_parseInt32Strict(raw, "--jobs")
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--unit-file", raw, nextIndex):
                unitFile = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--unit-batch-file", raw, nextIndex):
                unitBatchFile = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--module-cache", raw, nextIndex):
                moduleCachePath = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--link-objs", raw, nextIndex):
                linkObjsFile = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--runtime-obj", raw, nextIndex):
                runtimeObj = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--runtime-c", raw, nextIndex):
                runtimeC = raw
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--android-api", raw, nextIndex):
                androidApi = driver_parseInt32Strict(raw, "--android-api")
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--abi", raw, nextIndex):
                abi = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--uir-simd-max-width", raw, nextIndex):
                uirSimdMaxWidth = driver_parseInt32Strict(raw, "--uir-simd-max-width")
                i = nextIndex + 1
                continue
            if driver_cliReadValueAt(i, "--uir-simd-policy", raw, nextIndex):
                uirSimdPolicy = lowerAscii(driver_trimAsciiSpace(raw))
                i = nextIndex + 1
                continue

            var boolRaw: bool = false
            if driver_cliTryReadBoolFlagAt(i, "--profile", "--no-profile", "--profile", boolRaw, nextIndex):
                backendProfileEnabled = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--uir-profile", "--no-uir-profile", "--uir-profile", boolRaw, nextIndex):
                uirProfileEnabled = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--validate", "--no-validate", "--validate", boolRaw, nextIndex):
                validateEnabled = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--opt2", "--no-opt2", "--opt2", boolRaw, nextIndex):
                opt2 = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--opt", "--no-opt", "--opt", boolRaw, nextIndex):
                optEnabled = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--multi", "--no-multi", "--multi", boolRaw, nextIndex):
                multi = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--multi-force", "--no-multi-force", "--multi-force", boolRaw, nextIndex):
                multiForce = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--multi-lto", "--no-multi-lto", "--multi-lto", boolRaw, nextIndex):
                multiLto = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--incremental", "--no-incremental", "--incremental", boolRaw, nextIndex):
                incremental = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--allow-no-main", "--no-allow-no-main", "--allow-no-main", boolRaw, nextIndex):
                allowNoMain = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--whole-program", "--no-whole-program", "--whole-program", boolRaw, nextIndex):
                wholeProgram = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--skip-global-init", "--no-skip-global-init", "--skip-global-init", boolRaw, nextIndex):
                skipGlobalInit = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--no-runtime-c", "--with-runtime-c", "--no-runtime-c", boolRaw, nextIndex):
                noRuntimeC = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--native-contract", "--no-native-contract", "--native-contract", boolRaw, nextIndex):
                nativeContractEnabled = boolRaw
                i = nextIndex + 1
                continue
            if driver_cliTryReadBoolFlagAt(i, "--uir-simd", "--no-uir-simd", "--uir-simd", boolRaw, nextIndex):
                uirSimdRaw = driver_bool01(boolRaw)
                i = nextIndex + 1
                continue

            if driver_strHasPrefix(arg, "-"):
                driver_panic("backend_driver: unknown argument: " + arg)
            if positionalInputConsumed:
                driver_panic("backend_driver: unexpected positional argument: " + arg)
            inputPath = arg
            positionalInputConsumed = true
            i = i + 1

    if !optLevelExplicit:
        optDefault = opt2 ? 2 : (optEnabled ? 1 : 2)
        optLevel = optDefault
    if multiForce:
        multi = true

    var profile: DriverProfileState = driver_profileInit(backendProfileEnabled, "backend_profile")
    var uirProfile: DriverProfileState = driver_profileInit(uirProfileEnabled, "uir_profile")

    frontend = lowerAscii(driver_trimAsciiSpace(frontend))
    if driver_strIsEmpty(frontend):
        frontend = "stage1"
    elif !driver_strEq(frontend, "stage1"):
        driver_panic("backend_driver: unsupported --frontend (expected stage1): " + frontend)
    if driver_strIsEmpty(backendIr):
        backendIr = "uir"
    if driver_strIsEmpty(genericMode):
        genericMode = "dict"
    if !driver_isKnownGenericMode(genericMode):
        driver_panic("backend_driver: invalid GENERIC_MODE (expected dict|dictionary|hybrid): " + genericMode)
    if genericSpecBudget < 0:
        driver_panic("backend_driver: invalid GENERIC_SPEC_BUDGET (expected >= 0)")
    if driver_strIsEmpty(borrowIr):
        borrowIr = "mir"
    if !driver_isKnownBorrowIr(borrowIr):
        driver_panic("backend_driver: invalid BORROW_IR (expected mir|stage1): " + borrowIr)
    if driver_strIsEmpty(genericLowering):
        genericLowering = "mir_hybrid"
    if !driver_isKnownGenericLowering(genericLowering):
        driver_panic("backend_driver: invalid GENERIC_LOWERING (expected mir_hybrid|mir_dict): " + genericLowering)
    if driver_strIsEmpty(uirSimdRaw):
        uirSimdEnabled = optLevel >= 3
    else:
        uirSimdEnabled = driver_parseBoolStrict(uirSimdRaw, "--uir-simd")
    if uirSimdMaxWidth < 0:
        driver_panic("backend_driver: invalid UIR_SIMD_MAX_WIDTH (expected >= 0)")
    if driver_strIsEmpty(uirSimdPolicy):
        uirSimdPolicy = "autovec"
    elif !driver_isKnownSimdPolicy(uirSimdPolicy):
        driver_writeLine(os.get_stderr(),
                     "backend_driver: unknown UIR_SIMD_POLICY, fallback to autovec: " + uirSimdPolicy)
        uirSimdPolicy = "autovec"
    driver_failRemovedEnv("MIR_PROFILE", "UIR_PROFILE")
    driver_failRemovedEnv("BACKEND_SSA", "BACKEND_OPT_LEVEL")
    driver_failRemovedEnv("STAGE1_SKIP_MONO", "GENERIC_MODE=dict")
    driver_failRemovedEnv("BACKEND_SKIP_MONO", "GENERIC_MODE=dict")
    driver_failRemovedEnv("BACKEND_SKIP_MONO_AFTER_CPROFILE", "GENERIC_MODE=dict")
    driver_failRemovedEnv("BACKEND_SKIP_MONO_DICT", "GENERIC_MODE=dict")
    driver_failRemovedEnv("STAGE1_SKIP_MONO_AFTER_CPROFILE", "GENERIC_MODE=dict")
    driver_failRemovedEnv("STAGE1_SKIP_MONO_DICT", "GENERIC_MODE=dict")
    driver_failRemovedEnv("C_SYSTEM", "std/system (always enabled)")
    if driver_strIsEmpty(abi):
        abi = "v2_noptr"
    elif !driver_strEq(abi, "v2_noptr"):
        driver_panic("backend_driver: unsupported ABI (expected v2_noptr): " + abi)
    driver_profileStepBoth(profile, uirProfile, "parse_args")
    driver_emitUirSimdNotice(uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy)
    if driver_strIsEmpty(emitMode):
        emitMode = "exe"
    if !driver_strEq(backendIr, "uir"):
        driver_panic("backend_driver: unsupported BACKEND_IR (expected uir): " + backendIr)
    if nativeContractEnabled:
        validateEnabled = true
        noRuntimeC = true
        var linkerNorm0: str = lowerAscii(driver_trimAsciiSpace(linker))
        if driver_strIsEmpty(linkerNorm0):
            linker = "self"
            linkerNorm0 = "self"
        if !driver_strEq(linkerNorm0, "self"):
            driver_panic("backend_driver: BACKEND_NATIVE_CONTRACT requires BACKEND_LINKER=self")
        linker = linkerNorm0
        let mm0: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("MM", "")))
        if driver_strNonEmpty(mm0) && !driver_strEq(mm0, "orc"):
            driver_panic("backend_driver: BACKEND_NATIVE_CONTRACT requires MM=orc (got: " + mm0 + ")")
    if driver_strIsEmpty(target) || driver_strEq(target, "auto"):
        target = driver_detectHostTargetAuto()
    if driver_strIsEmpty(target):
        driver_panic("backend_driver: auto target detect failed; pass --target=<triple> or set BACKEND_TARGET")
    if !driver_strEq(emitMode, "exe"):
        driver_panic("backend_driver: invalid emit mode (expected exe): " + emitMode)

    if driver_strEq(emitMode, "exe") && driver_strEq(elfProfile, "nolibc"):
        if !(driver_strEq(linker, "self") &&
             driver_targetIsAarch64(target) &&
             driver_targetIsLinux(target) &&
             !driver_targetIsDarwin(target) &&
             !driver_targetIsWindows(target)):
            driver_panic("backend_driver: BACKEND_ELF_PROFILE=nolibc requires self-link on linux aarch64 target: " + target)

    let intBitsRaw: str = driver_envDefault("INTBITS", "")
    if driver_strNonEmpty(intBitsRaw):
        let intBits: int32 = driver_parseInt32Default(intBitsRaw, -1)
        if intBits != 32 && intBits != 64:
            panic "backend_driver: unsupported INTBITS (expected 32 or 64)"

    if !driver_targetIsAarch64(target) && !driver_targetIsX86_64(target) && !driver_targetIsRiscv64(target):
        driver_panic("backend_driver: unsupported BACKEND_TARGET (expected aarch64/arm64, x86_64, or riscv64): " + target)
    if nativeContractEnabled:
        if !(driver_targetIsAarch64(target) &&
             driver_targetIsLinux(target) &&
             !driver_targetIsAndroid(target) &&
             !driver_targetIsDarwin(target) &&
             !driver_targetIsWindows(target)):
            driver_panic("backend_driver: BACKEND_NATIVE_CONTRACT requires linux aarch64 target: " + target)

    if driver_targetIsAndroid(target):
        if !ccExplicit && driver_strEq(ccCmd, "cc"):
            let ndkCc: str = driver_defaultAndroidNdkClang(androidApi)
            if driver_strNonEmpty(ndkCc):
                ccCmd = ndkCc
        if !ldExplicit && (driver_strIsEmpty(ldCmd)):
            ldCmd = ccCmd
        if len(cflags) == 0:
            cflags = "-fPIE"
        if len(ldflags) == 0:
            ldflags = "-fPIE -pie"
        ldflags = driver_flagsAppendToken(ldflags, "-lm")

    if driver_targetIsDarwin(target) && driver_targetIsX86_64(target):
        # Ensure the system toolchain links the right arch on Apple Silicon.
        cflags = driver_flagsAppendToken(cflags, "-arch")
        cflags = driver_flagsAppendToken(cflags, "x86_64")
    if driver_strIsEmpty(ldCmd):
        ldCmd = ccCmd
    driver_profileStepBoth(profile, uirProfile, "config")

    let buildTrackRaw0: str = lowerAscii(driver_trimAsciiSpace(driver_envDefault("BACKEND_BUILD_TRACK", "")))
    var buildTrack: str = driver_strIsEmpty(buildTrackRaw0) ? "dev" : buildTrackRaw0
    if !driver_strEq(buildTrack, "dev") && !driver_strEq(buildTrack, "release"):
        driver_panic("backend_driver: invalid BACKEND_BUILD_TRACK (expected dev|release): " + buildTrack)
    var resolvedLinker: str = lowerAscii(driver_trimAsciiSpace(linker))
    if driver_strIsEmpty(resolvedLinker):
        resolvedLinker = "system"

    let linkerSymtabAll: bool = driver_parseLinkerSymtabAll(linkerSymtab)

    # Fork-parallel avoids subprocesses rebuilding the full module. When fork
    # is disabled/unavailable, default to enabling module-cache so parallel
    # workers can reuse the parent-built module instead of rebuilding it.
    let forkDefault: bool = true
    let allowForkParallel0: bool = driver_envBoolDefault("BACKEND_MULTI_FORK", forkDefault)

    let compileStamp0: str = driver_buildObjCompileStamp(target, frontend, objWriter, inputPath,
                                                         allowNoMain, wholeProgram,
                                                         skipGlobalInit, multi, multiForce,
                                                         multiLto, abi, buildTrack, resolvedLinker, noRuntimeC,
                                                         driver_selfCompilerStamp(),
                                                         nativeContractEnabled,
                                                         backendIr, genericMode, genericSpecBudget,
                                                         opt2, optEnabled, optLevel,
                                                         validateEnabled,
                                                         uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy,
                                                         borrowIr, genericLowering,
                                                         driver_envDefault("PLUGIN_ENABLE", ""),
                                                         driver_envDefault("PLUGIN_PATH", ""),
                                                         driver_envDefault("PLUGIN_PATHS", ""),
                                                         driver_envDefault("METERING_PLUGIN", ""))
    let compileStampHash0: int64 = uirFnv1a64(compileStamp0)
    if driver_strNonEmpty(compileStampOutPath):
        os.writeFile(compileStampOutPath, compileStamp0)

    if len(outputPath) == 0:
        if len(inputPath) == 0:
            panic "backend_driver: output path required"
        outputPath = inputPath
    var outBase: str = outputPath
    let moduleCacheDefault0: bool = true
    let moduleCacheEnabled0: bool = driver_envBoolDefault("BACKEND_MULTI_MODULE_CACHE", moduleCacheDefault0)
    if driver_strIsEmpty(moduleCachePath) && moduleCacheEnabled0 &&
       driver_strEq(emitMode, "exe") && multi && !multiLto:
        moduleCachePath = outBase + ".cache/.build.module.cache"

    if driver_strNonEmpty(linkObjsFile):
        driver_panic("backend_driver: BACKEND_LINK_OBJS has been removed from production path")

    var cache: DriverModuleCache = nil
    if driver_strNonEmpty(moduleCachePath) && driver_envIsTrue("BACKEND_MODULE_CACHE_DEBUG"):
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "backend_driver: module cache load disabled in bootstrap-compatible mode")
    driver_profileStepBoth(profile, uirProfile, "module_cache.load")

    if nativeContractEnabled:
        let sourceViolation: str = driver_nativeContractSourceViolation(inputPath)
        if driver_strNonEmpty(sourceViolation):
            driver_panic("backend_driver: native_contract hard-fail @" + inputPath + ": " + sourceViolation)
    var mod: UirModule
    if len(inputPath) == 0:
        mod = uirDemoModule()
    else:
        mod = uirBuildModuleFromFileStage1OrPanic(inputPath)
    if driver_strNonEmpty(target):
        let _targetCli: str = target
    driver_profileStepBoth(profile, uirProfile, "build_module")
    let highUirCheckedFuncs: int32 = uirModuleCountHighUirCheckedFuncs(mod)
    let lowUirLoweredFuncs: int32 = uirModuleCountLowUirLoweredFuncs(mod)
    let highUirFallbackFuncs: int32 = uirModuleCountHighUirFallbackFuncs(mod)
    driver_emitGenericsReport(uirProfile.enabled, backendIr, genericMode, genericSpecBudget,
                              borrowIr, genericLowering, 0, 0, 0, 0,
                              highUirCheckedFuncs, lowUirLoweredFuncs, highUirFallbackFuncs, 0)

    var unitFiles: str[]
    var unitIndex: DriverUnitIndex = nil
    var unitStateHashes: int64[]
    if cache != nil:
        unitFiles = cache.unitFiles
        unitIndex = driver_moduleCacheToUnitIndex(cache)
    if unitFiles.len == 0:
        unitFiles = driver_collectUnitFiles(mod)
    if unitFiles.len > 0 && unitIndex == nil:
        unitIndex = driver_buildUnitIndex(mod, unitFiles)
    if unitStateHashes.len == 0 && unitFiles.len > 0:
        unitStateHashes = driver_buildUnitFileStateHashes(unitFiles)
    if cache == nil && driver_strNonEmpty(moduleCachePath) &&
       driver_strEq(emitMode, "exe") && multi && !multiLto &&
       unitIndex != nil && unitStateHashes.len == unitFiles.len:
        driver_ensureParentDir(moduleCachePath)
        let _cacheWritten: bool = driver_writeModuleCache(moduleCachePath, mod, unitIndex,
                                                          compileStampHash0, unitStateHashes)
    if cache == nil && driver_strNonEmpty(moduleCachePath) &&
       driver_strEq(emitMode, "exe") && multi && !multiLto:
        driver_profileStepBoth(profile, uirProfile, "module_cache.write")

    if driver_strNonEmpty(unitBatchFile):
        panic "backend_driver: BACKEND_UNIT_BATCH_FILE is disabled in bootstrap-compatible mode"

    if driver_strNonEmpty(unitFile):
        panic "backend_driver: BACKEND_UNIT_FILE is disabled in bootstrap-compatible mode"

    # Legacy multi-object sidecar pipeline has been removed from production path.

    let mainObjBytes: uint8[] = driver_emitObjBytesFromModule(mod, optLevel, target, objWriter,
                                                               uirSimdEnabled, uirSimdMaxWidth, uirSimdPolicy,
                                                               validateEnabled ? 1 : 0)
    driver_profileStepBoth(profile, uirProfile, "single.emit_obj_bytes")
    let linkerlessInMem: bool = driver_envBoolDefault("BACKEND_LINKERLESS_INMEM", true)
    if linkerlessInMem &&
       driver_tryLinkExeMainObjMem(mainObjBytes, target, linker, linkerSymtabAll, outputPath, runtimeObj):
        driver_profileStepBoth(profile, uirProfile, "single.link_mem")
        return 0

    let objPath: str = outputPath + ".tmp.linkobj"
    driver_ensureParentDir(objPath)
    os.writeFileBytes(objPath, mainObjBytes)
    driver_profileStepBoth(profile, uirProfile, "single.emit_tmp_obj")
    var linkObjs2: str[]
    add(linkObjs2, objPath)
    driver_linkExeObjects(linkObjs2, target, linker, linkerSymtabAll, ldCmd, cflags, ldflags,
                          outputPath, runtimeObj, runtimeC, noRuntimeC, genericMode)
    driver_profileStepBoth(profile, uirProfile, "single.link")
    if !driver_envBoolDefault("BACKEND_KEEP_TMP_LINKOBJ", false):
        driver_runCmd("rm -f " + driver_shellQuote(objPath))
    return 0

fn backendMainDelegate(): int32 =
    if !driver_delegateEmergencyAllowed():
        driver_panic("backend_driver: delegate mode blocked; set BACKEND_DRIVER_ALLOW_DELEGATE_EMERGENCY=1")
    let stage0: str = driver_resolveStage0ForDelegate()
    if driver_strIsEmpty(stage0):
        driver_panic("backend_driver: missing delegate stage0 path")
    let cmd: str = "BACKEND_BUILD_DRIVER_STAGE0= BACKEND_DRIVER_BOOT_MODE=native BACKEND_DRIVER_NATIVE_DISPATCHED=1 " +
                   "BACKEND_DRIVER=" + driver_shellQuote(stage0) + " " + driver_shellQuote(stage0)
    let rc: int32 = driver_runCmdExitCode(cmd)
    if rc != 0:
        driver_panic("backend_driver: delegate mode stage0 dispatch failed")
    return 0

fn backendMainNativeDispatch(): int32 =
    if driver_envBoolDefault("BACKEND_DRIVER_NATIVE_DISPATCHED", false):
        return backendMainNative()
    let selfDriver: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_DRIVER", ""))
    let nativeBinRaw: str = driver_trimAsciiSpace(driver_envDefault("BACKEND_DRIVER_NATIVE_BIN", ""))
    if driver_strIsEmpty(nativeBinRaw):
        return backendMainNative()
    if driver_pathLooksSame(nativeBinRaw, selfDriver):
        return backendMainNative()
    if !driver_isExecutable(nativeBinRaw):
        driver_panic("backend_driver: native mode target not executable: " + nativeBinRaw)
    let cmd: str = "BACKEND_DRIVER_BOOT_MODE=native BACKEND_DRIVER_NATIVE_DISPATCHED=1 " +
                   "BACKEND_DRIVER=" + driver_shellQuote(nativeBinRaw) + " " + driver_shellQuote(nativeBinRaw)
    let rc: int32 = driver_runCmdExitCode(cmd)
    if rc != 0:
        driver_panic("backend_driver: native mode dispatch failed")
    return 0

fn backendMain(): int32 =
    let mode: str = driver_bootMode()
    if driver_strEq(mode, "delegate"):
        return backendMainDelegate()
    return backendMainNativeDispatch()

fn main(argc: int32, argv: str*): int32 =
    let _argc: int32 = argc
    let _argv: str* = argv
    # Debug: stage0-compat built stage1 may crash in early runtime paths; allow a minimal
    # allocator/seq smoke to isolate miscompiles.
    if driver_strEq(driver_envDefault("BACKEND_SELFTEST", ""), "1"):
        let f: os.File = os.get_stderr()
        driver_writeLine(f, "selftest: seq<int32>")
        os.c_fflush f
        var xs: int32[]
        add(xs, 1)
        add(xs, 2)
        if xs.len != 2 || xs[0] != 1 || xs[1] != 2:
            panic "selftest: seq<int32> failed"

        driver_writeLine(f, "selftest: seq<str>")
        os.c_fflush f
        var ss: str[]
        add(ss, "a")
        add(ss, "b")
        if ss.len != 2 || !driver_strEq(ss[0], "a") || !driver_strEq(ss[1], "b"):
            panic "selftest: seq<str> failed"

        driver_writeLine(f, "selftest: seq<uint8>")
        os.c_fflush f
        var bs: uint8[]
        add(bs, uint8(0xCF))
        add(bs, uint8(0xFA))
        if bs.len != 2 || int32(bs[0]) != 207 || int32(bs[1]) != 250:
            panic "selftest: seq<uint8> failed"

        driver_writeLine(f, "selftest: seq<uint8> copy")
        os.c_fflush f
        var rv: uint8[] = bs
        if rv.len != 2 || int32(rv[0]) != 207 || int32(rv[1]) != 250:
            panic "selftest: seq<uint8> copy failed"

        driver_writeLine(f, "selftest: seq<ptr>")
        os.c_fflush f
        var ps: ptr[]
        let marker: str = "ptr_ok"
        add(ps, void*(marker))
        if ps.len != 1:
            panic "selftest: seq<ptr> len failed"
        if str(ps[0]) != "ptr_ok":
            panic "selftest: seq<ptr> value failed"

        driver_writeLine(f, "selftest: hashmap<str,int32>")
        os.c_fflush f
        driver_writeLine(f, "selftest: hashmap.init")
        os.c_fflush f
        var m: DriverMapStrInt = driver_hashMapStrIntInit(16)
        driver_writeLine(f, "selftest: hashmap.put")
        os.c_fflush f
        driver_hashMapStrIntPut(m, "k1", 7)
        driver_writeLine(f, "selftest: hashmap.get")
        os.c_fflush f
        var found: bool = false
        let v: int32 = driver_hashMapStrIntGet(m, "k1", found)
        if !found || v != 7:
            panic "selftest: hashmap failed"

        driver_writeLine(f, "selftest: seq<seq<int32>>")
        os.c_fflush f
        var rows: DriverSeqSeqInt32 = driver_newSeq2DInt(3)
        if rows.len != 3:
            panic "selftest: seq<seq<int32>> init failed"
        var r0: int32[] = driver_getRowInt32(rows, 0)
        add(r0, 9)
        driver_setRowInt32(rows, 0, r0)
        # Ensure nested-seq stores retain the inner buffer (no UAF after clearing the local copy).
        r0 = []
        let r0b: int32[] = driver_getRowInt32(rows, 0)
        if r0b.len != 1 || r0b[0] != 9:
            panic "selftest: seq<seq<int32>> update failed"
        let r1: int32[] = driver_getRowInt32(rows, 1)
        if r1.len != 0:
            panic "selftest: seq<seq<int32>> row alias"

        driver_writeLine(f, "selftest: hashmap.value_copy")
        os.c_fflush f
        var mp: DriverMapStrInt = driver_hashMapStrIntInit(16)
        driver_hashMapStrIntPut(mp, "k1", 7)
        var found2: bool = false
        let v2: int32 = driver_hashMapStrIntGet(mp, "k1", found2)
        if !found2 || v2 != 7:
            panic "selftest: hashmap.value_copy failed"

        driver_writeLine(f, "selftest: ok")
        os.c_fflush f
        return 0
    return backendMain()
