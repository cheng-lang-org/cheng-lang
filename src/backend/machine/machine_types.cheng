# Machine IR facade: backed by machine internal core types.
# Export a stable machine surface so object writers do not import internals directly.
import cheng/backend/machine/machine_internal/machine_core_types
import std/result

type
    MachineReg = MachineCoreReg
    MachineCond = MachineCoreCond
    MachineOp = MachineCoreOp
    MachineInst = MachineCoreInst
    MachineFunc = MachineCoreFunc
    MachineCString = MachineCoreCString
    MachineGlobal = MachineCoreGlobal
    MachineModule = MachineCoreModule

fn Ok_MachineReg(value: MachineReg): Result[MachineReg] =
    var out: Result[MachineReg]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_MachineReg(err: str): Result[MachineReg] =
    var out: Result[MachineReg]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn Ok_MachineModule(value: MachineModule): Result[MachineModule] =
    var out: Result[MachineModule]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_MachineModule(err: str): Result[MachineModule] =
    var out: Result[MachineModule]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn ErrInfo_MachineModule(err: ErrorInfo): Result[MachineModule] =
    var out: Result[MachineModule]
    out.ok = false
    out.err = err
    return out

fn machineModuleTargetOf(module: MachineModule): str =
    return machineCoreModuleTargetOf(module)

fn machineModuleFuncsLen(module: MachineModule): int32 =
    return machineCoreModuleFuncsLen(module)

fn machineModuleFuncAt(module: MachineModule, idx: int32): MachineFunc =
    let coreModule: MachineCoreModule = module
    return coreModule.funcs[idx]

fn machineModuleCstrsLen(module: MachineModule): int32 =
    return machineCoreModuleCstrsLen(module)

fn machineModuleCStringAt(module: MachineModule, idx: int32): MachineCString =
    let coreModule: MachineCoreModule = module
    return coreModule.cstrs[idx]

fn machineModuleGlobalsLen(module: MachineModule): int32 =
    return machineCoreModuleGlobalsLen(module)

fn machineModuleGlobalAt(module: MachineModule, idx: int32): MachineGlobal =
    let coreModule: MachineCoreModule = module
    return coreModule.globals[idx]

fn machineFuncNameOf(func: MachineFunc): str =
    return machineCoreFuncNameOf(func)

fn machineFuncInstsLen(func: MachineFunc): int32 =
    return machineCoreFuncInstsLen(func)

fn machineFuncInstAt(func: MachineFunc, idx: int32): MachineInst =
    let coreFunc: MachineCoreFunc = func
    return coreFunc.insts[idx]

fn machineCStringLabelOf(c: MachineCString): str =
    return machineCoreCStringLabelOf(c)

fn machineCStringValueOf(c: MachineCString): str =
    return machineCoreCStringValueOf(c)

fn machineGlobalNameOf(g: MachineGlobal): str =
    return machineCoreGlobalNameOf(g)

fn machineGlobalSizeOf(g: MachineGlobal): int32 =
    return machineCoreGlobalSizeOf(g)

fn machineGlobalAlignPow2Of(g: MachineGlobal): int32 =
    return machineCoreGlobalAlignPow2Of(g)

fn machineGlobalInitOf(g: MachineGlobal): int64 =
    return machineCoreGlobalInitOf(g)

fn machineGlobalHasInit(g: MachineGlobal): bool =
    return machineCoreGlobalHasInit(g)

fn machineInstOpOf(inst: MachineInst): MachineOp =
    return machineCoreInstOpOf(inst)

fn machineInstRdOf(inst: MachineInst): MachineReg =
    return machineCoreInstRdOf(inst)

fn machineInstRnOf(inst: MachineInst): MachineReg =
    return machineCoreInstRnOf(inst)

fn machineInstRmOf(inst: MachineInst): MachineReg =
    return machineCoreInstRmOf(inst)

fn machineInstRaOf(inst: MachineInst): MachineReg =
    return machineCoreInstRaOf(inst)

fn machineInstImmOf(inst: MachineInst): int64 =
    return machineCoreInstImmOf(inst)

fn machineInstLabelOf(inst: MachineInst): str =
    return machineCoreInstLabelOf(inst)

fn machineInstCondOf(inst: MachineInst): MachineCond =
    return machineCoreInstCondOf(inst)
