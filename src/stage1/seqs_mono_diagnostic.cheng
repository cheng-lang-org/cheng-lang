# Stage1: seq[Diagnostic] monomorphized (for bootstrap).
type
    seq_Diagnostic =
        len: int32
        cap: int32
        buffer: void*
fn newSeq_Diagnostic(len: int32, cap: int32): seq_Diagnostic =
    var seqInstance: seq_Diagnostic
    seqInstance.len = 0
    seqInstance.cap = cap
    if cap > 0:
        var size64: int64 = int64(cap) * sizeof Diagnostic
        var size32: int32 = int32(size64)
        seqInstance.buffer = alloc size32
    else:
        seqInstance.buffer = nil
        return seqInstance
fn get_Diagnostic(seqInst: seq_Diagnostic, i: int32): Diagnostic =
    var idx64: int64 = int64(i)
    var offset64: int64 = idx64 * sizeof Diagnostic
    var offset32: int32 = int32(offset64)
    var p: void* = ptr_add(seqInst.buffer, offset32)
    var pt: Diagnostic* = Diagnostic* p
    return *pt
fn addPtr_Diagnostic(seqInst: seq_Diagnostic*, val: Diagnostic) =
    if seqInst->len >= seqInst->cap:
        var newCap: int32 = 4
        if seqInst->cap != 0:
            newCap = seqInst->cap * 2
            seqInst->cap = newCap
            var cap64: int64 = int64(newCap)
            var size64: int64 = int64(cap64) * sizeof Diagnostic
            var size32: int32 = int32(size64)
            seqInst->buffer = realloc(seqInst->buffer, size32)
            var idx64: int64 = int64(seqInst->len)
            var offset64: int64 = int64(idx64) * sizeof Diagnostic
            var offset32: int32 = int32(offset64)
            var p: void* = ptr_add(seqInst->buffer, offset32)
            var pt: Diagnostic* = Diagnostic* p
            *pt = val
            seqInst->len = seqInst->len + 1
