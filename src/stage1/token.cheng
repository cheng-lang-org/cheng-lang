# token.cheng
# Stage1 token definitions (ported from stage0/token).
import std/strings

type
    TokenKind = enum
        tkIdent, tkNumber, tkString, tkChar, tkKeyword, tkSymbol,
        tkIndent, tkDedent, tkNewline, tkComment, tkEof

    Token =
        kind: TokenKind
        lexeme: str
        ## Only for tkString: records source prefix ('r'/'f'); no prefix => '\0'.
        strPrefix: char
        line: int32
        col: int32

fn kindName(k: TokenKind): str =
    var out: str = "unknown"
    case k
    of tkIdent: out = "ident"
    of tkNumber: out = "number"
    of tkString: out = "str"
    of tkChar: out = "char"
    of tkKeyword: out = "keyword"
    of tkSymbol: out = "symbol"
    of tkIndent: out = "indent"
    of tkDedent: out = "dedent"
    of tkNewline: out = "newline"
    of tkComment: out = "comment"
    of tkEof: out = "eof"
    else: out = "unknown"
    return out

fn newToken(kind: TokenKind, lexeme: str, line: int32, col: int32, strPrefix: char): Token =
    var t: Token
    t.kind = kind
    t.lexeme = lexeme
    t.strPrefix = strPrefix
    t.line = line
    t.col = col
    return t

fn newToken(kind: TokenKind, lexeme: str, line: int32, col: int32): Token =
    var t: Token
    t.kind = kind
    t.lexeme = lexeme
    t.strPrefix = chr 0
    t.line = line
    t.col = col
    return t

fn freeSeq_Token(seqInst: var Token[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0
