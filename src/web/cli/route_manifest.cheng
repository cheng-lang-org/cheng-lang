import cmdline
import std/os
import std/strutils as strutil
import std/strings

type
    RouteEntryTmp =
        file: str
        path: str
        weights: int32[]

fn printLine(text: str) =
    os.writeLine(os.get_stdout(), text)

fn printErr(text: str) =
    os.writeLine(os.get_stderr(), text)

fn printUsage() =
    printLine("usage: cheng route-manifest --root:<dir> [--out:<file>] [--exts:<list>]")
    printLine("")
    printLine("env:")
    printLine("  WEB_ROUTES_ROOT   root directory to scan")
    printLine("  WEB_ROUTES_OUT    output file path")
    printLine("  WEB_ROUTES_EXTS   comma list of extensions (default .cwc,.cheng)")

fn hasPrefix(s: str, prefix: str): bool =
    if s == nil || prefix == nil:
        return false
    if len(prefix) > len(s):
        return false
    for i in 0..<len(prefix):
        if s[i] != prefix[i]:
            return false
    return true

fn normalizeExt(ext: str): str =
    if ext == nil:
        return ""
    var out = strutil.strip(ext)
    if len(out) == 0:
        return ""
    out = strutil.toLowerAscii(out)
    if out[0] != '.':
        out = "." + out
    return out

fn parseExts(raw: str, fallback: str): str[] =
    let text = if len(raw) > 0: raw else: fallback
    let parts = strutil.split(text, ',')
    var out: str[] 
    for i in 0..<len(parts):
        let ext = normalizeExt(parts[i])
        if len(ext) > 0:
            out.add(ext)
    if len(out) == 0:
        out.add(".cwc")
        out.add(".cheng")
    return out

fn isIgnoredSegment(seg: str): bool =
    if len(seg) == 0:
        return false
    return seg == ".git" || seg == "node_modules" || seg == "chengcache" || seg == "dist" || seg == "build" || seg == "out" || seg == ".cache" || seg == ".idea" || seg == ".vscode" || seg == "tmp" || seg == "tmp_build"

fn shouldIgnorePath(relPath: str): bool =
    if len(relPath) == 0:
        return false
    let parts = strutil.split(relPath, '/')
    for i in 0..<len(parts):
        let subparts = strutil.split(parts[i], '\\')
        for j in 0..<len(subparts):
            if isIgnoredSegment(subparts[j]):
                return true
    return false

fn startsWithDot(name: str): bool =
    return len(name) > 0 && name[0] == '.'

fn extMatches(path: str, exts: str[]): bool =
    let parts = os.splitFile(path)
    var ext = parts.ext
    if ext == nil:
        ext = ""
    ext = strutil.toLowerAscii(ext)
    for i in 0..<len(exts):
        if ext == exts[i]:
            return true
    return false

fn normalizeSlashes(path: str): str =
    if path == nil:
        return ""
    var out: str = ""
    for i in 0..<len(path):
        var c = path[i]
        if c == '\\':
            c = '/'
        out = out + c
    return out

fn isPathPrefix(path: str, prefix: str): bool =
    if path == nil || prefix == nil:
        return false
    let p = normalizeSlashes(path)
    let pre = normalizeSlashes(prefix)
    if len(pre) == 0 || len(p) < len(pre):
        return false
    for i in 0..<len(pre):
        if p[i] != pre[i]:
            return false
    if len(p) == len(pre):
        return true
    let next = p[len(pre)]
    return next == '/'

fn walkRoutes(root: str, rel: str, out: str[]*, exts: str[], excludeRel: str) =
    let dirPath = if len(rel) == 0: root else: os.joinPath(root, rel)
    let items = os.walkDir(dirPath)
    for i in 0..<items.len:
        let entry = os.os_get_WalkDirEntry(items, i)
        let fullPath = entry.path
        let name = os.extractFilename(fullPath)
        if startsWithDot(name) && name != ".github":
            continue
        let nextRel = if len(rel) == 0: name else: rel + "/" + name
        if shouldIgnorePath(nextRel):
            continue
        if len(excludeRel) > 0 && normalizeSlashes(nextRel) == excludeRel:
            continue
        if entry.kind == os.pcDir || entry.kind == os.pcLinkToDir:
            walkRoutes(root, nextRel, out, exts, excludeRel)
        elif entry.kind == os.pcFile || entry.kind == os.pcLinkToFile:
            if extMatches(name, exts):
                out->add(nextRel)

fn stripSuffix(name: str, suffix: str): str =
    if name == nil || suffix == nil:
        return name
    let nLen: int32 = len(name)
    let sLen: int32 = len(suffix)
    if sLen == 0 || nLen < sLen:
        return name
    let tail = substr(name, nLen - sLen, sLen)
    if strutil.toLowerAscii(tail) == strutil.toLowerAscii(suffix):
        return substr(name, 0, nLen - sLen)
    return name

fn endsWith(s: str, suffix: str): bool =
    if s == nil || suffix == nil:
        return false
    let sLen: int32 = len(s)
    let pLen: int32 = len(suffix)
    if pLen == 0 || sLen < pLen:
        return false
    for i in 0..<pLen:
        if s[sLen - pLen + i] != suffix[i]:
            return false
    return true

fn filePathToRoute(relPath: str): str =
    if len(relPath) == 0:
        return "/"
    var p = normalizeSlashes(relPath)
    p = stripSuffix(p, ".cwc")
    p = stripSuffix(p, ".cheng")
    if endsWith(p, "/index"):
        p = substr(p, 0, len(p) - len("/index"))
    elif p == "index":
        p = ""
    if len(p) == 0:
        return "/"
    if p[0] != '/':
        p = "/" + p
    return p

fn splitPathParts(path: str): str[] =
    var out: str[] 
    if path == nil:
        return out
    var start: int32 = 0
    for i in 0..len(path):
        if i == len(path) || path[i] == '/':
            if i > start:
                out.add(substr(path, start, i - start))
            start = i + 1
    return out

fn pathWeights(routePath: str): int32[] =
    let parts = splitPathParts(routePath)
    var out: int32[] 
    for i in 0..<len(parts):
        let part = parts[i]
        if hasPrefix(part, "[..."):
            out.add(1)
        elif hasPrefix(part, "["):
            out.add(2)
        else:
            out.add(3)
    return out

fn compareRoutes(a: RouteEntryTmp, b: RouteEntryTmp): int32 =
    let maxLen = if len(a.weights) > len(b.weights): len(a.weights) else: len(b.weights)
    for i in 0..<maxLen:
        let ai = if i < len(a.weights): a.weights[i] else: 0
        let bi = if i < len(b.weights): b.weights[i] else: 0
        if ai != bi:
            return bi - ai
    if len(a.weights) != len(b.weights):
        return len(b.weights) - len(a.weights)
    return cmp(a.path, b.path)

fn sortRoutes(entries: var RouteEntryTmp[]) =
    for i in 0..<len(entries):
        for j in i + 1..<len(entries):
            if compareRoutes(entries[j], entries[i]) < 0:
                let tmp = entries[i]
                entries[i] = entries[j]
                entries[j] = tmp

fn escapeString(text: str): str =
    if text == nil:
        return ""
    var out: str = ""
    for i in 0..<len(text):
        let c = text[i]
        if c == '\\' || c == '"':
            out = out + "\\"
        out = out + c
    return out

fn renderManifest(entries: RouteEntryTmp[]): str =
    var lines: str[] 
    lines.add("# Generated by cheng route-manifest. DO NOT EDIT.")
    lines.add("import cheng / web / router / router")
    lines.add("")
    lines.add("fn routeEntries(): RouteEntry[] =")
    lines.add("    var out: RouteEntry[] = []")
    lines.add("    var entry: RouteEntry")
    for i in 0..<len(entries):
        let entry = entries[i]
        lines.add("    entry.id = " + intToStr(i + 1))
        lines.add("    entry.path = \"" + escapeString(entry.path) + "\"")
        lines.add("    entry.file = \"" + escapeString(entry.file) + "\"")
        lines.add("    out.add(entry)")
    lines.add("    return out")
    lines.add("")
    lines.add("fn buildRoutes(): Route[] =")
    lines.add("    let entries = routeEntries()")
    lines.add("    var out: Route[] = []")
    lines.add("    var i: int32 = 0")
    lines.add("    while i < len(entries):")
    lines.add("        let entry = entries[i]")
    lines.add("        out.add(newRoute(entry.id, entry.path))")
    lines.add("        i = i + 1")
    lines.add("    return out")
    lines.add("")
    lines.add("fn routeFile(entries: RouteEntry[], id: int32): str =")
    lines.add("    var i: int32 = 0")
    lines.add("    while i < len(entries):")
    lines.add("        let entry = entries[i]")
    lines.add("        if entry.id == id:")
    lines.add("            return entry.file")
    lines.add("        i = i + 1")
    lines.add("    return \"\"")
    lines.add("")
    return strutil.join(lines, "\n") + "\n"

fn createDirAll(path: str) =
    if len(path) == 0:
        return
    if os.dirExists(path):
        return
    let parent = os.parentDir(path)
    if len(parent) > 0 && parent != path && ! os.dirExists(parent):
        createDirAll(parent)
    if ! os.dirExists(path):
        os.createDir(path)

fn generateRouteManifest(root: str, outPath: str, exts: str[]): str =
    if len(root) == 0:
        return "root not found"
    if ! os.dirExists(root):
        return "root not found: " + root
    var excludeRel: str = ""
    if len(outPath) > 0 && isPathPrefix(outPath, root):
        excludeRel = normalizeSlashes(os.relativePath(outPath, root))
    var files: str[] 
    walkRoutes(root, "", &files, exts, excludeRel)
    var enriched: RouteEntryTmp[] 
    for i in 0..<len(files):
        let file = normalizeSlashes(files[i])
        let routePath = filePathToRoute(file)
        var entry: RouteEntryTmp
        entry.file = file
        entry.path = routePath
        entry.weights = pathWeights(routePath)
        enriched.add(entry)
    sortRoutes(enriched)
    let content = renderManifest(enriched)
    let outDir = os.parentDir(outPath)
    if len(outDir) > 0:
        createDirAll(outDir)
    os.writeFile(outPath, content)
    return ""

fn collectArgsFromCmdline(): str[] =
    var out: str[] 
    let count: int32 = cmdline.paramCount()
    for i in 0..<count:
        out.add(cmdline.paramStr(i + 1))
    return out

fn runRouteManifestArgs(args: str[]): int32 =
    var root: str = ""
    var outPath: str = ""
    var extsRaw: str = ""
    for i in 0..<len(args):
        let arg = args[i]
        if arg == "--help" || arg == "-h":
            printUsage()
            return 0
        if hasPrefix(arg, "--root:"):
            root = substr(arg, len("--root:"), len(arg) - len("--root:"))
        elif hasPrefix(arg, "--out:"):
            outPath = substr(arg, len("--out:"), len(arg) - len("--out:"))
        elif hasPrefix(arg, "--exts:"):
            extsRaw = substr(arg, len("--exts:"), len(arg) - len("--exts:"))
        else:
            printErr("unknown arg: " + arg)
            printUsage()
            return 1
    if len(root) == 0:
        root = os.getEnv("WEB_ROUTES_ROOT")
    if len(outPath) == 0:
        outPath = os.getEnv("WEB_ROUTES_OUT")
    if len(extsRaw) == 0:
        extsRaw = os.getEnv("WEB_ROUTES_EXTS")
    if len(root) == 0:
        printErr("root not found, pass --root or WEB_ROUTES_ROOT")
        printUsage()
        return 1
    let rootAbs = os.absolutePath(root)
    var outAbs = outPath
    if len(outAbs) == 0:
        outAbs = os.joinPath(rootAbs, "routes_manifest.cheng")
    elif ! os.isAbsolute(outAbs):
        outAbs = os.absolutePath(outAbs)
    let exts = parseExts(extsRaw, ".cwc,.cheng")
    let err = generateRouteManifest(rootAbs, outAbs, exts)
    if len(err) > 0:
        printErr("route manifest failed: " + err)
        return 1
    printLine("route manifest ok: " + outAbs)
    return 0

fn main(argc: int32, argv: str*): int32 =
    cmdline.__cheng_setCmdLine(argc, void*(argv))
    let args = collectArgsFromCmdline()
    return runRouteManifestArgs(args)
