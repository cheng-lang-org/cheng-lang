# std foundation smoke: rawbytes/buffer/varint/stringlist/sequninit

import std/system
import std/result
import std/rawbytes
import std/varint
import std/stringlist
import std/sequninit

fn id(x: T): T =
    return x

fn main() =
    # rawbytes: alloc/set/slice/equal
    var b: Bytes = bytesAlloc(4)
    bytesSet(b, 0, 1)
    bytesSet(b, 1, 2)
    bytesSet(b, 2, 3)
    bytesSet(b, 3, 4)
    let s: Bytes = bytesSlice(b, 1, 2)
    var expect: Bytes = bytesAlloc(2)
    bytesSet(expect, 0, 2)
    bytesSet(expect, 1, 3)
    assert(bytesEqual(s, expect), "std/rawbytes slice/equal")

    # varint: encode/decode
    let enc: Bytes = encodeUVarint(300)
    let decRes: Result[VarintDecoded] = decodeUVarint(enc, 0)
    assert(IsOk(decRes), "std/varint decode ok")
    let dec: VarintDecoded = Value(decRes)
    assert(dec.value == 300, "std/varint value")
    assert(dec.next == bytesLen(enc), "std/varint next")

    # stringlist: add + fromLines (dedupe)
    var list: StringList = initStringList()
    let addRes: Result[bool] = stringListAdd(list, "a")
    assert(IsOk(addRes) && Value(addRes), "std/stringlist add")
    let linesRes: Result[StringList] = stringListFromLines("x\ny\nx\n")
    assert(IsOk(linesRes), "std/stringlist fromLines")
    let list2: StringList = Value(linesRes)
    assert(stringListCount(list2) == 2, "std/stringlist dedupe")

    # sequninit: add + pop
    var seq: SeqUninit[int32] = initSeqUninit[int32]()
    let sAdd1: Result[bool] = sequninitAdd(seq, 10)
    let sAdd2: Result[bool] = sequninitAdd(seq, 20)
    assert(IsOk(sAdd1) && IsOk(sAdd2), "std/sequninit add")
    let popRes: Result[int32] = sequninitPop(seq)
    assert(IsOk(popRes) && Value(popRes) == 20, "std/sequninit pop")

    # implicit type params in user code
    let v: int32 = id(int32(123))
    assert(v == 123, "implicit generics: id")
