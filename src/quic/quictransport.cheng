# QUIC transport compatibility shim.
# NOTE: This fallback maps QUIC semantics onto memory transport so callers can
# compile and run in environments without native QUIC backends.

import cheng/libp2p/utils/result
import cheng/libp2p/utils/strings
import cheng/libp2p/multiaddress
import cheng/libp2p/stream/connection
import cheng/libp2p/transports/memorytransport

type
    QuicTransport =
        memory: MemoryTransport

fn initQuicTransport(): QuicTransport =
    QuicTransport(memory: initMemoryTransport())

fn start(t: var QuicTransport, addr: MultiAddress) =
    var mem: MemoryTransport = t.memory
    start(mem, addr)
    t.memory = mem

fn stop(t: var QuicTransport) =
    var mem: MemoryTransport = t.memory
    stop(mem)
    t.memory = mem

fn accept(t: var QuicTransport): Result[Connection] =
    var mem: MemoryTransport = t.memory
    let res: Result[Connection] = accept(mem)
    t.memory = mem
    return res

fn dial(t: var QuicTransport, addr: MultiAddress): Result[Connection] =
    var mem: MemoryTransport = t.memory
    let res: Result[Connection] = dial(mem, addr)
    t.memory = mem
    return res

fn handles(t: QuicTransport, addr: MultiAddress): bool =
    t
    let text: str = lpMultiAddressToString(addr)
    if strContains(text, "/quic-v1"):
        return true
    return strContains(text, "/quic/")

fn dropQuicPendingByPipe(t: QuicTransport, addr: MultiAddress, pipeIdx: int32): Result[bool] =
    return dropMemoryPendingByPipe(t.memory, addr, pipeIdx)
