# OpenSSL QUIC transport compatibility shim.
# NOTE: This fallback maps OpenSSL QUIC semantics onto memory transport.

import cheng/libp2p/utils/result
import cheng/libp2p/utils/strings
import cheng/libp2p/multiaddress
import cheng/libp2p/stream/connection
import cheng/libp2p/transports/memorytransport

type
    OpenSslQuicTransport =
        memory: MemoryTransport

fn initOpenSslQuicTransport(): OpenSslQuicTransport =
    OpenSslQuicTransport(memory: initMemoryTransport())

fn start(t: var OpenSslQuicTransport, addr: MultiAddress) =
    var mem: MemoryTransport = t.memory
    start(mem, addr)
    t.memory = mem

fn stop(t: var OpenSslQuicTransport) =
    var mem: MemoryTransport = t.memory
    stop(mem)
    t.memory = mem

fn accept(t: var OpenSslQuicTransport): Result[Connection] =
    var mem: MemoryTransport = t.memory
    let res: Result[Connection] = accept(mem)
    t.memory = mem
    return res

fn dial(t: var OpenSslQuicTransport, addr: MultiAddress): Result[Connection] =
    var mem: MemoryTransport = t.memory
    let res: Result[Connection] = dial(mem, addr)
    t.memory = mem
    return res

fn handles(t: OpenSslQuicTransport, addr: MultiAddress): bool =
    t
    let text: str = lpMultiAddressToString(addr)
    if strContains(text, "/quic-v1/tls"):
        return true
    if strContains(text, "/quic/tls"):
        return true
    return strContains(text, "/tls") && strContains(text, "/quic")

fn dropOpenSslQuicPendingByPipe(t: OpenSslQuicTransport, addr: MultiAddress, pipeIdx: int32): Result[bool] =
    return dropMemoryPendingByPipe(t.memory, addr, pipeIdx)
