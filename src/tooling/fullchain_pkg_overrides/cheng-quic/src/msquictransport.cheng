# Fullchain override: keep msquic API surface for compile/smoke gates while
# avoiding the heavy transport implementation that can crash stage1 tool-builds.

import std/result
import std/strings
import std/rawbytes
import std/multiformats/multiaddress
import std/net/stream/connection

type
    MsQuicSettings =
        allowDatagram: bool
        maxDatagram: int32
        minimumMtu: int32
        maximumMtu: int32
        migrationEnabled: bool
        ecnEnabled: bool

    MsQuicTransport =
        running: bool
        hasAddr: bool
        addr: MultiAddress
        settings: MsQuicSettings

fn initMsQuicSettings(): MsQuicSettings =
    MsQuicSettings(
        allowDatagram: false,
        maxDatagram: 1200,
        minimumMtu: 1200,
        maximumMtu: 1500,
        migrationEnabled: false,
        ecnEnabled: false
    )

fn validateMsQuicSettings(settings: MsQuicSettings): Result[bool] =
    if settings.minimumMtu < 576:
        return Err[bool]("msquic: minimum mtu too small")
    if settings.maximumMtu > 0 && settings.maximumMtu < settings.minimumMtu:
        return Err[bool]("msquic: maximum mtu < minimum mtu")
    if settings.maxDatagram < 0:
        return Err[bool]("msquic: max datagram must be non-negative")
    return Ok[bool](true)

fn initMsQuicTransport(): MsQuicTransport =
    MsQuicTransport(
        running: false,
        hasAddr: false,
        settings: initMsQuicSettings()
    )

fn msquicTransportSettings(t: MsQuicTransport): MsQuicSettings =
    t.settings

fn setMsQuicTransportSettings(t: var MsQuicTransport, settings: MsQuicSettings): Result[bool] =
    let validRes: Result[bool] = validateMsQuicSettings(settings)
    if IsErr(validRes):
        return Err[bool](Error(validRes))
    t.settings = settings
    return Ok[bool](true)

fn handles(t: MsQuicTransport, addr: MultiAddress): bool =
    t
    let text: str = toString(addr)
    return strContains(text, "/quic")

fn start(t: var MsQuicTransport, addr: MultiAddress) =
    t.running = true
    t.hasAddr = true
    t.addr = addr

fn stop(t: var MsQuicTransport) =
    t.running = false

fn accept(t: var MsQuicTransport): Result[Connection] =
    t
    return Err[Connection]("msquic: disabled in fullchain override")

fn dial(t: var MsQuicTransport, addr: MultiAddress): Result[Connection] =
    t
    addr
    return Err[Connection]("msquic: disabled in fullchain override")

fn dropMsQuicPendingByPipe(t: MsQuicTransport, addr: MultiAddress, pipeIdx: int32): Result[bool] =
    t
    addr
    pipeIdx
    return Ok[bool](false)

fn dropMsQuicConnectionsByPipe(pipeIdx: int32) =
    pipeIdx

fn msquicTransportDatagramWrite(t: var MsQuicTransport, conn: var Connection, data: Bytes): Result[int32] =
    t
    conn
    data
    return Err[int32]("msquic: datagram disabled in fullchain override")

fn msquicTransportDatagramRead(t: var MsQuicTransport, conn: var Connection): Result[Bytes] =
    t
    conn
    return Err[Bytes]("msquic: datagram disabled in fullchain override")
