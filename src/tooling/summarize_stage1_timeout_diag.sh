#!/usr/bin/env sh
. "$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)/env_prefix_bridge.sh"
set -eu
(set -o pipefail) 2>/dev/null && set -o pipefail

usage() {
  cat <<'EOF'
Usage:
  src/tooling/summarize_stage1_timeout_diag.sh [--dir:<diag_dir>] [--latest:<n>] [--file:<summary_or_log>]

Notes:
  - Summarizes stage1 fullspec timeout diagnostics generated by verify_stage1_fullspec.sh.
  - Prefers <diag_dir>/summary.tsv when available, and falls back to parsing latest diag logs.
EOF
}

root="$(CDPATH= cd -- "$(dirname -- "$0")/../.." && pwd)"
cd "$root"

diag_dir="chengcache/stage1_fullspec_timeout_diag"
latest="3"
single_file=""

while [ "${1:-}" != "" ]; do
  case "$1" in
    --dir:*)
      diag_dir="${1#--dir:}"
      ;;
    --latest:*)
      latest="${1#--latest:}"
      ;;
    --file:*)
      single_file="${1#--file:}"
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "[stage1_timeout_diag] unknown arg: $1" 1>&2
      usage 1>&2
      exit 2
      ;;
  esac
  shift || true
done

case "$latest" in
  ''|*[!0-9]*)
    echo "[stage1_timeout_diag] invalid --latest: $latest" 1>&2
    exit 2
    ;;
esac
if [ "$latest" -lt 1 ]; then
  latest="1"
fi

hint_for_backend() {
  backend="$1"
  case "$backend" in
    module_cache.load)
      echo "likely stuck in build_module (frontend/semantics/generics/lowering)."
      ;;
    build_module)
      echo "likely stuck after IR build (emit/link path)."
      ;;
    single.emit_obj|single.link)
      echo "likely stuck in object emit or link stage."
      ;;
    *)
      echo "inspect profile tail + diag log for next missing stage transition."
      ;;
  esac
}

summary_print_header() {
  echo "== stage1_timeout_diag.summary =="
}

summary_print_row() {
  ts="$1"
  label="$2"
  diag_status="$3"
  backend_after="$4"
  uir_after="$5"
  health="$6"
  hint="$7"
  log_file="$8"
  health_log="$9"
  printf "ts=%s label=%s diag_status=%s backend_after=%s uir_after=%s health=%s\n" \
    "$ts" "$label" "$diag_status" "$backend_after" "$uir_after" "$health"
  printf "hint=%s\n" "$hint"
  printf "log=%s\n" "$log_file"
  if [ "$health_log" != "" ]; then
    printf "health_log=%s\n" "$health_log"
  fi
}

parse_log_last_label() {
  log_file="$1"
  marker="$2"
  awk -F'\t' -v marker="$marker" '
    $0 ~ marker {label=$2}
    END {
      if (label == "") {
        print "unknown"
      } else {
        print label
      }
    }
  ' "$log_file"
}

if [ "$single_file" != "" ]; then
  if [ ! -f "$single_file" ]; then
    echo "[stage1_timeout_diag] missing file: $single_file" 1>&2
    exit 2
  fi
  case "$single_file" in
    *.tsv)
      summary_file="$single_file"
      ;;
    *)
      summary_print_header
      backend_after="$(parse_log_last_label "$single_file" "backend_profile")"
      uir_after="$(parse_log_last_label "$single_file" "uir_profile")"
      hint="$(hint_for_backend "$backend_after")"
      summary_print_row "unknown" "$(basename "$single_file")" "unknown" "$backend_after" "$uir_after" "unknown" "$hint" "$single_file" ""
      exit 0
      ;;
  esac
else
  summary_file="$diag_dir/summary.tsv"
fi

if [ -f "$summary_file" ]; then
  summary_print_header
  echo "source=$summary_file"
  tmp_rows="$(mktemp "$root/chengcache/.stage1_timeout_rows.XXXXXX" 2>/dev/null || echo "$root/chengcache/.stage1_timeout_rows.$$")"
  trap 'rm -f "$tmp_rows"' EXIT
  awk 'NR > 1 {print}' "$summary_file" | tail -n "$latest" >"$tmp_rows"
  if [ ! -s "$tmp_rows" ]; then
    echo "[stage1_timeout_diag] no entries in summary file" 1>&2
    exit 2
  fi
  while IFS="$(printf '\t')" read -r ts label cmd diag_status backend_after uir_after health hint log_file health_log; do
    [ "$ts" = "" ] && continue
    summary_print_row "$ts" "$label" "$diag_status" "$backend_after" "$uir_after" "$health" "$hint" "$log_file" "$health_log"
    if [ "$cmd" != "" ]; then
      printf "cmd=%s\n" "$cmd"
    fi
  done <"$tmp_rows"
  exit 0
fi

if [ ! -d "$diag_dir" ]; then
  echo "[stage1_timeout_diag] missing diag dir: $diag_dir" 1>&2
  exit 2
fi

diag_files="$(ls -1t "$diag_dir"/*.log 2>/dev/null | grep -v "/health_probe_" | head -n "$latest" || true)"
if [ "$diag_files" = "" ]; then
  echo "[stage1_timeout_diag] no diag logs found in $diag_dir" 1>&2
  exit 2
fi

summary_print_header
echo "source=$diag_dir (log fallback)"
printf "%s\n" "$diag_files" | while IFS= read -r log_file; do
  [ "$log_file" = "" ] && continue
  log_base="$(basename "$log_file" .log)"
  ts="${log_base##*_}"
  label="${log_base%_$ts}"
  backend_after="$(parse_log_last_label "$log_file" "backend_profile")"
  uir_after="$(parse_log_last_label "$log_file" "uir_profile")"
  hint="$(hint_for_backend "$backend_after")"
  health_log="$diag_dir/health_probe_${label}_${ts}.log"
  health_obj="$diag_dir/health_probe_${label}_${ts}.o"
  health="unknown"
  if [ -s "$health_obj" ]; then
    health="ok"
  elif [ -f "$health_log" ]; then
    health="log-only"
  else
    health="missing"
    health_log=""
  fi
  summary_print_row "$ts" "$label" "unknown" "$backend_after" "$uir_after" "$health" "$hint" "$log_file" "$health_log"
done
