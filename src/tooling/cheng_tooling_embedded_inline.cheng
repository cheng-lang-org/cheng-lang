# Auto-generated embedded tooling command payload map.
# Source: former src/tooling/tooling_inline/*.inline + src/tooling/verify_inline/*.inline.
# Generated by cheng_tooling embedded-map-rewrite.
# Do not edit manually.

fn toolingEmbeddedScriptIds(): str[] =
    var out: str[] = []
    add(out, "backend_driver_exec")
    add(out, "backend_driver_path")
    add(out, "backend_host_runner")
    add(out, "backend_hotpatch_apply")
    add(out, "backend_link_env")
    add(out, "backend_prod_closure")
    add(out, "backend_prod_publish")
    add(out, "backend_release_bundle")
    add(out, "backend_release_manifest")
    add(out, "backend_release_publish")
    add(out, "backend_release_rollback")
    add(out, "backend_release_sign")
    add(out, "backend_release_verify")
    add(out, "backend_resolve_selflink_runtime_obj")
    add(out, "backend_seed_pure")
    add(out, "bootstrap")
    add(out, "bootstrap_pure")
    add(out, "build_backend_dod_contract")
    add(out, "build_backend_driver")
    add(out, "build_backend_mem_contract")
    add(out, "build_backend_profile_baseline")
    add(out, "build_backend_profile_schema")
    add(out, "build_backend_rawptr_contract")
    add(out, "build_mobile_export")
    add(out, "build_profile_backend_sample")
    add(out, "build_unimaker_desktop")
    add(out, "cheng_pkg_fetch")
    add(out, "cheng_pkg_pack")
    add(out, "cheng_pkg_publish")
    add(out, "cheng_rwad_bridge")
    add(out, "cheng_tooling")
    add(out, "chengc")
    add(out, "chengc_daemon")
    add(out, "cleanup_backend_obj_like_artifacts")
    add(out, "cleanup_cheng_local")
    add(out, "closedloop")
    add(out, "demo_compute_settle")
    add(out, "demo_io_lease")
    add(out, "detect_host_target")
    add(out, "mobile_ci_android")
    add(out, "mobile_ci_harmony")
    add(out, "mobile_ci_ios")
    add(out, "mobile_run_android")
    add(out, "mobile_run_harmony")
    add(out, "mobile_run_ios")
    add(out, "package_ide")
    add(out, "package_unimaker_desktop")
    add(out, "prewarm_deps_parallel")
    add(out, "profile_backend_sample")
    add(out, "rawptr_migrate_ffi")
    add(out, "resolve_system_linker")
    add(out, "run_mdns_lan_two_node_smoke")
    add(out, "summarize_stage1_timeout_diag")
    add(out, "summarize_timeout_diag")
    add(out, "web_build_native_server")
    add(out, "verify_android_kotlin_only")
    add(out, "verify_backend_abi_v2_noptr")
    add(out, "verify_backend_android")
    add(out, "verify_backend_android_run")
    add(out, "verify_backend_ci_obj_only")
    add(out, "verify_backend_closedloop")
    add(out, "verify_backend_coff_lld_link")
    add(out, "verify_backend_concurrency_stress")
    add(out, "verify_backend_debug")
    add(out, "verify_backend_determinism")
    add(out, "verify_backend_determinism_strict")
    add(out, "verify_backend_dod_contract")
    add(out, "verify_backend_dod_opt_regression")
    add(out, "verify_backend_dod_soa")
    add(out, "verify_backend_driver_cli_parity")
    add(out, "verify_backend_driver_selfbuild_smoke")
    add(out, "verify_backend_dual_track")
    add(out, "verify_backend_egraph_cost")
    add(out, "verify_backend_emit_obj_contract")
    add(out, "verify_backend_exe_determinism")
    add(out, "verify_backend_exe_determinism_strict")
    add(out, "verify_backend_ffi_abi")
    add(out, "verify_backend_ffi_borrow_bridge")
    add(out, "verify_backend_ffi_handle_sandbox")
    add(out, "verify_backend_ffi_outptr_tuple")
    add(out, "verify_backend_ffi_slice_shim")
    add(out, "verify_backend_float")
    add(out, "verify_backend_hotpatch")
    add(out, "verify_backend_hotpatch_inplace")
    add(out, "verify_backend_hotpatch_meta")
    add(out, "verify_backend_import_cycle_predeclare")
    add(out, "verify_backend_incr_patch_fastpath")
    add(out, "verify_backend_linker_abi_core")
    add(out, "verify_backend_linkerless_dev")
    add(out, "verify_backend_macho_signature_gate")
    add(out, "verify_backend_metering_phase_barrier")
    add(out, "verify_backend_mem_contract")
    add(out, "verify_backend_mem_exe_emit")
    add(out, "verify_backend_mem_image_core")
    add(out, "verify_backend_mem_patch_regression")
    add(out, "verify_backend_metering_stream")
    add(out, "verify_backend_mir_borrow")
    add(out, "verify_backend_mm")
    add(out, "verify_backend_multi")
    add(out, "verify_backend_multi_lto")
    add(out, "verify_backend_multi_module_cache_stability")
    add(out, "verify_backend_multi_perf_regression")
    add(out, "verify_backend_no_legacy_refs")
    add(out, "verify_backend_no_obj_artifacts")
    add(out, "verify_backend_noalias_opt")
    add(out, "verify_backend_nolibc_linux_aarch64")
    add(out, "verify_backend_noptr_default_cli")
    add(out, "verify_backend_noptr_exemption_scope")
    add(out, "verify_backend_obj")
    add(out, "verify_backend_obj_determinism")
    add(out, "verify_backend_obj_determinism_strict")
    add(out, "verify_backend_obj_fullspec_gate")
    add(out, "verify_backend_opt")
    add(out, "verify_backend_opt2")
    add(out, "verify_backend_opt3")
    add(out, "verify_backend_plugin_isolation")
    add(out, "verify_backend_plugin_system")
    add(out, "verify_backend_profile_baseline")
    add(out, "verify_backend_profile_schema")
    add(out, "verify_backend_rawptr_closedloop")
    add(out, "verify_backend_rawptr_contract")
    add(out, "verify_backend_rawptr_migration")
    add(out, "verify_backend_rawptr_surface_forbid")
    add(out, "verify_backend_release_c_o3_lto")
    add(out, "verify_backend_release_rollback_drill")
    add(out, "verify_backend_riscv64_quic_boundary")
    add(out, "verify_backend_runtime_abi")
    add(out, "verify_backend_sanitizer")
    add(out, "verify_backend_self_linker_coff")
    add(out, "verify_backend_self_linker_elf")
    add(out, "verify_backend_self_linker_riscv64")
    add(out, "verify_backend_self_obj_writer")
    add(out, "verify_backend_self_obj_writer_coff")
    add(out, "verify_backend_self_obj_writer_coff_determinism")
    add(out, "verify_backend_self_obj_writer_elf_determinism")
    add(out, "verify_backend_self_obj_writer_macho")
    add(out, "verify_backend_self_obj_writer_macho_determinism")
    add(out, "verify_backend_selfhost_100ms_host")
    add(out, "verify_backend_selfhost_bootstrap")
    add(out, "verify_backend_selfhost_bootstrap_fast")
    add(out, "verify_backend_selfhost_bootstrap_self_obj")
    add(out, "verify_backend_selfhost_nightly")
    add(out, "verify_backend_selfhost_parallel_perf")
    add(out, "verify_backend_selfhost_perf_regression")
    add(out, "verify_backend_selfhost_strict_noreuse_probe")
    add(out, "verify_backend_simd")
    add(out, "verify_backend_spawn_api_gate")
    add(out, "verify_backend_ssa")
    add(out, "verify_backend_stage0_no_compat")
    add(out, "verify_backend_stress")
    add(out, "verify_backend_ast_simhash_contract")
    add(out, "verify_backend_targets")
    add(out, "verify_backend_targets_matrix")
    add(out, "verify_backend_uir_stability")
    add(out, "verify_backend_x86_64_darwin")
    add(out, "verify_backend_x86_64_linux")
    add(out, "verify_backend_zero_script_closure")
    add(out, "verify_buildmeta")
    add(out, "verify_cheng_skill_consistency")
    add(out, "verify_demo_compute_settle")
    add(out, "verify_demo_io_lease")
    add(out, "verify_fullchain_bootstrap")
    add(out, "verify_libp2p_frontier")
    add(out, "verify_libp2p_prod_closure")
    add(out, "verify_mobile_run_entrypoints")
    add(out, "verify_no_legacy_net_multiformats_imports")
    add(out, "verify_no_root_build_artifacts")
    add(out, "verify_rwad_interface_contract")
    add(out, "verify_stage1_fullspec")
    add(out, "verify_stage1_seed_layout")
    add(out, "verify_std_import_surface")
    add(out, "verify_std_layout_sync")
    add(out, "verify_tooling_cmdline")
    add(out, "verify")
    add(out, "build_backend_native_contract")
    add(out, "verify_backend_native_contract")
    return out

fn toolingEmbeddedScriptBody(id: str): str =
    if id == "backend_driver_exec":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nresolve_real_driver() {\n  if [ \"${BACKEND_DRIVER_REAL:-}\" != \"\" ]; then\n    if [ -x \"${BACKEND_DRIVER_REAL}\" ]; then\n      printf '%s\\n' \"${BACKEND_DRIVER_REAL}\"\n      return 0\n    fi\n    echo \"[backend_driver_exec] BACKEND_DRIVER_REAL is not runnable: ${BACKEND_DRIVER_REAL}\" >&2\n    return 1\n  fi\n\n  for cand in \\\n    \"$root/artifacts/backend_driver/cheng\" \\\n    \"$root/artifacts/backend_seed/cheng.stage2\" \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng_stage0_default\" \\\n    \"$root/artifacts/backend_driver/cheng.fixed3\" \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng_stage0_prod\" \\\n    \"$root/dist/releases/current/cheng\"; do\n    if [ -x \"$cand\" ]; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\ncleanup_sidecar() {\n  emit_mode=\"${BACKEND_EMIT:-}\"\n  output_path=\"${BACKEND_OUTPUT:-}\"\n  keep_obj=\"${BACKEND_KEEP_EXE_OBJ:-0}\"\n  case \"$emit_mode\" in\n    exe)\n      ;;\n    *)\n      return 0\n      ;;\n  esac\n  case \"$output_path\" in\n    \"\"|-)\n      return 0\n      ;;\n  esac\n  case \"$keep_obj\" in\n    1|true|TRUE|yes|YES|on|ON)\n      return 0\n      ;;\n  esac\n  rm -f \"${output_path}.o\" \"${output_path}.tmp.linkobj\" \"${output_path}.tmp\"\n  rm -rf \"${output_path}.objs\" \"${output_path}.objs.lock\"\n}\n\nreal_driver=\"$(resolve_real_driver)\" || {\n  echo \"[backend_driver_exec] no healthy backend driver candidate found\" >&2\n  exit 1\n}\n\nset +e\n\"$real_driver\" \"$@\"\nstatus=\"$?\"\nset -e\nif [ \"$status\" -eq 0 ]; then\n  cleanup_sidecar\nfi\nexit \"$status\"\n"
    if id == "backend_driver_path":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nto_abs() {\n  p=\"$1\"\n  case \"$p\" in\n    /*)\n      ;; \n    *)\n      p=\"$root/$p\"\n      ;;\n  esac\n  d=\"$(CDPATH= cd -- \"$(dirname -- \"$p\")\" && pwd)\"\n  printf \"%s/%s\\n\" \"$d\" \"$(basename -- \"$p\")\"\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndetect_smoke_target() {\n  t=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\n  if [ \"$t\" = \"\" ]; then\n    echo \"auto\"\n    return\n  fi\n  echo \"$t\"\n}\n\nresolve_runtime_obj_for_target() {\n  target=\"$1\"\n  if [ \"${BACKEND_RUNTIME_OBJ:-}\" != \"\" ]; then\n    echo \"${BACKEND_RUNTIME_OBJ}\"\n    return\n  fi\n  s"
        out = out + "afe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n  echo \"$root/chengcache/system_helpers.backend.cheng.${safe_target}.o\"\n}\n\ndriver_sanity_ok() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  set +e\n  run_with_timeout 5 \"$bin\" --help >/dev/null 2>&1\n  status=$?\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_compile_smoke_ok() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  smoke_src=\"$root/tests/cheng/backend/fixtures/return_add.cheng\"\n  smoke_dict_src=\"$root/tests/cheng/backend/fixtures/return_spawn_default_thread_entry_gate.cheng\"\n  if [ ! -f \"$smoke_src\" ]; then\n    return 0\n  fi\n  if [ ! -f \"$smoke_dict_src\" ]; then\n    return 0\n  fi\n  smoke_out=\"$root/chengcache/.backend_driver_path.smoke.bin\"\n  smoke_out_stage1=\"$root/chengcache/.backend_driver_path.smoke.stage1.bin\"\n  smoke_out_stage1_dict=\"$root/chengcache/.backend_driver_path.smoke.stage1.dict.bin\"\n  smoke_stage1=\"${BACKEND_DRIVER_PATH_STAGE1_STRICT_SMOKE:-0}\"\n  smoke_stage1_dict=\"${BACKEND_DRIVER_PATH_STAGE1_DICT_SMOKE:-0}\"\n  smoke_timeout=\"${BACKEND_DRIVER_PATH_SMOKE_TIMEOUT:-12}\"\n  smoke_target=\"$(detect_smoke_target)\"\n  smoke_runtime_obj=\"$(resolve_runtime_obj_for_target \"$smoke_target\")\"\n  if [ ! -f \"$smoke_runtime_obj\" ]; then\n    return 1\n  fi\n  mkdir -p \"$root/chengcache\"\n  rm -f \"$smoke_out\"\n  rm -f \"$smoke_out_stage1\"\n  rm -f \""
        out = out + "$smoke_out_stage1_dict\"\n  set +e\n  run_with_timeout \"$smoke_timeout\" env \\\n    MM=orc \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    BACKEND_VALIDATE=0 \\\n    STAGE1_SKIP_SEM=1 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$smoke_runtime_obj\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$smoke_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$smoke_src\" \\\n    BACKEND_OUTPUT=\"$smoke_out\" \\\n    \"$bin\" >/dev/null 2>&1\n  status=$?\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  if [ ! -s \"$smoke_out\" ]; then\n    return 1\n  fi\n  if [ \"$smoke_stage1\" = \"1\" ]; then\n    set +e\n    run_with_timeout 30 env \\\n      MM=orc \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      BACKEND_VALIDATE=0 \\\n      STAGE1_SKIP_SEM=0 \\\n      GENERIC_MODE=hybrid \\\n      GENERIC_SPEC_BUDGET=0 \\\n      STAGE1_SKIP_OWNERSHIP=0 \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$smoke_runtime_obj\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$smoke_target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$smoke_src\" \\\n      BACKEND_OUTPUT=\"$smoke_out_stage1\" \\\n      \"$bin\" >/dev/null 2>&1\n    status_stage1=$?\n    set -e\n    if [ \""
        out = out + "$status_stage1\" -ne 0 ]; then\n      return 1\n    fi\n    [ -s \"$smoke_out_stage1\" ] || return 1\n  fi\n  if [ \"$smoke_stage1_dict\" = \"1\" ]; then\n    set +e\n    run_with_timeout 60 env \\\n      MM=orc \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      BACKEND_VALIDATE=0 \\\n      STAGE1_SKIP_SEM=0 \\\n      GENERIC_MODE=dict \\\n      GENERIC_SPEC_BUDGET=0 \\\n      STAGE1_SKIP_OWNERSHIP=1 \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$smoke_runtime_obj\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$smoke_target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$smoke_dict_src\" \\\n      BACKEND_OUTPUT=\"$smoke_out_stage1_dict\" \\\n      \"$bin\" >/dev/null 2>&1\n    status_stage1_dict=$?\n    set -e\n    if [ \"$status_stage1_dict\" -ne 0 ]; then\n      return 1\n    fi\n    [ -s \"$smoke_out_stage1_dict\" ] || return 1\n  fi\n  return 0\n}\n\nacquire_rebuild_lock() {\n  lock_dir=\"$1\"\n  owner_file=\"$lock_dir/owner.pid\"\n  waits=0\n  while ! mkdir \"$lock_dir\" 2>/dev/null; do\n    if [ -f \"$owner_file\" ]; then\n      owner=\"$(cat \"$owner_file\" 2>/dev/null || true)\"\n      if [ \"$owner\" != \"\" ] && ! kill -0 \"$owner\" 2>/dev/null; then\n        rm -rf \"$lock_dir\" 2>/dev/null || true\n        continue\n      fi\n    fi\n    waits=$((waits + 1))\n    if [ \"$waits\" -ge 2400 ]; then\n      echo \"[Error] backend_driver_path: time"
        out = out + "out waiting rebuild lock: $lock_dir\" 1>&2\n      exit 1\n    fi\n    sleep 0.05\n  done\n  printf '%s\\n' \"$$\" >\"$owner_file\"\n}\n\nrelease_rebuild_lock() {\n  lock_dir=\"$1\"\n  owner_file=\"$lock_dir/owner.pid\"\n  if [ -f \"$owner_file\" ]; then\n    owner=\"$(cat \"$owner_file\" 2>/dev/null || true)\"\n    if [ \"$owner\" = \"$$\" ]; then\n      rm -rf \"$lock_dir\" 2>/dev/null || true\n      return\n    fi\n  fi\n}\n\ndriver=\"${BACKEND_DRIVER:-}\"\nexplicit_driver_fallback=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\"\nif [ \"$driver\" != \"\" ]; then\n  abs=\"$(to_abs \"$driver\")\"\n  if [ -x \"$abs\" ] && driver_sanity_ok \"$abs\" && driver_compile_smoke_ok \"$abs\"; then\n    printf \"%s\\n\" \"$abs\"\n    exit 0\n  fi\n  if [ \"$explicit_driver_fallback\" != \"1\" ]; then\n    if [ ! -x \"$abs\" ]; then\n      echo \"[Error] BACKEND_DRIVER is not executable: $abs\" 1>&2\n    else\n      echo \"[Error] BACKEND_DRIVER is not runnable: $abs\" 1>&2\n    fi\n    exit 1\n  fi\n  if [ ! -x \"$abs\" ]; then\n    echo \"[Warn] BACKEND_DRIVER is not executable, fallback auto-select: $abs\" 1>&2\n  else\n    echo \"[Warn] BACKEND_DRIVER is not runnable, fallback auto-select: $abs\" 1>&2\n  fi\n  driver=\"\"\nfi\n\nis_stale() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 0\n  fi\n  if find \"$root/src/backend\" \"$root/src/stage1\" \"$root/src/std\" \"$root/src/core\" \"$root/src/system\" \\\n      -type f \\( -name '*.cheng' -o -name '*.c' -o -name '*.h' \\) \\\n  "
        out = out + "    -newer \"$bin\" -print -quit | grep -q .; then\n    return 0\n  fi\n  return 1\n}\n\nfind_fallback_driver() {\n  allow_selfhost_fallback=\"${BACKEND_DRIVER_PATH_ALLOW_SELFHOST:-0}\"\n  for cand in \\\n    \"$abs_default\" \\\n    \"$root/artifacts/backend_driver/cheng.fixed3\" \\\n    \"$root/artifacts/backend_seed/cheng.stage2\" \\\n    \"$root/dist/releases/current/cheng\" \\\n    \"$wrapper_driver\"; do\n    if [ -x \"$cand\" ] && driver_sanity_ok \"$cand\" && driver_compile_smoke_ok \"$cand\"; then\n      printf \"%s\\n\" \"$cand\"\n      return 0\n    fi\n  done\n  if [ \"$allow_selfhost_fallback\" != \"1\" ]; then\n    return 1\n  fi\n  for cand in \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng.stage1\"; do\n    if [ -x \"$cand\" ] && driver_sanity_ok \"$cand\" && driver_compile_smoke_ok \"$cand\"; then\n      printf \"%s\\n\" \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nlocal_driver_rel=\"${BACKEND_LOCAL_DRIVER_REL:-artifacts/backend_driver/cheng}\"\nabs_default=\"$root/$local_driver_rel\"\nwrapper_driver=\"${BACKEND_WRAPPER_DRIVER:-src/tooling/backend_driver_exec.sh}\"\nwrapper_enabled=\"${BACKEND_DRIVER_PATH_USE_WRAPPER:-0}\"\nprefer_rebuild=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-0}\"\nfallback_driver=\"\"\nset +e\nfallback_driver=\"$(find_fallback_driver)\"\nfallback_status=$?\nset -e\nif [ \"$fallback_status\" -ne 0 ]; then\n  fallback_driver=\"\"\nfi\n\n# Wrapper is n"
        out = out + "ow a fallback-only safety net; default production path should\n# converge on artifacts/backend_driver/cheng.\nif [ \"$wrapper_enabled\" = \"1\" ] && [ -x \"$wrapper_driver\" ] && driver_sanity_ok \"$wrapper_driver\" && driver_compile_smoke_ok \"$wrapper_driver\"; then\n  printf \"%s\\n\" \"$wrapper_driver\"\n  exit 0\nfi\n\n# Fast path: use the local rebuilt driver if it's fresh.\nif [ -x \"$abs_default\" ] && ! is_stale \"$abs_default\"; then\n  if driver_sanity_ok \"$abs_default\" && driver_compile_smoke_ok \"$abs_default\"; then\n    printf \"%s\\n\" \"$abs_default\"\n    exit 0\n  fi\nfi\n\nrebuild_default=\"0\"\nif [ ! -x \"$abs_default\" ]; then\n  rebuild_default=\"1\"\nelse\n  if is_stale \"$abs_default\"; then\n    rebuild_default=\"1\"\n  elif ! driver_sanity_ok \"$abs_default\" || ! driver_compile_smoke_ok \"$abs_default\"; then\n    rebuild_default=\"1\"\n  fi\nfi\n\nif [ \"$rebuild_default\" = \"1\" ] && [ \"$prefer_rebuild\" != \"1\" ] && [ \"$fallback_driver\" != \"\" ]; then\n  printf \"%s\\n\" \"$fallback_driver\"\n  exit 0\nfi\n\nif [ \"$rebuild_default\" = \"1\" ]; then\n  mkdir -p \"$root/chengcache\"\n  rebuild_lock=\"$root/chengcache/.backend_driver_path.lock\"\n  acquire_rebuild_lock \"$rebuild_lock\"\n  release_lock_on_exit() {\n    release_rebuild_lock \"$rebuild_lock\"\n  }\n  trap release_lock_on_exit EXIT INT TERM\n  rebuild_default=\"0\"\n  if [ ! -x \"$abs_default\" ]; then\n    rebuild_default=\"1\"\n  else\n    if is_stale \"$abs_default\"; the"
        out = out + "n\n      rebuild_default=\"1\"\n    elif ! driver_sanity_ok \"$abs_default\" || ! driver_compile_smoke_ok \"$abs_default\"; then\n      rebuild_default=\"1\"\n    fi\n  fi\nfi\n\nif [ \"$rebuild_default\" = \"1\" ]; then\n  abs_default_dir=\"$(dirname \"$abs_default\")\"\n  if [ \"$abs_default_dir\" != \"\" ] && [ ! -d \"$abs_default_dir\" ]; then\n    mkdir -p \"$abs_default_dir\"\n  fi\n  rebuild_log=\"$root/chengcache/backend_driver_path.rebuild.log\"\n  set +e\n  BACKEND_BUILD_DRIVER_SELFHOST=1 \\\n  BACKEND_BUILD_DRIVER_LINKER=\"${BACKEND_DRIVER_PATH_LINKER:-system}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_driver --name:\"$local_driver_rel\" >\"$rebuild_log\" 2>&1\n  rebuild_status=\"$?\"\n  set -e\n  if [ \"$rebuild_status\" -ne 0 ]; then\n    echo \"[Warn] backend_driver_path: local driver rebuild failed (status=$rebuild_status)\" 1>&2\n    if [ \"${BACKEND_DRIVER_PATH_DEBUG:-0}\" = \"1\" ]; then\n      tail -n 80 \"$rebuild_log\" 1>&2 || true\n    fi\n  fi\nfi\nif [ \"${rebuild_lock:-}\" != \"\" ]; then\n  release_rebuild_lock \"$rebuild_lock\"\n  trap - EXIT INT TERM\nfi\nif [ -x \"$abs_default\" ] && driver_sanity_ok \"$abs_default\" && driver_compile_smoke_ok \"$abs_default\"; then\n  printf \"%s\\n\" \"$abs_default\"\n  exit 0\nfi\n\nif [ \"$fallback_driver\" = \"\" ]; then\n  set +e\n  fallback_driver=\"$(find_fallback_driver)\"\n  fallback_status=$?\n  set -e\n  if [ \"$fallback_status\" -ne 0 ]; then\n    fallback_driver="
        out = out + "\"\"\n  fi\nfi\nif [ \"$fallback_driver\" != \"\" ]; then\n  printf \"%s\\n\" \"$fallback_driver\"\n  exit 0\nfi\n\nif [ ! -x \"$abs_default\" ]; then\n  echo \"[Error] missing backend driver: $abs_default\" 1>&2\nelse\n  echo \"[Error] backend driver exists but failed compile-smoke: $abs_default\" 1>&2\nfi\necho \"  hint: run src/tooling/build_backend_driver.sh --name:$local_driver_rel\" 1>&2\nexit 1\n"
        return out
    if id == "backend_host_runner":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_host_runner.sh init --state:<dir> --base:<exe>\n                                         [--layout-hash:<hash>] [--pool-mb:<N>]\n                                         [--mode:<trampoline>] [--page-policy:<rw_rx>]\n  src/tooling/backend_host_runner.sh commit --state:<dir> --patch:<exe>\n                                           [--layout-hash:<hash>] [--symbol:<name>]\n                                           [--thunk-id:<id>] [--target-slot:<offset>]\n                                           [--max-growth:<bytes>] [--check-exit:<code>]\n  src/tooling/backend_host_runner.sh run --state:<dir> [--check-exit:<code>]\n  src/tooling/backend_host_runner.sh status --state:<dir>\n  src/tooling/backend_host_runner.sh run-host --exe:<path>\n                                             [--state:<dir>] [--layout-hash:<hash>]\n\nNotes:\n  - Dev hotpatch transaction model: trampoline route + append-only pool + layout-hash fallback restart.\n  - Default policy is BACKEND_HOTPATCH_MODE=trampoline and BACKEND_HOSTRUNNER_PAGE_POLICY=rw_rx.\nEOF\n}\n\nnow_ms() {\n  if command -v perl >/dev/null 2>&1; then\n    perl -MTime::HiRes=time -e 'printf \"%.0f\\n\", time() * 1000'\n    return 0\n  fi\n  echo \"$(( $(date +%s) * 1000 ))\"\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print "
        out = out + "$1}'\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return 0\n  fi\n  cksum \"$file\" | awk '{print $1 \":\" $2}'\n}\n\nis_uint() {\n  case \"${1:-}\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nfile_size() {\n  if [ ! -f \"$1\" ]; then\n    echo \"0\"\n    return 0\n  fi\n  wc -c < \"$1\" | tr -d ' '\n}\n\nread_meta() {\n  state_dir=\"$1\"\n  meta=\"$state_dir/meta.env\"\n  if [ ! -f \"$meta\" ]; then\n    echo \"[backend_host_runner] missing state metadata: $meta\" >&2\n    return 1\n  fi\n  # shellcheck disable=SC1090\n  . \"$meta\"\n}\n\nwrite_meta() {\n  state_dir=\"$1\"\n  meta=\"$state_dir/meta.env\"\n  cat >\"$meta\" <<EOF\nschema_version=1\nmode=$mode\npage_policy=$page_policy\nlayout_hash_mode=$layout_hash_mode\non_layout_change=$on_layout_change\ntarget_platforms=$target_platforms\npool_limit_bytes=$pool_limit_bytes\npool_used_bytes=$pool_used_bytes\ncommit_epoch=$commit_epoch\nrestart_count=$restart_count\nlayout_hash=$layout_hash\nhost_pid=$host_pid\nbase_exe=$base_exe\ncurrent_exe=$current_exe\nlast_commit_kind=$last_commit_kind\nlast_symbol=$last_symbol\nlast_thunk_id=$last_thunk_id\nlast_target_slot=$last_target_slot\nlast_code_pool_offset=$last_code_pool_offset\nlast_patch_size=$last_patch_size\nlast_apply_ms=$last_apply_ms\nlast_error=$last_error\ncreated_ms=$created_ms\nupdated_ms=$updated_ms\nEOF\n}\n\nprint_status() {\n  state_dir=\"$1\"\n  read_meta \"$sta"
        out = out + "te_dir\"\n  cat <<EOF\nstatus=ok\nstate=$state_dir\nschema_version=$schema_version\nmode=$mode\npage_policy=$page_policy\nlayout_hash_mode=$layout_hash_mode\non_layout_change=$on_layout_change\ntarget_platforms=$target_platforms\npool_limit_bytes=$pool_limit_bytes\npool_used_bytes=$pool_used_bytes\ncommit_epoch=$commit_epoch\nrestart_count=$restart_count\nlayout_hash=$layout_hash\nhost_pid=$host_pid\nbase_exe=$base_exe\ncurrent_exe=$current_exe\nlast_commit_kind=$last_commit_kind\nlast_symbol=$last_symbol\nlast_thunk_id=$last_thunk_id\nlast_target_slot=$last_target_slot\nlast_code_pool_offset=$last_code_pool_offset\nlast_patch_size=$last_patch_size\nlast_apply_ms=$last_apply_ms\nlast_error=$last_error\ncreated_ms=$created_ms\nupdated_ms=$updated_ms\nEOF\n}\n\ncopy_exec() {\n  src=\"$1\"\n  dst=\"$2\"\n  cp \"$src\" \"$dst\"\n  chmod 755 \"$dst\" 2>/dev/null || true\n}\n\ninit_cmd() {\n  state=\"\"\n  base=\"\"\n  layout_arg=\"\"\n  pool_mb=\"${BACKEND_HOSTRUNNER_POOL_MB:-512}\"\n  mode_arg=\"${BACKEND_HOTPATCH_MODE:-trampoline}\"\n  page_policy_arg=\"${BACKEND_HOSTRUNNER_PAGE_POLICY:-rw_rx}\"\n  layout_hash_mode_arg=\"${BACKEND_HOTPATCH_LAYOUT_HASH_MODE:-full_program}\"\n  on_layout_change_arg=\"${BACKEND_HOTPATCH_ON_LAYOUT_CHANGE:-restart}\"\n  target_platforms_arg=\"${BACKEND_HOTPATCH_TARGET_PLATFORMS:-darwin,linux}\"\n\n  while [ \"${1:-}\" != \"\" ]; do\n    case \"$1\" in\n      --state:*) state=\"${1#--state:}\" ;;\n      --base:*) base=\"${1#--base:}\" ;;\n      --layo"
        out = out + "ut-hash:*) layout_arg=\"${1#--layout-hash:}\" ;;\n      --pool-mb:*) pool_mb=\"${1#--pool-mb:}\" ;;\n      --mode:*) mode_arg=\"${1#--mode:}\" ;;\n      --page-policy:*) page_policy_arg=\"${1#--page-policy:}\" ;;\n      --help|-h) usage; exit 0 ;;\n      *)\n        echo \"[backend_host_runner] init unknown arg: $1\" >&2\n        usage\n        exit 1\n        ;;\n    esac\n    shift || true\n  done\n\n  if [ \"$state\" = \"\" ] || [ \"$base\" = \"\" ]; then\n    echo \"[backend_host_runner] init requires --state and --base\" >&2\n    usage\n    exit 1\n  fi\n  if [ ! -f \"$base\" ]; then\n    echo \"[backend_host_runner] init base not found: $base\" >&2\n    exit 1\n  fi\n  if ! is_uint \"$pool_mb\"; then\n    echo \"[backend_host_runner] invalid --pool-mb: $pool_mb\" >&2\n    exit 1\n  fi\n  if [ \"$pool_mb\" -lt 1 ]; then\n    pool_mb=1\n  fi\n\n  mkdir -p \"$state\"\n  pool_file=\"$state/code_pool.bin\"\n  current_file=\"$state/current.exe\"\n  : >\"$pool_file\"\n  copy_exec \"$base\" \"$current_file\"\n\n  mode=\"$mode_arg\"\n  page_policy=\"$page_policy_arg\"\n  layout_hash_mode=\"$layout_hash_mode_arg\"\n  on_layout_change=\"$on_layout_change_arg\"\n  target_platforms=\"$target_platforms_arg\"\n  pool_limit_bytes=$((pool_mb * 1024 * 1024))\n  pool_used_bytes=0\n  commit_epoch=0\n  restart_count=0\n  if [ \"$layout_arg\" = \"\" ]; then\n    layout_hash=\"$(hash_file \"$base\")\"\n  else\n    layout_hash=\"$layout_arg\"\n  fi\n  host_pid=\"$$\"\n  base_exe=\"$base\"\n  c"
        out = out + "urrent_exe=\"$current_file\"\n  last_commit_kind=\"init\"\n  last_symbol=\"-\"\n  last_thunk_id=\"0\"\n  last_target_slot=\"0\"\n  last_code_pool_offset=\"0\"\n  last_patch_size=\"0\"\n  last_apply_ms=\"0\"\n  last_error=\"-\"\n  created_ms=\"$(now_ms)\"\n  updated_ms=\"$created_ms\"\n\n  write_meta \"$state\"\n  print_status \"$state\"\n}\n\ncommit_cmd() {\n  state=\"\"\n  patch=\"\"\n  layout_arg=\"\"\n  symbol_arg=\"-\"\n  thunk_id_arg=\"0\"\n  target_slot_arg=\"0\"\n  max_growth_arg=\"${BACKEND_HOTPATCH_MAX_GROWTH:-}\"\n  check_exit=\"\"\n\n  while [ \"${1:-}\" != \"\" ]; do\n    case \"$1\" in\n      --state:*) state=\"${1#--state:}\" ;;\n      --patch:*) patch=\"${1#--patch:}\" ;;\n      --layout-hash:*) layout_arg=\"${1#--layout-hash:}\" ;;\n      --symbol:*) symbol_arg=\"${1#--symbol:}\" ;;\n      --thunk-id:*) thunk_id_arg=\"${1#--thunk-id:}\" ;;\n      --target-slot:*) target_slot_arg=\"${1#--target-slot:}\" ;;\n      --max-growth:*) max_growth_arg=\"${1#--max-growth:}\" ;;\n      --check-exit:*) check_exit=\"${1#--check-exit:}\" ;;\n      --help|-h) usage; exit 0 ;;\n      *)\n        echo \"[backend_host_runner] commit unknown arg: $1\" >&2\n        usage\n        exit 1\n        ;;\n    esac\n    shift || true\n  done\n\n  if [ \"$state\" = \"\" ] || [ \"$patch\" = \"\" ]; then\n    echo \"[backend_host_runner] commit requires --state and --patch\" >&2\n    usage\n    exit 1\n  fi\n  if [ ! -f \"$patch\" ]; then\n    echo \"[backend_host_runner] commit patch not "
        out = out + "found: $patch\" >&2\n    exit 1\n  fi\n  if ! is_uint \"$thunk_id_arg\"; then\n    echo \"[backend_host_runner] invalid --thunk-id: $thunk_id_arg\" >&2\n    exit 1\n  fi\n  if ! is_uint \"$target_slot_arg\"; then\n    echo \"[backend_host_runner] invalid --target-slot: $target_slot_arg\" >&2\n    exit 1\n  fi\n  if [ \"$check_exit\" != \"\" ] && ! is_uint \"$check_exit\"; then\n    echo \"[backend_host_runner] invalid --check-exit: $check_exit\" >&2\n    exit 1\n  fi\n  if [ \"$max_growth_arg\" != \"\" ] && ! is_uint \"$max_growth_arg\"; then\n    echo \"[backend_host_runner] invalid --max-growth: $max_growth_arg\" >&2\n    exit 1\n  fi\n\n  read_meta \"$state\"\n  pool_file=\"$state/code_pool.bin\"\n  current_file=\"$state/current.exe\"\n  meta_file=\"$state/meta.env\"\n  meta_backup=\"$state/meta.env.bak\"\n  pool_backup=\"$state/code_pool.bin.bak\"\n  current_backup=\"$state/current.exe.bak\"\n  cp \"$meta_file\" \"$meta_backup\"\n  cp \"$pool_file\" \"$pool_backup\"\n  cp \"$current_file\" \"$current_backup\"\n\n  start_ms=\"$(now_ms)\"\n  patch_size=\"$(file_size \"$patch\")\"\n  current_size=\"$(file_size \"$current_file\")\"\n  input_layout=\"$layout_arg\"\n  if [ \"$input_layout\" = \"\" ]; then\n    input_layout=\"$layout_hash\"\n  fi\n\n  commit_kind=\"append\"\n  restart_reason=\"\"\n  code_pool_offset=\"$pool_used_bytes\"\n  growth=$((patch_size - current_size))\n  if [ \"$growth\" -lt 0 ]; then\n    growth=0\n  fi\n\n  if [ \"$on_layout_change\" = \"restart\" ] &"
        out = out + "& [ \"$input_layout\" != \"$layout_hash\" ]; then\n    restart_reason=\"layout_change\"\n  fi\n  if [ \"$restart_reason\" = \"\" ] && [ \"$max_growth_arg\" != \"\" ] && [ \"$growth\" -gt \"$max_growth_arg\" ]; then\n    restart_reason=\"max_growth\"\n  fi\n  next_used=$((pool_used_bytes + patch_size))\n  if [ \"$restart_reason\" = \"\" ] && [ \"$next_used\" -gt \"$pool_limit_bytes\" ]; then\n    restart_reason=\"pool_exhausted\"\n  fi\n\n  if [ \"$restart_reason\" = \"\" ]; then\n    cat \"$patch\" >>\"$pool_file\"\n    pool_used_bytes=\"$next_used\"\n    commit_kind=\"append\"\n  else\n    : >\"$pool_file\"\n    pool_used_bytes=0\n    restart_count=$((restart_count + 1))\n    commit_kind=\"restart_$restart_reason\"\n    code_pool_offset=0\n  fi\n\n  copy_exec \"$patch\" \"$current_file\"\n  layout_hash=\"$input_layout\"\n  commit_epoch=$((commit_epoch + 1))\n  last_symbol=\"$symbol_arg\"\n  last_thunk_id=\"$thunk_id_arg\"\n  last_target_slot=\"$target_slot_arg\"\n  last_code_pool_offset=\"$code_pool_offset\"\n  last_patch_size=\"$patch_size\"\n  last_commit_kind=\"$commit_kind\"\n  last_error=\"-\"\n  end_ms=\"$(now_ms)\"\n  last_apply_ms=$((end_ms - start_ms))\n  updated_ms=\"$end_ms\"\n\n  write_meta \"$state\"\n\n  run_exit=\"\"\n  if [ \"$check_exit\" != \"\" ]; then\n    set +e\n    \"$current_file\" >/dev/null 2>&1\n    run_exit=\"$?\"\n    set -e\n    if [ \"$run_exit\" -ne \"$check_exit\" ]; then\n      cp \"$meta_backup\" \"$meta_file\"\n      cp \"$pool_backup\" \""
        out = out + "$pool_file\"\n      copy_exec \"$current_backup\" \"$current_file\"\n      rm -f \"$meta_backup\" \"$pool_backup\" \"$current_backup\"\n      echo \"[backend_host_runner] post-commit check failed: expected=$check_exit actual=$run_exit\" >&2\n      exit 1\n    fi\n  fi\n\n  rm -f \"$meta_backup\" \"$pool_backup\" \"$current_backup\"\n  print_status \"$state\"\n  if [ \"$run_exit\" != \"\" ]; then\n    echo \"postcheck_exit=$run_exit\"\n  fi\n}\n\nrun_cmd() {\n  state=\"\"\n  check_exit=\"\"\n  while [ \"${1:-}\" != \"\" ]; do\n    case \"$1\" in\n      --state:*) state=\"${1#--state:}\" ;;\n      --check-exit:*) check_exit=\"${1#--check-exit:}\" ;;\n      --help|-h) usage; exit 0 ;;\n      *)\n        echo \"[backend_host_runner] run unknown arg: $1\" >&2\n        usage\n        exit 1\n        ;;\n    esac\n    shift || true\n  done\n  if [ \"$state\" = \"\" ]; then\n    echo \"[backend_host_runner] run requires --state\" >&2\n    usage\n    exit 1\n  fi\n  if [ \"$check_exit\" != \"\" ] && ! is_uint \"$check_exit\"; then\n    echo \"[backend_host_runner] invalid --check-exit: $check_exit\" >&2\n    exit 1\n  fi\n  read_meta \"$state\"\n  set +e\n  \"$current_exe\"\n  run_status=\"$?\"\n  set -e\n  echo \"status=ok\"\n  echo \"state=$state\"\n  echo \"run_exit=$run_status\"\n  if [ \"$check_exit\" != \"\" ] && [ \"$run_status\" -ne \"$check_exit\" ]; then\n    echo \"[backend_host_runner] run exit mismatch: expected=$check_exit actual=$run_status\" >&2\n    exit 1\n  fi\n  ex"
        out = out + "it \"$run_status\"\n}\n\nstatus_cmd() {\n  state=\"\"\n  while [ \"${1:-}\" != \"\" ]; do\n    case \"$1\" in\n      --state:*) state=\"${1#--state:}\" ;;\n      --help|-h) usage; exit 0 ;;\n      *)\n        echo \"[backend_host_runner] status unknown arg: $1\" >&2\n        usage\n        exit 1\n        ;;\n    esac\n    shift || true\n  done\n  if [ \"$state\" = \"\" ]; then\n    echo \"[backend_host_runner] status requires --state\" >&2\n    usage\n    exit 1\n  fi\n  print_status \"$state\"\n}\n\nrun_host_cmd() {\n  exe=\"\"\n  state=\"\"\n  layout_arg=\"\"\n  while [ \"${1:-}\" != \"\" ]; do\n    case \"$1\" in\n      --exe:*) exe=\"${1#--exe:}\" ;;\n      --state:*) state=\"${1#--state:}\" ;;\n      --layout-hash:*) layout_arg=\"${1#--layout-hash:}\" ;;\n      --help|-h) usage; exit 0 ;;\n      *)\n        echo \"[backend_host_runner] run-host unknown arg: $1\" >&2\n        usage\n        exit 1\n        ;;\n    esac\n    shift || true\n  done\n  if [ \"$exe\" = \"\" ]; then\n    echo \"[backend_host_runner] run-host requires --exe\" >&2\n    usage\n    exit 1\n  fi\n  if [ ! -f \"$exe\" ]; then\n    echo \"[backend_host_runner] run-host executable not found: $exe\" >&2\n    exit 1\n  fi\n  temp_state=\"0\"\n  if [ \"$state\" = \"\" ]; then\n    base_name=\"$(basename \"$exe\")\"\n    state=\"artifacts/backend_host_runner/run_host.${base_name}.$$\"\n    temp_state=\"1\"\n  fi\n  init_args=\"--state:$state --base:$exe\"\n  if [ \"$layout_arg\" != \"\" ]; then\n    init_"
        out = out + "args=\"$init_args --layout-hash:$layout_arg\"\n  fi\n  # shellcheck disable=SC2086\n  sh \"$0\" init $init_args >/dev/null\n  set +e\n  sh \"$0\" run --state:\"$state\"\n  run_status=\"$?\"\n  set -e\n  if [ \"$temp_state\" = \"1\" ] && [ \"${BACKEND_HOSTRUNNER_KEEP_STATE:-0}\" != \"1\" ]; then\n    rm -rf \"$state\"\n  fi\n  exit \"$run_status\"\n}\n\ncmd=\"${1:-}\"\nif [ \"$cmd\" = \"\" ] || [ \"$cmd\" = \"--help\" ] || [ \"$cmd\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\nshift || true\n\ncase \"$cmd\" in\n  init)\n    init_cmd \"$@\"\n    ;;\n  commit)\n    commit_cmd \"$@\"\n    ;;\n  run)\n    run_cmd \"$@\"\n    ;;\n  status)\n    status_cmd \"$@\"\n    ;;\n  run-host)\n    run_host_cmd \"$@\"\n    ;;\n  *)\n    echo \"[backend_host_runner] unknown command: $cmd\" >&2\n    usage\n    exit 1\n    ;;\nesac\n"
        return out
    if id == "backend_hotpatch_apply":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_hotpatch_apply --base:<exe> --patch:<exe> --symbol:<name>\n                                       [--check-exit:<code>] [--backup:<path>]\n                                       [--max-growth:<bytes>]\n                                       [--layout-hash:<hash>] [--state:<dir>]\n                                       [--thunk-id:<id>] [--target-slot:<offset>]\n\nNotes:\n  - Dev hotpatch terminal path uses trampoline route + append-only code pool.\n  - Layout hash drift or pool/max-growth pressure triggers controlled restart, not hard patch failure.\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return 0\n  fi\n  cksum \"$file\" | awk '{print $1 \":\" $2}'\n}\n\nread_status_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nis_uint() {\n  case \"${1:-}\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nbase=\"\"\n"
        out = out + "patch=\"\"\nsymbol=\"\"\ncheck_exit=\"\"\nbackup=\"\"\nmax_growth=\"${BACKEND_HOTPATCH_MAX_GROWTH:-}\"\nlayout_hash=\"${BACKEND_HOTPATCH_LAYOUT_HASH:-}\"\nstate_dir=\"${BACKEND_HOTPATCH_STATE_DIR:-}\"\nthunk_id=\"${BACKEND_HOTPATCH_THUNK_ID:-0}\"\ntarget_slot=\"${BACKEND_HOTPATCH_TARGET_SLOT:-0}\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --base:*) base=\"${1#--base:}\" ;;\n    --patch:*) patch=\"${1#--patch:}\" ;;\n    --symbol:*) symbol=\"${1#--symbol:}\" ;;\n    --check-exit:*) check_exit=\"${1#--check-exit:}\" ;;\n    --backup:*) backup=\"${1#--backup:}\" ;;\n    --max-growth:*) max_growth=\"${1#--max-growth:}\" ;;\n    --layout-hash:*) layout_hash=\"${1#--layout-hash:}\" ;;\n    --state:*) state_dir=\"${1#--state:}\" ;;\n    --thunk-id:*) thunk_id=\"${1#--thunk-id:}\" ;;\n    --target-slot:*) target_slot=\"${1#--target-slot:}\" ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[backend_hotpatch_apply] unknown arg: $1\" >&2\n      usage\n      exit 1\n      ;;\n  esac\n  shift\ndone\n\nif [ \"$base\" = \"\" ] || [ \"$patch\" = \"\" ] || [ \"$symbol\" = \"\" ]; then\n  echo \"[backend_hotpatch_apply] missing required args (--base --patch --symbol)\" >&2\n  usage\n  exit 1\nfi\nif [ ! -f \"$base\" ]; then\n  echo \"[backend_hotpatch_apply] base executable not found: $base\" >&2\n  exit 1\nfi\nif [ ! -f \"$patch\" ]; then\n  echo \"[backend_hotpatch_apply] patch executable not found: $patch\" >&2\n  exit 1\nfi\nif [ \"$check_exit\""
        out = out + " != \"\" ] && ! is_uint \"$check_exit\"; then\n  echo \"[backend_hotpatch_apply] invalid --check-exit: $check_exit\" >&2\n  exit 1\nfi\nif [ \"$max_growth\" != \"\" ] && ! is_uint \"$max_growth\"; then\n  echo \"[backend_hotpatch_apply] invalid --max-growth: $max_growth\" >&2\n  exit 1\nfi\nif ! is_uint \"$thunk_id\"; then\n  echo \"[backend_hotpatch_apply] invalid --thunk-id: $thunk_id\" >&2\n  exit 1\nfi\nif ! is_uint \"$target_slot\"; then\n  echo \"[backend_hotpatch_apply] invalid --target-slot: $target_slot\" >&2\n  exit 1\nfi\n\nif [ \"$backup\" = \"\" ]; then\n  backup=\"$base.hotpatch.bak\"\nfi\nif [ \"$state_dir\" = \"\" ]; then\n  state_dir=\"$base.hotpatch.state\"\nfi\nif [ \"$layout_hash\" = \"\" ]; then\n  layout_hash=\"$(hash_file \"$base\")\"\nfi\n\nrunner_exec=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\nrunner_id=\"backend_host_runner\"\nrunner_inline=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nif [ ! -f \"$runner_exec\" ]; then\n  echo \"[backend_hotpatch_apply] missing tooling exec: $runner_exec\" >&2\n  exit 1\nfi\nif [ ! -f \"$runner_inline\" ]; then\n  echo \"[backend_hotpatch_apply] missing host runner inline: $runner_inline\" >&2\n  exit 1\nfi\n\nmkdir -p \"$state_dir\"\ncp \"$base\" \"$backup\"\n\nstatus_tmp=\"$(mktemp \"${TMPDIR:-/tmp}/backend_hotpatch_apply_status.XXXXXX\")\"\ncleanup() {\n  rm -f \"$status_tmp\"\n}\ntrap cleanup EXIT INT TERM HUP\n\nif [ ! -f \"$state_dir/meta.env\" ]; then\n  \"$runner_exec\" \"$runner_id"
        out = out + "\" init \\\n    --state:\"$state_dir\" \\\n    --base:\"$base\" \\\n    --layout-hash:\"$layout_hash\" >/dev/null\nfi\n\nset +e\ncommit_args=\"--state:$state_dir --patch:$patch --layout-hash:$layout_hash --symbol:$symbol --thunk-id:$thunk_id --target-slot:$target_slot\"\nif [ \"$max_growth\" != \"\" ]; then\n  commit_args=\"$commit_args --max-growth:$max_growth\"\nfi\nif [ \"$check_exit\" != \"\" ]; then\n  commit_args=\"$commit_args --check-exit:$check_exit\"\nfi\n# shellcheck disable=SC2086\n\"$runner_exec\" \"$runner_id\" commit $commit_args >\"$status_tmp\"\nstatus=\"$?\"\nset -e\n\nif [ \"$status\" -ne 0 ]; then\n  cp \"$backup\" \"$base\"\n  echo \"[backend_hotpatch_apply] commit failed; restored base from backup: $backup\" >&2\n  exit \"$status\"\nfi\n\ncurrent_exe=\"$(read_status_value current_exe \"$status_tmp\")\"\nif [ \"$current_exe\" = \"\" ] || [ ! -f \"$current_exe\" ]; then\n  cp \"$backup\" \"$base\"\n  echo \"[backend_hotpatch_apply] missing committed executable in state: $state_dir\" >&2\n  exit 1\nfi\ncp \"$current_exe\" \"$base\"\nchmod 755 \"$base\" 2>/dev/null || true\n\ncommit_kind=\"$(read_status_value last_commit_kind \"$status_tmp\")\"\ncommit_epoch=\"$(read_status_value commit_epoch \"$status_tmp\")\"\nrestart_count=\"$(read_status_value restart_count \"$status_tmp\")\"\npool_used_bytes=\"$(read_status_value pool_used_bytes \"$status_tmp\")\"\npool_limit_bytes=\"$(read_status_value pool_limit_bytes \"$status_tmp\")\"\nhost_pid=\"$(read_status_value"
        out = out + " host_pid \"$status_tmp\")\"\nlast_apply_ms=\"$(read_status_value last_apply_ms \"$status_tmp\")\"\nresolved_layout_hash=\"$(read_status_value layout_hash \"$status_tmp\")\"\n\necho \"status=ok\"\necho \"base=$base\"\necho \"patch=$patch\"\necho \"symbol=$symbol\"\necho \"state=$state_dir\"\necho \"backup=$backup\"\necho \"thunk_id=$thunk_id\"\necho \"target_slot=$target_slot\"\necho \"commit_kind=$commit_kind\"\necho \"commit_epoch=$commit_epoch\"\necho \"restart_count=$restart_count\"\necho \"pool_used_bytes=$pool_used_bytes\"\necho \"pool_limit_bytes=$pool_limit_bytes\"\necho \"host_pid=$host_pid\"\necho \"apply_ms=$last_apply_ms\"\necho \"layout_hash=$resolved_layout_hash\"\n"
        return out
    if id == "backend_link_env":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ndriver=\"${BACKEND_DRIVER:-}\"\ntarget=\"${BACKEND_TARGET:-}\"\nlinker_mode=\"${BACKEND_LINKER:-}\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --driver:*)\n      driver=\"${1#--driver:}\"\n      ;;\n    --target:*)\n      target=\"${1#--target:}\"\n      ;;\n    --linker:*)\n      linker_mode=\"${1#--linker:}\"\n      ;;\n    --help|-h)\n      echo \"Usage: src/tooling/backend_link_env.sh [--driver:<path>] [--target:<triple>] [--linker:<self|system|auto>]\" 1>&2\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\n\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\n\ntarget_supports_self_linker() {\n  t=\"$1\"\n  case \"$t\" in\n    *darwin*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*riscv64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$t\" in\n        *arm64*|*aarch64*) return 0 ;;\n      esa"
        out = out + "c\n      return 1\n      ;;\n  esac\n  return 1\n}\n\ncase \"$target\" in\n  \"\"|auto|native|host)\n    target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\n    ;;\n  darwin_arm64|darwin_aarch64)\n    target=\"arm64-apple-darwin\"\n    ;;\n  darwin_x86_64|darwin_amd64)\n    target=\"x86_64-apple-darwin\"\n    ;;\n  linux_arm64|linux_aarch64)\n    target=\"aarch64-unknown-linux-gnu\"\n    ;;\n  linux_x86_64|linux_amd64)\n    target=\"x86_64-unknown-linux-gnu\"\n    ;;\n  linux_riscv64)\n    target=\"riscv64-unknown-linux-gnu\"\n    ;;\n  windows_arm64|windows_aarch64)\n    target=\"aarch64-pc-windows-msvc\"\n    ;;\n  windows_x86_64|windows_amd64)\n    target=\"x86_64-pc-windows-msvc\"\n    ;;\nesac\n\ncase \"$linker_mode\" in\n  self)\n    ;;\n  system)\n    printf \"BACKEND_LINKER=system\\n\"\n    exit 0\n    ;;\n  \"\"|auto)\n    if target_supports_self_linker \"$target\"; then\n      linker_mode=\"self\"\n    else\n      printf \"BACKEND_LINKER=system\\n\"\n      exit 0\n    fi\n    ;;\n  *)\n    echo \"[Error] invalid linker mode: $linker_mode\" 1>&2\n    exit 2\n    ;;\nesac\n\nruntime_nm_has_sym() {\n  sym=\"$1\"\n  printf '%s\\n' \"$nm_out\" | awk '{print $NF}' | sed 's/^_//' | grep -Fxq \"$sym\"\n}\n\nruntime_has_core_symbols() {\n  obj=\"$1\"\n  [ -f \"$obj\" ] || return 1\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null || true)\"\n  [ \"$nm_out\" != \"\" ] || return 1\n  runtime_nm_has_sym cheng_strlen &&\n  runtime_nm_has_sym cheng_memcpy &&\n  runtime_nm_has_sym cheng_memset &&\n  runtime_nm_has_sym cheng_malloc &&\n  runtime_nm_has_sym cheng_free &&\n  runtime_nm_has_sym cheng_mem_retain &&\n  runtime_nm_has_sym cheng_mem_release &&\n  runtime_nm_has_sym cheng_seq_get &&\n  runtime_nm_has_sym cheng_seq_set &&\n  runtime_nm_has_sym cheng_strcmp &&\n  runtime_nm_has_sym cheng_f32_bits_to_i64 &&\n  runtime_nm_has_sym cheng_f64_bits_to_i64\n}\n\nresolve_runtime_obj() {\n  if [ \"${BACKEND_RUNTIME_OBJ:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_RUNTIME_OBJ}\"\n    return 0\n  fi\n  candidates=\"\nchengcache/runtime_selflink/system_helpers.backend.combined.${target}.o\nartifacts/backend_mm/system_helpers.backend.combined.${target}.o\nchengcache/system_helpers.backend.cheng.${target}.o\nartifacts/backend_selfhost_self_obj/stage1.native.runtime.dedup.o\nartifacts/backend_selfhost_self_obj/system_helpers.backend.cheng.stage1shim.o\nchengcache/system_helpers.backend.cheng.o\nartifacts/backend_selfhost_self_obj/system_helpers.backend.cheng.o\n\"\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ] && runtime_has_core_symbols \"$cand\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ]; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nruntime_obj=\"$(resolve_runtime_obj || true)\"\nif [ \"$runtime_obj\" = \"\" ] || [ ! -f \"$runtime_obj\" ]; then\n  echo \"[backend_link_env] missing runtime object for target=$target\" >&2\n  echo \"  hint: set BACKEND_RUNTIME_OBJ or prepare chengcache/runtime_selflink/system_helpers.backend.combined.${target}.o\" >&2\n  exit 1\nfi\nif ! runtime_has_core_symbols \"$runtime_obj\"; then\n  echo \"[backend_link_env] warn: runtime object may be incomplete for self-link: $runtime_obj\" >&2\nfi\nprintf \"BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_RUNTIME_OBJ=%s\\n\" \"$runtime_obj\"\n"
        return out
    if id == "backend_prod_closure":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\n  Usage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure [--no-validate] [--debug] [--no-debug] [--no-ffi] [--no-determinism-strict]\n                                     [--no-opt] [--no-exe-determinism]\n                                      [--no-opt2] [--no-opt3] [--uir-aggressive] [--no-uir-aggressive]\n                                      [--uir-stability] [--no-uir-stability]\n                                      [--uir-aggressive-iters:<n>]\n                                      [--uir-opt2-iters:<n>] [--uir-opt3-iters:<n>] [--uir-opt3-cleanup-iters:<n>]\n                                      [--uir-cfg-canon-iters:<n>] [--uir-simd] [--no-uir-simd]\n                                      [--uir-simd-max-width:<n>] [--uir-simd-policy:<autovec|copy|loop|slp|none>]\n                                      [--uir-inline-iters:<n>]\n                                      [--no-sanitizer]\n                                     [--stress|--no-stress] [--no-bundle]\n                                     [--no-sign]\n                                     [--release-rollback-drill|--no-release-rollback-drill]\n                                     [--no-ssa]\n                                     [--selfhost|--no-selfhost]\n                                     [--low-mem|--no-low-mem]\n                                     [--multi-perf|--no-mult"
        out = out + "i-perf]\n                                     [--selfhost-parallel-perf|--no-selfhost-parallel-perf]\n                                     [--driver-selfbuild-smoke|--no-driver-selfbuild-smoke]\n                                     [--self-linker-gates|--no-self-linker-gates]\n                                     [--selfhost-fast|--selfhost-strict]\n                                     [--selfhost-strict-gate|--no-selfhost-strict-gate]\n                                     [--stage0-no-compat-gate|--no-stage0-no-compat-gate]\n                                     [--selfhost-strict-noreuse-probe|--no-selfhost-strict-noreuse-probe]\n                                     [--fullchain|--no-fullchain]\n                                     [--seed:<path>] [--seed-id:<id>] [--seed-tar:<path>] [--require-seed]\n                                     [--no-mm]\n                                     [--no-publish]\n                                     [--strict]\n                                     [--manifest:<path>] [--bundle:<path>]\n\nNotes:\n  - Runs the self-hosted backend production closure (includes required target-matrix gates).\n  - Default includes backend validation (BACKEND_VALIDATE=1) and emits a release manifest.\n  - Default enables closedloop fullspec gate (`BACKEND_RUN_FULLSPEC=1`);\n    `BACKEND_RUN_FULLSPEC=0` is no longer supported.\n  - `--no-ssa` disables the UIR generic-mode compare gate (dict vs hybrid) in verify_backend_ssa.\n  - Gate timeout defaults to 60s (`BA"
        out = out + "CKEND_PROD_GATE_TIMEOUT`; set 0 to disable).\n  - Selfhost bootstrap timeout defaults to 60s (`BACKEND_PROD_SELFHOST_TIMEOUT`).\n  - Selfhost bootstrap RSS guard defaults to 8192MB (`BACKEND_PROD_SELFHOST_MAX_RSS_MB`; set 0 to disable).\n  - Selfhost bootstrap gate timeout defaults to selfhost timeout (`BACKEND_PROD_SELFHOST_GATE_TIMEOUT`).\n  - Timeout diagnostics are enabled by default (`BACKEND_PROD_TIMEOUT_DIAG=1`).\n  - Selfhost performance regression gate is enabled by default (`BACKEND_RUN_SELFHOST_PERF=1`).\n  - Optional dedicated 100ms gate: set `BACKEND_RUN_SELFHOST_100MS=1` to run `backend.selfhost_100ms_host` (recommended on dedicated Darwin arm64 perf runners).\n  - Selfhost performance baseline defaults to `src/tooling/selfhost_perf_baseline.env` (`SELFHOST_PERF_BASELINE`).\n  - Multi compile performance regression gate is disabled by default (`BACKEND_RUN_MULTI_PERF=0`; dedicated perf runner opt-in).\n  - Multi perf baseline defaults to `src/tooling/multi_perf_baseline.env` (`MULTI_PERF_BASELINE`).\n  - Selfhost serial-vs-parallel perf gate is disabled by default (`BACKEND_RUN_SELFHOST_PARALLEL_PERF=0`; dedicated perf runner opt-in).\n  - Selfhost parallel perf timeout defaults to strict probe timeout (`BACKEND_PROD_SELFHOST_PARALLEL_PERF_TIMEOUT`).\n  - Selfhost parallel perf gate timeout defaults to 190s (`BACKEND_PROD_SELFHOST_PARALLEL_PERF_GATE_TIMEOUT`).\n  - Driver selfbuild smoke gate is disabled by default (`BACKEND_RUN_DRIVER_SELFBUILD_SMOKE=0`; dedicated perf runner opt-in).\n  - Driver selfbuild smoke gate timeout defaults to 60s (`BACKEND_"
        out = out + "PROD_DRIVER_SELFBUILD_SMOKE_TIMEOUT`).\n  - Driver selfbuild smoke build timeout defaults to 55s (`BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_BUILD_TIMEOUT`).\n  - Driver selfbuild smoke RSS guard defaults to 8192MB (`BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MAX_RSS_MB`; set 0 to disable).\n  - Low-memory profile is enabled by default (`BACKEND_PROD_LOW_MEM_PROFILE=1`); use `--no-low-mem` (or `BACKEND_PROD_LOW_MEM_PROFILE=0`) to disable.\n    Enabled low-mem enforces serial backend compile env, disables `multi_perf/selfhost_parallel_perf/driver_selfbuild_smoke`,\n    and caps default RSS to 8192MB (override via `BACKEND_PROD_LOW_MEM_RSS_MB` and `BACKEND_PROD_LOW_MEM_JOBS`).\n  - Self-linker\\u4e13\\u9879 gate \\u4e3a\\u5f3a\\u5236 required\\uff08`BACKEND_RUN_SELF_LINKER_GATES` \\u5fc5\\u987b\\u4e3a `1`\\uff09\\u3002\n  - Release \\u7b7e\\u540d\\u4e0e\\u9a8c\\u7b7e gate \\u9ed8\\u8ba4\\u4e3a required\\uff08`BACKEND_RUN_SIGN=1`\\uff09\\uff1b\\u7f3a\\u5c11 OpenSSL \\u6216\\u7b7e\\u540d\\u6750\\u6599\\u5f02\\u5e38\\u4f1a\\u76f4\\u63a5\\u963b\\u65ad\\u3002\n  - Release publish+rollback \\u6f14\\u7ec3 gate \\u9ed8\\u8ba4\\u5f00\\u542f\\uff08`BACKEND_RUN_RELEASE_ROLLBACK_DRILL=1`\\uff09\\u3002\n  - Fullchain bootstrap gate is opt-in (`--fullchain` or `BACKEND_RUN_FULLCHAIN=1`).\n  - Production closure is strict: any step that exits with skip code (2) fails the closure.\n  - Tooling gate dispatch defaults to global bundle exec (`tooling_exec`, profile=`full`,\n    `TOOLING_EXEC_REQUIRE_BUNDLE=1`); override with `BACKEND_TOOLING_BUNDLE_PROFILE`\n    / `BACKEND_TOOLING_REQUIRE_BUNDLE` o"
        out = out + "nly for diagnostics.\n  - `--require-seed` requires explicit `--seed`/`--seed-id`/`--seed-tar`.\n  - Publish path requires explicit seed (`--seed`/`--seed-id`/`--seed-tar`).\n  - Selfhost bootstrap is opt-in (`--selfhost` or `BACKEND_RUN_SELFHOST=1`).\n  - `--no-publish` keeps full gate set (stable-profile downgrade removed).\n  - Default selfhost mode is `fast` when selfhost is enabled (`BACKEND_PROD_SELFHOST_MODE` / `SELF_OBJ_BOOTSTRAP_MODE`).\n  - `--uir-aggressive` runs the opt3 fixture pack once in aggressive full-pass mode (`UIR_AGGRESSIVE=1`).\n    Default from `BACKEND_PROD_UIR_AGGRESSIVE` (fallback `0`), and\n    `BACKEND_PROD_UIR_FULL_ITERS` controls aggressive pass rounds (default `2`).\n  - `--uir-stability` enables repeated-mode/object determinism checks for UIR using `verify_backend_uir_stability`.\n    It is enabled by default (`BACKEND_RUN_UIR_STABILITY=1`; `--no-uir-stability` to disable).\n  - `--uir-aggressive-iters:<n>` overrides `BACKEND_PROD_UIR_FULL_ITERS` (accepted range `1..16`) for this run.\n  - `--uir-opt2-"
        out = out + "iters:<n>` controls `UIR_OPT2_ITERS` (default `5`).\n  - `--uir-opt3-iters:<n>` controls `UIR_OPT3_ITERS` (default `4`).\n  - `--uir-opt3-cleanup-iters:<n>` controls `UIR_OPT3_CLEANUP_ITERS` (default `3`).\n  - `--uir-cfg-canon-iters:<n>` controls `UIR_CFG_CANON_ITERS` (default `1`).\n  - `--uir-simd` / `--no-uir-simd` toggles `UIR_SIMD` (default `auto`: enabled when `opt3` gate runs).\n  - `--uir-simd-max-width:<n>` sets `UIR_SIMD_MAX_WIDTH` (default `0`).\n  - `--uir-simd-policy:<policy>` sets `UIR_SIMD_POLICY` (default `autovec`).\n  - `--uir-inline-iters:<n>` controls `UIR_INLINE_ITERS` (default `4`).\n  - `BACKEND_PROD_TARGET` controls target triple for `backend.opt/opt2/opt3/simd/uir_stability`.\n    When unset, non-darwin ambient `BACKEND_TARGET` is ignored and fallback target is `arm64-apple-darwin`.\n  - `BACKEND_OPT_DRIVER` can override `backend.opt/opt2/multi_lto/multi_perf/opt3/simd/uir_stability`\n    gate driver without changing the main required-gates driver.\n  - Production closure uses explicit linker per gate:\n    dev-path gates pin `BACKEND_LINKER=self`,\n    release-path gate pins `BACKEND_LINKER=system`.\n  - Production closure now enforces `backend.no_legacy_refs` / `backend.zero_script_closure` /\n    `backend.profile_schema` / `backend.emit_obj_contract` /\n    `backend.rawptr_contract` / `backend.rawptr_surface_forbid` / `backend.ffi_slice_shim` / `backend.ffi_outptr_tuple` / `backend.ffi_handle_sandbox` / `backend.ffi_borrow_bridge` / `backend.mem_c"
        out = out + "ontract` / `backend.dod_contract` / `backend.mem_image_core` / `backend.mem_exe_emit` /\n    `backend.profile_baseline` / `backend.dual_track` / `backend.linkerless_dev` /\n    `backend.macho_signature_gate` / `backend.metering_phase_barrier` / `backend.ast_simhash_contract` /\n    `backend.hotpatch_meta` / `backend.hotpatch_inplace` / `backend.incr_patch_fastpath` /\n    `backend.mem_patch_regression` / `backend.hotpatch` / `backend.release_system_link` /\n    `backend.plugin_isolation` / `backend.linker_abi_core` / `backend.self_linker.elf` /\n    `backend.self_linker.coff` / `backend.riscv64_quic_boundary` /\n    `backend.noptr_exemption_scope` / `backend.no_obj_artifacts` as required gates.\n  - `BACKEND_LINKERLESS_DRIVER` can override only `backend.linkerless_dev` gate driver.\n  - Strict selfhost gate is enabled by default when selfhost is enabled (`BACKEND_RUN_SELFHOST_STRICT=0` to disable).\n  - Stage0 no-compat gate is enabled and blocking by default when selfhost is enabled (`BACKEND_RUN_STAGE0_NO_COMPAT_GATE=0` to disable).\n  - Stage0 no-compat gate timeout defaults to 60s (`BACKEND_PROD_STAGE0_NO_COMPAT_GATE_TIMEOUT`).\n  - Strict no-reuse probe is enabled and blocking by default when selfhost is enabled (`BACKEND_RUN_SELFHOST_STRICT_NOREUSE_PROBE=0` to disable).\n  - Strict no-reuse probe defaults to `gate=110s` and `probe=90s`; override with\n    `BACKEND_PROD_SELFHOST_STRICT_NOREUSE_GATE_TIMEOUT` / `BACKEND_PROD_SELFHOST_STRICT_NOREUSE_PROBE_TIMEOUT`.\n  - Alias-off strict no-reuse probe supports latency profile knobs:\n    `BACKEND_PROD_SELFHOST_STRICT_NOREUSE_ALIAS_OFF_FAST` (default `1`),\n    `BACK"
        out = out + "END_PROD_SELFHOST_STRICT_NOREUSE_REQUIRE_RUNNABLE`,\n    `BACKEND_PROD_SELFHOST_STRICT_NOREUSE_SKIP_SMOKE`,\n    `BACKEND_PROD_SELFHOST_STRICT_NOREUSE_VALIDATE`.\nEOF\n}\n\nprod_closure_normalize_int() {\n  raw=\"$1\"\n  default=\"$2\"\n  minv=\"$3\"\n  maxv=\"$4\"\n  case \"$raw\" in\n    ''|*[!0-9]*)\n      echo \"$default\"\n      return\n      ;;\n  esac\n  if [ \"$raw\" -lt \"$minv\" ]; then\n    echo \"$minv\"\n    return\n  fi\n  if [ \"$raw\" -gt \"$maxv\" ]; then\n    echo \"$maxv\"\n    return\n  fi\n  echo \"$raw\"\n}\n\nvalidate=\"1\"\nrun_debug=\"\"\nrun_ffi=\"1\"\nrun_det_strict=\"1\"\nrun_opt=\"1\"\nrun_opt2=\"1\"\nrun_opt3=\"1\"\nrun_ssa=\"1\"\nrun_selfhost=\"\"\nif [ \"${BACKEND_RUN_SELFHOST:-0}\" = \"1\" ]; then\n  run_selfhost=\"1\"\nfi\nrun_fullchain=\"\"\nif [ \"${BACKEND_RUN_FULLCHAIN:-}\" = \"1\" ]; then\n  run_fullchain=\"1\"\nfi\nseed=\"\"\nseed_id=\"\"\nseed_tar=\"\"\nrequire_seed=\"0\"\nrun_obj=\"\"\nrun_obj_det=\"\"\nrun_exe_det=\"1\"\nrun_sanitizer=\"1\"\nrun_uir_stability=\"${BACKEND_RUN_UIR_STABILITY:-1}\"\nrun_uir_aggressive=\"${BACKEND_PROD_UIR_AGGRESSIVE:-}\"\nuir_aggressive_iters=\"${BACKEND_PROD_UIR_FULL_ITERS:-2}\"\nuir_opt2_iters=\"${BACKEND_PROD_UIR_OPT2_ITERS:-5}\"\nuir_opt3_iters=\"${BACKEND_PROD_UIR_OPT3_ITERS:-4}\"\nuir_opt3_cleanup_iters=\"${BACKEND_PROD_UIR_OPT3_CLEANUP_ITERS:-3}\"\nuir_cfg_canon_iters=\"${BACKEND_PROD_UIR_CFG_CANON_ITERS:-1}\"\nuir_inline_iters=\"${BACKEND_PROD_UIR_INLINE_ITERS:-4}\"\nuir_simd=\"${UIR_SIMD:-auto}\""
        out = out + "\nuir_simd_max_width=\"${UIR_SIMD_MAX_WIDTH:-0}\"\nuir_simd_policy=\"${UIR_SIMD_POLICY:-autovec}\"\nprod_target=\"${BACKEND_PROD_TARGET:-}\"\nrun_stress=\"\"\nif [ \"${BACKEND_RUN_STRESS:-}\" = \"1\" ]; then\n  run_stress=\"1\"\nfi\nrun_bundle=\"1\"\nrun_sign=\"1\"\nrun_release_rollback_drill=\"${BACKEND_RUN_RELEASE_ROLLBACK_DRILL:-1}\"\nrun_mm=\"1\"\nrun_publish=\"1\"\nmanifest=\"artifacts/backend_prod/release_manifest.json\"\nbundle=\"artifacts/backend_prod/backend_release.tar.gz\"\ndebug_explicit=\"0\"\nselfhost_timeout=\"${BACKEND_PROD_SELFHOST_TIMEOUT:-60}\"\nselfhost_max_rss_mb=\"${BACKEND_PROD_SELFHOST_MAX_RSS_MB:-8192}\"\nselfhost_gate_timeout=\"${BACKEND_PROD_GATE_TIMEOUT:-60}\"\nselfhost_bootstrap_gate_timeout=\"${BACKEND_PROD_SELFHOST_GATE_TIMEOUT:-$selfhost_timeout}\"\nstage0_no_compat_gate_timeout=\"${BACKEND_PROD_STAGE0_NO_COMPAT_GATE_TIMEOUT:-60}\"\nselfhost_strict_noreuse_gate_timeout=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_GATE_TIMEOUT:-110}\"\nselfhost_strict_noreuse_probe_timeout=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_PROBE_TIMEOUT:-105}\"\nselfhost_parallel_perf_timeout=\"${BACKEND_PROD_SELFHOST_PARALLEL_PERF_TIMEOUT:-$selfhost_strict_noreuse_probe_timeout}\"\nselfhost_parallel_perf_gate_timeout=\"${BACKEND_PROD_SELFHOST_PARALLEL_PERF_GATE_TIMEOUT:-190}\"\ndriver_selfbuild_smoke_gate_timeout=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_TIMEOUT:-60}\"\ndriver_selfbuild_smoke_build_timeout=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_BUILD_TIMEOUT:-55}\"\ndriver_s"
        out = out + "elfbuild_smoke_max_rss_mb=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MAX_RSS_MB:-8192}\"\nselfhost_reuse=\"${BACKEND_PROD_SELFHOST_REUSE:-${SELF_OBJ_BOOTSTRAP_REUSE:-1}}\"\nselfhost_session=\"${BACKEND_PROD_SELFHOST_SESSION:-${SELF_OBJ_BOOTSTRAP_SESSION:-prod}}\"\nselfhost_mode=\"${BACKEND_PROD_SELFHOST_MODE:-${SELF_OBJ_BOOTSTRAP_MODE:-fast}}\"\nrun_selfhost_strict=\"${BACKEND_RUN_SELFHOST_STRICT:-1}\"\nrun_stage0_no_compat_gate=\"${BACKEND_RUN_STAGE0_NO_COMPAT_GATE:-1}\"\nrun_selfhost_strict_noreuse_probe=\"${BACKEND_RUN_SELFHOST_STRICT_NOREUSE_PROBE:-1}\"\nrun_selfhost_parallel_perf=\"${BACKEND_RUN_SELFHOST_PARALLEL_PERF:-0}\"\nrun_driver_selfbuild_smoke=\"${BACKEND_RUN_DRIVER_SELFBUILD_SMOKE:-0}\"\nrun_self_linker_gates=\"${BACKEND_RUN_SELF_LINKER_GATES:-1}\"\nrun_selfhost_perf=\"${BACKEND_RUN_SELFHOST_PERF:-1}\"\nrun_selfhost_100ms=\"${BACKEND_RUN_SELFHOST_100MS:-0}\"\nrun_multi_perf=\"${BACKEND_RUN_MULTI_PERF:-0}\"\nlow_mem_profile=\"${BACKEND_PROD_LOW_MEM_PROFILE:-1}\"\nlow_mem_rss_mb=\"${BACKEND_PROD_LOW_MEM_RSS_MB:-8192}\"\nlow_mem_jobs=\"${BACKEND_PROD_LOW_MEM_JOBS:-1}\"\nselfhost_perf_use_strict_session=\"${BACKEND_SELFHOST_PERF_USE_STRICT_SESSION:-1}\"\ntimeout_diag_enabled=\"${BACKEND_PROD_TIMEOUT_DIAG:-1}\"\ntimeout_diag_seconds=\"${BACKEND_PROD_TIMEOUT_DIAG_SECONDS:-5}\"\ntimeout_diag_dir=\"${BACKEND_PROD_TIMEOUT_DIAG_DIR:-chengcache/backend_timeout_diag}\"\ntimeout_diag_tool=\"${BACKEND_P"
        out = out + "ROD_TIMEOUT_DIAG_TOOL:-sample}\"\ntimeout_diag_summary_enabled=\"${BACKEND_PROD_TIMEOUT_DIAG_SUMMARY:-1}\"\ntimeout_diag_summary_top=\"${BACKEND_PROD_TIMEOUT_DIAG_SUMMARY_TOP:-12}\"\ntimeout_diag_last_file=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --no-validate)\n      validate=\"\"\n      ;;\n    --debug)\n      run_debug=\"1\"\n      debug_explicit=\"1\"\n      ;;\n    --no-debug)\n      run_debug=\"\"\n      debug_explicit=\"1\"\n      ;;\n    --no-ffi)\n      run_ffi=\"\"\n      ;;\n    --no-determinism-strict)\n      run_det_strict=\"\"\n      ;;\n    --no-opt)\n      run_opt=\"\"\n      ;;\n    --no-opt2)\n      run_opt2=\"\"\n      run_opt3=\"\"\n      ;;\n    --no-opt3)\n      run_opt3=\"\"\n      run_uir_aggressive=\"\"\n      ;;\n    --uir-aggressive)\n      run_uir_aggressive=\"1\"\n      ;;\n    --uir-aggressive-iters:*)\n      run_uir_aggressive=\"1\"\n      uir_aggressive_iters=\"${1#--uir-aggressive-iters:}\"\n      ;;\n    --uir-opt2-iters:*)\n      uir_opt2_iters=\"${1#--uir-opt2-iters:}\"\n      ;;\n    --uir-opt3-iters:*)\n      uir_opt3_iters=\"${1#--uir-opt3-iters:}\"\n      ;;\n    --uir-opt3-cleanup-iters:*)\n      uir_opt3_cleanup_iters=\"${1#--uir-opt3-cleanup-iters:}\"\n      ;;\n    --uir-cfg-canon-iters:*)\n      uir_cfg_canon_iters=\"${1#--uir-cfg-canon-iters:}\"\n      ;;\n    --uir-inline-iters:*)\n      uir_inline_iters=\"${1#--uir-inline-iters:}\"\n      ;;\n    --uir-simd)\n      uir_simd=\"1\"\n      ;;\n    --no-uir-si"
        out = out + "md)\n      uir_simd=\"0\"\n      ;;\n    --uir-simd-max-width:*)\n      uir_simd_max_width=\"${1#--uir-simd-max-width:}\"\n      ;;\n    --uir-simd-policy:*)\n      uir_simd_policy=\"${1#--uir-simd-policy:}\"\n      ;;\n    --no-uir-aggressive)\n      run_uir_aggressive=\"\"\n      ;;\n    --uir-stability)\n      run_uir_stability=\"1\"\n      ;;\n    --no-uir-stability)\n      run_uir_stability=\"\"\n      ;;\n    --no-ssa)\n      run_ssa=\"\"\n      ;;\n    --selfhost)\n      run_selfhost=\"1\"\n      ;;\n    --no-selfhost)\n      run_selfhost=\"\"\n      ;;\n    --low-mem)\n      low_mem_profile=\"1\"\n      ;;\n    --no-low-mem)\n      low_mem_profile=\"0\"\n      ;;\n    --multi-perf)\n      run_multi_perf=\"1\"\n      ;;\n    --no-multi-perf)\n      run_multi_perf=\"0\"\n      ;;\n    --selfhost-fast)\n      run_selfhost=\"1\"\n      selfhost_mode=\"fast\"\n      ;;\n    --selfhost-strict)\n      run_selfhost=\"1\"\n      selfhost_mode=\"strict\"\n      ;;\n    --selfhost-strict-gate)\n      run_selfhost=\"1\"\n      run_selfhost_strict=\"1\"\n      ;;\n    --no-selfhost-strict-gate)\n      run_selfhost_strict=\"0\"\n      ;;\n    --stage0-no-compat-gate)\n      run_selfhost=\"1\"\n      run_stage0_no_compat_gate=\"1\"\n      ;;\n    --no-stage0-no-compat-gate)\n      run_stage0_no_compat_gate=\"0\"\n      ;;\n    --selfhost-strict-noreuse-probe)\n      run_selfhost=\"1\"\n      run_selfhost_strict_noreuse_probe=\"1\"\n      ;;\n    --no-selfhost-strict-noreuse-probe)\n"
        out = out + "      run_selfhost_strict_noreuse_probe=\"0\"\n      ;;\n    --selfhost-parallel-perf)\n      run_selfhost=\"1\"\n      run_selfhost_parallel_perf=\"1\"\n      ;;\n    --no-selfhost-parallel-perf)\n      run_selfhost_parallel_perf=\"0\"\n      ;;\n    --driver-selfbuild-smoke)\n      run_selfhost=\"1\"\n      run_driver_selfbuild_smoke=\"1\"\n      ;;\n    --no-driver-selfbuild-smoke)\n      run_driver_selfbuild_smoke=\"0\"\n      ;;\n    --self-linker-gates)\n      run_self_linker_gates=\"1\"\n      ;;\n    --no-self-linker-gates)\n      run_self_linker_gates=\"0\"\n      ;;\n    --no-fullchain)\n      run_fullchain=\"\"\n      ;;\n    --fullchain)\n      run_fullchain=\"1\"\n      ;;\n    --seed:*)\n      seed=\"${1#--seed:}\"\n      ;;\n    --seed-id:*)\n      seed_id=\"${1#--seed-id:}\"\n      ;;\n    --seed-tar:*)\n      seed_tar=\"${1#--seed-tar:}\"\n      ;;\n    --require-seed)\n      require_seed=\"1\"\n      ;;\n    --only-self-obj-bootstrap|--no-obj|--no-obj-determinism|--no-self-obj-writer)\n      echo \"[backend_prod_closure] note: $1 is deprecated and ignored (obj/self-obj flow removed)\" 1>&2\n      ;;\n    --no-exe-determinism)\n      run_exe_det=\"\"\n      ;;\n    --no-sanitizer)\n      run_sanitizer=\"\"\n      ;;\n    --no-stress)\n      run_stress=\"\"\n      ;;\n    --stress)\n      run_stress=\"1\"\n      ;;\n    --no-bundle)\n      run_bundle=\"\"\n      ;;\n    --no-sign)\n      run_sign=\"\"\n      ;;\n    --release-rollback-drill)\n      run_release"
        out = out + "_rollback_drill=\"1\"\n      ;;\n    --no-release-rollback-drill)\n      run_release_rollback_drill=\"\"\n      ;;\n    --no-mm)\n      run_mm=\"\"\n      ;;\n    --no-publish)\n      run_publish=\"\"\n      ;;\n    --strict)\n      ;;\n    --allow-skip)\n      echo \"[backend_prod_closure] --allow-skip is no longer supported\" 1>&2\n      exit 2\n      ;;\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --bundle:*)\n      bundle=\"${1#--bundle:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$selfhost_mode\" != \"strict\" ] && [ \"$selfhost_mode\" != \"fast\" ]; then\n  echo \"[Error] invalid selfhost mode: $selfhost_mode (expected strict|fast)\" 1>&2\n  exit 2\nfi\n\ncase \"0\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid no_publish_stable_profile: 0 (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n\ncase \"$low_mem_profile\" in\n  1|true|TRUE|yes|YES|on|ON)\n    low_mem_profile=\"1\"\n    ;;\n  0|false|FALSE|no|NO|off|OFF|\"\")\n    low_mem_profile=\"0\"\n    ;;\n  *)\n    echo \"[Error] invalid BACKEND_PROD_LOW_MEM_PROFILE: $low_mem_profile (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$low_mem_rss_mb\" in\n  ''|*[!0-9]*)\n    low_mem_rss_mb=8192\n    ;;\nesac\nif [ \"$low_mem_rss_mb\" -lt 1024 ]; then\n  low_mem_rss_mb=1024"
        out = out + "\nfi\ncase \"$low_mem_jobs\" in\n  ''|*[!0-9]*)\n    low_mem_jobs=1\n    ;;\nesac\nif [ \"$low_mem_jobs\" -lt 1 ]; then\n  low_mem_jobs=1\nfi\nif [ \"$low_mem_jobs\" -gt 2 ]; then\n  low_mem_jobs=2\nfi\n\nif [ \"$low_mem_profile\" = \"1\" ]; then\n  if [ \"${BACKEND_PROD_SELFHOST_MAX_RSS_MB:-}\" = \"\" ]; then\n    selfhost_max_rss_mb=\"$low_mem_rss_mb\"\n  fi\n  if [ \"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MAX_RSS_MB:-}\" = \"\" ]; then\n    driver_selfbuild_smoke_max_rss_mb=\"$low_mem_rss_mb\"\n  fi\n  run_multi_perf=\"0\"\n  run_selfhost_parallel_perf=\"0\"\n  run_driver_selfbuild_smoke=\"0\"\n  export BACKEND_MULTI=0\n  export BACKEND_MULTI_FORCE=0\n  export BACKEND_INCREMENTAL=0\n  export BACKEND_JOBS=\"$low_mem_jobs\"\n  export SELF_OBJ_BOOTSTRAP_JOBS=\"$low_mem_jobs\"\n  export BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_JOBS=\"$low_mem_jobs\"\n  export BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MULTI=0\n  export BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MULTI_FORCE=0\n  export BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_INCREMENTAL=0\n  echo \"[backend_prod_closure] low-mem profile enabled (rss=${low_mem_rss_mb}MB jobs=$low_mem_jobs): disable multi_perf/selfhost_parallel_perf/driver_selfbuild_smoke, force serial backend compile env\" 1>&2\nfi\n\nif [ \"$run_publish\" = \"\" ] && [ \"0\" = \"1\" ]; then\n  run_det_strict=\"\"\n  run_opt=\"\"\n  run_opt2=\"\"\n  run_opt3=\"\"\n  run_uir_aggressive=\"\"\n  run_uir_stability=\"\"\n  run_ssa=\"\"\n  run_ffi=\"\"\n  run_sanitiz"
        out = out + "er=\"\"\n  run_exe_det=\"\"\n  run_multi_perf=\"0\"\n  run_driver_selfbuild_smoke=\"0\"\n  if [ \"$debug_explicit\" = \"0\" ]; then\n    run_debug=\"\"\n  fi\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport TOOLING_EXEC_USE_BUNDLE_CORE=\"${TOOLING_EXEC_USE_BUNDLE_CORE:-${BACKEND_USE_TOOLING_BUNDLE_CORE:-1}}\"\nexport TOOLING_EXEC_BUNDLE_CORE_AUTO_BUILD=\"${TOOLING_EXEC_BUNDLE_CORE_AUTO_BUILD:-${BACKEND_TOOLING_BUNDLE_CORE_AUTO_BUILD:-0}}\"\nexport TOOLING_EXEC_BUNDLE_LINKER=\"${TOOLING_EXEC_BUNDLE_LINKER:-${BACKEND_TOOLING_BUNDLE_LINKER:-system}}\"\nexport TOOLING_EXEC_BUNDLE_OUT_DIR=\"${TOOLING_EXEC_BUNDLE_OUT_DIR:-${BACKEND_TOOLING_BUNDLE_OUT_DIR:-artifacts/tooling_bundle}}\"\nexport TOOLING_EXEC_BUNDLE_CORE_BIN_DIR=\"${TOOLING_EXEC_BUNDLE_CORE_BIN_DIR:-${BACKEND_TOOLING_BUNDLE_CORE_BIN_DIR:-$TOOLING_EXEC_BUNDLE_OUT_DIR/core/bin}}\"\nexport TOOLING_EXEC_GLOBAL_BIN=\"${TOOLING_EXEC_GLOBAL_BIN:-${BACKEND_TOOLING_BUNDLE_GLOBAL_BIN:-artifacts/tooling_cmd/cheng_tooling_global}}\"\nexport TOOLING_EXEC_BUNDLE_PROFILE=\"${TOOLING_EXEC_BUNDLE_PROFILE:-${BACKEND_TOOLING_BUNDLE_PROFILE:-full}}\"\nexport TOOLING_EXEC_REQUIRE_BUNDLE=\"${TOOLING_EXEC_REQUIRE_BUNDLE:-${BACKEND_TOOLING_REQUIRE_BUNDLE:-1}}\"\ncase \"$TOOLING_EXEC_BUNDLE_PROFILE\" in\n  full)\n    ;;\n  *)\n    echo \"[backend_prod_closure] invalid TOOLING_EXEC_BUNDLE_PROFILE: $TOOLING_EXEC_BUNDLE_PROFILE (expected full)\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"${TOOLIN"
        out = out + "G_EXEC_BUNDLE_BIN_DIR:-}\" = \"\" ]; then\n  export TOOLING_EXEC_BUNDLE_BIN_DIR=\"${BACKEND_TOOLING_BUNDLE_BIN_DIR:-$TOOLING_EXEC_BUNDLE_OUT_DIR/full/bin}\"\nfi\n\ntooling_true() {\n  case \"${1:-}\" in\n    1|true|TRUE|yes|YES|on|ON) return 0 ;;\n    *) return 1 ;;\n  esac\n}\n\ntooling_bin_dir_abs() {\n  raw=\"$1\"\n  if [ \"$raw\" = \"\" ]; then\n    printf \"%s\\n\" \"\"\n    return\n  fi\n  case \"$raw\" in\n    /*) printf \"%s\\n\" \"$raw\" ;;\n    *) printf \"%s/%s\\n\" \"$root\" \"$raw\" ;;\n  esac\n}\n\ntooling_bin_health_ok() {\n  bin_dir=\"$1\"\n  [ \"$bin_dir\" != \"\" ] || return 1\n  [ -x \"$bin_dir/cheng_tooling\" ] || return 1\n  set +e\n  TOOLING_ROOT=\"$root\" \"$bin_dir/cheng_tooling\" list >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  [ \"$status\" -eq 0 ]\n}\n\ntooling_prepare_bundle() {\n  tooling_bin_health_ok \"$TOOLING_EXEC_BUNDLE_BIN_DIR\"\n}\n\nif [ \"$TOOLING_EXEC_BUNDLE_PROFILE\" != \"full\" ]; then\n  echo \"[backend_prod_closure] zero-script closure requires TOOLING_EXEC_BUNDLE_PROFILE=full\" 1>&2\n  exit 2\nfi\nif ! tooling_true \"$TOOLING_EXEC_REQUIRE_BUNDLE\"; then\n  echo \"[backend_prod_closure] zero-script closure requires TOOLING_EXEC_REQUIRE_BUNDLE=1\" 1>&2\n  exit 2\nfi\nif tooling_true \"$TOOLING_EXEC_BUNDLE_CORE_AUTO_BUILD\"; then\n  echo \"[backend"
        out = out + "_prod_closure] zero-script closure requires TOOLING_EXEC_BUNDLE_CORE_AUTO_BUILD=0\" 1>&2\n  exit 2\nfi\n\nTOOLING_EXEC_BUNDLE_BIN_DIR=\"$(tooling_bin_dir_abs \"$TOOLING_EXEC_BUNDLE_BIN_DIR\")\"\ntooling_fallback_bin_dir=\"${BACKEND_TOOLING_FALLBACK_BIN_DIR:-artifacts/tooling_cmd/bin}\"\ntooling_fallback_bin_dir=\"$(tooling_bin_dir_abs \"$tooling_fallback_bin_dir\")\"\nif ! tooling_prepare_bundle; then\n  if tooling_bin_health_ok \"$tooling_fallback_bin_dir\"; then\n    echo \"[backend_prod_closure] warn: unhealthy tooling bundle bin ($TOOLING_EXEC_BUNDLE_BIN_DIR), fallback: $tooling_fallback_bin_dir\" 1>&2\n    export TOOLING_EXEC_BUNDLE_BIN_DIR=\"$tooling_fallback_bin_dir\"\n  else\n    echo \"[backend_prod_closure] missing tooling bundle entry: $TOOLING_EXEC_BUNDLE_BIN_DIR/cheng_tooling\" 1>&2\n    echo \"[backend_prod_closure] fallback tooling bin is also unhealthy: $tooling_fallback_bin_dir\" 1>&2\n    exit 1\n  fi\nfi\n\n# Keep local backend driver for the whole closure; many sub-gates rely on it.\nexport CLEAN_CHENG_LOCAL=0\n\nif [ \"$debug_explicit\" = \"0\" ] && [ \"$(uname -s 2>/dev/null || echo unknown)\" = \"Darwin\" ] && ! { [ \"$run_publish\" = \"\" ] && [ \"0\" = \"1\" ]; }; then\n  run_debug=\"1\"\nfi\n\nbackend_driver_explicit=\"0\"\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  backend_driver_explicit=\"1\"\nfi\n\nseed_from_tar() {\n  tar_path=\"$1\"\n  if [ ! -f \"$tar_path\" ]; then\n    echo \"[Error] seed tar not found: $tar_pat"
        out = out + "h\" 1>&2\n    exit 2\n  fi\n  out_dir=\"chengcache/backend_seed_prod_$$\"\n  mkdir -p \"$out_dir\"\n  tar -xzf \"$tar_path\" -C \"$out_dir\"\n  extracted=\"$out_dir/cheng\"\n  if [ ! -f \"$extracted\" ]; then\n    echo \"[Error] seed tar missing cheng: $tar_path\" 1>&2\n    exit 2\n  fi\n  chmod +x \"$extracted\" 2>/dev/null || true\n  printf \"%s\\n\" \"$extracted\"\n}\n\nseed_path=\"\"\nseed_requested=\"0\"\nif [ \"$require_seed\" = \"1\" ] || [ \"$seed\" != \"\" ] || [ \"$seed_id\" != \"\" ] || [ \"$seed_tar\" != \"\" ]; then\n  seed_requested=\"1\"\nfi\n\nif [ \"$seed_requested\" = \"1\" ]; then\n  if [ \"$seed\" != \"\" ]; then\n    seed_path=\"$seed\"\n  elif [ \"$seed_tar\" != \"\" ]; then\n    seed_path=\"$(seed_from_tar \"$seed_tar\")\"\n  elif [ \"$seed_id\" != \"\" ]; then\n    try_tar=\"dist/releases/$seed_id/backend_release.tar.gz\"\n    if [ ! -f \"$try_tar\" ]; then\n      echo \"[Error] missing seed tar for --seed-id:$seed_id ($try_tar)\" 1>&2\n      exit 2\n    fi\n    seed_tar=\"$try_tar\"\n    seed_path=\"$(seed_from_tar \"$seed_tar\")\"\n  elif [ \"$require_seed\" = \"1\" ]; then\n    echo \"[Error] --require-seed requires explicit --seed/--seed-id/--seed-tar\" 1>&2\n    exit 2\n  fi\n\n  if [ \"$seed_path\" = \"\" ] && [ \"$require_seed\" = \"1\" ]; then\n    echo \"[Error] missing seed: pass --seed/--seed-id/--seed-tar\" 1>&2\n    exit 2\n  fi\n\n  if [ \"$seed_path\" != \"\" ]; then\n    case \"$seed_path\" in\n      /*) ;;\n      *) seed_path=\"$root/$"
        out = out + "seed_path\" ;;\n    esac\n    if [ ! -x \"$seed_path\" ]; then\n      echo \"[Error] seed driver is not executable: $seed_path\" 1>&2\n      exit 2\n    fi\n  fi\nfi\n\nif [ \"$run_publish\" != \"\" ] && [ \"$seed_path\" = \"\" ]; then\n  echo \"[Error] publish requires explicit seed: pass --seed/--seed-id/--seed-tar (or use --no-publish)\" 1>&2\n  exit 2\nfi\n\nmkdir -p chengcache\ntiming_file=\"chengcache/backend_prod_closure.timings.$$\"\n: > \"$timing_file\"\n\ncleanup_timing_file() {\n  rm -f \"$timing_file\"\n}\ntrap cleanup_timing_file EXIT\n\ntimestamp_now() {\n  date +%s\n}\n\nrecord_timing() {\n  printf '%s\\t%s\\t%s\\n' \"$1\" \"$2\" \"$3\" >>\"$timing_file\"\n}\n\nprint_timing_summary() {\n  if [ ! -s \"$timing_file\" ]; then\n    return\n  fi\n  tab=\"$(printf '\\t')\"\n  echo \"== backend_prod_closure.timing_top ==\"\n  sort -t \"$tab\" -k3,3nr \"$timing_file\" | head -n 12 | while IFS=\"$tab\" read -r label status duration; do\n    [ \"$label\" = \"\" ] && continue\n    echo \"  ${duration}s [$status] $label\"\n  done\n}\n\nsanitize_diag_label() {\n  printf '%s' \"$1\" | tr -cs 'A-Za-z0-9._-' '_'\n}\n\nprepare_timeout_diag() {\n  label=\"$1\"\n  timeout_diag_last_file=\"\"\n  case \"$timeout_diag_enabled\" in\n    1|true|TRUE|yes|YES|on|ON)\n      ;;\n    *)\n      return 0\n      ;;\n  esac\n  if ! command -v \"$timeout_diag_tool\" >/dev/null 2>&1; then\n    return 0\n  fi\n  mkdir -p \"$timeout_diag_dir\"\n  safe_label=\"$(sanitize_diag_label \"$label\")\"\n "
        out = out + " if [ \"$safe_label\" = \"\" ]; then\n    safe_label=\"gate\"\n  fi\n  stamp=\"$(date +%Y%m%dT%H%M%S)\"\n  timeout_diag_last_file=\"$timeout_diag_dir/${stamp}_${safe_label}.sample.txt\"\n  export TIMEOUT_DIAG_FILE=\"$timeout_diag_last_file\"\n  export TIMEOUT_DIAG_SECONDS=\"$timeout_diag_seconds\"\n  export TIMEOUT_DIAG_TOOL=\"$timeout_diag_tool\"\n}\n\nfinish_timeout_diag() {\n  status=\"$1\"\n  label=\"$2\"\n  if [ \"$status\" -eq 124 ] && [ \"$timeout_diag_last_file\" != \"\" ]; then\n    echo \"[backend_prod_closure] timeout diag ($label): $timeout_diag_last_file\" 1>&2\n    case \"$timeout_diag_summary_enabled\" in\n      1|true|TRUE|yes|YES|on|ON)\n        if [ -f \"src/tooling/summarize_timeout_diag.sh\" ]; then\n          set +e\n          \"$TOOLING_EXEC_BUNDLE_BIN_DIR/summarize_timeout_diag\" --file:\"$timeout_diag_last_file\" --top:\"$timeout_diag_summary_top\"\n          set -e\n        fi\n        ;;\n    esac\n  fi\n  unset TIMEOUT_DIAG_FILE TIMEOUT_DIAG_SECONDS TIMEOUT_DIAG_TOOL\n  timeout_diag_last_file=\"\"\n}\n\nrun_with_timeout_labeled() {\n  label=\"$1\"\n  seconds=\"$2\"\n  shift 2\n  prepare_timeout_diag \"$label\"\n  run_with_timeout \"$seconds\" \"$@\"\n  status=\"$?\"\n  finish_timeout_diag \"$status\" \"$label\"\n  return \"$status\"\n}\n\nrun_required() {\n  label=\"$1\"\n  shift\n  run_required_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_required_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n  start=\"$(timestamp_"
        out = out + "now)\"\n  set +e\n  if [ \"$timeout_sec\" -gt 0 ] 2>/dev/null; then\n    run_with_timeout_labeled \"$label\" \"$timeout_sec\" \"$@\"\n  else\n    \"$@\"\n  fi\n  status=\"$?\"\n  set -e\n  end=\"$(timestamp_now)\"\n  duration=$((end - start))\n  if [ \"$status\" -eq 0 ]; then\n    record_timing \"$label\" \"ok\" \"$duration\"\n  else\n    if [ \"$status\" -eq 124 ]; then\n      echo \"[backend_prod_closure] $label timed out after ${timeout_sec}s\" 1>&2\n    fi\n    record_timing \"$label\" \"fail\" \"$duration\"\n    exit \"$status\"\n  fi\n}\n\nrun_optional() {\n  label=\"$1\"\n  shift\n  run_optional_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_optional_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n  start=\"$(timestamp_now)\"\n  set +e\n  if [ \"$timeout_sec\" -gt 0 ] 2>/dev/null; then\n    run_with_timeout_labeled \"$label\" \"$timeout_sec\" \"$@\"\n  else\n    \"$@\"\n  fi\n  status=\"$?\"\n  set -e\n  end=\"$(timestamp_now)\"\n  duration=$((end - start))\n  if [ \"$status\" -eq 0 ]; then\n    record_timing \"$label\" \"ok\" \"$duration\"\n  elif [ \"$status\" -eq 2 ]; then\n    echo \"[backend_prod_closure] $label requested skip, but production closure is strict\" 1>&2\n    record_timing \"$label\" \"fail\" \"$duration\"\n    exit 1\n  else\n    if [ \"$status\" -eq 124 ]; then\n      echo \"[backend_prod_closure] $label timed out after ${timeout_sec}s\" 1>&2\n    fi\n    record_timing \"$label\" \"fail\" \"$duration\"\n    exit \"$stat"
        out = out + "us\"\n  fi\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $diag_file = $ENV{\"TIMEOUT_DIAG_FILE\"} // \"\";\n    my $diag_tool = $ENV{\"TIMEOUT_DIAG_TOOL\"} // \"sample\";\n    my $diag_secs = $ENV{\"TIMEOUT_DIAG_SECONDS\"} // 5;\n    if ($diag_secs !~ /^\\d+$/ || $diag_secs <= 0) {\n      $diag_secs = 5;\n    } elsif ($diag_secs > 30) {\n      $diag_secs = 30;\n    }\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        $res = waitpid($pid, WNOHANG);\n        if ($res == $pid) {\n          my $status = $?;\n          if (($status & 127) != 0) {\n            exit(128 + ($status & 127));\n          }\n          exit($status >> 8);\n        }\n        if ($diag_file ne \"\" && $^O eq \"darwin\") {\n          system($diag_tool, \"$pid\", \"$diag_secs\", \"-mayDie\", \"-file\", $diag_file);\n        }\n        $res = waitpid($pid, WNOHANG);\n        if ($res == $pid) {\n          my $status = $?;\n          if (($status & 127) != 0) {\n            exit(128 + ($status & 127));\n          }\n          exit($"
        out = out + "status >> 8);\n        }\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end = time + 1;\n        while (time < $grace_end) {\n          $res = waitpid($pid, WNOHANG);\n          if ($res == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nresolve_runtime_obj_for_target() {\n  target=\"$1\"\n  if [ \"${BACKEND_RUNTIME_OBJ:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_RUNTIME_OBJ}\"\n    return\n  fi\n  safe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n  printf '%s\\n' \"chengcache/system_helpers.backend.cheng.${safe_target}.o\"\n}\n\ndriver_stage0_probe_ok() {\n  cand=\"$1\"\n  [ \"$cand\" != \"\" ] || return 1\n  [ -x \"$cand\" ] || return 1\n  cand_hash=\"\"\n  if command -v shasum >/dev/null 2>&1; then\n    cand_hash=\"$(shasum -a 256 \"$cand\" 2>/dev/null | awk '{print $1}')\"\n  elif command -v sha256sum >/dev/null 2>&1; then\n    cand_hash=\"$(sha256sum \"$cand\" 2>/dev/null | awk '{print $1}')\"\n  fi\n  case \"$cand_hash\" in\n    # Known-bad release artifacts that can wedge in UE state during stage0 probe.\n    08b9888a214418a32a468f1d9155c9d21"
        out = out + "d1789d01579cf84e7d9d6321366e382|\\\n    d059d1d84290dac64120dc78f0dbd9cb24e0e4b3d5a9045e63ad26232373ed1a)\n      return 1\n      ;;\n  esac\n  resolved=\"$cand\"\n  probe_mode=\"${BACKEND_PROD_STAGE0_PROBE_MODE:-}\"\n  if [ \"$probe_mode\" = \"\" ]; then\n    if [ \"$run_selfhost\" != \"\" ] || [ \"$run_selfhost_strict_noreuse_probe\" = \"1\" ] || [ \"$run_selfhost_parallel_perf\" = \"1\" ]; then\n      probe_mode=\"light\"\n    else\n      probe_mode=\"path\"\n    fi\n  fi\n  case \"$probe_mode\" in\n    path)\n      printf \"%s\\n\" \"$resolved\"\n      return 0\n      ;;\n    light)\n      probe_input=\"${BACKEND_PROD_STAGE0_PROBE_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\n      if [ ! -f \"$probe_input\" ]; then\n        printf \"%s\\n\" \"$resolved\"\n        return 0\n      fi\n      probe_target=\"$(\"$TOOLING_EXEC_BUNDLE_BIN_DIR/detect_host_target\" 2>/dev/null || echo auto)\"\n      probe_runtime_obj=\"$(resolve_runtime_obj_for_target \"$probe_target\")\"\n      if [ ! -f \"$probe_runtime_obj\" ]; then\n        return 1\n      fi\n      probe_out=\"chengcache/.backend_prod_stage0_probe_light_$$.bin\"\n      probe_timeout=\"${BACKEND_PROD_STAGE0_PROBE_TIMEOUT:-20}\"\n      rm -f \"$probe_out\"\n      set +e\n      run_with_timeout_labeled \"backend.stage0_probe.light\" \"$probe_timeout\" env \\\n        MM=orc \\\n        CACHE=0 \\\n        BACKEND_IR=uir \\\n        BACKEND_MULTI=0 \\\n        BACKEND_MULTI_FORCE=0 \\\n        BACKEND_INCREMENTAL=0 \\\n"
        out = out + "        BACKEND_VALIDATE=0 \\\n        BACKEND_WHOLE_PROGRAM=1 \\\n        BACKEND_LINKER=self \\\n        BACKEND_DRIVER=\"$resolved\" \\\n        BACKEND_NO_RUNTIME_C=1 \\\n        BACKEND_RUNTIME_OBJ=\"$probe_runtime_obj\" \\\n        BACKEND_EMIT=exe \\\n        BACKEND_TARGET=\"$probe_target\" \\\n        BACKEND_FRONTEND=stage1 \\\n        BACKEND_INPUT=\"$probe_input\" \\\n        BACKEND_OUTPUT=\"$probe_out\" \\\n        \"$resolved\" >/dev/null 2>&1\n      status=\"$?\"\n      set -e\n      if [ \"$status\" -ne 0 ] || [ ! -s \"$probe_out\" ]; then\n        rm -f \"$probe_out\"\n        return 1\n      fi\n      rm -f \"$probe_out\"\n      ;;\n    full)\n      probe_target=\"$(\"$TOOLING_EXEC_BUNDLE_BIN_DIR/detect_host_target\" 2>/dev/null || echo auto)\"\n      probe_runtime_obj=\"$(resolve_runtime_obj_for_target \"$probe_target\")\"\n      if [ ! -f \"$probe_runtime_obj\" ]; then\n        return 1\n      fi\n      probe_out=\"chengcache/.backend_prod_stage0_probe_$$.bin\"\n      probe_timeout=\"${BACKEND_PROD_STAGE0_PROBE_TIMEOUT:-$selfhost_timeout}\"\n      rm -f \"$probe_out\"\n      set +e\n      run_with_timeout_labeled \"backend.stage0_probe.full\" \"$probe_timeout\" env \\\n        STAGE1_SKIP_SEM=1 \\\n        GENERIC_MODE=dict \\\n        GENERIC_SPEC_BUDGET=0 \\\n        STAGE1_SKIP_OWNERSHIP=1 \\\n        MM=orc \\\n        CACHE=chengcache \\\n        BACKEND_MULTI=0 \\\n        BACKEND_MULTI_FORCE=0 \\\n        BACKEND_INCREMENTAL=1 \\\n        BACKEND_J"
        out = out + "OBS=0 \\\n        BACKEND_VALIDATE=1 \\\n        BACKEND_WHOLE_PROGRAM=1 \\\n        BACKEND_LINKER=self \\\n        BACKEND_NO_RUNTIME_C=1 \\\n        BACKEND_RUNTIME_OBJ=\"$probe_runtime_obj\" \\\n        BACKEND_EMIT=exe \\\n        BACKEND_TARGET=\"$probe_target\" \\\n        BACKEND_FRONTEND=stage1 \\\n        BACKEND_INPUT=src/backend/tooling/backend_driver.cheng \\\n        BACKEND_OUTPUT=\"$probe_out\" \\\n        \"$resolved\" >/dev/null 2>&1\n      status=\"$?\"\n      set -e\n      if [ \"$status\" -ne 0 ] || [ ! -s \"$probe_out\" ]; then\n        rm -f \"$probe_out\"\n        return 1\n      fi\n      rm -f \"$probe_out\"\n      ;;\n    *)\n      echo \"[Error] invalid BACKEND_PROD_STAGE0_PROBE_MODE: $probe_mode (expected path|light|full)\" 1>&2\n      return 1\n      ;;\n  esac\n  printf \"%s\\n\" \"$resolved\"\n  return 0\n}\n\nexport BACKEND_MATRIX_STRICT=1\nif [ \"${ABI:-}\" != \"\" ] && [ \"${ABI}\" != \"v2_noptr\" ]; then\n  echo \"[backend_prod_closure] only ABI=v2_noptr is supported (got: ${ABI})\" 1>&2\n  exit 2\nfi\nexport ABI=v2_noptr\nif [ \"${BORROW_IR:-}\" = \"\" ]; then\n  export BORROW_IR=mir\nfi\nif [ \"${GENERIC_LOWERING:-}\" = \"\" ]; then\n  export GENERIC_LOWERING=mir_hybrid\nfi\nif [ \"${STAGE1_STD_NO_POINTERS:-}\" = \"\" ]; then\n  export STAGE1_STD_NO_POINTERS=1\nfi\nif [ \"${STAGE1_STD_NO_POINTERS_STRICT:-}\" = \"\" ]; then\n  export STAGE1_STD_NO_POINTERS_STRICT=0\nfi\nif [ \"${STAGE1_NO_POINTERS_NON_C_ABI:-}\" = \"\" ]; then\n  export ST"
        out = out + "AGE1_NO_POINTERS_NON_C_ABI=1\nfi\nif [ \"${STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL:-}\" = \"\" ]; then\n  export STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1\nfi\n\nmain_allow_selfhost_driver=\"${BACKEND_MAIN_ALLOW_SELFHOST_DRIVER:-auto}\"\nif [ \"$main_allow_selfhost_driver\" = \"auto\" ]; then\n  if [ \"${STAGE1_NO_POINTERS_NON_C_ABI:-0}\" = \"1\" ]; then\n    main_allow_selfhost_driver=\"0\"\n  else\n    main_allow_selfhost_driver=\"1\"\n  fi\nfi\ncase \"$main_allow_selfhost_driver\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid BACKEND_MAIN_ALLOW_SELFHOST_DRIVER: $main_allow_selfhost_driver (expected auto|0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n\nselfhost_stage0=\"${seed_path:-}\"\nif [ \"$run_selfhost\" != \"\" ]; then\n  if [ \"$selfhost_stage0\" = \"\" ] && [ \"$backend_driver_explicit\" = \"1\" ]; then\n    if [ -x \"${BACKEND_DRIVER:-}\" ]; then\n      selfhost_stage0=\"${BACKEND_DRIVER}\"\n    fi\n  fi\n  if [ \"$selfhost_stage0\" = \"\" ]; then\n    if [ -x \"artifacts/backend_driver/cheng\" ]; then\n      selfhost_stage0=\"artifacts/backend_driver/cheng\"\n    fi\n  fi\n  if [ \"$selfhost_stage0\" = \"\" ] && [ \"$seed_requested\" != \"1\" ] && [ \"$backend_driver_explicit\" != \"1\" ]; then\n    selfhost_stage0=\"$(env BACKEND_DRIVER_PATH_ALLOW_SELFHOST=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_driver_path\" 2>/dev/null || true)\"\n  fi\n  resolved=\"\"\n  if resolved=\"$(driver_stage0_probe_ok \"$selfhost_stage0\")\"; then\n    selfhost_stage0=\"$resolved\"\n  els"
        out = out + "e\n    selfhost_stage0=\"\"\n  fi\n  if [ \"$selfhost_stage0\" = \"\" ]; then\n    echo \"[backend_prod_closure] no healthy selfhost stage0 driver found (expected stable driver)\" 1>&2\n    echo \"  hint: run ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_driver --name:artifacts/backend_driver/cheng\" 1>&2\n    echo \"  or provide --seed:<path> / BACKEND_DRIVER=<path>\" 1>&2\n    exit 1\n  fi\nfi\n\ndriver_runnable() {\n  cand=\"$1\"\n  [ \"$cand\" != \"\" ] || return 1\n  [ -x \"$cand\" ] || return 1\n  set +e\n  env BACKEND_DRIVER=\"$cand\" BACKEND_DRIVER_PATH_STAGE1_STRICT_SMOKE=0 BACKEND_DRIVER_PATH_STAGE1_DICT_SMOKE=1 \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_driver_path\" >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ]; then\n    return 0\n  fi\n  if driver_help_ok \"$cand\"; then\n    return 0\n  fi\n  if driver_stage1_compile_ok \"$cand\"; then\n    return 0\n  fi\n  return 1\n}\n\ndriver_help_ok() {\n  cand=\"$1\"\n  [ \"$cand\" != \"\" ] || return 1\n  [ -x \"$cand\" ] || return 1\n  help_timeout=\"${BACKEND_PROD_DRIVER_HELP_TIMEOUT:-5}\"\n  set +e\n  run_with_timeout \"$help_timeout\" \"$cand\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_has_non_c_abi_diag() {\n  cand=\"$1\"\n  [ \"$cand\" != \"\" ] || return 1\n  [ -x \"$cand\" ] || return 1\n  if ! command -v strings >/dev/null 2>&1; then\n    return 0\n  fi\n  tmp_strings=\"$("
        out = out + "mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\ndriver_stage1_compile_ok() {\n  cand=\"$1\"\n  [ \"$cand\" != \"\" ] || return 1\n  [ -x \"$cand\" ] || return 1\n  probe_input=\"${BACKEND_MAIN_DRIVER_PROBE_INPUT:-tests/cheng/backend/fixtures/return_forward_decl_call.cheng}\"\n  if [ ! -f \"$probe_input\" ]; then\n    probe_input=\"tests/cheng/backend/fixtures/return_i64.cheng\"\n  fi\n  probe_skip_sem=\"${STAGE1_SKIP_SEM:-0}\"\n  probe_skip_ownership=\"${STAGE1_SKIP_OWNERSHIP:-1}\"\n  if [ ! -f \"$probe_input\" ]; then\n    return 1\n  fi\n  probe_target=\"$(\"$TOOLING_EXEC_BUNDLE_BIN_DIR/detect_host_target\" 2>/dev/null || echo auto)\"\n  probe_out=\"chengcache/.backend_main_driver_probe_$$.bin\"\n  probe_timeout=\"${BACKEND_MAIN_DRIVER_PROBE_TIMEOUT:-20}\"\n  rm -f \"$probe_out\"\n  set +e\n  run_with_timeout_labeled \"backend.main_driver_probe\" \"$probe_timeout\" env \\\n    MM=orc \\\n    BACKEND_VALIDATE=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_NO_"
        out = out + "POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"$probe_skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$probe_skip_ownership\" \\\n    STAGE1_SKIP_SEM=\"$probe_skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$probe_skip_ownership\" \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$probe_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_input\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$probe_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_input\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$cand\" >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ ! -s \"$probe_out\" ]; then\n    rm -f \"$probe_out\"\n    return 1\n  fi\n  set +e\n  run_with_timeout_labeled \"backend.main_driver_probe.run\" \"$probe_timeout\" \"$probe_out\" >/dev/null 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ge 124 ] 2>/dev/null; then\n    rm -f \"$probe_out\"\n    return 1\n  fi\n  probe_out_unprefixed=\"chengcache/.backend_main_driver_probe_unprefixed_$$.bin\"\n  rm -f \"$probe_out_unprefixed\"\n  set +e\n  run_with_timeout_labeled \"backend.main_driver_probe.unprefixed\" \"$probe_timeout\" env \\\n    MM=orc \\\n    BACKEND_VALIDATE=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_I"
        out = out + "NTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"$probe_skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$probe_skip_ownership\" \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$probe_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_input\" \\\n    BACKEND_OUTPUT=\"$probe_out_unprefixed\" \\\n    \"$cand\" >/dev/null 2>&1\n  status_unprefixed=\"$?\"\n  set -e\n  if [ \"$status_unprefixed\" -ne 0 ] || [ ! -s \"$probe_out_unprefixed\" ]; then\n    rm -f \"$probe_out\" \"$probe_out_unprefixed\"\n    return 1\n  fi\n  rm -f \"$probe_out_unprefixed\"\n  rm -f \"$probe_out\"\n  return 0\n}\n\nif [ \"$run_selfhost\" != \"\" ]; then\n  selfhost_label=\"backend.selfhost_bootstrap\"\n  if [ \"$selfhost_mode\" = \"fast\" ]; then\n    selfhost_label=\"backend.selfhost_bootstrap.fast\"\n  else\n    selfhost_label=\"backend.selfhost_bootstrap.strict\"\n  fi\n  if [ \"$selfhost_stage0\" != \"\" ]; then\n    run_optional_timeout \"$selfhost_label\" \"$selfhost_bootstrap_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$selfhost_timeout\" SELF_OBJ_BOOTSTRAP_MAX_RSS_MB=\"$selfhost_max_rss_mb\" SELF_OBJ_BOOTSTRAP_REUSE=\"$selfhost_reuse\" SELF_OBJ_BOOTSTRAP_SESSION=\"$selfhost_session\" SELF_OBJ_BOOTSTRAP_MODE=\"$selfhost_mode\" SELF_OBJ_BOOTSTRAP_MULTI=0 SELF_OBJ_BOOTSTRAP_MULTI_FORCE=0 SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=0 SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 "
        out = out + "SELF_OBJ_BOOTSTRAP_STAGE0=\"$selfhost_stage0\" \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_bootstrap\"\n  else\n    run_optional_timeout \"$selfhost_label\" \"$selfhost_bootstrap_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$selfhost_timeout\" SELF_OBJ_BOOTSTRAP_MAX_RSS_MB=\"$selfhost_max_rss_mb\" SELF_OBJ_BOOTSTRAP_REUSE=\"$selfhost_reuse\" SELF_OBJ_BOOTSTRAP_SESSION=\"$selfhost_session\" SELF_OBJ_BOOTSTRAP_MODE=\"$selfhost_mode\" SELF_OBJ_BOOTSTRAP_MULTI=0 SELF_OBJ_BOOTSTRAP_MULTI_FORCE=0 SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=0 SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_bootstrap\"\n  fi\n  if [ \"$run_selfhost_strict\" = \"1\" ] && [ \"$selfhost_mode\" = \"fast\" ]; then\n    strict_session=\"${BACKEND_PROD_SELFHOST_STRICT_SESSION:-$selfhost_session}\"\n    strict_allow_fast_reuse=\"${BACKEND_PROD_SELFHOST_STRICT_ALLOW_FAST_REUSE:-1}\"\n    if [ \"$selfhost_stage0\" != \"\" ]; then\n      run_optional_timeout \"backend.selfhost_bootstrap.strict\" \"$selfhost_bootstrap_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$selfhost_timeout\" SELF_OBJ_BOOTSTRAP_MAX_RSS_MB=\"$selfhost_max_rss_mb\" SELF_OBJ_BOOTSTRAP_REUSE=\"$selfhost_reuse\" SELF_OBJ_BOOTSTRAP_SESSION=\"$strict_session\" SELF_OBJ_BOOTSTRAP_MODE=strict SELF_OBJ_BOOTSTRAP_MULTI=0 SELF_OBJ_BOOTSTRAP_MULTI_FORCE"
        out = out + "=0 SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=0 SELF_OBJ_BOOTSTRAP_STRICT_ALLOW_FAST_REUSE=\"$strict_allow_fast_reuse\" SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 SELF_OBJ_BOOTSTRAP_STAGE0=\"$selfhost_stage0\" \\\n        \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_bootstrap\"\n    else\n      run_optional_timeout \"backend.selfhost_bootstrap.strict\" \"$selfhost_bootstrap_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$selfhost_timeout\" SELF_OBJ_BOOTSTRAP_MAX_RSS_MB=\"$selfhost_max_rss_mb\" SELF_OBJ_BOOTSTRAP_REUSE=\"$selfhost_reuse\" SELF_OBJ_BOOTSTRAP_SESSION=\"$strict_session\" SELF_OBJ_BOOTSTRAP_MODE=strict SELF_OBJ_BOOTSTRAP_MULTI=0 SELF_OBJ_BOOTSTRAP_MULTI_FORCE=0 SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=0 SELF_OBJ_BOOTSTRAP_STRICT_ALLOW_FAST_REUSE=\"$strict_allow_fast_reuse\" SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_bootstrap\"\n    fi\n  fi\n  if [ \"$run_stage0_no_compat_gate\" = \"1\" ]; then\n    stage0_no_compat_session=\"${BACKEND_PROD_STAGE0_NO_COMPAT_SESSION:-${selfhost_session}.stage0_no_compat}\"\n    stage0_no_compat_mode=\"${BACKEND_PROD_STAGE0_NO_COMPAT_MODE:-fast}\"\n    stage0_no_compat_timeout=\"${BACKEND_PROD_STAGE0_NO_COMPAT_TIMEOUT:-$selfhost_timeout}\"\n    stage0_no_compat_stage0=\"${BACKEND_PROD_STAGE0_NO_COMPAT_STAGE0:-$selfhost_stage0}\"\n    stage0_no_compat_reuse=\"${BACKEND_PROD_STAGE0_NO_COMPAT_REUSE:-0}\"\n    stage0_no_compat_v"
        out = out + "alidate=\"${BACKEND_PROD_STAGE0_NO_COMPAT_VALIDATE:-0}\"\n    stage0_no_compat_skip_smoke=\"${BACKEND_PROD_STAGE0_NO_COMPAT_SKIP_SMOKE:-1}\"\n    stage0_no_compat_require_runnable=\"${BACKEND_PROD_STAGE0_NO_COMPAT_REQUIRE_RUNNABLE:-0}\"\n    stage0_no_compat_stage1_probe_required=\"${BACKEND_PROD_STAGE0_NO_COMPAT_STAGE1_PROBE_REQUIRED:-$stage0_no_compat_require_runnable}\"\n    if [ \"$stage0_no_compat_stage0\" != \"\" ]; then\n      run_required_timeout \"backend.stage0_no_compat\" \"$stage0_no_compat_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE0_NO_COMPAT_SESSION=\"$stage0_no_compat_session\" STAGE0_NO_COMPAT_MODE=\"$stage0_no_compat_mode\" STAGE0_NO_COMPAT_TIMEOUT=\"$stage0_no_compat_timeout\" STAGE0_NO_COMPAT_REUSE=\"$stage0_no_compat_reuse\" STAGE0_NO_COMPAT_VALIDATE=\"$stage0_no_compat_validate\" STAGE0_NO_COMPAT_SKIP_SMOKE=\"$stage0_no_compat_skip_smoke\" STAGE0_NO_COMPAT_REQUIRE_RUNNABLE=\"$stage0_no_compat_require_runnable\" STAGE0_NO_COMPAT_STAGE1_PROBE_REQUIRED=\"$stage0_no_compat_stage1_probe_required\" STAGE0_NO_COMPAT_STAGE0=\"$stage0_no_compat_stage0\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_stage0_no_compat\"\n    else\n      run_required_timeout \"backend.stage0_no_compat\" \"$stage0_no_compat_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE0_NO_COMPAT_SESSION=\"$stage0_no_compat_session\" STAGE0_NO_COMPAT_MODE=\"$stage0_no_compat_mode\" STAGE0_NO_COMPAT_TI"
        out = out + "MEOUT=\"$stage0_no_compat_timeout\" STAGE0_NO_COMPAT_REUSE=\"$stage0_no_compat_reuse\" STAGE0_NO_COMPAT_VALIDATE=\"$stage0_no_compat_validate\" STAGE0_NO_COMPAT_SKIP_SMOKE=\"$stage0_no_compat_skip_smoke\" STAGE0_NO_COMPAT_REQUIRE_RUNNABLE=\"$stage0_no_compat_require_runnable\" STAGE0_NO_COMPAT_STAGE1_PROBE_REQUIRED=\"$stage0_no_compat_stage1_probe_required\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_stage0_no_compat\"\n    fi\n  fi\n  if [ \"$run_selfhost_strict_noreuse_probe\" = \"1\" ]; then\n    strict_probe_timeout=\"$selfhost_strict_noreuse_probe_timeout\"\n    gate_timeout_numeric=\"1\"\n    probe_timeout_numeric=\"1\"\n    case \"$selfhost_strict_noreuse_gate_timeout\" in\n      ''|*[!0-9]*)\n        gate_timeout_numeric=\"0\"\n        ;;\n    esac\n    case \"$strict_probe_timeout\" in\n      ''|*[!0-9]*)\n        probe_timeout_numeric=\"0\"\n        ;;\n    esac\n    if [ \"$gate_timeout_numeric\" = \"1\" ] && [ \"$probe_timeout_numeric\" = \"1\" ]; then\n      if [ \"$selfhost_strict_noreuse_gate_timeout\" -gt 0 ] && [ \"$strict_probe_timeout\" -ge \"$selfhost_strict_noreuse_gate_timeout\" ]; then\n        strict_probe_timeout=$((selfhost_strict_noreuse_gate_timeout - 5))\n        if [ \"$strict_probe_timeout\" -lt 1 ]; then\n          strict_probe_timeout=1\n        fi\n      fi\n    fi\n    strict_probe_session_base=\"${BACKEND_PROD_SELFHOST_STRICT_SESSION:-$selfhost_session}\"\n    strict_probe_session=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_SESSION:-${stric"
        out = out + "t_probe_session_base}.noreuse}\"\n    strict_probe_require=\"${BACKEND_SELFHOST_STRICT_NOREUSE_PROBE_REQUIRE:-1}\"\n    strict_probe_validate=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_VALIDATE:-0}\"\n    strict_probe_skip_smoke=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_SKIP_SMOKE:-1}\"\n    strict_probe_require_runnable=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_REQUIRE_RUNNABLE:-1}\"\n    strict_probe_stage1_probe_required=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_STAGE1_PROBE_REQUIRED:-0}\"\n    strict_probe_alias_off_fast=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_ALIAS_OFF_FAST:-1}\"\n    if [ \"$strict_probe_alias_off_fast\" = \"1\" ]; then\n      if [ \"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_REQUIRE_RUNNABLE:-}\" = \"\" ]; then\n        strict_probe_require_runnable=\"0\"\n      fi\n      if [ \"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_STAGE1_PROBE_REQUIRED:-}\" = \"\" ]; then\n        strict_probe_stage1_probe_required=\"0\"\n      fi\n      if [ \"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_SKIP_SMOKE:-}\" = \"\" ]; then\n        strict_probe_skip_smoke=\"1\"\n      fi\n      if [ \"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_VALIDATE:-}\" = \"\" ]; then\n        strict_probe_validate=\"0\"\n      fi\n      echo \"[backend_prod_closure] info: strict noreuse alias-off fast profile enabled (frontend=stage1, require_runnable=${strict_probe_require_runnable})\" 1>&2\n    fi\n    strict_probe_stage0=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_STAGE0:-}\"\n    if [ \"$strict_probe_stage0\" = \"\""
        out = out + " ]; then\n      strict_probe_stage0=\"$selfhost_stage0\"\n    else\n      strict_probe_resolved=\"\"\n      if strict_probe_resolved=\"$(driver_stage0_probe_ok \"$strict_probe_stage0\")\"; then\n        strict_probe_stage0=\"$strict_probe_resolved\"\n      else\n        strict_probe_stage0=\"$selfhost_stage0\"\n      fi\n    fi\n    if [ \"$strict_probe_stage0\" != \"\" ]; then\n      run_required_timeout \"backend.selfhost_strict_noreuse_probe\" \"$selfhost_strict_noreuse_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELFHOST_STRICT_PROBE_SESSION=\"$strict_probe_session\" SELFHOST_STRICT_PROBE_TIMEOUT=\"$strict_probe_timeout\" SELFHOST_STRICT_PROBE_REQUIRE=\"$strict_probe_require\" SELFHOST_STRICT_PROBE_REUSE=0 SELFHOST_STRICT_PROBE_STRICT_ALLOW_FAST_REUSE=0 SELFHOST_STRICT_PROBE_VALIDATE=\"$strict_probe_validate\" SELFHOST_STRICT_PROBE_SKIP_SMOKE=\"$strict_probe_skip_smoke\" SELFHOST_STRICT_PROBE_REQUIRE_RUNNABLE=\"$strict_probe_require_runnable\" SELFHOST_STRICT_PROBE_STAGE1_PROBE_REQUIRED=\"$strict_probe_stage1_probe_required\" SELFHOST_STRICT_PROBE_STAGE0=\"$strict_probe_stage0\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_strict_noreuse_probe\"\n    else\n      run_required_timeout \"backend.selfhost_strict_noreuse_probe\" \"$selfhost_strict_noreuse_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELFHOST_STRICT_PROBE_SESSION=\"$strict_probe_session\" SELFHOST_STRICT_PROBE_T"
        out = out + "IMEOUT=\"$strict_probe_timeout\" SELFHOST_STRICT_PROBE_REQUIRE=\"$strict_probe_require\" SELFHOST_STRICT_PROBE_REUSE=0 SELFHOST_STRICT_PROBE_STRICT_ALLOW_FAST_REUSE=0 SELFHOST_STRICT_PROBE_VALIDATE=\"$strict_probe_validate\" SELFHOST_STRICT_PROBE_SKIP_SMOKE=\"$strict_probe_skip_smoke\" SELFHOST_STRICT_PROBE_REQUIRE_RUNNABLE=\"$strict_probe_require_runnable\" SELFHOST_STRICT_PROBE_STAGE1_PROBE_REQUIRED=\"$strict_probe_stage1_probe_required\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_strict_noreuse_probe\"\n    fi\n    if [ \"$run_selfhost_parallel_perf\" = \"1\" ]; then\n      parallel_probe_stage0=\"$strict_probe_stage0\"\n      if [ \"$parallel_probe_stage0\" = \"\" ]; then\n        parallel_probe_stage0=\"$selfhost_stage0\"\n      fi\n      parallel_probe_session=\"${BACKEND_PROD_SELFHOST_PARALLEL_PERF_SESSION:-${strict_probe_session}.parallel_perf}\"\n      parallel_max_slowdown=\"${BACKEND_PROD_SELFHOST_PARALLEL_PERF_MAX_SLOWDOWN_SEC:-12}\"\n      parallel_probe_timeout=\"$selfhost_parallel_perf_timeout\"\n      parallel_gate_timeout=\"$selfhost_parallel_perf_gate_timeout\"\n      case \"$parallel_probe_timeout:$parallel_gate_timeout\" in\n        *[!0-9:]*)\n          :\n          ;;\n        *)\n          min_parallel_gate=\"$((parallel_probe_timeout * 2 + 10))\"\n          if [ \"$parallel_gate_timeout\" -gt 0 ] && [ \"$parallel_gate_timeout\" -lt \"$min_parallel_gate\" ]; then\n            parallel_gate_timeout=\"$min_parallel_gate\"\n          fi\n      "
        out = out + "    ;;\n      esac\n      if [ \"$parallel_probe_stage0\" != \"\" ]; then\n        run_required_timeout \"backend.selfhost_parallel_perf\" \"$parallel_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELFHOST_PARALLEL_PERF_TIMEOUT=\"$parallel_probe_timeout\" SELFHOST_PARALLEL_PERF_STAGE0=\"$parallel_probe_stage0\" SELFHOST_PARALLEL_PERF_BASE_SESSION=\"$parallel_probe_session\" SELFHOST_PARALLEL_PERF_MAX_SLOWDOWN_SEC=\"$parallel_max_slowdown\" SELFHOST_PARALLEL_PERF_SKIP_SMOKE=\"$strict_probe_skip_smoke\" SELFHOST_PARALLEL_PERF_REQUIRE_RUNNABLE=\"$strict_probe_require_runnable\" SELFHOST_PARALLEL_PERF_VALIDATE=\"$strict_probe_validate\" SELFHOST_PARALLEL_PERF_SKIP_SEM=1 SELFHOST_PARALLEL_PERF_SKIP_OWNERSHIP=1 SELFHOST_PARALLEL_PERF_SKIP_CPROFILE=1 SELFHOST_PARALLEL_PERF_GENERIC_MODE=dict SELFHOST_PARALLEL_PERF_GENERIC_SPEC_BUDGET=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_parallel_perf\"\n      else\n        run_required_timeout \"backend.selfhost_parallel_perf\" \"$parallel_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 SELFHOST_PARALLEL_PERF_TIMEOUT=\"$parallel_probe_timeout\" SELFHOST_PARALLEL_PERF_BASE_SESSION=\"$parallel_probe_session\" SELFHOST_PARALLEL_PERF_MAX_SLOWDOWN_SEC=\"$parallel_max_slowdown\" SELFHOST_PARALLEL_PERF_SKIP_SMOKE=\"$strict_probe_skip_smoke\" SELFHOST_PARALLEL_PERF_REQUIRE_RUNNABLE=\"$strict_probe_require_runnable\" SELFHOST_PARALLEL_PERF_VALIDATE=\"$str"
        out = out + "ict_probe_validate\" SELFHOST_PARALLEL_PERF_SKIP_SEM=1 SELFHOST_PARALLEL_PERF_SKIP_OWNERSHIP=1 SELFHOST_PARALLEL_PERF_SKIP_CPROFILE=1 SELFHOST_PARALLEL_PERF_GENERIC_MODE=dict SELFHOST_PARALLEL_PERF_GENERIC_SPEC_BUDGET=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_parallel_perf\"\n      fi\n    fi\n  fi\nfi\n\nif [ \"$run_driver_selfbuild_smoke\" = \"1\" ]; then\n  driver_selfbuild_stage0=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_STAGE0:-}\"\n  if [ \"$driver_selfbuild_stage0\" = \"\" ]; then\n    driver_selfbuild_stage0=\"$selfhost_stage0\"\n  fi\n  if [ \"$driver_selfbuild_stage0\" = \"\" ] && [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n    driver_selfbuild_stage0=\"${BACKEND_DRIVER}\"\n  fi\n  driver_selfbuild_session_base=\"${BACKEND_PROD_SELFHOST_STRICT_NOREUSE_SESSION:-${BACKEND_PROD_SELFHOST_STRICT_SESSION:-$selfhost_session}}\"\n  driver_selfbuild_session=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_SESSION:-${driver_selfbuild_session_base}.driver_selfbuild}\"\n  driver_selfbuild_session_safe=\"$(printf '%s' \"$driver_selfbuild_session\" | tr -c 'A-Za-z0-9._-' '_')\"\n  driver_selfbuild_report=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_REPORT:-artifacts/backend_driver_selfbuild_smoke/selfbuild_smoke_${driver_selfbuild_session_safe}.tsv}\"\n  driver_selfbuild_output=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_OUTPUT:-artifacts/backend_driver/cheng}\"\n  driver_selfbuild_require_rebuild=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_REQUIRE_REBUILD:-0}\"\n  driver_selfbuild_max_sta"
        out = out + "ge0_attempts=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MAX_STAGE0_ATTEMPTS:-1}\"\n  driver_selfbuild_multi=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MULTI:-0}\"\n  driver_selfbuild_multi_force=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_MULTI_FORCE:-0}\"\n  driver_selfbuild_incremental=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_INCREMENTAL:-1}\"\n  driver_selfbuild_jobs=\"${BACKEND_PROD_DRIVER_SELFBUILD_SMOKE_JOBS:-0}\"\n  if [ \"$driver_selfbuild_stage0\" != \"\" ]; then\n    run_required_timeout \"backend.driver_selfbuild_smoke\" \"$driver_selfbuild_smoke_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 DRIVER_SELFBUILD_SMOKE_SKIP_SEM=0 DRIVER_SELFBUILD_SMOKE_SKIP_OWNERSHIP=0 DRIVER_SELFBUILD_SMOKE_STAGE0=\"$driver_selfbuild_stage0\" DRIVER_SELFBUILD_SMOKE_TIMEOUT=\"$driver_selfbuild_smoke_build_timeout\" DRIVER_SELFBUILD_SMOKE_MAX_RSS_MB=\"$driver_selfbuild_smoke_max_rss_mb\" DRIVER_SELFBUILD_SMOKE_REPORT=\"$driver_selfbuild_report\" DRIVER_SELFBUILD_SMOKE_OUTPUT=\"$driver_selfbuild_output\" DRIVER_SELFBUILD_SMOKE_REQUIRE_REBUILD=\"$driver_selfbuild_require_rebuild\" DRIVER_SELFBUILD_SMOKE_MAX_STAGE0_ATTEMPTS=\"$driver_selfbuild_max_stage0_attempts\" DRIVER_SELFBUILD_SMOKE_MULTI=\"$driver_selfbuild_multi\" DRIVER_SELFBUILD_SMOKE_MULTI_FORCE=\"$driver_selfbuild_multi_force\" DRIVER_SELFBUILD_SMOKE_INCREMENTAL=\"$driver_selfbuild_incremental\" DRIVER_SELFBUILD_SMOKE_JOBS=\"$driver_selfbuild_jobs\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dr"
        out = out + "iver_selfbuild_smoke\"\n  else\n    run_required_timeout \"backend.driver_selfbuild_smoke\" \"$driver_selfbuild_smoke_gate_timeout\" env STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 DRIVER_SELFBUILD_SMOKE_SKIP_SEM=0 DRIVER_SELFBUILD_SMOKE_SKIP_OWNERSHIP=0 DRIVER_SELFBUILD_SMOKE_TIMEOUT=\"$driver_selfbuild_smoke_build_timeout\" DRIVER_SELFBUILD_SMOKE_MAX_RSS_MB=\"$driver_selfbuild_smoke_max_rss_mb\" DRIVER_SELFBUILD_SMOKE_REPORT=\"$driver_selfbuild_report\" DRIVER_SELFBUILD_SMOKE_OUTPUT=\"$driver_selfbuild_output\" DRIVER_SELFBUILD_SMOKE_REQUIRE_REBUILD=\"$driver_selfbuild_require_rebuild\" DRIVER_SELFBUILD_SMOKE_MAX_STAGE0_ATTEMPTS=\"$driver_selfbuild_max_stage0_attempts\" DRIVER_SELFBUILD_SMOKE_MULTI=\"$driver_selfbuild_multi\" DRIVER_SELFBUILD_SMOKE_MULTI_FORCE=\"$driver_selfbuild_multi_force\" DRIVER_SELFBUILD_SMOKE_INCREMENTAL=\"$driver_selfbuild_incremental\" DRIVER_SELFBUILD_SMOKE_JOBS=\"$driver_selfbuild_jobs\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_driver_selfbuild_smoke\"\n  fi\nfi\n\nif [ \"$run_selfhost\" != \"\" ] && [ \"$run_selfhost_perf\" = \"1\" ]; then\n  selfhost_perf_session=\"$selfhost_session\"\n  if [ \"$selfhost_mode\" = \"fast\" ] && [ \"$run_selfhost_strict\" = \"1\" ]; then\n    case \"$selfhost_perf_use_strict_session\" in\n      1|true|TRUE|yes|YES|on|ON)\n        selfhost_perf_session=\"${BACKEND_PROD_SELFHOST_STRICT_SESSION:-$selfhost_session}\"\n        ;;\n    esac\n  fi\n  run_required \"backend.selfhost_perf_r"
        out = out + "egression\" env \\\n    SELFHOST_PERF_SESSION=\"$selfhost_perf_session\" \\\n    SELFHOST_PERF_AUTO_BUILD=0 \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_perf_regression\"\nfi\n\nif [ \"$run_selfhost\" != \"\" ] && [ \"$run_selfhost_100ms\" = \"1\" ]; then\n  run_required \"backend.selfhost_100ms_host\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_100ms_host\"\nfi\n\nresolve_main_driver_fallback() {\n  for cand in \\\n    \"$root/artifacts/backend_driver/cheng\" \\\n    \"$root/artifacts/backend_seed/cheng.stage2\" \\\n    \"$root/dist/releases/current/cheng\" \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n    \"$root/artifacts/backend_selfhost_self_obj/cheng.stage1\"; do\n    if [ -x \"$cand\" ] && driver_help_ok \"$cand\" && driver_stage1_compile_ok \"$cand\"; then\n      printf \"%s\\n\" \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nresolve_main_driver_auto() {\n  if [ ! -x \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_driver_path\" ]; then\n    resolve_main_driver_fallback\n    return $?\n  fi\n  set +e\n  resolved=\"$(env \\\n    BACKEND_DRIVER_PATH_ALLOW_SELFHOST=0 \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_driver_path\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ] && [ \"$resolved\" != \"\" ] && driver_help_ok \"$resolved\" && driver_stage1_compile_ok \"$resolved\"; then\n    printf \"%s\\"
        out = out + "n\" \"$resolved\"\n    return 0\n  fi\n  resolve_main_driver_fallback\n}\n\nif [ \"${BACKEND_DRIVER:-}\" = \"\" ]; then\n  set +e\n  main_driver_auto=\"$(resolve_main_driver_auto)\"\n  main_driver_status=\"$?\"\n  set -e\n  if [ \"$main_driver_status\" -eq 0 ] && [ \"$main_driver_auto\" != \"\" ]; then\n    export BACKEND_DRIVER=\"$main_driver_auto\"\n  else\n    export BACKEND_DRIVER=\"\"\n  fi\nfi\necho \"[backend_prod_closure] main gates driver: ${BACKEND_DRIVER}\" 1>&2\nif ! driver_runnable \"${BACKEND_DRIVER:-}\" || ! driver_stage1_compile_ok \"${BACKEND_DRIVER:-}\"; then\n  echo \"[backend_prod_closure] selected main driver failed health probe: ${BACKEND_DRIVER:-<empty>}\" 1>&2\n  exit 1\nfi\n\n# Main driver has been validated above; avoid repeated stage1 smoke in each gate.\nif [ \"${BACKEND_DRIVER_PATH_STAGE1_STRICT_SMOKE:-}\" = \"\" ]; then\n  export BACKEND_DRIVER_PATH_STAGE1_STRICT_SMOKE=0\nfi\n\nopt_gate_driver=\"${BACKEND_OPT_DRIVER:-}\"\nopt_gate_driver_env=\"\"\nif [ \"$opt_gate_driver\" != \"\" ]; then\n  if [ ! -x \"$opt_gate_driver\" ]; then\n    echo \"[backend_prod_closure] opt gate driver missing: $opt_gate_driver\" 1>&2\n    exit 1\n  fi\n  if ! driver_help_ok \"$opt_gate_driver\"; then\n    echo \"[backend_prod_closure] opt gate driver failed health probe: $opt_gate_driver\" 1>&2\n    exit 1\n  fi\n  opt_gate_driver_env=\"BACKEND_DRIVER=$opt_gate_driver\"\n  echo \"[backend_prod_closure] opt gates driver: $opt_gate_driver\" 1>&2\nfi\n\nclosedloop_fullsp"
        out = out + "ec=\"${BACKEND_RUN_FULLSPEC:-1}\"\nclosedloop_timeout=\"$selfhost_gate_timeout\"\nif [ \"$closedloop_fullspec\" = \"1\" ]; then\n  closedloop_timeout=\"${BACKEND_PROD_CLOSEDLOOP_TIMEOUT:-180}\"\nfi\n\n# normalize UIR iteration knobs for a stable and bounded closure profile\nuir_opt2_iters=\"$(prod_closure_normalize_int \"$uir_opt2_iters\" 5 1 32)\"\nuir_opt3_iters=\"$(prod_closure_normalize_int \"$uir_opt3_iters\" 4 1 32)\"\nuir_opt3_cleanup_iters=\"$(prod_closure_normalize_int \"$uir_opt3_cleanup_iters\" 3 1 32)\"\nuir_cfg_canon_iters=\"$(prod_closure_normalize_int \"$uir_cfg_canon_iters\" 1 1 16)\"\nuir_aggressive_iters=\"$(prod_closure_normalize_int \"$uir_aggressive_iters\" 2 1 16)\"\nuir_inline_iters=\"$(prod_closure_normalize_int \"$uir_inline_iters\" 4 1 16)\"\nuir_simd_max_width=\"$(prod_closure_normalize_int \"$uir_simd_max_width\" 0 0 256)\"\nif [ \"$uir_simd\" = \"auto\" ]; then\n  if [ \"$run_opt3\" != \"\" ]; then\n    uir_simd=\"1\"\n  else\n    uir_simd=\"0\"\n  fi\nfi\ncase \"$uir_simd\" in\n  0|1) ;;\n  *)\n    echo \"[backend_prod_closure] invalid SIMD toggle (expected auto|0|1): $uir_simd\" 1>&2\n    exit 2\n    ;;\nesac\n\nif [ \"$prod_target\" = \"\" ]; then\n  ambient_target=\"${BACKEND_TARGET:-}\"\n  case \"$ambient_target\" in\n    \"\"|arm64-apple-darwin|x86_64-apple-darwin)\n      if [ \"$ambient_target\" = \"\" ]; then\n        prod_target=\"arm64-apple-darwin\"\n      else\n        prod_target=\"$ambient_target\"\n      fi\n      ;;\n    *)\n      "
        out = out + "prod_target=\"arm64-apple-darwin\"\n      echo \"[backend_prod_closure] info: ignore ambient BACKEND_TARGET=$ambient_target for opt/exe gates; use $prod_target (set BACKEND_PROD_TARGET to override)\" 1>&2\n      ;;\n  esac\nfi\n\nif [ \"${BACKEND_LINKER_ABI_CORE_ALLOW_SKIP:-0}\" = \"1\" ]; then\n  echo \"[backend_prod_closure] BACKEND_LINKER_ABI_CORE_ALLOW_SKIP=1 is no longer supported\" 1>&2\n  exit 2\nfi\n\nif [ \"$validate\" != \"\" ]; then\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nelse\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nfi\nlinker_abi_core_driver=\"${BACKEND_LINKER_ABI_CORE_DRIVER:-}\"\nif [ \"$linker_abi_core_driver\" = \"\" ]; then\n  for cand in \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_driver/cheng\"; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -x \"$cand\" ];"
        out = out + " then\n      linker_abi_core_driver=\"$cand\"\n      break\n    fi\n  done\nfi\nif [ \"$linker_abi_core_driver\" != \"\" ]; then\n  run_required \"backend.linker_abi_core\" env \\\n    BACKEND_LINKER_ABI_CORE_DRIVER=\"$linker_abi_core_driver\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_linker_abi_core\"\nelse\n  run_required \"backend.linker_abi_core\" env \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_linker_abi_core\"\nfi\nrun_required \"backend.no_legacy_refs\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_no_legacy_refs\"\nrun_required \"backend.zero_script_closure\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_zero_script_closure\"\nrun_required \"backend.profile_schema\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_profile_schema\"\nrun_required \"backend.emit_obj_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_emit_obj_contract\"\nrun_required \"tooling.cmdline_runner\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_tooling_cmdline\"\nimport_cycle_gate_driver=\"${BACKEND_IMPORT_CYCLE_DRIVER:-}\"\nif [ \"$import_cycle_gate_driver\" = \"\" ]; then\n  for cand in \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_seed/cheng."
        out = out + "stage2\" \\\n    \"dist/releases/current/cheng\"; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -x \"$cand\" ]; then\n      import_cycle_gate_driver=\"$cand\"\n      break\n    fi\n  done\nfi\nif [ \"$import_cycle_gate_driver\" != \"\" ]; then\n  run_required \"backend.import_cycle_predeclare\" env BACKEND_DRIVER=\"$import_cycle_gate_driver\" BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"\nelse\nrun_required \"backend.import_cycle_predeclare\" env BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"\nfi\nrun_required \"backend.rawptr_hard_gate\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_rawptr_contract\"\nrun_required \"backend.rawptr_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_rawptr_contract\"\nrun_required \"backend.rawptr_surface_forbid\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_rawptr_surface_forbid\"\nrun_required \"backend.rawptr_migration\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_rawptr_migration\"\nrun_required \"backend.ffi_slice_shim\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ffi_slice_shim\"\nrun_required \"backend.ffi_outptr_tuple\" env BACKEND_FFI_OUTPTR_TUPLE_ALLOW_RUN_FAIL=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ffi_outptr_tu"
        out = out + "ple\"\nrun_required \"backend.ffi_handle_sandbox\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ffi_handle_sandbox\"\nrun_required \"backend.ffi_borrow_bridge\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ffi_borrow_bridge\"\nrun_required \"backend.rawptr_closedloop\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_rawptr_closedloop\"\nrun_required \"backend.mem_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mem_contract\"\nrun_required \"backend.dod_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_contract\"\nrun_required \"backend.native_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_native_contract\"\nrun_required \"backend.native_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_native_contract\"\nrun_required \"backend.mem_image_core\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mem_image_core\"\nrun_required \"backend.mem_exe_emit\" env BACKEND_LINKER=self BACKEND_MEM_EXE_EMIT_REQUIRE_DRIVER_SIDECAR_ZERO=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mem_exe_emit\"\nrun_required \"backend.profile_baseline\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_profile_baseline\"\nrun_required \"backend.dual_track\" env -u BACKEND_LINKER -u BACKEND_LINKER \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dual_track\"\nrun_required \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noalias_opt\"\nrun_required \"backend.egraph_cost\" env \\\n  STAGE1_"
        out = out + "SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_egraph_cost\"\nrun_required \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_opt_regression\"\nlinkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"\nif [ \"$linkerless_gate_driver\" != \"\" ]; then\n  if [ ! -x \"$linkerless_gate_driver\" ]; then\n    echo \"[backend_prod_closure] backend.linkerless_dev driver missing: $linkerless_gate_driver\" 1>&2\n    exit 1\n  fi\n  if ! driver_help_ok \"$linkerless_gate_driver\"; then\n    echo \"[backend_prod_closure] backend.linkerless_dev driver failed health probe: $linkerless_gate_driver\" 1>&2\n    exit 1\n  fi\n  run_required \"backend.linkerless_dev\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev BACKEND_DRIVER=\"$linkerless_gate_driver\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_linkerless_dev\"\nelse\n  run_required \"backend.linkerless_dev\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_linkerless_dev\"\nfi\nrun_required \"backend.macho_signature_gate\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_macho_signature_gate\"\nrun_required \"backend.metering_phase_barrier\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_metering_phase_barrier\"\nrun_required \"backend.ast_simhash_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ast_simhash_contract\"\nrun_required \"backend.hotpatch_meta\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_hotpatch_meta\"\nrun_required \"backend.hotpatch_inplace\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_hotpatch_i"
        out = out + "nplace\"\nrun_required \"backend.incr_patch_fastpath\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_incr_patch_fastpath\"\nrun_required \"backend.mem_patch_regression\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mem_patch_regression\"\nrun_required \"backend.hotpatch\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_hotpatch\"\nrun_required \"backend.release_system_link\" env BACKEND_BUILD_TRACK=release BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_release_c_o3_lto\"\nrun_required \"backend.plugin_isolation\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_plugin_isolation\"\nrun_required \"backend.noptr_exemption_scope\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noptr_exemption_scope\"\n# ABI/no-pointer dedicated compile-only gates still exist for legacy obj coverage,\n# but are no longer part of the linkerless production required closure.\n\nif [ \"$run_fullchain\" != \"\" ]; then\n  run_required \"backend.fullchain_bootstrap.obj_only\" env FULLCHAIN_OBJ_ONLY=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_fullchain_bootstrap\"\nfi\n\nif [ \"$run_det_strict\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.determinism_strict\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_determinism_strict\"\n  # shellcheck dis"
        out = out + "able=SC2086\n  run_required \"backend.exe_determinism_strict\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_exe_determinism_strict\"\nfi\n\nif [ \"$run_opt\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.opt\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt\"\nfi\n\nif [ \"$run_opt2\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.opt2\" env \\\n    $opt_gate_driver_env \\\n    BACKEND_TARGET=\"$prod_target\" \\\n    UIR_OPT2_ITERS=\"$uir_opt2_iters\" \\\n    UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n    UIR_SIMD=\"$uir_simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt2\"\n  # shellcheck disable=SC2086\n  run_required \"backend.multi_lto\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_multi_lto\"\n  if [ \"$run_multi_perf\" = \"1\" ]; then\n    # shellcheck disable=SC2086\n    run_required \"backend.multi_perf_regression\" env \\\n      $opt_gate_driver_env \\\n      BACKEND_TARGET=\"$prod_target\" \\\n      MULTI_PERF_TIMEOUT=\"${BACKEND_PROD_MULTI_PERF_TIMEOUT:-$selfhost_gate_timeout}\" \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_multi_perf_regression\"\n  fi\n  if [ \"$run_opt"
        out = out + "3\" != \"\" ]; then\n    # shellcheck disable=SC2086\n    run_required \"backend.opt3\" env \\\n      $opt_gate_driver_env \\\n      BACKEND_TARGET=\"$prod_target\" \\\n      UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n      UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n      UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n      UIR_SIMD=\"$uir_simd\" \\\n      UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n      UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n      UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt3\"\n    # shellcheck disable=SC2086\n    run_required \"backend.simd\" env \\\n      $opt_gate_driver_env \\\n      BACKEND_TARGET=\"$prod_target\" \\\n      UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n      UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n      UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n      UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n      UIR_SIMD=1 \\\n      UIR_SIMD_MAX_WIDTH=\"${BACKEND_PROD_UIR_SIMD_MAX_WIDTH:-16}\" \\\n      UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_simd\"\n    if [ \"$run_uir_aggressive\" = \"1\" ]; then\n      # shellcheck disable=SC2086\n      run_required \"backend.opt3.aggressive\" env \\\n        $opt_gate_driver_env \\\n        BACKEND_TARGET=\"$prod_target\" \\\n        UIR_AGGRESSIVE=1 \\\n        UIR_FULL_ITERS=\"$uir_aggressive_iters\" \\\n        UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n        UIR_OPT3_CLEANUP"
        out = out + "_ITERS=\"$uir_opt3_cleanup_iters\" \\\n        UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n        UIR_SIMD=\"$uir_simd\" \\\n        UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n        UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n        UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n        \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt3\"\n    fi\n  fi\nfi\n\nif [ \"$run_uir_stability\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.uir_stability\" env \\\n    $opt_gate_driver_env \\\n    BACKEND_TARGET=\"$prod_target\" \\\n    UIR_STABILITY_ITERS=\"${BACKEND_PROD_UIR_STABILITY_ITERS:-3}\" \\\n    UIR_OPT2_ITERS=\"$uir_opt2_iters\" \\\n    UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n    UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n    UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n    UIR_SIMD=\"$uir_simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_uir_stability\"\nfi\n\nif [ \"$run_ssa\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.ssa\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ssa\"\nfi\n\nif [ \"$run_ffi\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.ffi_abi\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_ffi_a"
        out = out + "bi\"\nfi\n\nif [ \"$run_self_linker_gates\" != \"1\" ]; then\n  echo \"[backend_prod_closure] BACKEND_RUN_SELF_LINKER_GATES=0 is no longer supported in production closure\" 1>&2\n  exit 2\nfi\nself_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_driver/cheng}\"\nif [ \"$self_linker_gate_driver\" != \"\" ] && [ -x \"$self_linker_gate_driver\" ]; then\n  run_required \"backend.self_linker.elf\" env BACKEND_SELF_LINKER_DRIVER=\"$self_linker_gate_driver\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_self_linker_elf\"\n  run_required \"backend.self_linker.coff\" env BACKEND_SELF_LINKER_DRIVER=\"$self_linker_gate_driver\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_self_linker_coff\"\nelse\n  run_required \"backend.self_linker.elf\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_self_linker_elf\"\n  run_required \"backend.self_linker.coff\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_self_linker_coff\"\nfi\nrun_required \"backend.riscv64_quic_boundary\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_riscv64_quic_boundary\"\nrun_optional \"backend.coff_lld_link\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_coff_lld_link\"\n\nif [ \"$run_exe_det\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.exe_determinism\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_exe_determinism\"\nfi\n\nif [ \"$run_sanitizer\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_optional \"backend.sanitizer\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_san"
        out = out + "itizer\"\nfi\n\nif [ \"$run_debug\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_optional \"backend.debug\" env $opt_gate_driver_env BACKEND_TARGET=\"$prod_target\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_debug\"\nfi\n\nstage2_driver=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\nrelease_driver=\"${BACKEND_RELEASE_DRIVER:-${BACKEND_DRIVER:-}}\"\nif [ \"$release_driver\" = \"\" ] && [ -x \"$stage2_driver\" ]; then\n  release_driver=\"$stage2_driver\"\nfi\nmanifest_args=\"\"\nbundle_args=\"\"\nif [ \"$release_driver\" != \"\" ] && [ -x \"$release_driver\" ]; then\n  manifest_args=\"$manifest_args --driver:$release_driver\"\n  bundle_args=\"$bundle_args --driver:$release_driver\"\nfi\n\nfullchain_bin=\"artifacts/fullchain/bin\"\nfor extra in \"$fullchain_bin/cheng_pkg_source\" \"$fullchain_bin/cheng_pkg\" \"$fullchain_bin/cheng_storage\"; do\n  if [ -f \"$extra\" ]; then\n    bundle_args=\"$bundle_args --extra:$extra\"\n  fi\ndone\nfor extra in \\\n  \"src/tooling/chengb.sh\" \\\n  \"src/tooling/chengc.sh\" \\\n  \"src/tooling/detect_host_target.sh\" \\\n  \"src/tooling/backend_link_env.sh\" \\\n  \"src/tooling/summarize_timeout_diag.sh\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_"
        out = out + "embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/build_backend_profile_schema.sh\" \\\n  \"src/tooling/build_backend_mem_contract.sh\" \\\n  \"src/tooling/build_backend_rawptr_contract.sh\" \\\n  \"src/tooling/build_backend_dod_contract.sh\" \\\n  \"src/tooling/rawptr_migrate_ffi.sh\" \\\n  \"src/tooling/build_backend_profile_baseline.sh\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cleanup_backend_obj_like_artifacts.sh\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/resolve_system_linker.sh\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/"
        out = out + "tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/backend_hotpatch_apply.sh\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/backend_dod_opt_regression_baseline.env\" \\\n  \"src/tooling/backend_dod_soa_baseline.env\" \\\n  \"src/tooling/backend_profile_schema.env\" \\\n  \"src/tooling/backend_mem_contract.env\" \\\n  \"src/tooling/backend_dod_contract.env\" \\\n  \"src/tooling/backend_profile_baseline.env\" \\\n  \"docs/backend-mem-hotpatch-contract.md\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/selfhost_perf_baseline.env\" \\\n  \"src/tooling/selfhost_perf_100ms_host.env\" \\\n  \"src/tooling/multi_perf_baseline.env\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"tests/cheng/backend/fixtures/ffi_importc_slice_seq_i32.cheng\" \\\n  \"tests/cheng/backend/fixtures/ffi_outptr_tuple_importc_pair_i32.cheng\" \\"
        out = out + "\n  \"tests/cheng/backend/fixtures/ffi_outptr_tuple_importc_status_i32_objonly.cheng\" \\\n  \"tests/cheng/backend/fixtures/compile_fail_ffi_outptr_tuple_arity_mismatch.cheng\" \\\n  \"tests/cheng/backend/fixtures/return_forward_decl_call.cheng\" \\\n  \"tests/cheng/backend/fixtures/compile_fail_import_cycle_entry.cheng\" \\\n  \"tests/cheng/backend/fixtures/import_cycle_a.cheng\" \\\n  \"tests/cheng/backend/fixtures/import_cycle_b.cheng\" \\\n  \"tests/cheng/backend/fixtures/compile_fail_ffi_importc_slice_openarray_i32.cheng\" \\\n  \"tests/cheng/backend/fixtures/compile_fail_ffi_slice_user_raw_ptr_surface.cheng\" \\\n  \"tests/cheng/backend/fixtures/hotpatch_slot_v1.cheng\" \\\n  \"tests/cheng/backend/fixtures/hotpatch_slot_v2.cheng\" \\\n  \"tests/cheng/backend/fixtures/hotpatch_slot_v3_overflow.cheng\"; do\n  if [ -f \"$extra\" ]; then\n    bundle_args=\"$bundle_args --extra:$extra\"\n  fi\ndone\n\n# shellcheck disable=SC2086\nrun_required \"backend.release_manifest\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_release_manifest\" --out:\"$manifest\" $manifest_args\nif [ \"$run_bundle\" != \"\" ]; then\n  # shellcheck disable=SC2086\n  run_required \"backend.release_bundle\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_release_bundle\" --out:\"$bundle\" --manifest:\"$manifest\" $bundle_args\n  if [ \"$run_sign\" != \"\" ]; then\n    run_required \"backend.release_sign\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_release_sign\" --manifest:\"$manifest\" --bundle:\"$bundle\"\n    run_requir"
        out = out + "ed \"backend.release_verify\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_release_verify\" --manifest:\"$manifest\" --bundle:\"$bundle\"\n    if [ \"$run_release_rollback_drill\" != \"\" ]; then\n      run_required \"backend.release_rollback_drill\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_release_rollback_drill\" --manifest:\"$manifest\" --bundle:\"$bundle\" --dst:\"${BACKEND_RELEASE_DST:-dist/releases}\"\n    fi\n    if [ \"$run_publish\" != \"\" ]; then\n      run_required \"backend.release_publish\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/backend_release_publish\" --manifest:\"$manifest\" --bundle:\"$bundle\" --dst:\"${BACKEND_RELEASE_DST:-dist/releases}\"\n    fi\n  fi\nfi\nif [ \"$run_stress\" != \"\" ]; then\n  run_required \"backend.stress\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_stress\"\n  run_required \"backend.concurrency_stress\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_concurrency_stress\"\nfi\nif [ \"$run_mm\" != \"\" ]; then\n  mm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"\n  if [ \"$mm_gate_driver\" != \"\" ]; then\n    if [ ! -x \"$mm_gate_driver\" ]; then\n      echo \"[backend_prod_closure] backend.mm driver missing: $mm_gate_driver\" 1>&2\n      exit 1\n    fi\n    if ! driver_help_ok \"$mm_gate_driver\"; then\n      echo \"[backend_prod_closure] backend.mm driver failed health probe: $mm_gate_driver\" 1>&2\n      exit 1\n    fi\n    run_required \"backend.mm\" env \\\n      BACKEND_DRIVER=\"$mm_gate_driver\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  "
        out = out + "    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"\n  else\n    run_required \"backend.mm\" env \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"\n  fi\nfi\n\nrun_required \"backend.no_obj_cleanup\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/cleanup_backend_obj_like_artifacts\"\nrun_required \"backend.no_obj_artifacts\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_no_obj_artifacts\"\n\nprint_timing_summary\necho \"backend_prod_closure ok\"\n"
        return out
    if id == "backend_prod_publish":
        return "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_prod_publish.sh [--dst:<dir>] [backend_prod_closure_args...]\n\nNotes:\n  - Runs backend production closure and publishes the signed release into dist/.\n  - Pass-through args are forwarded to backend_prod_closure.sh (e.g. --no-android-run, etc).\nEOF\n}\n\ndst=\"dist/releases\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --dst:*)\n      dst=\"${1#--dst:}\"\n      shift || true\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      break\n      ;;\n  esac\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure \"$@\"\n\nmanifest=\"artifacts/backend_prod/release_manifest.json\"\nbundle=\"artifacts/backend_prod/backend_release.tar.gz\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_publish --manifest:\"$manifest\" --bundle:\"$bundle\" --dst:\"$dst\"\n\necho \"backend_prod_publish ok\"\n"
    if id == "backend_release_bundle":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  src/tooling/backend_release_bundle.sh [--out:<path>] [--name:<binName>] [--manifest:<path>]\n                                       [--driver:<path>] [--extra:<path> ...]\n\nNotes:\n  - Creates a minimal release bundle (tar.gz).\n  - Bundle includes: backend driver + release manifest + optional extras + sha256sum file (if available).\n  - By default it bundles ./<binName> built via build_backend_driver.sh.\n  - Use --driver:<path> to bundle a self-hosted stage2 driver (or any custom driver binary).\n  - Uses SOURCE_DATE_EPOCH (or git commit timestamp) to stabilize bundle mtimes when possible.\nUSAGE\n}\n\nout=\"artifacts/backend_prod/backend_release.tar.gz\"\nname=\"cheng\"\nmanifest=\"artifacts/backend_prod/release_manifest.json\"\ndriver=\"\"\nextras=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --driver:*)\n      driver=\"${1#--driver:}\"\n      ;;\n    --extra:*)\n      extras=\"$extras\\n${1#--extra:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nresolve_path() {\n  p=\"$1\"\n  case \"$"
        out = out + "p\" in\n    /*) printf '%s\\n' \"$p\" ;;\n    *) printf '%s\\n' \"$root/$p\" ;;\n  esac\n}\n\n# Determine which driver binary to bundle.\ndriver_path=\"$driver\"\nif [ \"$driver_path\" = \"\" ]; then\n  if [ ! -x \"./$name\" ]; then\n    src/tooling/build_backend_driver.sh --name:\"$name\" >/dev/null\n  fi\n  driver_path=\"./$name\"\nfi\n\nif [ ! -f \"$manifest\" ]; then\n  echo \"[Error] missing manifest: $manifest\" 1>&2\n  exit 2\nfi\n\nbundle_dir=\"$(dirname \"$out\")/bundle_tmp\"\nrm -rf \"$bundle_dir\"\nmkdir -p \"$bundle_dir\"\n\ncp \"$(resolve_path \"$driver_path\")\" \"$bundle_dir/$name\"\ncp \"$manifest\" \"$bundle_dir/$(basename \"$manifest\")\"\n\nextra_files=\"\"\nif [ \"$extras\" != \"\" ]; then\n  printf '%b\\n' \"$extras\" | while IFS= read -r p; do\n    if [ \"$p\" = \"\" ]; then\n      continue\n    fi\n    srcp=\"$(resolve_path \"$p\")\"\n    if [ ! -f \"$srcp\" ]; then\n      echo \"[Error] extra not found: $p\" 1>&2\n      exit 1\n    fi\n    base=\"$(basename \"$srcp\")\"\n    cp \"$srcp\" \"$bundle_dir/$base\"\n    printf '%s\\n' \"$base\"\n  done >\"$bundle_dir/.extras.list\"\n  if [ -s \"$bundle_dir/.extras.list\" ]; then\n    extra_files=\"$(tr '\\n' ' ' <\"$bundle_dir/.extras.list\" | tr -s ' ' | sed -E 's/[[:space:]]+$//' || true)\"\n  fi\nfi\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{pr"
        out = out + "int $1}'\n    return\n  fi\n  echo \"\"\n}\n\nsha_out=\"$bundle_dir/sha256sum.txt\"\nrm -f \"$sha_out\"\nsha_any=\"0\"\n\nemit_sha() {\n  f=\"$1\"\n  sha=\"$(sha256_file \"$bundle_dir/$f\")\"\n  if [ \"$sha\" != \"\" ]; then\n    printf '%s  %s\\n' \"$sha\" \"$f\" >>\"$sha_out\"\n    sha_any=\"1\"\n  fi\n}\n\nemit_sha \"$name\"\nemit_sha \"$(basename \"$manifest\")\"\nif [ \"$extra_files\" != \"\" ]; then\n  for f in $extra_files; do\n    emit_sha \"$f\"\n  done\nfi\n\nif [ \"$sha_any\" != \"1\" ]; then\n  rm -f \"$sha_out\"\nfi\n\nout_dir=\"$(dirname \"$out\")\"\nmkdir -p \"$out_dir\"\n\n# Stabilize mtimes inside the bundle when possible (for reproducible tarballs).\nbundle_epoch=\"${SOURCE_DATE_EPOCH:-}\"\nif [ \"$bundle_epoch\" = \"\" ] && command -v git >/dev/null 2>&1; then\n  bundle_epoch=\"$(git log -1 --format=%ct 2>/dev/null || echo \"\")\"\nfi\nif [ \"$bundle_epoch\" != \"\" ] && command -v python3 >/dev/null 2>&1; then\n  python3 - \"$bundle_dir\" \"$bundle_epoch\" <<'PY'\nimport os, sys\nroot = sys.argv[1]\ntry:\n    epoch = int(sys.argv[2])\nexcept Exception:\n    epoch = 0\nfor base, dirs, files in os.walk(root):\n    for n in dirs + files:\n        p = os.path.join(base, n)\n        try:\n            os.utime(p, (epoch, epoch), follow_symlinks=False)\n        except Exception:\n            pass\nPY\nfi\n\n# Create tarball with deterministic ordering + no gzip timestamps (best-effort).\ntmp_tar=\"$out_dir/backend_release.tar\"\nrm -f \"$tmp_tar\" \"$tmp_tar.gz\""
        out = out + " \"$out\" 2>/dev/null || true\n\nfiles=\"$name $(basename \"$manifest\")\"\nif [ \"$extra_files\" != \"\" ]; then\n  files=\"$files $extra_files\"\nfi\nif [ -f \"$bundle_dir/sha256sum.txt\" ]; then\n  files=\"$files sha256sum.txt\"\nfi\n\nCOPYFILE_DISABLE=1 tar -cf \"$tmp_tar\" -C \"$bundle_dir\" $files\nif command -v gzip >/dev/null 2>&1; then\n  gzip -n -f \"$tmp_tar\"\n  mv \"$tmp_tar.gz\" \"$out\"\nelse\n  tar -czf \"$out\" -C \"$bundle_dir\" .\nfi\nrm -rf \"$bundle_dir\"\n\necho \"backend release bundle ok: $out\"\n"
        return out
    if id == "backend_release_manifest":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  src/tooling/backend_release_manifest.sh [--out:<path>] [--name:<binName>]\n                                         [--driver:<path>]\n\nNotes:\n  - Emits a backend release manifest (JSON).\n  - By default it builds ./<binName> via build_backend_driver.sh.\n  - Use --driver:<path> to record the SHA of a self-hosted stage2 driver (or any custom driver binary).\n  - Uses SOURCE_DATE_EPOCH when provided for build_id; otherwise uses the latest git commit timestamp.\nUSAGE\n}\n\nout=\"artifacts/backend_prod/release_manifest.json\"\nname=\"cheng\"\ndriver=\"\"\nbackend_ir_version=\"${BACKEND_IR_VERSION:-uir-v1}\"\nbackend_abi_version=\"${BACKEND_ABI_VERSION:-v2_noptr-aarch64}\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --driver:*)\n      driver=\"${1#--driver:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nresolve_p"
        out = out + "ath() {\n  p=\"$1\"\n  case \"$p\" in\n    /*) printf '%s\\n' \"$p\" ;;\n    *) printf '%s\\n' \"$root/$p\" ;;\n  esac\n}\n\n# Determine which driver binary to hash.\ndriver_path=\"$driver\"\nif [ \"$driver_path\" = \"\" ]; then\n  src/tooling/build_backend_driver.sh --name:\"$name\" >/dev/null\n  driver_path=\"./$name\"\nfi\n\ndriver_abs=\"$(resolve_path \"$driver_path\")\"\ndriver_sha=\"\"\nif [ -f \"$driver_abs\" ]; then\n  driver_sha=\"$(sha256_file \"$driver_abs\")\"\nfi\n\nbuild_id=\"\"\nbuild_epoch=\"${SOURCE_DATE_EPOCH:-}\"\nif [ \"$build_epoch\" = \"\" ] && command -v git >/dev/null 2>&1; then\n  build_epoch=\"$(git log -1 --format=%ct 2>/dev/null || echo \"\")\"\nfi\nif [ \"$build_epoch\" != \"\" ]; then\n  if command -v python3 >/dev/null 2>&1; then\n    build_id=\"$(python3 - \"$build_epoch\" <<'PY'\nimport datetime, sys\ntry:\n    epoch = int(sys.argv[1])\nexcept Exception:\n    epoch = 0\nprint(datetime.datetime.fromtimestamp(epoch, tz=datetime.timezone.utc).strftime('%Y-%m-%dT%H:%M:%SZ'))\nPY\n)\"\n  elif command -v date >/dev/null 2>&1; then\n    build_id=\"$(date -u -r \"$build_epoch\" +\"%Y-%m-%dT%H:%M:%SZ\" 2>/dev/null || date -u -d \"@$build_epoch\" +\"%Y-%m-%dT%H:%M:%SZ\" 2>/dev/null || echo \"\")\"\n  fi\nfi\nif [ \"$build_id\" = \"\" ] && command -v date >/dev/null 2>&1; then\n  build_id=\"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\" 2>/dev/null || echo \"\")\"\nfi\nif [ \"$build_id\" = \"\" ]; then\n  build_id=\"unknown\"\nfi\n\ngit_rev=\"unknown\"\ngit_dirty=\"u"
        out = out + "nknown\"\nif command -v git >/dev/null 2>&1; then\n  git_rev=\"$(git rev-parse --short HEAD 2>/dev/null || echo unknown)\"\n  if git diff --quiet --ignore-submodules -- 2>/dev/null; then\n    git_dirty=\"false\"\n  else\n    git_dirty=\"true\"\n  fi\nfi\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\ncc_path=\"$(command -v cc 2>/dev/null || echo cc)\"\ncc_version=\"$(\"$cc_path\" --version 2>/dev/null | head -n 1 | tr -d '\\r' || echo unknown)\"\n\nout_dir=\"$(dirname \"$out\")\"\nmkdir -p \"$out_dir\"\n\ncat >\"$out\" <<EOF_JSON\n{\n  \"build_id\": \"$build_id\",\n  \"git_rev\": \"$git_rev\",\n  \"git_dirty\": \"$git_dirty\",\n  \"host_os\": \"$host_os\",\n  \"host_arch\": \"$host_arch\",\n  \"cc_path\": \"$cc_path\",\n  \"cc_version\": \"$cc_version\",\n  \"backend_ir_version\": \"$backend_ir_version\",\n  \"backend_abi_version\": \"$backend_abi_version\",\n  \"backend_driver\": \"$name\",\n  \"backend_driver_sha256\": \"$driver_sha\"\n}\nEOF_JSON\n\necho \"backend release manifest ok: $out\"\n"
        return out
    if id == "backend_release_publish":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_release_publish.sh --manifest:<path> --bundle:<path>\n                                        [--out-dir:<path>] [--dst:<dir>]\n\nNotes:\n  - Publishes a signed release into dist/ for local \"current/rollback\" workflows.\n  - Expects signature + sha files to exist in --out-dir (defaults to dirname(manifest)).\n  - Writes:\n      <dst>/<release_id>/{release_manifest.json, backend_release.tar.gz, *.sig, *.sha256, signing_ed25519_pub.pem, ...bundle files...}\n      <dst>/current -> <release_id>\n      <dst>/current_id.txt\nEOF\n}\n\nmanifest=\"\"\nbundle=\"\"\nout_dir=\"\"\ndst=\"dist/releases\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --bundle:*)\n      bundle=\"${1#--bundle:}\"\n      ;;\n    --out-dir:*)\n      out_dir=\"${1#--out-dir:}\"\n      ;;\n    --dst:*)\n      dst=\"${1#--dst:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$manifest\" = \"\" ] || [ \"$bundle\" = \"\" ]; then\n  echo \"[Error] missing --manifest/--bundle\" 1>&2\n  usage\n  exit 2\nfi\nif [ ! -f \"$manifest\" ]; then\n  echo \"[Error] manifest not found: $manifest\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$bundle\" ]; then\n  echo \"[Error] bundle not found: $bundle\" 1>&2\n  exit 2"
        out = out + "\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"$out_dir\" = \"\" ]; then\n  out_dir=\"$(dirname \"$manifest\")\"\nfi\n\npub_src=\"$out_dir/signing_ed25519_pub.pem\"\npub_base=\"signing_ed25519_pub.pem\"\nalgo_file=\"$out_dir/signing_algo.txt\"\nalgo=\"\"\nif [ -f \"$algo_file\" ]; then\n  algo=\"$(head -n 1 \"$algo_file\" | tr -d '\\r\\n' || true)\"\nfi\nif [ \"$algo\" = \"rsa-sha256\" ]; then\n  pub_src=\"$out_dir/signing_rsa_pub.pem\"\n  pub_base=\"signing_rsa_pub.pem\"\nelse\n  pub_src=\"$out_dir/signing_ed25519_pub.pem\"\n  pub_base=\"signing_ed25519_pub.pem\"\n  if [ ! -f \"$pub_src\" ] && [ -f \"$out_dir/signing_rsa_pub.pem\" ]; then\n    algo=\"rsa-sha256\"\n    pub_src=\"$out_dir/signing_rsa_pub.pem\"\n    pub_base=\"signing_rsa_pub.pem\"\n  fi\nfi\nif [ ! -f \"$pub_src\" ]; then\n  echo \"[Error] missing signing pub key in $out_dir (expected ed25519 or rsa pub)\" 1>&2\n  exit 2\nfi\n\nman_base=\"$(basename \"$manifest\")\"\nbun_base=\"$(basename \"$bundle\")\"\nsig_manifest=\"$out_dir/$man_base.sig\"\nsig_bundle=\"$out_dir/$bun_base.sig\"\nsha_manifest=\"$out_dir/$man_base.sha256\"\nsha_bundle=\"$out_dir/$bun_base.sha256\"\n\nif [ ! -f \"$sig_manifest\" ] || [ ! -f \"$sig_bundle\" ]; then\n  echo \"[Error] missing signatures in $out_dir\" 1>&2\n  exit 2\nfi\n\nrelease_id=\"$(python3 - \"$manifest\" <<'PY'\nimport json, re, sys\npath = sys.argv[1]\nwith open(path, \"r\", encoding=\"utf-8\") as f:\n    m = json.load(f)\n"
        out = out + "build_id = m.get(\"build_id\", \"unknown\")\ngit_rev = m.get(\"git_rev\", \"unknown\")\nrid = f\"{build_id}_{git_rev}\"\nrid = re.sub(r\"[^0-9A-Za-z._-]+\", \"_\", rid)\nrid = rid.strip(\"_\") or \"unknown\"\nprint(rid)\nPY\n)\"\n\ndst_root=\"$dst\"\nmkdir -p \"$dst_root\"\n\ndest=\"$dst_root/$release_id\"\nif [ -e \"$dest\" ]; then\n  n=2\n  while [ -e \"${dest}_$n\" ]; do\n    n=$((n + 1))\n  done\n  dest=\"${dest}_$n\"\nfi\n\nmkdir -p \"$dest\"\ncp \"$manifest\" \"$dest/$man_base\"\ncp \"$bundle\" \"$dest/$bun_base\"\ncp \"$sig_manifest\" \"$dest/$man_base.sig\"\ncp \"$sig_bundle\" \"$dest/$bun_base.sig\"\nif [ -f \"$sha_manifest\" ]; then\n  cp \"$sha_manifest\" \"$dest/$man_base.sha256\"\nfi\nif [ -f \"$sha_bundle\" ]; then\n  cp \"$sha_bundle\" \"$dest/$bun_base.sha256\"\nfi\ncp \"$pub_src\" \"$dest/$pub_base\"\nif [ -f \"$algo_file\" ]; then\n  cp \"$algo_file\" \"$dest/$(basename \"$algo_file\")\"\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_verify \\\n  --manifest:\"$dest/$man_base\" \\\n  --bundle:\"$dest/$bun_base\" \\\n  --out-dir:\"$dest\" \\\n  --pub:\"$dest/$pub_base\"\n\n# Extract the minimal distribution payload in-place so dist/releases/<id>/ can be used directly.\ntar -xzf \"$dest/$bun_base\" -C \"$dest\"\n\nln -sfn \"$(basename \"$dest\")\" \"$dst_root/current\"\nprintf \"%s\\n\" \"$(basename \"$dest\")\" >\"$dst_root/current_id.txt\"\n\necho \"backend release publish ok: $dest\"\n"
        return out
    if id == "backend_release_rollback":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_release_rollback.sh [--to:<release_id>] [--root:<dir>]\n\nNotes:\n  - Switches the current symlink to a previous published release.\n  - Default root is dist/releases.\n  - If --to is omitted, rolls back to the previous release by directory order.\nEOF\n}\n\nto=\"\"\nroot_dir=\"dist/releases\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --to:*)\n      to=\"${1#--to:}\"\n      ;;\n    --root:*)\n      root_dir=\"${1#--root:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ncurrent_link=\"$root_dir/current\"\ncurrent_id_file=\"$root_dir/current_id.txt\"\nreleases_dir=\"$root_dir\"\nif [ ! -d \"$releases_dir\" ]; then\n  echo \"[Error] missing release root: $releases_dir\" 1>&2\n  exit 2\nfi\n\ncurrent_id=\"\"\nif [ -L \"$current_link\" ]; then\n  cur_path=\"$(readlink \"$current_link\" 2>/dev/null || echo \"\")\"\n  current_id=\"$(basename \"$cur_path\")\"\nfi\n\npick_prev() {\n  python3 - \"$1\" \"$2\" <<'PY'\nimport os, sys\nreleases = sys.argv[1]\ncurrent = sys.argv[2]\nitems = []\nfor d in os.listdir(releases):\n    if d in (\"current\", \"releases\"):\n        continue\n    p = os.path.join(releases, d)\n    if os.path.islink(p):\n        conti"
        out = out + "nue\n    if os.path.isdir(p):\n        items.append(d)\nitems.sort()\nif not items:\n    print(\"\")\n    sys.exit(0)\nif current and current in items:\n    idx = items.index(current)\n    if idx > 0:\n        print(items[idx - 1])\n        sys.exit(0)\nprint(items[-1])\nPY\n}\n\nif [ \"$to\" = \"\" ]; then\n  to=\"$(pick_prev \"$releases_dir\" \"$current_id\")\"\nfi\nif [ \"$to\" = \"\" ]; then\n  echo \"[Error] no releases found\" 1>&2\n  exit 2\nfi\n\ntarget=\"$releases_dir/$to\"\nif [ ! -d \"$target\" ]; then\n  echo \"[Error] release not found: $target\" 1>&2\n  exit 2\nfi\n\nln -sfn \"$to\" \"$current_link\"\nprintf \"%s\\n\" \"$to\" >\"$current_id_file\"\n\necho \"backend release rollback ok: $to\"\n"
        return out
    if id == "backend_release_sign":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_release_sign.sh --manifest:<path> --bundle:<path>\n                                     [--out-dir:<path>]\n                                     [--key:<path>] [--pub:<path>]\n\nNotes:\n  - Signs the manifest and bundle via OpenSSL.\n  - Default algorithm is Ed25519; if OpenSSL lacks Ed25519 support, falls back to RSA-SHA256.\n  - If --key/--pub are not provided, uses (or generates):\n      <out-dir>/signing_ed25519_priv.pem + <out-dir>/signing_ed25519_pub.pem\n    or (fallback):\n      <out-dir>/signing_rsa_priv.pem + <out-dir>/signing_rsa_pub.pem\n  - Outputs:\n      <out-dir>/<manifest>.sig + .sha256\n      <out-dir>/<bundle>.sig + .sha256\n  - Writes:\n      <out-dir>/signing_algo.txt (ed25519 | rsa-sha256)\nEOF\n}\n\nmanifest=\"\"\nbundle=\"\"\nout_dir=\"\"\nkey=\"\"\npub=\"\"\nalgo=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --bundle:*)\n      bundle=\"${1#--bundle:}\"\n      ;;\n    --out-dir:*)\n      out_dir=\"${1#--out-dir:}\"\n      ;;\n    --key:*)\n      key=\"${1#--key:}\"\n      ;;\n    --pub:*)\n      pub=\"${1#--pub:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$manifest\" = \"\" ] || [ \"$bundle\" = \"\" ]; then\n  echo \"[Erro"
        out = out + "r] missing --manifest/--bundle\" 1>&2\n  usage\n  exit 2\nfi\nif [ ! -f \"$manifest\" ]; then\n  echo \"[Error] manifest not found: $manifest\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$bundle\" ]; then\n  echo \"[Error] bundle not found: $bundle\" 1>&2\n  exit 2\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v openssl >/dev/null 2>&1; then\n  echo \"backend_release_sign skip: missing openssl\" 1>&2\n  exit 2\nfi\n\nsupports_ed25519() {\n  tmp_key=\"$(mktemp 2>/dev/null || true)\"\n  if [ \"$tmp_key\" = \"\" ]; then\n    return 1\n  fi\n  rm -f \"$tmp_key\" >/dev/null 2>&1 || true\n  tmp_key=\"$(mktemp -t cheng_ed25519_key 2>/dev/null || true)\"\n  if [ \"$tmp_key\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  openssl genpkey -algorithm ed25519 -out \"$tmp_key\" >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_key\" >/dev/null 2>&1 || true\n  [ \"$status\" -eq 0 ]\n}\n\nsupports_ed25519_sign() {\n  tmp_dir=\"$(mktemp -d \"${TMPDIR:-/tmp}/cheng_release_sign.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_dir\" = \"\" ] || [ ! -d \"$tmp_dir\" ]; then\n    return 1\n  fi\n  tmp_key=\"$tmp_dir/ed25519_priv.pem\"\n  tmp_pub=\"$tmp_dir/ed25519_pub.pem\"\n  tmp_msg=\"$tmp_dir/msg.txt\"\n  tmp_sig=\"$tmp_dir/msg.sig\"\n  printf \"cheng-release-sign-smoke\\n\" >\"$tmp_msg\"\n  set +e\n  openssl genpkey -algorithm ed25519 -out \"$tmp_key\" >/dev/null 2>&1\n  s0=$?\n  if [ \"$s0\" -eq 0 ]; then\n    openssl pkey -in \"$tmp_key\" "
        out = out + "-pubout -out \"$tmp_pub\" >/dev/null 2>&1\n    s1=$?\n  else\n    s1=1\n  fi\n  if [ \"$s0\" -eq 0 ] && [ \"$s1\" -eq 0 ]; then\n    openssl pkeyutl -sign -inkey \"$tmp_key\" -in \"$tmp_msg\" -out \"$tmp_sig\" >/dev/null 2>&1\n    s2=$?\n  else\n    s2=1\n  fi\n  if [ \"$s2\" -eq 0 ]; then\n    openssl pkeyutl -verify -pubin -inkey \"$tmp_pub\" -sigfile \"$tmp_sig\" -in \"$tmp_msg\" >/dev/null 2>&1\n    s3=$?\n  else\n    s3=1\n  fi\n  set -e\n  rm -rf \"$tmp_dir\" >/dev/null 2>&1 || true\n  [ \"$s0\" -eq 0 ] && [ \"$s1\" -eq 0 ] && [ \"$s2\" -eq 0 ] && [ \"$s3\" -eq 0 ]\n}\n\nexplicit_sign_material=\"0\"\nif [ \"$key\" != \"\" ] || [ \"$pub\" != \"\" ]; then\n  explicit_sign_material=\"1\"\nfi\n\nif [ \"$out_dir\" = \"\" ]; then\n  out_dir=\"$(dirname \"$manifest\")\"\nfi\nmkdir -p \"$out_dir\"\n\nalgo_file=\"$out_dir/signing_algo.txt\"\nif [ \"$algo\" = \"\" ] && [ -f \"$algo_file\" ]; then\n  algo=\"$(head -n 1 \"$algo_file\" | tr -d '\\r\\n' || true)\"\nfi\ned25519_ready=\"0\"\nif supports_ed25519 && supports_ed25519_sign; then\n  ed25519_ready=\"1\"\nfi\nif [ \"$algo\" = \"\" ]; then\n  if [ \"$ed25519_ready\" = \"1\" ]; then\n    algo=\"ed25519\"\n  else\n    algo=\"rsa-sha256\"\n  fi\nfi\nif [ \"$algo\" = \"ed25519\" ] && [ \"$ed25519_ready\" != \"1\" ]; then\n  if [ \"$explicit_sign_material\" = \"1\" ]; then\n    echo \"[Error] openssl cannot sign Ed25519 on this host (explicit key/pub provided)\" 1>&2\n    exit 1\n  fi\n  echo \"[backend_release_sign] warn: Ed25519 "
        out = out + "sign unsupported on this host, fallback to rsa-sha256\" 1>&2\n  algo=\"rsa-sha256\"\nfi\n\nif [ \"$key\" = \"\" ] && [ \"$pub\" = \"\" ]; then\n  if [ \"$algo\" = \"ed25519\" ]; then\n    key=\"$out_dir/signing_ed25519_priv.pem\"\n    pub=\"$out_dir/signing_ed25519_pub.pem\"\n  else\n    key=\"$out_dir/signing_rsa_priv.pem\"\n    pub=\"$out_dir/signing_rsa_pub.pem\"\n  fi\nfi\n\nif [ ! -f \"$key\" ]; then\n  if [ \"$algo\" = \"ed25519\" ]; then\n    openssl genpkey -algorithm ed25519 -out \"$key\" >/dev/null\n  else\n    openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out \"$key\" >/dev/null\n  fi\n  chmod 600 \"$key\" >/dev/null 2>&1 || true\nfi\nif [ ! -f \"$pub\" ]; then\n  openssl pkey -in \"$key\" -pubout -out \"$pub\" >/dev/null\nfi\nprintf \"%s\\n\" \"$algo\" >\"$algo_file\"\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nman_base=\"$(basename \"$manifest\")\"\nbun_base=\"$(basename \"$bundle\")\"\n\nsig_manifest=\"$out_dir/$man_base.sig\"\nsig_bundle=\"$out_dir/$bun_base.sig\"\nsha_manifest=\"$out_dir/$man_base.sha256\"\nsha_bundle=\"$out_dir/$bun_base.sha256\"\n\nif [ \"$algo\" = \"ed25519\" ]; then\n  set +e\n  openssl pkeyutl -sign -inkey \"$key\" -in \"$manifest\" -out \"$sig_manifest\" >/dev/null 2>&1\n  sign_m_status=$?\n  openssl pkeyutl -sign "
        out = out + "-inkey \"$key\" -in \"$bundle\" -out \"$sig_bundle\" >/dev/null 2>&1\n  sign_b_status=$?\n  set -e\n  if [ \"$sign_m_status\" -ne 0 ] || [ \"$sign_b_status\" -ne 0 ]; then\n    if [ \"$explicit_sign_material\" = \"1\" ]; then\n      echo \"[Error] Ed25519 signing failed with explicit key/pub\" 1>&2\n      exit 1\n    fi\n    echo \"[backend_release_sign] warn: Ed25519 signing failed, fallback to rsa-sha256\" 1>&2\n    algo=\"rsa-sha256\"\n    key=\"$out_dir/signing_rsa_priv.pem\"\n    pub=\"$out_dir/signing_rsa_pub.pem\"\n    if [ ! -f \"$key\" ]; then\n      openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out \"$key\" >/dev/null\n      chmod 600 \"$key\" >/dev/null 2>&1 || true\n    fi\n    if [ ! -f \"$pub\" ]; then\n      openssl pkey -in \"$key\" -pubout -out \"$pub\" >/dev/null\n    fi\n    printf \"%s\\n\" \"$algo\" >\"$algo_file\"\n    openssl dgst -sha256 -sign \"$key\" -out \"$sig_manifest\" \"$manifest\" >/dev/null\n    openssl dgst -sha256 -sign \"$key\" -out \"$sig_bundle\" \"$bundle\" >/dev/null\n  fi\nelse\n  openssl dgst -sha256 -sign \"$key\" -out \"$sig_manifest\" \"$manifest\" >/dev/null\n  openssl dgst -sha256 -sign \"$key\" -out \"$sig_bundle\" \"$bundle\" >/dev/null\nfi\n\nsha_m=\"$(sha256_file \"$manifest\")\"\nsha_b=\"$(sha256_file \"$bundle\")\"\nif [ \"$sha_m\" != \"\" ]; then\n  printf \"%s  %s\\n\" \"$sha_m\" \"$man_base\" >\"$sha_manifest\"\nfi\nif [ \"$sha_b\" != \"\" ]; then\n  printf \"%s  %s\\n\" \"$sha_b\" \"$bun_base\" >\"$sha_b"
        out = out + "undle\"\nfi\n\nif [ \"$algo\" = \"ed25519\" ]; then\n  openssl pkeyutl -verify -pubin -inkey \"$pub\" -sigfile \"$sig_manifest\" -in \"$manifest\" >/dev/null\n  openssl pkeyutl -verify -pubin -inkey \"$pub\" -sigfile \"$sig_bundle\" -in \"$bundle\" >/dev/null\nelse\n  openssl dgst -sha256 -verify \"$pub\" -signature \"$sig_manifest\" \"$manifest\" >/dev/null\n  openssl dgst -sha256 -verify \"$pub\" -signature \"$sig_bundle\" \"$bundle\" >/dev/null\nfi\n\necho \"backend release sign ok: $sig_manifest $sig_bundle (algo=$algo)\"\n"
        return out
    if id == "backend_release_verify":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_release_verify.sh --manifest:<path> --bundle:<path>\n                                       [--out-dir:<path>] [--pub:<path>]\n\nNotes:\n  - Verifies sha256 (if .sha256 files exist) and verifies Ed25519 signatures via OpenSSL.\n  - Defaults:\n      pub = <out-dir>/signing_ed25519_pub.pem (or signing_rsa_pub.pem)\n      sig/sha files are expected in <out-dir> named:\n        <manifest>.sig / <manifest>.sha256\n        <bundle>.sig   / <bundle>.sha256\n  - Algorithm:\n      reads <out-dir>/signing_algo.txt if present (ed25519 | rsa-sha256),\n      otherwise infers from pub key file existence.\nEOF\n}\n\nmanifest=\"\"\nbundle=\"\"\nout_dir=\"\"\npub=\"\"\nalgo=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --bundle:*)\n      bundle=\"${1#--bundle:}\"\n      ;;\n    --out-dir:*)\n      out_dir=\"${1#--out-dir:}\"\n      ;;\n    --pub:*)\n      pub=\"${1#--pub:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$manifest\" = \"\" ] || [ \"$bundle\" = \"\" ]; then\n  echo \"[Error] missing --manifest/--bundle\" 1>&2\n  usage\n  exit 2\nfi\nif [ ! -f \"$manifest\" ]; then\n  echo \"[Error] manifest not found: $manifest\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$bundle\""
        out = out + " ]; then\n  echo \"[Error] bundle not found: $bundle\" 1>&2\n  exit 2\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v openssl >/dev/null 2>&1; then\n  echo \"backend_release_verify skip: missing openssl\" 1>&2\n  exit 2\nfi\n\nif [ \"$out_dir\" = \"\" ]; then\n  out_dir=\"$(dirname \"$manifest\")\"\nfi\nif [ \"$pub\" = \"\" ]; then\n  if [ -f \"$out_dir/signing_algo.txt\" ]; then\n    algo=\"$(head -n 1 \"$out_dir/signing_algo.txt\" | tr -d '\\r\\n' || true)\"\n  fi\n  if [ \"$algo\" = \"rsa-sha256\" ]; then\n    pub=\"$out_dir/signing_rsa_pub.pem\"\n  else\n    pub=\"$out_dir/signing_ed25519_pub.pem\"\n    if [ ! -f \"$pub\" ] && [ -f \"$out_dir/signing_rsa_pub.pem\" ]; then\n      algo=\"rsa-sha256\"\n      pub=\"$out_dir/signing_rsa_pub.pem\"\n    fi\n  fi\nfi\nif [ \"$algo\" = \"\" ] && [ -f \"$out_dir/signing_algo.txt\" ]; then\n  algo=\"$(head -n 1 \"$out_dir/signing_algo.txt\" | tr -d '\\r\\n' || true)\"\nfi\nif [ \"$algo\" = \"\" ]; then\n  algo=\"ed25519\"\nfi\nif [ ! -f \"$pub\" ]; then\n  echo \"[Error] missing pub key: $pub\" 1>&2\n  exit 2\nfi\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nman_base=\"$(basename \"$manifest\")\"\nbun_base=\"$(basename \"$bundle\")\"\n\nsig_manifest=\"$out_dir/$man_base.si"
        out = out + "g\"\nsig_bundle=\"$out_dir/$bun_base.sig\"\nsha_manifest=\"$out_dir/$man_base.sha256\"\nsha_bundle=\"$out_dir/$bun_base.sha256\"\n\nif [ ! -f \"$sig_manifest\" ] || [ ! -f \"$sig_bundle\" ]; then\n  echo \"[Error] missing signature files in $out_dir\" 1>&2\n  exit 2\nfi\n\nif [ -f \"$sha_manifest\" ]; then\n  expect=\"$(awk '{print $1}' \"$sha_manifest\")\"\n  actual=\"$(sha256_file \"$manifest\")\"\n  if [ \"$expect\" != \"\" ] && [ \"$actual\" != \"\" ] && [ \"$expect\" != \"$actual\" ]; then\n    echo \"[Error] manifest sha256 mismatch\" 1>&2\n    exit 1\n  fi\nfi\nif [ -f \"$sha_bundle\" ]; then\n  expect2=\"$(awk '{print $1}' \"$sha_bundle\")\"\n  actual2=\"$(sha256_file \"$bundle\")\"\n  if [ \"$expect2\" != \"\" ] && [ \"$actual2\" != \"\" ] && [ \"$expect2\" != \"$actual2\" ]; then\n    echo \"[Error] bundle sha256 mismatch\" 1>&2\n    exit 1\n  fi\nfi\n\nif [ \"$algo\" = \"rsa-sha256\" ]; then\n  openssl dgst -sha256 -verify \"$pub\" -signature \"$sig_manifest\" \"$manifest\" >/dev/null\n  openssl dgst -sha256 -verify \"$pub\" -signature \"$sig_bundle\" \"$bundle\" >/dev/null\nelse\n  openssl pkeyutl -verify -pubin -inkey \"$pub\" -sigfile \"$sig_manifest\" -in \"$manifest\" >/dev/null\n  openssl pkeyutl -verify -pubin -inkey \"$pub\" -sigfile \"$sig_bundle\" -in \"$bundle\" >/dev/null\nfi\n\necho \"backend release verify ok (algo=$algo)\"\n"
        return out
    if id == "backend_resolve_selflink_runtime_obj":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport TOOLING_EXEC_WRAPPER_CALLER=\"backend_resolve_selflink_runtime_obj\"\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_resolve_selflink_runtime_obj \"$@\"\n"
    if id == "backend_seed_pure":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/backend_seed_pure.sh [--seed:<path>] [--out:<path>]\n\nNotes:\n  - Rebuilds the backend stage2 driver using a prebuilt seed driver (no C backend).\n  - Seed must be an executable backend driver binary (typically a previously published stage2).\n  - The seed is copied into chengcache/ before running so it won't be clobbered.\n  - Output stage2 is produced at: artifacts/backend_selfhost_self_obj/cheng.stage2\n\nExamples:\n  # Use a previously built stage2 as the seed and copy the new seed out:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_seed_pure \\\n    --seed:artifacts/backend_selfhost_self_obj/cheng.stage2 \\\n    --out:artifacts/backend_seed/cheng.stage2\n\n  # Use a custom seed binary:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_seed_pure --seed:/path/to/cheng.stage2\nEOF\n}\n\nseed=\"\"\nout=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --seed:*)\n      seed=\"${1#--seed:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"$seed\" = \"\" ]; then\n  seed=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\nfi"
        out = out + "\n\nif [ ! -x \"$seed\" ]; then\n  echo \"[Error] missing seed driver (expected executable): $seed\" 1>&2\n  echo \"  tip: pass --seed:<path> to a prebuilt stage2 driver\" 1>&2\n  exit 2\nfi\n\nmkdir -p chengcache\nseed_copy=\"chengcache/backend_seed_stage0.$(basename \"$seed\")\"\ncp \"$seed\" \"$seed_copy\"\nchmod +x \"$seed_copy\" 2>/dev/null || true\n\necho \"== backend.seed_pure.bootstrap ==\"\nSELF_OBJ_BOOTSTRAP_STAGE0=\"$seed_copy\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure --only-self-obj-bootstrap\n\nstage2=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\nif [ ! -x \"$stage2\" ]; then\n  echo \"[Error] missing stage2 output: $stage2\" 1>&2\n  exit 1\nfi\n\nstage2_sha=\"\"\nif command -v shasum >/dev/null 2>&1; then\n  stage2_sha=\"$(shasum -a 256 \"$stage2\" | awk '{print $1}')\"\nelif command -v sha256sum >/dev/null 2>&1; then\n  stage2_sha=\"$(sha256sum \"$stage2\" | awk '{print $1}')\"\nfi\n\nif [ \"$out\" != \"\" ]; then\n  out_dir=\"$(dirname \"$out\")\"\n  mkdir -p \"$out_dir\"\n  cp \"$stage2\" \"$out\"\n  if [ -f \"$stage2.o\" ]; then\n    cp \"$stage2.o\" \"$out.o\"\n  fi\nfi\n\necho \"backend_seed_pure ok: stage2=$stage2 sha256=$stage2_sha\"\n\n"
        return out
    if id == "bootstrap":
        return "#!/usr/bin/env sh\n:\nset -eu\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\necho \"[Warn] src/tooling/bootstrap.sh has been migrated to pure obj/exe bootstrap.\" 1>&2\necho \"       forwarding to src/tooling/bootstrap_pure.sh\" 1>&2\n\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} bootstrap_pure \"$@\"\n"
    if id == "bootstrap_pure":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  src/tooling/bootstrap_pure.sh [--fullspec] [--seed:<backend_driver>]\n\nNotes:\n  - Pure backend-only bootstrap: C bootstrap path removed.\n  - Core path runs verify_backend_selfhost_bootstrap_self_obj.sh.\n  - --fullspec additionally runs verify_fullchain_bootstrap.sh (obj-only).\n\nOptions:\n  --fullspec          Run obj-only fullchain verification after selfhost bootstrap.\n  --seed:<path>       Seed backend driver executable path.\n\nEnv:\n  BOOTSTRAP_UPDATE_SEED=1  Copy artifacts/backend_selfhost_self_obj/cheng.stage2\n                                 to artifacts/backend_seed/cheng.stage2.\nUSAGE\n}\n\nfullspec=\"0\"\nseed_override=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    --fullspec)\n      fullspec=\"1\"\n      ;;\n    --seed:*)\n      seed_override=\"${1#--seed:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"$seed_override\" != \"\" ]; then\n  export SELF_OBJ_BOOTSTRAP_STAGE0=\"$seed_override\"\nfi\n\necho \"== bootstrap_pure.selfhost_self_obj ==\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n\nif [ \"$fullspec\" = \"1\" ]; then\n  echo \"== bo"
        out = out + "otstrap_pure.fullchain_obj_only ==\"\n  FULLCHAIN_OBJ_ONLY=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_fullchain_bootstrap\nfi\n\nif [ \"${BOOTSTRAP_UPDATE_SEED:-0}\" = \"1\" ]; then\n  new_seed=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n  if [ ! -x \"$new_seed\" ]; then\n    echo \"[Error] missing refreshed seed stage2: $new_seed\" 1>&2\n    exit 1\n  fi\n  mkdir -p artifacts/backend_seed\n  cp \"$new_seed\" \"artifacts/backend_seed/cheng.stage2\"\n  chmod +x \"artifacts/backend_seed/cheng.stage2\" 2>/dev/null || true\n  echo \"seed updated: artifacts/backend_seed/cheng.stage2\"\nfi\n\necho \"bootstrap_pure ok\"\n"
        return out
    if id == "build_backend_dod_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_dod_contract [--out:<path>] [--doc:<path>]\n\nNotes:\n  - Generates deterministic DOPAR-01 DOD contract baseline.\n  - Default output: src/tooling/backend_dod_contract.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nout=\"src/tooling/backend_dod_contract.env\"\ndoc=\"docs/cheng-plan-full.md\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_dod_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nstage1_ast=\"src/stage1/ast.cheng\"\nuir_types=\"src/backend/uir/uir_internal/uir_core_types.cheng\"\nuir_ssa=\"src/backend/uir/uir_internal/uir_core_ssa.cheng\"\nverify_script=\"src/tooling/cheng_tooling_embedded_inline"
        out = out + ".cheng\"\nverify_dod_soa=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nclosedloop_script=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nprod_closure_script=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nfor required in \\\n  \"$doc\" \\\n  \"$stage1_ast\" \\\n  \"$uir_types\" \\\n  \"$uir_ssa\" \\\n  \"$verify_script\" \\\n  \"$verify_dod_soa\" \\\n  \"$closedloop_script\" \\\n  \"$prod_closure_script\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_dod_contract] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_dod_contract_markers.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_markers\"\n}\ntrap cleanup EXIT\n\n{\n  rg -o \\\n    'DOD-ATOM-0[1-5]|DOPAR-0[1-2]|backend\\.dod_contract|backend\\.dod_soa|SoA|Arena|No-Alias|E-Graph' \\\n    \"$doc\" || true\n  rg -o \\\n    'nodeArena: Node\\[\\]|nodeArenaEnabled: bool = true' \\\n    \"$stage1_ast\" || true\n  rg -o \\\n    'localIndex: int32|slot: int32|frameOff: int32' \\\n    \"$uir_types\" || true\n  rg -o \\\n    'rpoIndex: int32\\[\\]' \\\n    \"$uir_ssa\" || true\n} | LC_ALL=C sort -u >\"$tmp_markers\"\n\nmarker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\nif [ \"$marker_count\" -eq 0 ]; then\n  echo \"[build_backend_dod_contract] no DOD contract markers found\" 1>&2\n  exit 2\nfi\n\nstage1_arena_count=\"$(rg -o 'nodeArena: Node\\[\\]|nodeArenaEnabled: bool = true' \"$stage1_ast\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\nuir"
        out = out + "_index_count=\"$(rg -o 'localIndex: int32|slot: int32|frameOff: int32|rpoIndex: int32\\[\\]' \"$uir_types\" \"$uir_ssa\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\ndoc_sha=\"$(hash_file \"$doc\")\"\nmarker_sha=\"$(hash_file \"$tmp_markers\")\"\nverify_sha=\"$(hash_file \"$verify_script\")\"\nverify_dod_soa_sha=\"$(hash_file \"$verify_dod_soa\")\"\nclosedloop_sha=\"$(hash_file \"$closedloop_script\")\"\nprod_closure_sha=\"$(hash_file \"$prod_closure_script\")\"\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\n{\n  echo \"BACKEND_DOD_CONTRACT_BASELINE_VERSION=1\"\n  echo \"BACKEND_DOD_CONTRACT_DOC=$doc\"\n  echo \"BACKEND_DOD_CONTRACT_DOC_SHA256=$doc_sha\"\n  echo \"BACKEND_DOD_CONTRACT_MARKER_COUNT=$marker_count\"\n  echo \"BACKEND_DOD_CONTRACT_MARKER_SHA256=$marker_sha\"\n  echo \"BACKEND_DOD_CONTRACT_STAGE1_ARENA_MARKER_COUNT=$stage1_arena_count\"\n  echo \"BACKEND_DOD_CONTRACT_UIR_INDEX_MARKER_COUNT=$uir_index_count\"\n  echo \"BACKEND_DOD_CONTRACT_VERIFY_SCRIPT_SHA256=$verify_sha\"\n  echo \"BACKEND_DOD_CONTRACT_VERIFY_DOD_SOA_SHA256=$verify_dod_soa_sha\"\n  echo \"BACKEND_DOD_CONTRACT_CLOSEDLOOP_SHA256=$closedloop_sha\"\n  echo \"BACKEND_DOD_CONTRACT_PROD_CLOSURE_SHA256=$prod_closure_sha\"\n  echo \"BACKEND_DOD_CONTRACT_REQUIRED_GATES=backend.dod_contract,backend.dod_soa\"\n} >\"$out\"\n\necho \"backend dod contract baseline generated: $out\"\n"
        return out
    if id == "build_backend_driver":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  src/tooling/build_backend_driver.sh [--name:<binName>]\n\nBuilds backend driver via stage0 selfhost rebuild:\n  1) rebuild from a stage0 backend driver\n  2) no seed/tar copy path\n\nOutput:\n  <binName> (default: artifacts/backend_driver/cheng)\n\nEnv:\n  BACKEND_BUILD_DRIVER_LINKER=system (default system; accepts self|system)\n  BACKEND_BUILD_DRIVER_SELFHOST=1    (default 1)\n  BACKEND_BUILD_DRIVER_STAGE0=<path> (optional stage driver override)\n  BACKEND_BUILD_DRIVER_MULTI=0       (default 0; serial incremental)\n  BACKEND_BUILD_DRIVER_MULTI_FORCE=0 (default 0)\n  BACKEND_BUILD_DRIVER_INCREMENTAL=1 (default 1)\n  BACKEND_BUILD_DRIVER_JOBS=0        (default 0=auto)\n  BACKEND_BUILD_DRIVER_TIMEOUT=60    (default 60s per compile attempt)\n  BACKEND_BUILD_DRIVER_SMOKE=0       (default 0; set 1 to run stage1 compile smoke)\n  BACKEND_BUILD_DRIVER_REQUIRE_SMOKE=1 (default 1; require smoke for freshly rebuilt driver)\n  BACKEND_BUILD_DRIVER_FRONTEND=stage1 (default stage1; frontend used for backend_driver selfbuild)\n  BACKEND_BUILD_DRIVER_SMOKE_TARGETS=<csv> (default host)\n  BACKEND_BUILD_DRIVER_MAX_STAGE0_ATTEMPTS=3 (default 3; 0=all candidates)\n  BACKEND_BUILD_DRIVER_FORCE=0       (default 0; set 1 to skip reuse and force rebuild)\n  BACKEND_BUILD_DRIVER_NO_RECOVER=0  (default 0; set 1 to fail hard when rebuild fails)\n  BACKEND_IR=uir                     "
        out = out + "(default uir)\n  GENERIC_MODE=dict                  (default dict)\n  GENERIC_SPEC_BUDGET=0              (default 0)\nUSAGE\n}\n\nname=\"${BACKEND_LOCAL_DRIVER_REL:-artifacts/backend_driver/cheng}\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\ntarget=\"\"\ncase \"$host_os/$host_arch\" in\n  Darwin/arm64)\n    target=\"arm64-apple-darwin\"\n    if ! command -v codesign >/dev/null 2>&1; then\n      echo \"[Error] build_backend_driver requires codesign on Darwin/arm64\" 1>&2\n      exit 2\n    fi\n    ;;\n  Linux/aarch64|Linux/arm64)\n    target=\"aarch64-unknown-linux-gnu\"\n    ;;\n  *)\n    echo \"build_backend_driver skip: unsupported host=$host_os/$host_arch\" 1>&2\n    exit 2\n    ;;\nesac\n\nlinker_mode=\"${BACKEND_BUILD_DRIVER_LINKER:-system}\"\ncase \"$linker_mode\" in\n  self|system)\n    ;;\n  *)\n    echo \"[Error] invalid BACKEND_BUILD_DRIVER_LINKER: $linker_mode (expected self|system)\" 1>&2\n    exit 2\n    ;;\nesac\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n   "
        out = out + " my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end = time + 1;\n        while (time < $grace_end) {\n          my $r = waitpid($pid, WNOHANG);\n          if ($r == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndriver_sanity_ok() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  cmd=\"$bin\"\n  case \"$cmd\" in\n    /*|./*|../*) ;;\n    *) cmd=\"./$cmd\" ;;\n  esac\n  set +e\n  run_with_timeout 5 \"$cmd\" --help >/dev/null 2>&1\n  status=$?\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_stage1_smoke_ok() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  smoke_src=\"$root/tests/cheng/"
        out = out + "backend/fixtures/return_add.cheng\"\n  if [ ! -f \"$smoke_src\" ]; then\n    return 0\n  fi\n  smoke_targets=\"${BACKEND_BUILD_DRIVER_SMOKE_TARGETS:-host}\"\n  old_ifs=\"$IFS\"\n  IFS=','\n  for smoke_target in $smoke_targets; do\n    IFS=\"$old_ifs\"\n    case \"$smoke_target\" in\n      \"\"|host|auto)\n        smoke_target=\"$target\"\n        ;;\n    esac\n    safe_target=\"$(printf '%s' \"$smoke_target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n    smoke_out=\"$root/chengcache/.build_backend_driver.stage1_smoke.${safe_target}.bin\"\n    rm -f \"$smoke_out\" \"$smoke_out.tmp\" \"$smoke_out.tmp.linkobj\" \"$smoke_out.o\"\n    rm -rf \"$smoke_out.objs\" \"$smoke_out.objs.lock\"\n    set +e\n    run_with_timeout 40 env \\\n      MM=orc \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      BACKEND_VALIDATE=0 \\\n      STAGE1_SKIP_SEM=1 \\\n      STAGE1_SKIP_CPROFILE=1 \\\n      GENERIC_MODE=dict \\\n      GENERIC_SPEC_BUDGET=0 \\\n      STAGE1_SKIP_OWNERSHIP=1 \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$smoke_target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$smoke_src\" \\\n      BACKEND_OUTPUT=\"$smoke_out\" \\\n      \"$bin\" >/dev/null 2>&1\n    status=$?\n    set -e\n    if [ \"$status\" -ne 0 ] || [ ! -s \"$smoke_out\" ]; then\n      IFS=\"$old_ifs\"\n      return 1\n    fi\n  done\n  IFS=\"$old_ifs\\"
        out = out + "n  return 0\n}\n\nbackend_sources_newer_than() {\n  out=\"$1\"\n  [ -e \"$out\" ] || return 0\n  search_dirs=\"\"\n  for d in src/backend src/stage1 src/std src/core src/system; do\n    if [ -d \"$d\" ]; then\n      search_dirs=\"$search_dirs $d\"\n    fi\n  done\n  if [ \"$search_dirs\" = \"\" ]; then\n    return 1\n  fi\n  # shellcheck disable=SC2086\n  find $search_dirs -type f \\( -name '*.cheng' -o -name '*.c' -o -name '*.h' \\) \\\n    -newer \"$out\" -print -quit | grep -q .\n}\n\nto_abs() {\n  p=\"$1\"\n  case \"$p\" in\n    /*) ;;\n    *) p=\"$root/$p\" ;;\n  esac\n  d=\"$(dirname -- \"$p\")\"\n  b=\"$(basename -- \"$p\")\"\n  if [ -d \"$d\" ]; then\n    d=\"$(CDPATH= cd -- \"$d\" && pwd)\"\n  fi\n  printf \"%s/%s\\n\" \"$d\" \"$b\"\n}\n\nclear_stale_lock_dir() {\n  lock_dir=\"$1\"\n  if [ \"$lock_dir\" = \"\" ] || [ ! -d \"$lock_dir\" ]; then\n    return 0\n  fi\n  owner_file=\"$lock_dir/owner.pid\"\n  if [ -f \"$owner_file\" ]; then\n    owner_pid=\"$(cat \"$owner_file\" 2>/dev/null || true)\"\n    if [ \"$owner_pid\" != \"\" ] && kill -0 \"$owner_pid\" 2>/dev/null; then\n      return 0\n    fi\n  fi\n  rm -rf \"$lock_dir\" 2>/dev/null || true\n  return 0\n}\n\nruntime_obj_has_required_symbols() {\n  obj=\"$1\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  set +e\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ \"$nm_out\" = \"\" ]; then\n  "
        out = out + "  return 1\n  fi\n  case \"$nm_out\" in\n    *\" _reserve_ptr_void\"*|*\" T _reserve_ptr_void\"*|*\" t _reserve_ptr_void\"*)\n      return 0\n      ;;\n  esac\n  return 1\n}\n\nprepare_driver_symbol_bridge_obj() {\n  src=\"$1\"\n  out=\"$2\"\n  if [ ! -f \"$src\" ]; then\n    return 1\n  fi\n  out_dir=\"$(dirname -- \"$out\")\"\n  if [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n    mkdir -p \"$out_dir\"\n  fi\n  if [ ! -f \"$out\" ] || [ \"$src\" -nt \"$out\" ]; then\n    cc_bin=\"${CC:-cc}\"\n    \"$cc_bin\" -std=c11 -O2 -c \"$src\" -o \"$out\" >/dev/null 2>&1 || return 1\n  fi\n  return 0\n}\n\nmkdir -p chengcache\nstage0_candidates_file=\"$root/chengcache/.build_backend_driver.stage0_candidates.$$\"\n: >\"$stage0_candidates_file\"\n\ncleanup_stage0_candidates_file() {\n  rm -f \"$stage0_candidates_file\" 2>/dev/null || true\n}\ntrap cleanup_stage0_candidates_file EXIT INT TERM\n\nappend_stage0_candidate() {\n  cand=\"$1\"\n  if [ \"$cand\" = \"\" ]; then\n    return 0\n  fi\n  abs=\"$(to_abs \"$cand\")\"\n  if ! driver_sanity_ok \"$abs\"; then\n    return 0\n  fi\n  if grep -Fx -- \"$abs\" \"$stage0_candidates_file\" >/dev/null 2>&1; then\n    return 0\n  fi\n  printf '%s\\n' \"$abs\" >>\"$stage0_candidates_file\"\n  return 0\n}\n\nstage0_explicit=\"${BACKEND_BUILD_DRIVER_STAGE0:-}\"\nstage0_strict=\"0\"\nif [ \"$stage0_explicit\" != \"\" ]; then\n  stage0_abs=\"$(to_abs \"$stage0_explicit\")\"\n  if ! driver_sanity_ok \"$stage0_abs\"; then\n    if [ -x \"$stag"
        out = out + "e0_abs\" ]; then\n      echo \"[Error] stage0 driver is not runnable: $stage0_abs\" 1>&2\n    else\n      echo \"[Error] stage0 driver is not executable: $stage0_abs\" 1>&2\n    fi\n    exit 1\n  fi\n  printf '%s\\n' \"$stage0_abs\" >\"$stage0_candidates_file\"\n  stage0_strict=\"1\"\nelse\n  append_stage0_candidate \"${BACKEND_DRIVER:-}\"\n  append_stage0_candidate \"$root/artifacts/backend_seed/cheng.stage2\"\n  append_stage0_candidate \"$root/artifacts/backend_selfhost_self_obj/cheng_stage0_default\"\n  append_stage0_candidate \"$root/artifacts/backend_selfhost_self_obj/cheng_stage0_prod\"\n  append_stage0_candidate \"$root/artifacts/backend_selfhost_self_obj/cheng.stage2\"\n  append_stage0_candidate \"$root/artifacts/backend_selfhost_self_obj/cheng.stage1\"\n  append_stage0_candidate \"$root/artifacts/backend_driver/cheng\"\n  append_stage0_candidate \"$root/dist/releases/current/cheng\"\n  append_stage0_candidate \"$root/cheng\"\nfi\n\nif [ ! -s \"$stage0_candidates_file\" ]; then\n  echo \"[Error] build_backend_driver requires stage0 driver (set BACKEND_BUILD_DRIVER_STAGE0 or BACKEND_DRIVER)\" 1>&2\n  exit 1\nfi\n\nselfhost=\"${BACKEND_BUILD_DRIVER_SELFHOST:-1}\"\nif [ \"$selfhost\" = \"0\" ]; then\n  echo \"[Error] BACKEND_BUILD_DRIVER_SELFHOST=0 is not supported (seed copy path removed)\" 1>&2\n  exit 2\nfi\n\ndriver_multi=\"${BACKEND_BUILD_DRIVER_MULTI:-0}\"\ndriver_multi_force=\"${BACKEND_BUILD_DRIVER_MULTI_FORCE:-0}\"\ndriver_incremental=\"${BACKEND_BUILD_DRIVER_IN"
        out = out + "CREMENTAL:-1}\"\ndriver_jobs=\"${BACKEND_BUILD_DRIVER_JOBS:-0}\"\nbuild_timeout=\"${BACKEND_BUILD_DRIVER_TIMEOUT:-60}\"\ndriver_smoke=\"${BACKEND_BUILD_DRIVER_SMOKE:-0}\"\ndriver_require_smoke=\"${BACKEND_BUILD_DRIVER_REQUIRE_SMOKE:-1}\"\ndriver_frontend=\"${BACKEND_BUILD_DRIVER_FRONTEND:-stage1}\"\nmax_stage0_attempts=\"${BACKEND_BUILD_DRIVER_MAX_STAGE0_ATTEMPTS:-3}\"\nbuild_force=\"${BACKEND_BUILD_DRIVER_FORCE:-0}\"\nbuild_no_recover=\"${BACKEND_BUILD_DRIVER_NO_RECOVER:-0}\"\ncase \"$max_stage0_attempts\" in\n  ''|*[!0-9]*)\n    max_stage0_attempts=3\n    ;;\nesac\nmm=\"${BACKEND_BUILD_DRIVER_MM:-${MM:-orc}}\"\nstage0_compat_allowed=\"${BACKEND_BUILD_DRIVER_STAGE0_COMPAT:-0}\"\nif [ \"$stage0_compat_allowed\" != \"0\" ]; then\n  echo \"[Error] build_backend_driver removed BACKEND_BUILD_DRIVER_STAGE0_COMPAT (only 0 is supported)\" 1>&2\n  exit 2\nfi\nif [ \"${BACKEND_IR:-}\" = \"\" ]; then\n  export BACKEND_IR=uir\nfi\nif [ \"${GENERIC_MODE:-}\" = \"\" ]; then\n  export GENERIC_MODE=dict\nfi\nif [ \"${GENERIC_SPEC_BUDGET:-}\" = \"\" ]; then\n  export GENERIC_SPEC_BUDGET=0\nfi\nif [ \"${STAGE1_SKIP_SEM:-}\" = \"\" ]; then\n  export STAGE1_SKIP_SEM=1\nfi\nif [ \"${STAGE1_SKIP_OWNERSHIP:-}\" = \"\" ]; then\n  export STAGE1_SKIP_OWNERSHIP=1\nfi\nif [ \"${STAGE1_SKIP_CPROFILE:-}\" = \"\" ]; then\n  export STAGE1_SKIP_CPROFILE=1\nfi\n\ncase \"$name\" in\n  /*)\n    name_abs=\"$name\"\n    ;;\n  *)\n    name_abs=\"$root/$name\"\n    ;;\nesac\nname_obj_abs=\"${name_abs}.o\"\nname_di"
        out = out + "r=\"$(dirname \"$name_abs\")\"\nif [ \"$name_dir\" != \"\" ] && [ ! -d \"$name_dir\" ]; then\n  mkdir -p \"$name_dir\"\nfi\ntmp_bin_abs=\"${name_abs}.tmp\"\ntmp_obj_abs=\"${tmp_bin_abs}.o\"\n\nclear_stale_lock_dir \"${name_abs}.objs.lock\"\nclear_stale_lock_dir \"${tmp_bin_abs}.objs.lock\"\n\nif [ \"$build_force\" != \"1\" ] && [ -x \"$name_abs\" ]; then\n  if ! backend_sources_newer_than \"$name_abs\" && driver_sanity_ok \"$name_abs\"; then\n    if [ \"$driver_smoke\" = \"1\" ] && ! driver_stage1_smoke_ok \"$name_abs\"; then\n      :\n    else\n      if [ \"$driver_smoke\" = \"1\" ]; then\n        echo \"build_backend_driver ok (reuse+smoke)\"\n      else\n        echo \"build_backend_driver ok (reuse)\"\n      fi\n      exit 0\n    fi\n  fi\nfi\n\nruntime_src=\"src/std/system_helpers_backend.cheng\"\nruntime_obj=\"chengcache/system_helpers.backend.cheng.${target}.o\"\nruntime_obj_abs=\"$root/$runtime_obj\"\ndriver_symbol_bridge_src=\"$root/src/backend/tooling/backend_driver_symbol_bridge.c\"\ndriver_symbol_bridge_obj_abs=\"$root/chengcache/backend_driver_symbol_bridge.o\"\nlog_root=\"$root/chengcache/build_backend_driver\"\nattempt_report=\"$log_root/attempts.$$.tsv\"\nmodule_cache_path=\"$root/chengcache/build_backend_driver.module_cache.tsv\"\nmkdir -p \"$log_root\"\n: >\"$attempt_report\"\n\ndriver_ldflags_base=\"${BACKEND_BUILD_DRIVER_LDFLAGS:-${BACKEND_LDFLAGS:-}}\"\ndriver_ldflags=\"$driver_ldflags_base\"\nif [ \"$linker_mode\" = \"system\" ]; then\n  if ! prepare_dri"
        out = out + "ver_symbol_bridge_obj \"$driver_symbol_bridge_src\" \"$driver_symbol_bridge_obj_abs\"; then\n    echo \"[Error] failed to build backend driver symbol bridge object: $driver_symbol_bridge_src\" 1>&2\n    exit 1\n  fi\n  if [ \"$driver_ldflags\" = \"\" ]; then\n    driver_ldflags=\"$driver_symbol_bridge_obj_abs\"\n  else\n    driver_ldflags=\"$driver_ldflags $driver_symbol_bridge_obj_abs\"\n  fi\nfi\n\nstage0_tag() {\n  raw=\"$1\"\n  tag=\"$(printf '%s' \"$raw\" | tr '/: ' '___' | tr -cd 'A-Za-z0-9._-')\"\n  if [ \"$tag\" = \"\" ]; then\n    tag=\"stage0\"\n  fi\n  printf '%s\\n' \"$tag\"\n}\n\nrun_driver_compile_once() {\n  compiler=\"$1\"\n  out_bin=\"$2\"\n  multi_now=\"$3\"\n  multi_force_now=\"$4\"\n  log_file=\"$5\"\n  if [ \"$linker_mode\" = \"self\" ]; then\n    run_with_timeout \"$build_timeout\" env \\\n      MM=\"$mm\" \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-1}\" \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-${STAGE1_SKIP_SEM:-1}}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-${STAGE1_SKIP_OWNERSHIP:-1}}\" \\\n      STAGE1_SKIP_CPROFILE=\"${STAGE1_SKIP_CPROFILE:-1}\" \\\n      STAGE1_SKIP_CPROFILE=\"${STAGE1_SKIP_CPROFILE:-${STAGE1_SKIP_CPROFILE:-1}}\" \\\n      STAGE1_AUTO_SYSTEM=0 \\\n      BACKEND_MULTI=\"$multi_now\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force_now\" \\\n      BACKEND_INCREMENTAL=\"$driver_incremental\" \\\n      BACKEND_JOBS=\"$driver_jobs\" \\\n      BACKEND_"
        out = out + "VALIDATE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj_abs\" \\\n      BACKEND_LDFLAGS=\"$driver_ldflags\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=\"$driver_frontend\" \\\n      BACKEND_INPUT=\"src/backend/tooling/backend_driver.cheng\" \\\n      BACKEND_OUTPUT=\"$out_bin\" \\\n      \"$compiler\" >>\"$log_file\" 2>&1\n    return\n  fi\n  run_with_timeout \"$build_timeout\" env \\\n    MM=\"$mm\" \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-1}\" \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-${STAGE1_SKIP_SEM:-1}}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-${STAGE1_SKIP_OWNERSHIP:-1}}\" \\\n    STAGE1_SKIP_CPROFILE=\"${STAGE1_SKIP_CPROFILE:-1}\" \\\n    STAGE1_SKIP_CPROFILE=\"${STAGE1_SKIP_CPROFILE:-${STAGE1_SKIP_CPROFILE:-1}}\" \\\n    STAGE1_AUTO_SYSTEM=0 \\\n    BACKEND_MULTI=\"$multi_now\" \\\n    BACKEND_MULTI_FORCE=\"$multi_force_now\" \\\n    BACKEND_INCREMENTAL=\"$driver_incremental\" \\\n    BACKEND_JOBS=\"$driver_jobs\" \\\n    BACKEND_VALIDATE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_LDFLAGS=\"$driver_ldflags\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=\"$driver_frontend\" \\\n    BACKEND_INPUT=\"src/back"
        out = out + "end/tooling/backend_driver.cheng\" \\\n    BACKEND_OUTPUT=\"$out_bin\" \\\n    \"$compiler\" >>\"$log_file\" 2>&1\n}\n\nattempt_build_with_stage0() {\n  stage0=\"$1\"\n  attempt_idx=\"$2\"\n  stage0_tag_s=\"$(stage0_tag \"$stage0\")\"\n  attempt_log=\"$log_root/attempt_${attempt_idx}_${stage0_tag_s}.log\"\n  : >\"$attempt_log\"\n  printf 'stage0=%s\\n' \"$stage0\" >>\"$attempt_log\"\n\n  runtime_needs_rebuild=\"0\"\n  if [ \"$linker_mode\" = \"self\" ]; then\n    if [ ! -f \"$runtime_obj_abs\" ]; then\n      runtime_needs_rebuild=\"1\"\n    elif ! runtime_obj_has_required_symbols \"$runtime_obj_abs\"; then\n      runtime_needs_rebuild=\"1\"\n    fi\n  fi\n  if [ \"$runtime_needs_rebuild\" = \"1\" ]; then\n    printf 'missing runtime_obj=%s (self-link requires prebuilt runtime object)\\n' \"$runtime_obj_abs\" >>\"$attempt_log\"\n    printf 'hint: prepare runtime object before driver selfbuild (source=%s)\\n' \"$runtime_src\" >>\"$attempt_log\"\n    attempt_status=1\n    return 1\n  fi\n\n  rm -f \"$tmp_bin_abs\" \"$tmp_obj_abs\"\n  set +e\n  run_driver_compile_once \"$stage0\" \"$tmp_bin_abs\" \"$driver_multi\" \"$driver_multi_force\" \"$attempt_log\"\n  status=$?\n  set -e\n  if [ \"$status\" -ne 0 ] && [ \"$driver_multi\" != \"0\" ] && [ \"$status\" -ne 124 ]; then\n    rm -f \"$tmp_bin_abs\" \"$tmp_obj_abs\"\n    set +e\n    run_driver_compile_once \"$stage0\" \"$tmp_bin_abs\" \"0\" \"0\" \"$attempt_log\"\n    status=$?\n    set -e\n  fi\n  if [ \"$status\" -eq 0 ] && [ -x "
        out = out + "\"$tmp_bin_abs\" ] && driver_sanity_ok \"$tmp_bin_abs\"; then\n    smoke_required=\"$driver_require_smoke\"\n    if [ \"$driver_smoke\" = \"1\" ]; then\n      smoke_required=\"1\"\n    fi\n    smoke_ok=\"1\"\n    if [ \"$smoke_required\" = \"1\" ] && ! driver_stage1_smoke_ok \"$tmp_bin_abs\"; then\n      smoke_ok=\"0\"\n    fi\n    if [ \"$smoke_ok\" = \"1\" ]; then\n      mode_tag=\"system_link\"\n      if [ \"$linker_mode\" = \"self\" ]; then\n        mode_tag=\"self_link\"\n      fi\n      mv \"$tmp_bin_abs\" \"$name_abs\"\n      if [ -s \"$tmp_obj_abs\" ]; then\n        mv \"$tmp_obj_abs\" \"$name_obj_abs\"\n      fi\n      if [ \"$smoke_required\" = \"1\" ]; then\n        echo \"build_backend_driver ok (selfhost_${mode_tag}+smoke; stage0=$stage0)\"\n      else\n        echo \"build_backend_driver ok (selfhost_${mode_tag}; stage0=$stage0)\"\n      fi\n      return 0\n    fi\n    attempt_status=86\n    rm -f \"$tmp_bin_abs\" \"$tmp_obj_abs\"\n    status=\"$attempt_status\"\n  else\n    attempt_status=\"$status\"\n    rm -f \"$tmp_bin_abs\" \"$tmp_obj_abs\"\n    if [ \"$attempt_status\" -eq 0 ]; then\n      attempt_status=1\n    fi\n  fi\n\n  rm -f \"$tmp_bin_abs\" \"$tmp_obj_abs\"\n  return 1\n}\n\nattempt_idx=0\nwhile IFS= read -r stage0; do\n  if [ \"$stage0\" = \"\" ]; then\n    continue\n  fi\n  attempt_idx=$((attempt_idx + 1))\n  if [ \"$max_stage0_attempts\" -gt 0 ] && [ \"$attempt_idx\" -gt \"$max_stage0_attempts\" ]; then\n    break\n  fi\n  attempt_status=1\n  att"
        out = out + "empt_log=\"\"\n  if attempt_build_with_stage0 \"$stage0\" \"$attempt_idx\"; then\n    exit 0\n  fi\n  printf '%s\\tstatus=%s\\tlog=%s\\n' \"$stage0\" \"$attempt_status\" \"$attempt_log\" >>\"$attempt_report\"\n  if [ \"$stage0_strict\" = \"1\" ]; then\n    break\n  fi\ndone <\"$stage0_candidates_file\"\n\necho \"[Error] build_backend_driver selfhost_${linker_mode}_link failed for all stage0 candidates\" 1>&2\nif [ -s \"$attempt_report\" ]; then\n  echo \"  attempts:\" 1>&2\n  sed 's/^/  - /' \"$attempt_report\" 1>&2\nfi\nif [ \"$build_no_recover\" = \"1\" ]; then\n  echo \"  hint: hard-fail enabled (BACKEND_BUILD_DRIVER_NO_RECOVER=1), no fallback to existing driver\" 1>&2\n  echo \"  hint: inspect logs under $log_root\" 1>&2\n  exit 1\nfi\nrecover_smoke_required=\"$driver_require_smoke\"\nif [ \"$driver_smoke\" = \"1\" ]; then\n  recover_smoke_required=\"1\"\nfi\nif [ -x \"$name_abs\" ] && driver_sanity_ok \"$name_abs\"; then\n  recover_ok=\"1\"\n  if [ \"$recover_smoke_required\" = \"1\" ] && ! driver_stage1_smoke_ok \"$name_abs\"; then\n    recover_ok=\"0\"\n  fi\n  if [ \"$recover_ok\" = \"1\" ]; then\n    echo \"[Warn] build_backend_driver rebuild failed; keep existing healthy driver: $name_abs\" 1>&2\n    exit 0\n  fi\nfi\necho \"  hint: inspect logs under $log_root\" 1>&2\nexit 1\n"
        return out
    if id == "build_backend_mem_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_mem_contract [--out:<path>] [--doc:<path>]\n\nNotes:\n  - Generates deterministic PAR-01 Memory-Exe + Hotpatch contract baseline.\n  - Default output: src/tooling/backend_mem_contract.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nout=\"src/tooling/backend_mem_contract.env\"\ndoc=\"docs/backend-mem-hotpatch-contract.md\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_mem_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nfor required in \\\n  \"$doc\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_"
        out = out + "inline.cheng\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_mem_contract] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_mem_contract_markers.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_markers\"\n}\ntrap cleanup EXIT\n\nrg -o \\\n  'mem_contract\\.version=[0-9]+|mem_image\\.schema\\.version=[0-9]+|patch_meta\\.schema\\.version=[0-9]+|mem_image\\.field\\.[A-Za-z0-9_]+|patch_meta\\.field\\.[A-Za-z0-9_]+|mem_image\\.invariant\\.[A-Za-z0-9_]+|patch_meta\\.invariant\\.[A-Za-z0-9_]+' \\\n  \"$doc\" \\\n  | LC_ALL=C sort -u >\"$tmp_markers\"\n\nmarker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\nif [ \"$marker_count\" -eq 0 ]; then\n  echo \"[build_backend_mem_contract] no contract markers found in: $doc\" 1>&2\n  exit 2\nfi\n\ncontract_version=\"$(rg -o 'mem_contract\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nmem_schema_version=\"$(rg -o 'mem_image\\.schema\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\npatch_schema_version=\"$(rg -o 'patch_meta\\.schema\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n\nif [ \"$contract_version\" = \"\" ] || [ \"$mem_schema_version\" = \"\" ] || [ \"$patch_schema_version\" = \"\" ]; then\n  echo \"[build_backend_mem_contract] missing version markers in: $doc\" 1>&2\n  exit 2\nfi\n\nmem_field_count=\"$(rg -o 'mem_image\\.field\\.[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\npatch_field_cou"
        out = out + "nt=\"$(rg -o 'patch_meta\\.field\\.[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\nmem_invariant_count=\"$(rg -o 'mem_image\\.invariant\\.[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\npatch_invariant_count=\"$(rg -o 'patch_meta\\.invariant\\.[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\n\nmarker_sha=\"$(hash_file \"$tmp_markers\")\"\ndoc_sha=\"$(hash_file \"$doc\")\"\nverify_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nclosedloop_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nprod_closure_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\n{\n  echo \"BACKEND_MEM_CONTRACT_BASELINE_VERSION=1\"\n  echo \"BACKEND_MEM_CONTRACT_DOC=$doc\"\n  echo \"BACKEND_MEM_CONTRACT_DOC_SHA256=$doc_sha\"\n  echo \"BACKEND_MEM_CONTRACT_VERSION=$contract_version\"\n  echo \"BACKEND_MEM_IMAGE_SCHEMA_VERSION=$mem_schema_version\"\n  echo \"BACKEND_PATCH_META_SCHEMA_VERSION=$patch_schema_version\"\n  echo \"BACKEND_MEM_CONTRACT_MARKER_COUNT=$marker_count\"\n  echo \"BACKEND_MEM_CONTRACT_MARKER_SHA256=$marker_sha\"\n  echo \"BACKEND_MEM_IMAGE_FIELD_COUNT=$mem_field_count\"\n  echo \"BACKEND_PATCH_META_FIELD_COUNT=$patch_field_count\"\n  echo \"BACKEND_MEM_IMAGE_INVARIANT_COUNT=$mem_invariant_count\"\n  echo \"BACKEND_PATCH_META_INVARIANT_COUNT=$patch_i"
        out = out + "nvariant_count\"\n  echo \"BACKEND_MEM_CONTRACT_VERIFY_SCRIPT_SHA256=$verify_sha\"\n  echo \"BACKEND_MEM_CONTRACT_CLOSEDLOOP_SHA256=$closedloop_sha\"\n  echo \"BACKEND_MEM_CONTRACT_PROD_CLOSURE_SHA256=$prod_closure_sha\"\n  echo \"BACKEND_MEM_CONTRACT_REQUIRED_GATES=backend.mem_contract\"\n} >\"$out\"\n\necho \"backend mem contract baseline generated: $out\"\n"
        return out
    if id == "build_backend_profile_baseline":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_baseline [--out:<path>] [--schema:<path>]\n\nNotes:\n  - Generates deterministic PAR-01 baseline snapshot for profile/plugin closure.\n  - Default output: src/tooling/backend_profile_baseline.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nout=\"src/tooling/backend_profile_baseline.env\"\nschema_file=\"src/tooling/backend_profile_schema.env\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --schema:*)\n      schema_file=\"${1#--schema:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_profile_baseline] rg is required\" 1>&2\n  exit 2\nfi\n\nfor required in \\\n  \"$schema_file\" \\\n  \"src/backend/tooling/backend_driver.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.che"
        out = out + "ng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\" \\\n  \"src/tooling/cheng_tooling_embedded_inline.cheng\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_profile_baseline] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_driver_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_profile_driver_markers.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_driver_markers\"\n}\ntrap cleanup EXIT\n\nrg --no-filename --no-line-number -o '\"backend_profile|uir_profile|generics_report|plugin_enable=|plugin_path=|plugin_paths=|metering_plugin=\"' \\\n  src/backend/tooling/backend_driver.cheng \\\n  | LC_ALL=C sort >\"$tmp_driver_markers\"\n\ndriver_marker_count=\"$(wc -l < \"$tmp_driver_markers\" | tr -d ' ')\"\ndriver_marker_sha=\"$(hash_file \"$tmp_driver_markers\")\"\n\nschema_sha=\"$(hash_file \"$schema_file\")\"\nclosedloop_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nplugin_isolation_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nplugin_system_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nverify_schema_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\nverify_baseline_sha=\"$(hash_file src/tooling/cheng_tooling_embedded_inline.cheng)\"\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_d"
        out = out + "ir\"\nfi\n\n{\n  echo \"BACKEND_PROFILE_BASELINE_VERSION=1\"\n  echo \"BACKEND_PROFILE_SCHEMA_FILE=$schema_file\"\n  echo \"BACKEND_PROFILE_SCHEMA_SHA256=$schema_sha\"\n  echo \"BACKEND_PROFILE_DRIVER_MARKER_COUNT=$driver_marker_count\"\n  echo \"BACKEND_PROFILE_DRIVER_MARKER_SHA256=$driver_marker_sha\"\n  echo \"BACKEND_PROFILE_CLOSEDLOOP_SHA256=$closedloop_sha\"\n  echo \"BACKEND_PROFILE_PLUGIN_ISOLATION_SHA256=$plugin_isolation_sha\"\n  echo \"BACKEND_PROFILE_PLUGIN_SYSTEM_SHA256=$plugin_system_sha\"\n  echo \"BACKEND_PROFILE_VERIFY_SCHEMA_SHA256=$verify_schema_sha\"\n  echo \"BACKEND_PROFILE_VERIFY_BASELINE_SHA256=$verify_baseline_sha\"\n  echo \"BACKEND_PROFILE_REQUIRED_GATES=backend.profile_schema,backend.profile_baseline,backend.plugin_isolation,backend.plugin_system\"\n} >\"$out\"\n\necho \"backend profile baseline generated: $out\"\n"
        return out
    if id == "build_backend_profile_schema":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/build_backend_profile_schema.sh [--out:<path>]\n\nNotes:\n  - Generates a deterministic profile schema snapshot for PAR-01.\n  - Default output: src/tooling/backend_profile_schema.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nout=\"src/tooling/backend_profile_schema.env\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_profile_schema] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_file=\"src/backend/tooling/backend_driver.cheng\"\nuir_builder_file=\"src/backend/uir/uir_internal/uir_core_builder.cheng\"\nstage1_file=\"src/stage1/frontend_lib.cheng\"\n\nfor required in \"$driver_file\" \"$uir_builder_file\" \"$stage1_file\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_profile_schema] missing sour"
        out = out + "ce file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_profile_schema_markers.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_markers\"\n}\ntrap cleanup EXIT\n\nmarker_regex='backend_profile|uir_profile|generics_report|\\[stage1\\] profile'\nrg --no-filename --no-line-number -o \"$marker_regex\" \\\n  \"$driver_file\" \\\n  \"$uir_builder_file\" \\\n  \"$stage1_file\" \\\n  | LC_ALL=C sort >\"$tmp_markers\"\n\nmarker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\nmarker_sha=\"$(hash_file \"$tmp_markers\")\"\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\n{\n  echo \"BACKEND_PROFILE_SCHEMA_VERSION=1\"\n  echo \"BACKEND_PROFILE_SCHEMA_PREFIXES=backend_profile,uir_profile,stage1_profile,generics_report\"\n  echo \"BACKEND_PROFILE_GENERICS_FIELDS=ir,mode,spec_budget,borrow_ir,generic_lowering\"\n  echo \"BACKEND_PROFILE_SCHEMA_MARKER_REGEX=backend_profile|uir_profile|generics_report|\\\\\\\\[stage1\\\\\\\\]\\\\\\\\ profile\"\n  echo \"BACKEND_PROFILE_SCHEMA_MARKER_COUNT=$marker_count\"\n  echo \"BACKEND_PROFILE_SCHEMA_MARKER_SHA256=$marker_sha\"\n  echo \"BACKEND_PROFILE_SCHEMA_SOURCES=$driver_file,$uir_builder_file,$stage1_file\"\n} >\"$out\"\n\necho \"backend profile schema generated: $out\"\n"
        return out
    if id == "build_backend_rawptr_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_rawptr_contract [--out:<path>] [--doc:<path>] [--formal-doc:<path>] [--tooling-doc:<path>]\n\nNotes:\n  - Generates deterministic RPSPAR-01 raw pointer safety contract baseline.\n  - Default output: src/tooling/backend_rawptr_contract.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nread_marker_value() {\n  file=\"$1\"\n  marker_regex=\"$2\"\n  rg -o \"${marker_regex}=[A-Za-z0-9_]+\" \"$file\" | head -n 1 | cut -d= -f2 || true\n}\n\nrequire_marker_value() {\n  file=\"$1\"\n  marker_regex=\"$2\"\n  marker_name=\"$3\"\n  expected=\"$4\"\n  value=\"$(read_marker_value \"$file\" \"$marker_regex\")\"\n  if [ \"$value\" != \"$expected\" ]; then\n    echo \"[build_backend_rawptr_contract] ${marker_name} must be ${expected} in: $file\" 1>&2\n    exit 2\n  fi\n  printf '%s\\n' \"$value\"\n}\n\nout=\"src/tooling/backend_rawptr_contract.env\"\ndoc=\"docs/raw-pointer-safety.md\"\nformal_doc=\"docs/cheng-formal-spec.md\"\ntooling_doc=\"src/tooling/README.md\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out=\"${1#--"
        out = out + "out:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --formal-doc:*)\n      formal_doc=\"${1#--formal-doc:}\"\n      ;;\n    --tooling-doc:*)\n      tooling_doc=\"${1#--tooling-doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_rawptr_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nverify_script=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nclosedloop_script=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nprod_closure_script=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nfor required in \\\n  \"$doc\" \\\n  \"$formal_doc\" \\\n  \"$tooling_doc\" \\\n  \"$verify_script\" \\\n  \"$closedloop_script\" \\\n  \"$prod_closure_script\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_rawptr_contract] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_rawptr_contract_markers.XXXXXX\")\"\ntmp_required_gates=\"$(mktemp \"${TMPDIR:-/tmp}/backend_rawptr_contract_required.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_markers\" \"$tmp_required_gates\"\n}\ntrap cleanup EXIT\n\n{\n  rg -o 'rawptr_contract\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" || true\n  rg -o 'rawptr_contract\\.[a-z0-9_.]+=[A-Za-z0"
        out = out + "-9_]+' \"$formal_doc\" || true\n  rg -o 'rawptr_contract\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$tooling_doc\" || true\n} | LC_ALL=C sort -u >\"$tmp_markers\"\n\nmarker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\nif [ \"$marker_count\" -eq 0 ]; then\n  echo \"[build_backend_rawptr_contract] no rawptr contract markers found\" 1>&2\n  exit 2\nfi\n\ncontract_version=\"$(read_marker_value \"$doc\" 'rawptr_contract\\.version')\"\nif [ \"$contract_version\" = \"\" ]; then\n  echo \"[build_backend_rawptr_contract] missing rawptr_contract.version marker in: $doc\" 1>&2\n  exit 2\nfi\n\ndoc_scheme_id=\"$(require_marker_value \"$doc\" 'rawptr_contract\\.scheme\\.id' 'rawptr_contract.scheme.id' 'ZRPC')\"\ndoc_scheme_name=\"$(require_marker_value \"$doc\" 'rawptr_contract\\.scheme\\.name' 'rawptr_contract.scheme.name' 'zero_rawptr_production_closure')\"\ndoc_scheme_normative=\"$(require_marker_value \"$doc\" 'rawptr_contract\\.scheme\\.normative' 'rawptr_contract.scheme.normative' '1')\"\ndoc_enforce_mode=\"$(require_marker_value \"$doc\" 'rawptr_contract\\.enforce\\.mode' 'rawptr_contract.enforce.mode' 'hard_fail')\"\n\nrequire_marker_value \"$formal_doc\" 'rawptr_contract\\.scheme\\.id' 'rawptr_contract.scheme.id' 'ZRPC' >/dev/null\nrequire_marker_value \"$formal_doc\" 'rawptr_contract\\.scheme\\.name' 'rawptr_contract.scheme.name' 'zero_rawptr_production_closure' >/dev/null\nrequire_marker_value \"$formal_doc\" 'rawptr_contract\\.scheme\\.normative' 'rawptr_contract.scheme.normative' '"
        out = out + "1' >/dev/null\nrequire_marker_value \"$formal_doc\" 'rawptr_contract\\.enforce\\.mode' 'rawptr_contract.enforce.mode' 'hard_fail' >/dev/null\n\nif ! rg -q 'rawptr_contract\\.formal_spec\\.synced=1' \"$formal_doc\"; then\n  echo \"[build_backend_rawptr_contract] missing formal spec sync marker: $formal_doc\" 1>&2\n  exit 2\nfi\nif ! rg -q 'rawptr_contract\\.tooling_readme\\.synced=1' \"$tooling_doc\"; then\n  echo \"[build_backend_rawptr_contract] missing tooling README sync marker: $tooling_doc\" 1>&2\n  exit 2\nfi\n\nannotation_count=\"$(rg -o 'rawptr_contract\\.annotation\\.[a-z0-9_]+=[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\nforbid_count=\"$(rg -o 'rawptr_contract\\.forbid\\.[a-z0-9_]+=[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\nrg -o 'rawptr_contract\\.required_gate\\.[a-z0-9_.]+=1' \"$doc\" \\\n  | sed -E 's/^rawptr_contract\\.required_gate\\.([a-z0-9_.]+)=1$/\\1/' \\\n  | LC_ALL=C sort -u >\"$tmp_required_gates\"\nrequired_gate_count=\"$(wc -l < \"$tmp_required_gates\" | tr -d ' ')\"\nif [ \"$required_gate_count\" -eq 0 ]; then\n  echo \"[build_backend_rawptr_contract] no required rawptr gates found in: $doc\" 1>&2\n  exit 2\nfi\nrequired_gates_csv=\"$(tr '\\n' ',' <\"$tmp_required_gates\" | sed -E 's/,+$//')\"\nif [ \"$required_gates_csv\" = \"\" ]; then\n  echo \"[build_backend_rawptr_contract] failed to compute required gate CSV\" 1>&2\n  exit 2\nfi\nmarker_sha=\"$(hash_file \"$tmp_markers\")\"\ndoc_sha=\"$(hash_file \""
        out = out + "$doc\")\"\nformal_doc_sha=\"$(hash_file \"$formal_doc\")\"\ntooling_doc_sha=\"$(hash_file \"$tooling_doc\")\"\nverify_sha=\"$(hash_file \"$verify_script\")\"\nclosedloop_sha=\"$(hash_file \"$closedloop_script\")\"\nprod_closure_sha=\"$(hash_file \"$prod_closure_script\")\"\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\n{\n  echo \"BACKEND_RAWPTR_CONTRACT_BASELINE_VERSION=1\"\n  echo \"BACKEND_RAWPTR_CONTRACT_DOC=$doc\"\n  echo \"BACKEND_RAWPTR_CONTRACT_FORMAL_DOC=$formal_doc\"\n  echo \"BACKEND_RAWPTR_CONTRACT_TOOLING_DOC=$tooling_doc\"\n  echo \"BACKEND_RAWPTR_CONTRACT_DOC_SHA256=$doc_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_FORMAL_DOC_SHA256=$formal_doc_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_TOOLING_DOC_SHA256=$tooling_doc_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_VERSION=$contract_version\"\n  echo \"BACKEND_RAWPTR_CONTRACT_SCHEME_ID=$doc_scheme_id\"\n  echo \"BACKEND_RAWPTR_CONTRACT_SCHEME_NAME=$doc_scheme_name\"\n  echo \"BACKEND_RAWPTR_CONTRACT_SCHEME_NORMATIVE=$doc_scheme_normative\"\n  echo \"BACKEND_RAWPTR_CONTRACT_ENFORCE_MODE=$doc_enforce_mode\"\n  echo \"BACKEND_RAWPTR_CONTRACT_MARKER_COUNT=$marker_count\"\n  echo \"BACKEND_RAWPTR_CONTRACT_MARKER_SHA256=$marker_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_ANNOTATION_COUNT=$annotation_count\"\n  echo \"BACKEND_RAWPTR_CONTRACT_FORBID_COUNT=$forbid_count\"\n  echo \"BACKEND_RAWPTR_CONTRACT_REQUIRED_GATE_COUNT=$required_gate_count\"\n  echo \"BAC"
        out = out + "KEND_RAWPTR_CONTRACT_VERIFY_SCRIPT_SHA256=$verify_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_CLOSEDLOOP_SHA256=$closedloop_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_PROD_CLOSURE_SHA256=$prod_closure_sha\"\n  echo \"BACKEND_RAWPTR_CONTRACT_REQUIRED_GATES=$required_gates_csv\"\n} >\"$out\"\n\necho \"backend rawptr contract baseline generated: $out\"\n"
        return out
    if id == "build_mobile_export":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  src/tooling/build_mobile_export.sh <file.cheng> [options]\n\nOptions:\n  --name:<appName>            Export app name (default: basename of input)\n  --out:<dir>                 Output directory (default: mobile_build/<name>)\n  --assets:<dir>              Extra assets directory to copy\n  --with-android-project      Export Android Studio project\n  --with-ios-project          Export iOS project\n  --with-harmony-project      Export Harmony project skeleton\n  --with-asm-gui              Copy asm_gui folder if available\n  --plugins:<dir1,dir2,...>   Plugin directories to weave into projects\n  --mobile-root:<dir>         Override cheng-mobile package path\n  --mm:<orc> | --orc          Accepted for compatibility (ignored)\n\nNotes:\n  - This is a compatibility shim for the removed legacy mobile C export pipeline.\n  - It always generates a stable native stub `cheng_mobile_app.c` so mobile build\n    pipelines remain runnable.\nUSAGE\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] input file not found: $in\" 1>&2\n  exit 2\nfi\n\nname=\"\"\nout=\"\"\nassets=\"\"\nplugins=\"${MOBILE_PLUGINS:-}\"\nmobile_root=\"\"\nwith_android=0\nwith_ios=0\nwith_harmony=0\nwith_asm_gui=0\nmm=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*)\n      "
        out = out + "name=\"${1#--name:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --assets:*)\n      assets=\"${1#--assets:}\"\n      ;;\n    --plugins:*)\n      plugins=\"${1#--plugins:}\"\n      ;;\n    --mobile-root:*)\n      mobile_root=\"${1#--mobile-root:}\"\n      ;;\n    --with-android-project)\n      with_android=1\n      ;;\n    --with-ios-project)\n      with_ios=1\n      ;;\n    --with-harmony-project)\n      with_harmony=1\n      ;;\n    --with-asm-gui)\n      with_asm_gui=1\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\n\nroot=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\n\nif [ \"$out\" = \"\" ]; then\n  out=\"mobile_build/$name\"\nfi\ncase \"$out\" in\n  /*) ;;\n  *) out=\"$root/$out\" ;;\nesac\n\nif [ \"$mobile_root\" = \"\" ]; then\n  if [ -n \"${MOBILE_ROOT:-}\" ]; then\n    mobile_root=\"$MOBILE_ROOT\"\n  elif [ -d \"$HOME/.cheng-packages/cheng-mobile\" ]; then\n    mobile_root=\"$HOME/.cheng-packages/cheng-mobile\"\n  elif [ -d \"$root/../cheng-mobile\" ]; then\n    mobile_root=\"$root/../cheng-mobile\"\n  fi\nfi\n\nif [ \"$mobile_root\" = \"\" "
        out = out + "] || [ ! -d \"$mobile_root\" ]; then\n  echo \"[Error] cheng-mobile root not found; set --mobile-root or MOBILE_ROOT\" 1>&2\n  exit 2\nfi\n\nif [ \"$with_android\" -eq 0 ] && [ \"$with_ios\" -eq 0 ] && [ \"$with_harmony\" -eq 0 ]; then\n  with_android=1\n  with_ios=1\n  with_harmony=1\nfi\n\nruntime_c=\"$root/src/runtime/native/system_helpers.c\"\nruntime_h=\"$root/src/runtime/native/system_helpers.h\"\nruntime_stb_image_h=\"$root/src/runtime/native/stb_image.h\"\nif [ ! -f \"$runtime_c\" ] || [ ! -f \"$runtime_h\" ]; then\n  echo \"[Error] runtime helpers not found under src/runtime/native\" 1>&2\n  exit 2\nfi\n\nmkdir -p \"$out\"\n\napp_c=\"$out/cheng_mobile_app.c\"\ncat > \"$app_c\" <<APP_C\n#include \"cheng_mobile_bridge.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#if !defined(_WIN32)\n#include <unistd.h>\n#else\n#include <windows.h>\n#endif\n\nstatic void app_sleep_ms(int ms) {\n#if defined(_WIN32)\n  Sleep((DWORD)(ms < 0 ? 0 : ms));\n#else\n  if (ms > 0) {\n    usleep((unsigned int)ms * 1000u);\n  }\n#endif\n}\n\nstatic uint32_t pack_rgba(uint32_t r, uint32_t g, uint32_t b) {\n  return 0xFF000000u | ((r & 0xFFu) << 16) | ((g & 0xFFu) << 8) | (b & 0xFFu);\n}\n\nstatic void fill_demo(uint32_t* px, int w, int h, int frame) {\n  if (px == NULL || w <= 0 || h <= 0) return;\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) {\n      uint32_t r = (uint32_t)((x + frame) % 255);\n      uint32_t g = (uint32_t)((y + (frame * 2)) % 255);\n    "
        out = out + "  uint32_t b = (uint32_t)((x + y + (frame * 3)) % 255);\n      px[y * w + x] = pack_rgba(r, g, b);\n    }\n  }\n}\n\nvoid cheng_mobile_app_main(void) {\n  ChengMobileConfig cfg;\n  memset(&cfg, 0, sizeof(cfg));\n#if defined(__ANDROID__)\n  cfg.platform = MOBILE_ANDROID;\n#elif defined(__APPLE__)\n  cfg.platform = MOBILE_IOS;\n#else\n  cfg.platform = MOBILE_HARMONY;\n#endif\n  cfg.resourceRoot = cheng_mobile_host_default_resource_root();\n  cfg.title = \"APP_TITLE_PLACEHOLDER\";\n  cfg.width = 1080;\n  cfg.height = 1920;\n  cfg.highDpi = 1;\n\n  (void)cheng_mobile_host_init(&cfg);\n  (void)cheng_mobile_host_open_window(&cfg);\n\n  int width = cfg.width > 0 ? cfg.width : 1080;\n  int height = cfg.height > 0 ? cfg.height : 1920;\n  int stride = width * 4;\n  uint32_t* pixels = (uint32_t*)malloc((size_t)stride * (size_t)height);\n  if (pixels == NULL) {\n    cheng_mobile_host_shutdown(\"alloc_failed\");\n    return;\n  }\n\n  int running = 1;\n  int frame = 0;\n  while (running) {\n    ChengMobileEvent ev;\n    int gotAny = 0;\n    while (cheng_mobile_host_poll_event(&ev) != 0) {\n      gotAny = 1;\n      if (ev.kind == MRE_RUNTIME_STOPPED) {\n        running = 0;\n        break;\n      }\n      if (ev.kind == MRE_WINDOW_OPENED) {\n        if (cfg.width > 0) width = cfg.width;\n        if (cfg.height > 0) height = cfg.height;\n        stride = width * 4;\n      }\n    }\n\n    if (!running) {\n      break;\n    }\n\n    fill_demo(pixels, width, height, frame);\n    cheng_mobile_h"
        out = out + "ost_present(pixels, width, height, stride);\n    frame = (frame + 1) % 100000;\n\n    if (!gotAny) {\n      app_sleep_ms(16);\n    }\n  }\n\n  free(pixels);\n  cheng_mobile_host_shutdown(\"exit\");\n}\nAPP_C\n\n# Inject title and record source for traceability.\nesc_name=\"$(printf '%s' \"$name\" | sed 's/[\\\\/&]/\\\\&/g')\"\nsed -i.bak \"s/APP_TITLE_PLACEHOLDER/${esc_name}/g\" \"$app_c\"\nrm -f \"$app_c.bak\"\n\necho \"/* source: $in */\" >> \"$app_c\"\n\ncopy_assets_into() {\n  src_dir=\"$1\"\n  dst_dir=\"$2\"\n  entry_src=\"$3\"\n\n  mkdir -p \"$dst_dir\"\n  if [ -n \"$src_dir\" ] && [ -d \"$src_dir\" ]; then\n    cp -R \"$src_dir/.\" \"$dst_dir/\"\n  fi\n\n  entry_name=\"$(basename \"$entry_src\")\"\n  cp \"$entry_src\" \"$dst_dir/$entry_name\"\n\n  manifest=\"$dst_dir/assets_manifest.txt\"\n  {\n    echo \"# relpath<TAB>size_bytes\"\n    (cd \"$dst_dir\" && find . -type f ! -name assets_manifest.txt | sort) | while IFS= read -r rel; do\n      rel=\"${rel#./}\"\n      size=\"$(wc -c < \"$dst_dir/$rel\" | tr -d ' ')\"\n      printf '%s\\t%s\\n' \"$rel\" \"$size\"\n    done\n  } > \"$manifest\"\n}\n\ncopy_common_cpp_sources() {\n  dst_cpp=\"$1\"\n  mkdir -p \"$dst_cpp\"\n\n  cp \"$app_c\" \"$dst_cpp/cheng_mobile_app.c\"\n  cp \"$runtime_c\" \"$dst_cpp/system_helpers.c\"\n  cp \"$runtime_h\" \"$dst_cpp/system_helpers.h\"\n  if [ -f \"$runtime_stb_image_h\" ]; then\n    cp \"$runtime_stb_image_h\" \"$dst_cpp/stb_image.h\"\n  fi\n\n  cp \"$mobile_root/bridge/cheng_mobile_brid"
        out = out + "ge.h\" \"$dst_cpp/cheng_mobile_bridge.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.c\" \"$dst_cpp/cheng_mobile_host_api.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.h\" \"$dst_cpp/cheng_mobile_host_api.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.c\" \"$dst_cpp/cheng_mobile_host_core.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.h\" \"$dst_cpp/cheng_mobile_host_core.h\"\n}\n\nweave_plugins_android() {\n  project_dir=\"$1\"\n  [ -z \"$plugins\" ] && return 0\n\n  plugins_kotlin=\"$project_dir/app/src/main/kotlin/com/cheng/mobile/plugins\"\n  plugins_cpp=\"$project_dir/app/src/main/cpp/plugins\"\n  mkdir -p \"$plugins_kotlin\" \"$plugins_cpp\"\n\n  lock_file=\"$out/mobile_plugins.lock\"\n  : > \"$lock_file\"\n\n  old_ifs=\"$IFS\"\n  IFS=','\n  for p in $plugins; do\n    p=\"$(printf '%s' \"$p\" | sed 's/^ *//;s/ *$//')\"\n    [ -z \"$p\" ] && continue\n    if [ ! -f \"$p/mobile_plugin.toml\" ]; then\n      echo \"[Warn] skip plugin (missing mobile_plugin.toml): $p\" 1>&2\n      continue\n    fi\n    plugin_name=\"$(basename \"$p\")\"\n    echo \"$plugin_name\\t$p\" >> \"$lock_file\"\n\n    if [ -d \"$p/android\" ]; then\n      mkdir -p \"$plugins_kotlin/$plugin_name\"\n      cp -R \"$p/android/.\" \"$plugins_kotlin/$plugin_name/\"\n    fi\n    if [ -d \"$p/android_cpp\" ]; then\n      mkdir -p \"$plugins_cpp/$plugin_name\"\n      cp -R \"$p/android_cpp/.\" \"$plugins_cpp/$plugin_name/\"\n    fi\n    if [ -d \"$p/cpp\" ]; then\n      mkdir -p"
        out = out + " \"$plugins_cpp/$plugin_name\"\n      cp -R \"$p/cpp/.\" \"$plugins_cpp/$plugin_name/\"\n    fi\n  done\n  IFS=\"$old_ifs\"\n}\n\nweave_plugins_ios() {\n  project_dir=\"$1\"\n  [ -z \"$plugins\" ] && return 0\n\n  plugins_dst=\"$project_dir/ChengMobileApp/Plugins\"\n  mkdir -p \"$plugins_dst\"\n\n  old_ifs=\"$IFS\"\n  IFS=','\n  for p in $plugins; do\n    p=\"$(printf '%s' \"$p\" | sed 's/^ *//;s/ *$//')\"\n    [ -z \"$p\" ] && continue\n    [ ! -f \"$p/mobile_plugin.toml\" ] && continue\n    plugin_name=\"$(basename \"$p\")\"\n    mkdir -p \"$plugins_dst/$plugin_name\"\n    if [ -d \"$p/ios\" ]; then\n      cp -R \"$p/ios/.\" \"$plugins_dst/$plugin_name/\"\n    fi\n    if [ -d \"$p/cheng\" ]; then\n      mkdir -p \"$plugins_dst/$plugin_name/cheng\"\n      cp -R \"$p/cheng/.\" \"$plugins_dst/$plugin_name/cheng/\"\n    fi\n  done\n  IFS=\"$old_ifs\"\n}\n\nweave_plugins_harmony() {\n  project_dir=\"$1\"\n  [ -z \"$plugins\" ] && return 0\n\n  plugins_dst=\"$project_dir/plugins\"\n  mkdir -p \"$plugins_dst\"\n\n  old_ifs=\"$IFS\"\n  IFS=','\n  for p in $plugins; do\n    p=\"$(printf '%s' \"$p\" | sed 's/^ *//;s/ *$//')\"\n    [ -z \"$p\" ] && continue\n    [ ! -f \"$p/mobile_plugin.toml\" ] && continue\n    plugin_name=\"$(basename \"$p\")\"\n    mkdir -p \"$plugins_dst/$plugin_name\"\n    if [ -d \"$p/harmony\" ]; then\n      cp -R \"$p/harmony/.\" \"$plugins_dst/$plugin_name/\"\n    fi\n    if [ -d \"$p/cheng\" ]; then\n      mkdir -p \"$plugins_dst/$plugin_name/cheng\"\n     "
        out = out + " cp -R \"$p/cheng/.\" \"$plugins_dst/$plugin_name/cheng/\"\n    fi\n  done\n  IFS=\"$old_ifs\"\n}\n\nif [ \"$with_android\" -eq 1 ]; then\n  android_project=\"$out/android_project\"\n  rm -rf \"$android_project\"\n  cp -R \"$mobile_root/android/project_template\" \"$android_project\"\n\n  android_cpp=\"$android_project/app/src/main/cpp\"\n  copy_common_cpp_sources \"$android_cpp\"\n\n  cp \"$mobile_root/android/cheng_mobile_host_android.c\" \"$android_cpp/cheng_mobile_host_android.c\"\n  cp \"$mobile_root/android/cheng_mobile_host_android.h\" \"$android_cpp/cheng_mobile_host_android.h\"\n  cp \"$mobile_root/android/cheng_mobile_android_jni.c\" \"$android_cpp/cheng_mobile_android_jni.c\"\n  cp \"$mobile_root/android/cheng_mobile_android_ndk.c\" \"$android_cpp/cheng_mobile_android_ndk.c\"\n  cp \"$mobile_root/android/cheng_mobile_android_gl.c\" \"$android_cpp/cheng_mobile_android_gl.c\"\n  cp \"$mobile_root/android/cheng_mobile_android_gl.h\" \"$android_cpp/cheng_mobile_android_gl.h\"\n  cp \"$mobile_root/android/cheng_gui_native_android.c\" \"$android_cpp/cheng_gui_native_android.c\"\n  cp \"$mobile_root/android/stb_truetype.h\" \"$android_cpp/stb_truetype.h\"\n\n  # Optional Android host overrides from cheng-lang.\n  mobile_android_override=\"src/tooling/mobile/android\"\n  if [ -d \"$mobile_android_override\" ]; then\n    [ -f \"$mobile_android_override/cheng_mobile_host_android.c\" ] && cp \"$mobile_android_override/cheng_mobile_host_android.c\" \"$android_cpp/cheng_mobile_"
        out = out + "host_android.c\"\n    [ -f \"$mobile_android_override/cheng_mobile_android_jni.c\" ] && cp \"$mobile_android_override/cheng_mobile_android_jni.c\" \"$android_cpp/cheng_mobile_android_jni.c\"\n\n    kotlin_dst=\"$android_project/app/src/main/kotlin/com/cheng/mobile\"\n    mkdir -p \"$kotlin_dst\"\n    [ -f \"$mobile_android_override/ChengActivity.kt\" ] && cp \"$mobile_android_override/ChengActivity.kt\" \"$kotlin_dst/ChengActivity.kt\"\n    [ -f \"$mobile_android_override/ChengSurfaceView.kt\" ] && cp \"$mobile_android_override/ChengSurfaceView.kt\" \"$kotlin_dst/ChengSurfaceView.kt\"\n    [ -f \"$mobile_android_override/AndroidHostServices.kt\" ] && cp \"$mobile_android_override/AndroidHostServices.kt\" \"$kotlin_dst/AndroidHostServices.kt\"\n  fi\n\n  if [ \"$with_asm_gui\" -eq 1 ] && [ -d \"$root/asm_gui\" ]; then\n    mkdir -p \"$android_cpp/asm_gui\"\n    cp -R \"$root/asm_gui/.\" \"$android_cpp/asm_gui/\"\n  fi\n\n  copy_assets_into \"$assets\" \"$android_project/app/src/main/assets\" \"$in\"\n  weave_plugins_android \"$android_project\"\n  echo \"[mobile-export] android project: $android_project\"\nfi\n\nif [ \"$with_ios\" -eq 1 ]; then\n  ios_project=\"$out/ios_project\"\n  rm -rf \"$ios_project\"\n  cp -R \"$mobile_root/ios/project_template\" \"$ios_project\"\n\n  ios_src=\"$ios_project/ChengMobileApp\"\n\n  cp \"$mobile_root/ios/ChengViewController.h\" \"$ios_src/ChengViewController.h\"\n  cp \"$mobile_root/ios/ChengViewController.m\" \"$ios_src/ChengViewController."
        out = out + "m\"\n  cp \"$mobile_root/ios/cheng_mobile_ios_glue.h\" \"$ios_src/cheng_mobile_ios_glue.h\"\n  cp \"$mobile_root/ios/cheng_mobile_ios_glue.m\" \"$ios_src/cheng_mobile_ios_glue.m\"\n  cp \"$mobile_root/ios/cheng_mobile_host_ios.m\" \"$ios_src/cheng_mobile_host_ios.m\"\n\n  cp \"$app_c\" \"$ios_src/cheng_mobile_app.c\"\n  cp \"$runtime_c\" \"$ios_src/system_helpers.c\"\n  cp \"$runtime_h\" \"$ios_src/system_helpers.h\"\n  if [ -f \"$runtime_stb_image_h\" ]; then\n    cp \"$runtime_stb_image_h\" \"$ios_src/stb_image.h\"\n  fi\n\n  cp \"$mobile_root/bridge/cheng_mobile_bridge.h\" \"$ios_src/cheng_mobile_bridge.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.c\" \"$ios_src/cheng_mobile_host_api.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.h\" \"$ios_src/cheng_mobile_host_api.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.c\" \"$ios_src/cheng_mobile_host_core.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.h\" \"$ios_src/cheng_mobile_host_core.h\"\n\n  copy_assets_into \"$assets\" \"$ios_src/Assets\" \"$in\"\n  weave_plugins_ios \"$ios_project\"\n  echo \"[mobile-export] ios project: $ios_project\"\nfi\n\nif [ \"$with_harmony\" -eq 1 ]; then\n  harmony_project=\"$out/harmony_project\"\n  rm -rf \"$harmony_project\"\n  mkdir -p \"$harmony_project\"\n\n  cp -R \"$mobile_root/harmony/arkts_template/.\" \"$harmony_project/\"\n\n  harmony_native=\"$harmony_project/native\"\n  mkdir -p \"$harmony_native\"\n\n  cp \"$mobile_root/harmony/cheng_mobile_harmony_b"
        out = out + "ridge.c\" \"$harmony_project/cheng_mobile_harmony_bridge.c\"\n  cp \"$mobile_root/harmony/cheng_mobile_harmony_bridge.h\" \"$harmony_project/cheng_mobile_harmony_bridge.h\"\n  cp \"$mobile_root/harmony/cheng_mobile_host_harmony.c\" \"$harmony_project/cheng_mobile_host_harmony.c\"\n  cp \"$mobile_root/harmony/cheng_mobile_host_harmony.h\" \"$harmony_project/cheng_mobile_host_harmony.h\"\n  cp \"$mobile_root/harmony/cheng_gui_native_harmony.c\" \"$harmony_project/cheng_gui_native_harmony.c\"\n  cp \"$mobile_root/harmony/CMakeLists.txt\" \"$harmony_project/CMakeLists.txt\"\n\n  cp \"$app_c\" \"$harmony_project/cheng_mobile_app.c\"\n  cp \"$runtime_c\" \"$harmony_project/system_helpers.c\"\n  cp \"$runtime_h\" \"$harmony_project/system_helpers.h\"\n  if [ -f \"$runtime_stb_image_h\" ]; then\n    cp \"$runtime_stb_image_h\" \"$harmony_project/stb_image.h\"\n  fi\n\n  cp \"$mobile_root/bridge/cheng_mobile_bridge.h\" \"$harmony_project/cheng_mobile_bridge.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.c\" \"$harmony_project/cheng_mobile_host_api.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_api.h\" \"$harmony_project/cheng_mobile_host_api.h\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.c\" \"$harmony_project/cheng_mobile_host_core.c\"\n  cp \"$mobile_root/bridge/cheng_mobile_host_core.h\" \"$harmony_project/cheng_mobile_host_core.h\"\n\n  # Fix include path for exported native NAPI source.\n  if [ -f \"$harmony_native/cheng_mobile_harmony_napi.c\" ]; then\n    sed "
        out = out + "-i.bak 's#\"../../cheng_mobile_harmony_bridge.h\"#\"../cheng_mobile_harmony_bridge.h\"#g' \"$harmony_native/cheng_mobile_harmony_napi.c\"\n    rm -f \"$harmony_native/cheng_mobile_harmony_napi.c.bak\"\n  fi\n\n  mkdir -p \"$harmony_project/assets\"\n  copy_assets_into \"$assets\" \"$harmony_project/assets\" \"$in\"\n  weave_plugins_harmony \"$harmony_project\"\n  echo \"[mobile-export] harmony project: $harmony_project\"\nfi\n\necho \"[mobile-export] shim mode active (generated native demo stub from $in)\"\necho \"[mobile-export] out=$out\"\n"
        return out
    if id == "build_profile_backend_sample":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nif ! command -v cc >/dev/null 2>&1; then\n  echo \"[Error] missing C compiler: cc\" 1>&2\n  exit 2\nfi\n\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\nsrc_file=\"$repo_root/src/tooling/profile_backend_sample.c\"\nout_file=\"${1:-$repo_root/artifacts/bin/profile_backend_sample}\"\n\ncase \"$out_file\" in\n  /*) ;;\n  *) out_file=\"$PWD/$out_file\" ;;\nesac\n\nmkdir -p \"$(dirname \"$out_file\")\"\ncc -O2 -Wall -Wextra -pedantic -std=c11 \"$src_file\" -o \"$out_file\"\necho \"$out_file\"\n"
    if id == "build_unimaker_desktop":
        return "#!/usr/bin/env sh\n:\nset -eu\n\necho \"[Error] legacy desktop C export pipeline has been removed.\" 1>&2\necho \"  tip: use backend-only build via src/tooling/chengc.sh or src/tooling/chengb.sh\" 1>&2\nexit 2\n"
    if id == "cheng_pkg_fetch":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nusage: src/tooling/cheng_pkg_fetch.sh --lock:<file> [--cache:<dir>] [--root:<dir>] [--mode:local|p2p] \\\n  [--listen:<addr>] [--peer:<addr>] [--source-listen:<addr>] [--source-peer:<addr>] [--out:<file>] [--print-roots]\n\nNotes:\n  - Fetches package snapshots listed in a lock file.\n  - Supports tarball (format=tar) and source (format=source) packages.\n  - Extracts tarballs into cache/<cid>/ or pulls source files into cache/<cid>/.\nEOF\n}\n\nROOT=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\nCHENGC=\"src/tooling/chengc.sh\"\n\nresolve_chengc_bin() {\n  name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$ROOT\" \"$name\"\n}\n\nlock=\"\"\ncache_root=\"${PKG_CACHE:-chengcache/packages}\"\nstorage_root=\"${PKG_STORAGE_ROOT:-build/cheng_storage}\"\nmode=\"${PKG_MODE:-local}\"\nlisten_addr=\"${PKG_LISTEN:-}\"\npeer_env=\"${PKG_PEERS:-}\"\npeer_args=\"\"\nsource_listen_addr=\"${PKG_SOURCE_LISTEN:-}\"\nsource_peer_env=\"${PKG_SOURCE_PEERS:-}\"\nsource_peer_args=\"\"\nout=\"\"\nprint_roots=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --lock:*)\n      lock=\"${1#--lock:}\"\n      ;;\n    --cache:*)\n      cache_root=\"${1#--cache:}\"\n      ;;\n    --root:*)\n      storage_root=\"${1#--root:}\"\n      ;;\n    --mode:*)\n      mode=\"${1#--mode:}\"\n      ;;\n    --listen:*)\n      listen_addr=\"${1"
        out = out + "#--listen:}\"\n      ;;\n    --peer:*)\n      peer_args=\"$peer_args --peer:${1#--peer:}\"\n      ;;\n    --source-listen:*)\n      source_listen_addr=\"${1#--source-listen:}\"\n      ;;\n    --source-peer:*)\n      source_peer_args=\"$source_peer_args --source-peer:${1#--source-peer:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --print-roots)\n      print_roots=\"1\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$lock\" = \"\" ]; then\n  echo \"[Error] missing --lock\" 1>&2\n  usage\n  exit 2\nfi\n\nif [ ! -f \"$lock\" ]; then\n  echo \"[Error] lock not found: $lock\" 1>&2\n  exit 2\nfi\n\nif [ ! -x \"$CHENGC\" ]; then\n  echo \"[Error] chengc.sh not found: $CHENGC\" 1>&2\n  exit 2\nfi\n\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\npkg_source_bin=\"$(resolve_chengc_bin cheng_pkg_source)\"\n\nif [ ! -x \"$storage_bin\" ] || [ \"src/tooling/cheng_storage.cheng\" -nt \"$storage_bin\" ]; then\n  (cd \"$ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_storage.cheng --name:cheng_storage)\nfi\n\nif [ \"$peer_env\" != \"\" ]; then\n  old_ifs=\"$IFS\"\n  IFS=','\n  for peer in $peer_env; do\n    if [ \"$peer\" != \"\" ]; then\n      peer_args=\"$peer_args --peer:$peer\"\n    fi\n  done\n  IFS=\"$old_ifs\"\nfi\n\nlisten_arg=\"\"\nif [ \"$listen_addr\" != \"\" ]; th"
        out = out + "en\n  listen_arg=\"--listen:$listen_addr\"\nfi\nstorage_listen_arg=\"\"\nif [ \"$listen_addr\" != \"\" ]; then\n  storage_listen_arg=\"--storage-listen:$listen_addr\"\nfi\n\nif [ \"$source_peer_env\" != \"\" ]; then\n  old_ifs=\"$IFS\"\n  IFS=','\n  for peer in $source_peer_env; do\n    if [ \"$peer\" != \"\" ]; then\n      source_peer_args=\"$source_peer_args --source-peer:$peer\"\n    fi\n  done\n  IFS=\"$old_ifs\"\nfi\n\nsource_listen_arg=\"\"\nif [ \"$source_listen_addr\" != \"\" ]; then\n  source_listen_arg=\"--listen:$source_listen_addr\"\nfi\n\ndeps=\"$(awk '\n  function emit() {\n    if (pkg == \"\" || cid == \"\") {\n      if (section_seen) {\n        exit 3\n      }\n      return\n    }\n    if (format == \"\") { format = \"tar\" }\n    print pkg \"|\" cid \"|\" format\n    section_seen = 0\n  }\n  /^\\[\\[dependencies\\]\\]/ { emit(); pkg=\"\"; cid=\"\"; format=\"\"; section_seen=1; next }\n  /^[[:space:]]*package_id[[:space:]]*=/ {\n    if ($0 ~ /\"/) { gsub(/.*=\"/, \"\", $0); gsub(/\".*/, \"\", $0); pkg=$0 }\n  }\n  /^[[:space:]]*cid[[:space:]]*=/ {\n    if ($0 ~ /\"/) { gsub(/.*=\"/, \"\", $0); gsub(/\".*/, \"\", $0); cid=$0 }\n  }\n  /^[[:space:]]*format[[:space:]]*=/ {\n    if ($0 ~ /\"/) { gsub(/.*=\"/, \"\", $0); gsub(/\".*/, \"\", $0); format=$0 }\n  }\n  END { emit() }\n' \"$lock\")\" || {\n  if [ \"$?\" -eq 3 ]; then\n    echo \"[Error] invalid lock file: dependency entry missing package_id or cid\" 1>&2\n    exit 2\n  fi\n  exit 2\n}\n\nroots=\"\"\nold_"
        out = out + "ifs=\"$IFS\"\nIFS='\n'\nfor entry in $deps; do\n  pkg=\"${entry%%|*}\"\n  rest=\"${entry#*|}\"\n  cid=\"${rest%%|*}\"\n  fmt=\"${rest#*|}\"\n  if [ \"$fmt\" = \"\" ]; then\n    fmt=\"tar\"\n  fi\n  fmt=\"$(printf \"%s\" \"$fmt\" | tr 'A-Z' 'a-z')\"\n  if [ \"$fmt\" != \"tar\" ] && [ \"$fmt\" != \"source\" ]; then\n    echo \"[Error] unknown package format: $fmt\" 1>&2\n    exit 2\n  fi\n  if [ \"$cid\" = \"\" ]; then\n    continue\n  fi\n  cid_dir=\"$cid\"\n  case \"$cid_dir\" in\n    cid://*) cid_dir=\"${cid_dir#cid://}\" ;;\n    cid:*) cid_dir=\"${cid_dir#cid:}\" ;;\n  esac\n  if echo \"$cid_dir\" | grep -q '/'; then\n    echo \"[Error] invalid cid in lock: $cid\" 1>&2\n    exit 2\n  fi\n  pkg_dir=\"$cache_root/$cid_dir\"\n  if [ -f \"$pkg_dir/cheng-package.toml\" ]; then\n    if [ \"$roots\" = \"\" ]; then\n      roots=\"$pkg_dir\"\n    else\n      roots=\"$roots,$pkg_dir\"\n    fi\n    continue\n  fi\n  mkdir -p \"$pkg_dir\"\n  if [ \"$fmt\" = \"source\" ]; then\n    if [ ! -x \"$pkg_source_bin\" ] || [ \"src/tooling/cheng_pkg_source.cheng\" -nt \"$pkg_source_bin\" ]; then\n      (cd \"$ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_pkg_source.cheng --name:cheng_pkg_source)\n    fi\n    \"$pkg_source_bin\" fetch --manifest:\"$cid_dir\" --out:\"$pkg_dir\" --root:\"$storage_root\" --mode:\"$mode\" \\\n      $storage_listen_arg $peer_args $source_listen_arg $source_peer_args\n  else\n    if ! command -v tar >/dev/null 2>&1; then\n"
        out = out + "      echo \"[Error] tar not found\" 1>&2\n      exit 2\n    fi\n    tmp=\"$(mktemp \"$pkg_dir/pkg.XXXXXX.tar.gz\")\"\n    \"$storage_bin\" get --cid:\"$cid_dir\" --out:\"$tmp\" --root:\"$storage_root\" --mode:\"$mode\" $listen_arg $peer_args\n    tar -xzf \"$tmp\" -C \"$pkg_dir\"\n    rm -f \"$tmp\"\n  fi\n  if [ \"$roots\" = \"\" ]; then\n    roots=\"$pkg_dir\"\n  else\n    roots=\"$roots,$pkg_dir\"\n  fi\ndone\nIFS=\"$old_ifs\"\n\nif [ \"$out\" != \"\" ]; then\n  out_dir=\"$(dirname \"$out\")\"\n  if [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n    mkdir -p \"$out_dir\"\n  fi\n  echo \"$roots\" > \"$out\"\nfi\n\nif [ \"$print_roots\" != \"\" ]; then\n  echo \"$roots\"\nfi\n"
        return out
    if id == "cheng_pkg_pack":
        return "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nusage: src/tooling/cheng_pkg_pack.sh --src:<dir> --out:<file> [--exclude:<pattern>...]\n\nNotes:\n  - Packs a package directory into a .tar.gz snapshot.\n  - Default excludes: .git, chengcache, .cheng-cache, build, dist, out, tmp, tmp_build, __pycache__, .DS_Store\n  - Set PKG_EXCLUDE_DEFAULTS=0 to disable default excludes.\nEOF\n}\n\nsrc=\"\"\nout=\"\"\nextra_excludes=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --src:*)\n      src=\"${1#--src:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --exclude:*)\n      extra_excludes=\"$extra_excludes --exclude=${1#--exclude:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$src\" = \"\" ] || [ \"$out\" = \"\" ]; then\n  echo \"[Error] missing --src or --out\" 1>&2\n  usage\n  exit 2\nfi\n\nif [ ! -d \"$src\" ]; then\n  echo \"[Error] src dir not found: $src\" 1>&2\n  exit 2\nfi\n\nif ! command -v tar >/dev/null 2>&1; then\n  echo \"[Error] tar not found\" 1>&2\n  exit 2\nfi\n\nout_dir=\"$(dirname \"$out\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\nexclude_args=\"\"\nif [ \"${PKG_EXCLUDE_DEFAULTS:-1}\" != \"0\" ]; then\n  exclude_args=\"--exclude=.git --exclude=chengcache --exclude=.cheng-cache --exclude=build --exclude=dist --exclude=out --exclude=tmp --exclude=tmp_build --exclude=__pycache__ --exclude=.DS_Store\"\nfi\n\necho \"[pkg] pack: $src -> $out\"\ntar -czf \"$out\" $exclude_args $extra_excludes -C \"$src\" .\n"
    if id == "cheng_pkg_publish":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nusage: src/tooling/cheng_pkg_publish.sh --src:<dir> --package:<id> --author:<id> --channel:<edge|stable|lts> \\\n  --epoch:<n> --priv:<key> [--format:<tar|source>] [--source-addr:<addr>] [--manifest-out:<file>] \\\n  [--registry:<path>] [--storage-root:<dir>] [--mode:local|p2p] [--listen:<addr>] [--peer:<addr>] \\\n  [--artifact:<file>]\n\nNotes:\n  - Packs a package directory (tar) or publishes source manifest (source) and publishes a registry snapshot.\n  - format=tar uses a .tar.gz snapshot; format=source stores a manifest and serves files read-only.\nEOF\n}\n\nROOT=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\nCHENGC=\"src/tooling/chengc.sh\"\n\nresolve_chengc_bin() {\n  name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$ROOT\" \"$name\"\n}\n\nsrc=\"\"\npackage_id=\"\"\nauthor_id=\"\"\nchannel=\"\"\nepoch=\"\"\npriv_key=\"\"\nregistry_path=\"build/cheng_registry/registry.jsonl\"\nstorage_root=\"build/cheng_storage\"\nmode=\"${PKG_MODE:-local}\"\nlisten_addr=\"${PKG_LISTEN:-}\"\npeer_args=\"\"\nartifact=\"\"\nformat=\"tar\"\nsource_addrs=\"\"\nmanifest_out=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --src:*)\n      src=\"${1#--src:}\"\n      ;;\n    --package:*)\n      package_id=\"${1#--package:}\"\n      ;;\n    --author:*)\n      author_id=\"${1#--author:}\"\n      ;;\n    --channel:*"
        out = out + ")\n      channel=\"${1#--channel:}\"\n      ;;\n    --epoch:*)\n      epoch=\"${1#--epoch:}\"\n      ;;\n    --priv:*)\n      priv_key=\"${1#--priv:}\"\n      ;;\n    --registry:*)\n      registry_path=\"${1#--registry:}\"\n      ;;\n    --storage-root:*)\n      storage_root=\"${1#--storage-root:}\"\n      ;;\n    --mode:*)\n      mode=\"${1#--mode:}\"\n      ;;\n    --listen:*)\n      listen_addr=\"${1#--listen:}\"\n      ;;\n    --peer:*)\n      peer_args=\"$peer_args --peer:${1#--peer:}\"\n      ;;\n    --artifact:*)\n      artifact=\"${1#--artifact:}\"\n      ;;\n    --format:*)\n      format=\"${1#--format:}\"\n      ;;\n    --source)\n      format=\"source\"\n      ;;\n    --source-addr:*)\n      source_addrs=\"$source_addrs --source-addr:${1#--source-addr:}\"\n      ;;\n    --manifest-out:*)\n      manifest_out=\"${1#--manifest-out:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nformat=\"$(printf \"%s\" \"$format\" | tr 'A-Z' 'a-z')\"\nif [ \"$format\" != \"tar\" ] && [ \"$format\" != \"source\" ]; then\n  echo \"[Error] unknown format: $format\" 1>&2\n  exit 2\nfi\n\nif [ \"$src\" = \"\" ] || [ \"$package_id\" = \"\" ] || [ \"$author_id\" = \"\" ] || [ \"$channel\" = \"\" ] || [ \"$epoch\" = \"\" ] || [ \"$priv_key\" = \"\" ]; then\n  echo \"[Error] missing required args\" 1>&2\n  usage\n  exit 2\nfi\n\nif [ ! -d \"$src\" ]; th"
        out = out + "en\n  echo \"[Error] src dir not found: $src\" 1>&2\n  exit 2\nfi\n\nif [ ! -x \"$CHENGC\" ]; then\n  echo \"[Error] chengc.sh not found: $CHENGC\" 1>&2\n  exit 2\nfi\n\npkg_source_bin=\"$(resolve_chengc_bin cheng_pkg_source)\"\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\nregistry_bin=\"$(resolve_chengc_bin cheng_registry)\"\n\nif [ \"$format\" = \"source\" ]; then\n  if [ ! -x \"$pkg_source_bin\" ] || [ \"src/tooling/cheng_pkg_source.cheng\" -nt \"$pkg_source_bin\" ]; then\n    (cd \"$ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_pkg_source.cheng --name:cheng_pkg_source)\n  fi\n  manifest_arg=\"\"\n  if [ \"$manifest_out\" != \"\" ]; then\n    manifest_arg=\"--manifest-out:$manifest_out\"\n  fi\n  listen_arg=\"\"\n  if [ \"$listen_addr\" != \"\" ]; then\n    listen_arg=\"--storage-listen:$listen_addr\"\n  fi\n  \"$pkg_source_bin\" publish --src:\"$src\" --package:\"$package_id\" --author:\"$author_id\" --channel:\"$channel\" \\\n    --epoch:\"$epoch\" --priv:\"$priv_key\" --registry:\"$registry_path\" --root:\"$storage_root\" --mode:\"$mode\" \\\n    $listen_arg $peer_args $source_addrs $manifest_arg\n  exit 0\nfi\n\nsanitize_pkg() {\n  echo \"$1\" | tr ':/.' '_' | tr -s '_'\n}\n\nif [ \"$artifact\" = \"\" ]; then\n  safe_name=\"$(sanitize_pkg \"$package_id\")\"\n  artifact=\"$ROOT/chengcache/pkg_artifacts/${safe_name}-epoch${epoch}.tar.gz\"\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_pkg_pack -"
        out = out + "-src:\"$src\" --out:\"$artifact\"\n\nif [ ! -x \"$storage_bin\" ] || [ \"src/tooling/cheng_storage.cheng\" -nt \"$storage_bin\" ]; then\n  (cd \"$ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_storage.cheng --name:cheng_storage)\nfi\nif [ ! -x \"$registry_bin\" ] || [ \"src/tooling/cheng_registry.cheng\" -nt \"$registry_bin\" ]; then\n  (cd \"$ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_registry.cheng --name:cheng_registry)\nfi\n\nlisten_arg=\"\"\nif [ \"$listen_addr\" != \"\" ]; then\n  listen_arg=\"--listen:$listen_addr\"\nfi\n\ncid=\"$(\"$storage_bin\" put --file:\"$artifact\" --root:\"$storage_root\" --mode:\"$mode\" $listen_arg $peer_args | tail -n 1)\"\nif [ \"$cid\" = \"\" ]; then\n  echo \"[Error] missing cid from cheng_storage\" 1>&2\n  exit 2\nfi\n\n\"$registry_bin\" publish --package:\"$package_id\" --author:\"$author_id\" --channel:\"$channel\" --epoch:\"$epoch\" \\\n  --cid:\"$cid\" --priv:\"$priv_key\" --format:tar --registry:\"$registry_path\"\n\necho \"[pkg] published $package_id@$channel epoch=$epoch cid=$cid\"\necho \"[pkg] artifact: $artifact\"\n"
        return out
    if id == "cheng_rwad_bridge":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nusage: cheng_rwad_bridge.sh <command> [args]\n\ncommands:\n  export --epoch:<n> [--ledger:<path>] [--root:<dir>] [--out:<file>]\n         [--batch-id:<id>] [--schema:<id>] [--top:<n>]\n  apply  --result:<file> [--batch:<file>] [--out:<file>] [--batch-id:<id>] [--require-status:<status>]\n         [--require-result-schema:<id>] [--require-request-schema:<id>]\nEOF\n}\n\nREPO_ROOT=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\n\nresolve_chengc_bin() {\n  local name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$REPO_ROOT\" \"$name\"\n}\n\ncheng_storage_bin=\"${STORAGE_BIN:-$(resolve_chengc_bin cheng_storage)}\"\n\nensure_cheng_storage_bin() {\n  if [ -x \"$cheng_storage_bin\" ] && [ \"$REPO_ROOT/src/tooling/cheng_storage.cheng\" -ot \"$cheng_storage_bin\" ]; then\n    return 0\n  fi\n  (cd \"$REPO_ROOT\" && ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_storage.cheng --name:cheng_storage >/dev/null)\n  if [ ! -x \"$cheng_storage_bin\" ]; then\n    echo \"export: missing cheng_storage binary: $cheng_storage_bin\" 1>&2\n    return 1\n  fi\n  return 0\n}\n\njson_escape() {\n  printf '%s' \"$1\" | sed 's/\\\\/\\\\\\\\/g; s/\"/\\\\\"/g'\n}\n\nextract_json_string() {\n  local key=\"$1\"\n  local file=\"$2\"\n  grep -o \"\\\"${key}\\\"[[:space:]]*:[[:space"
        out = out + ":]]*\\\"[^\\\"]*\\\"\" \"$file\" | head -n 1 | sed -n 's/^[^\"]*\"[^\"]*\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\"$/\\1/p'\n}\n\nextract_json_int() {\n  local key=\"$1\"\n  local file=\"$2\"\n  grep -o \"\\\"${key}\\\"[[:space:]]*:[[:space:]]*-*[0-9][0-9]*\" \"$file\" | head -n 1 | sed -n 's/^[^0-9-]*\\(-*[0-9][0-9]*\\)$/\\1/p'\n}\n\nextract_json_object() {\n  local key=\"$1\"\n  local file=\"$2\"\n  sed -n \"s/.*\\\"${key}\\\"[[:space:]]*:[[:space:]]*\\\\({[^}]*}\\\\).*/\\\\1/p\" \"$file\" | head -n 1\n}\n\nsha256_file() {\n  local file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  return 1\n}\n\ncmd_export() {\n  local root=\"build/cheng_storage\"\n  local epoch=\"-1\"\n  local ledger=\"\"\n  local out=\"\"\n  local top=\"0\"\n  local batch_id=\"\"\n  local schema=\"cheng-rwad-settlement/v1\"\n\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --root:*) root=\"${1#--root:}\" ;;\n      --epoch:*) epoch=\"${1#--epoch:}\" ;;\n      --ledger:*) ledger=\"${1#--ledger:}\" ;;\n      --out:*) out=\"${1#--out:}\" ;;\n      --top:*) top=\"${1#--top:}\" ;;\n      --batch-id:*) batch_id=\"${1#--batch-id:}\" ;;\n      --schema:*) schema=\"${1#--schema:}\" ;;\n      *) echo \"export: unknown arg: $1\" 1>&2; return 1 ;;\n    esac\n    shift\n  done\n\n  if [ -z \"$ledger\" ]; then\n    ledger=\"$(cd \""
        out = out + "$(dirname \"$root\")\" >/dev/null 2>&1 && pwd)/$(basename \"$root\")/ledger.jsonl\"\n    if [ ! -f \"$ledger\" ] && [ -d \"$root\" ]; then\n      ledger=\"$(cd \"$root\" >/dev/null 2>&1 && pwd)/ledger.jsonl\"\n    fi\n  fi\n\n  if [ -z \"$batch_id\" ]; then\n    if [ \"$epoch\" = \"-1\" ]; then\n      batch_id=\"cheng-epoch-all\"\n    else\n      batch_id=\"cheng-epoch-$epoch\"\n    fi\n  fi\n\n  local tmp\n  tmp=\"$(mktemp)\"\n  ensure_cheng_storage_bin || return 1\n  \"$cheng_storage_bin\" settle --epoch:\"$epoch\" --ledger:\"$ledger\" --root:\"$root\" --format:json --top:\"$top\" --out:\"$tmp\"\n  local settlement_sha256\n  settlement_sha256=\"$(sha256_file \"$tmp\")\"\n  if [ -z \"$settlement_sha256\" ]; then\n    echo \"export: failed to compute settlement sha256\" 1>&2\n    rm -f \"$tmp\"\n    return 1\n  fi\n\n  local payload\n  payload=\"$(mktemp)\"\n  {\n    printf '{\"schema_version\":\"%s\",\"source\":\"cheng-lang/cheng_rwad_bridge.sh\",\"batch_id\":\"%s\",\"epoch\":%s,\"ledger_path\":\"%s\",\"settlement_sha256\":\"%s\",\"settlement\":' \\\n      \"$(json_escape \"$schema\")\" \"$(json_escape \"$batch_id\")\" \"$epoch\" \"$(json_escape \"$ledger\")\" \"$(json_escape \"$settlement_sha256\")\"\n    cat \"$tmp\"\n    printf '}\\n'\n  } > \"$payload\"\n\n  if [ -n \"$out\" ]; then\n    mkdir -p \"$(dirname \"$out\")\"\n    cp \"$payload\" \"$out\"\n  else\n    cat \"$payload\"\n  fi\n  rm -f \"$tmp\" \"$payload\"\n}\n\ncmd_apply() {\n  local result=\"\"\n  local batch_"
        out = out + "file=\"\"\n  local out=\"\"\n  local batch_id_expect=\"\"\n  local require_status=\"\"\n  local require_result_schema=\"rwad-cheng-settlement-result/v1\"\n  local require_request_schema=\"cheng-rwad-settlement/v1\"\n  while [ $# -gt 0 ]; do\n    case \"$1\" in\n      --result:*) result=\"${1#--result:}\" ;;\n      --batch:*) batch_file=\"${1#--batch:}\" ;;\n      --out:*) out=\"${1#--out:}\" ;;\n      --batch-id:*) batch_id_expect=\"${1#--batch-id:}\" ;;\n      --require-status:*) require_status=\"${1#--require-status:}\" ;;\n      --require-result-schema:*) require_result_schema=\"${1#--require-result-schema:}\" ;;\n      --require-request-schema:*) require_request_schema=\"${1#--require-request-schema:}\" ;;\n      *) echo \"apply: unknown arg: $1\" 1>&2; return 1 ;;\n    esac\n    shift\n  done\n\n  if [ -z \"$result\" ]; then\n    echo \"apply: missing --result\" 1>&2\n    return 1\n  fi\n  if [ ! -f \"$result\" ]; then\n    echo \"apply: missing result file: $result\" 1>&2\n    return 1\n  fi\n  if [ -n \"$batch_file\" ] && [ ! -f \"$batch_file\" ]; then\n    echo \"apply: missing batch file: $batch_file\" 1>&2\n    return 1\n  fi\n\n  local result_schema\n  local request_schema\n  local batch_id\n  local status\n  local settlement_sha256\n  local epoch\n  local totals\n  result_schema=\"$(extract_json_string \"schema_version\" \"$result\")\"\n  request_schema=\"$(extract_json_string \"request_schema\" \"$result\")\"\n  batch_id=\"$(extract_json_string \"batch_id\" \"$re"
        out = out + "sult\")\"\n  status=\"$(extract_json_string \"status\" \"$result\")\"\n  settlement_sha256=\"$(extract_json_string \"settlement_sha256\" \"$result\")\"\n  epoch=\"$(extract_json_int \"epoch\" \"$result\")\"\n  totals=\"$(extract_json_object \"totals\" \"$result\")\"\n  if [ -z \"$epoch\" ]; then\n    epoch=\"0\"\n  fi\n\n  if [ -z \"$result_schema\" ]; then\n    echo \"apply: missing schema_version\" 1>&2\n    return 1\n  fi\n  if [ -z \"$request_schema\" ]; then\n    echo \"apply: missing request_schema\" 1>&2\n    return 1\n  fi\n  if [ -z \"$batch_id\" ]; then\n    echo \"apply: missing batch_id\" 1>&2\n    return 1\n  fi\n  if [ -z \"$settlement_sha256\" ]; then\n    echo \"apply: missing settlement_sha256\" 1>&2\n    return 1\n  fi\n  if [ -n \"$require_result_schema\" ] && [ \"$result_schema\" != \"$require_result_schema\" ]; then\n    echo \"apply: result schema mismatch: got=$result_schema expect=$require_result_schema\" 1>&2\n    return 1\n  fi\n  if [ -n \"$require_request_schema\" ] && [ \"$request_schema\" != \"$require_request_schema\" ]; then\n    echo \"apply: request schema mismatch: got=$request_schema expect=$require_request_schema\" 1>&2\n    return 1\n  fi\n  if [ -n \"$batch_id_expect\" ] && [ \"$batch_id\" != \"$batch_id_expect\" ]; then\n    echo \"apply: batch id mismatch: got=$batch_id expect=$batch_id_expect\" 1>&2\n    return 1\n  fi\n  if [ -n \"$require_status\" ] && [ \"$status\" != \"$require_status\" ]; then\n    echo \"apply: status mismatch: "
        out = out + "got=$status expect=$require_status\" 1>&2\n    return 1\n  fi\n  if [ -z \"$totals\" ]; then\n    echo \"apply: missing totals\" 1>&2\n    return 1\n  fi\n\n  if [ -n \"$batch_file\" ]; then\n    local batch_schema\n    local batch_id_from_file\n    local batch_sha256\n    batch_schema=\"$(extract_json_string \"schema_version\" \"$batch_file\")\"\n    batch_id_from_file=\"$(extract_json_string \"batch_id\" \"$batch_file\")\"\n    batch_sha256=\"$(extract_json_string \"settlement_sha256\" \"$batch_file\")\"\n    if [ -z \"$batch_schema\" ] || [ -z \"$batch_id_from_file\" ] || [ -z \"$batch_sha256\" ]; then\n      echo \"apply: invalid batch file payload\" 1>&2\n      return 1\n    fi\n    if [ -n \"$require_request_schema\" ] && [ \"$batch_schema\" != \"$require_request_schema\" ]; then\n      echo \"apply: batch schema mismatch: got=$batch_schema expect=$require_request_schema\" 1>&2\n      return 1\n    fi\n    if [ -z \"$batch_id_expect\" ]; then\n      batch_id_expect=\"$batch_id_from_file\"\n    fi\n    if [ \"$batch_id\" != \"$batch_id_from_file\" ]; then\n      echo \"apply: batch id mismatch between result and batch: result=$batch_id batch=$batch_id_from_file\" 1>&2\n      return 1\n    fi\n    if [ \"$settlement_sha256\" != \"$batch_sha256\" ]; then\n      echo \"apply: settlement_sha256 mismatch between result and batch\" 1>&2\n      return 1\n    fi\n  fi\n\n  local ack\n  ack=\"$(mktemp)\"\n  printf '{\"ok\":true,\"schema_version\":\"cheng-rwad-ack/v1\",\"applied_f"
        out = out + "rom\":\"%s\",\"request_schema\":\"%s\",\"batch_id\":\"%s\",\"status\":\"%s\",\"epoch\":%s,\"settlement_sha256\":\"%s\",\"totals\":%s,\"result_file\":\"%s\"}\\n' \\\n    \"$(json_escape \"$result_schema\")\" \"$(json_escape \"$request_schema\")\" \"$(json_escape \"$batch_id\")\" \"$(json_escape \"$status\")\" \"$epoch\" \"$(json_escape \"$settlement_sha256\")\" \"$totals\" \"$(json_escape \"$result\")\" > \"$ack\"\n\n  if [ -n \"$out\" ]; then\n    mkdir -p \"$(dirname \"$out\")\"\n    cp \"$ack\" \"$out\"\n  else\n    cat \"$ack\"\n  fi\n  rm -f \"$ack\"\n}\n\nmain() {\n  if [ $# -lt 1 ]; then\n    usage\n    return 1\n  fi\n  local cmd=\"$1\"\n  shift\n  case \"$cmd\" in\n    export) cmd_export \"$@\" ;;\n    apply) cmd_apply \"$@\" ;;\n    --help|-h|help) usage ;;\n    *) echo \"unknown command: $cmd\" 1>&2; usage; return 1 ;;\n  esac\n}\n\nmain \"$@\"\n"
        return out
    if id == "cheng_tooling":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsrc=\"src/tooling/cheng_tooling.cheng\"\nbin=\"${TOOLING_BIN:-$root/artifacts/tooling_cmd/cheng_tooling}\"\nforce_build=\"${TOOLING_FORCE_BUILD:-0}\"\ntooling_linker=\"${TOOLING_LINKER:-system}\"\nbuild_driver=\"${TOOLING_BUILD_DRIVER:-}\"\n\nif [ ! -f \"$src\" ]; then\n  echo \"[cheng_tooling] source not found: $src\" 1>&2\n  exit 1\nfi\n\nneed_build=\"0\"\nif [ ! -x \"$bin\" ]; then\n  need_build=\"1\"\nelif [ \"$src\" -nt \"$bin\" ]; then\n  need_build=\"1\"\nfi\ncase \"$force_build\" in\n  1|true|TRUE|yes|YES|on|ON) need_build=\"1\" ;;\nesac\n\nif [ \"$need_build\" = \"1\" ]; then\n  mkdir -p \"$(dirname \"$bin\")\"\n  if [ \"$build_driver\" = \"\" ]; then\n    if [ -x \"artifacts/backend_seed/cheng.stage2\" ]; then\n      build_driver=\"artifacts/backend_seed/cheng.stage2\"\n    else\n      build_driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n    fi\n  fi\n  # tooling launcher itself uses argv pointer entry; build it under non-C-ABI pointer exemption.\n  BACKEND_DRIVER=\"$build_driver\" \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$src\" --out:\"$bin\" --abi:v2_noptr --linker:\"$tooling_linker\"\nfi\n\nexport TOOLING_ROOT=\"$root\"\nexec \"$bin\" \"$@\"\n"
    if id == "chengb":
        return "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/chengb.sh <file.cheng> [legacy chengb flags...]\n\nNotes:\n  - `chengb.sh` is now a compatibility wrapper around `src/tooling/chengc.sh`.\n  - Legacy flags (`--emit/--frontend/--out/--multi/--pkg-roots/--run`) are forwarded.\n  - When `--out` is omitted, default output stays under `artifacts/chengb/` for compatibility.\nEOF\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nemit=\"exe\"\nhas_out=\"0\"\nfor arg in \"$@\"; do\n  case \"$arg\" in\n    --emit:*)\n      emit=\"${arg#--emit:}\"\n      ;;\n    --out:*)\n      has_out=\"1\"\n      ;;\n  esac\ndone\n\nif [ \"$has_out\" = \"0\" ]; then\n  base=\"$(basename \"$in\" .cheng)\"\n  out_dir=\"$root/artifacts/chengb\"\n  mkdir -p \"$out_dir\"\n  case \"$emit\" in\n    obj) default_out=\"$out_dir/${base}.o\" ;;\n    *) default_out=\"$out_dir/${base}\" ;;\n  esac\n  set -- \"$@\" \"--out:$default_out\"\nfi\n\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$in\" \"$@\"\n"
    if id == "chengc":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'USAGE'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc <file.cheng> [--name:<exeName>] [--jobs:<N>]\n                        [--manifest:<path>] [--lock:<path>] [--registry:<path>]\n                        [--package:<id>] [--channel:<edge|stable|lts>]\n                        [--lock-format:<toml|yaml|json>] [--meta-out:<path>]\n                        [--buildmeta:<path>]\n                        [--abi:<v2_noptr>]\n                        [--linker:<self|system>]\n                        [--target:<triple>]\n                        [--pkg-cache:<dir>] [--skip-pkg] [--verify] [--ledger:<path>]\n                        [--source-listen:<addr>] [--source-peer:<addr>]\n                        [--mm:<orc>] [--orc]\n                        [--release]\n                        [--emit:<exe>] [--frontend:<stage1>]\n                        [--out:<path>] [--multi] [--pkg-roots:<p1[:p2:...]>]\n                        [--run] [--run:file] [--run:host]\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run <android|ios|harmony> <file.cheng> [mobile-run-options]\n\nNotes:\n  - Backend-only entrypoint (exe only).\n  - Default build track is dev (`BACKEND_BUILD_TRACK=dev`).\n  - `--release` maps to `BACKEND_BUILD_TRACK=release` and defaults linker to system.\n  - Optional compile daemon: set `CHENGC_DAEMON=1` to route builds through `chengc_daemon`.\n  - `--run` defaults to host runn"
        out = out + "er (`--run:host`); use `--run:file` for legacy file-exec mode.\n  - Default `MM=orc`.\n  - Executable output for bare `--name:<bin>` defaults to `artifacts/chengc/<bin>`.\n  - `--jobs:<N>` forwards to `BACKEND_JOBS`.\n  - Legacy `chengb.sh` flags are accepted for compatibility.\n  - `run <platform>` forwards to mobile host runners:\n      android -> ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_android\n      ios     -> ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_ios\n      harmony -> ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_harmony\nUSAGE\n}\n\nusage_run() {\n  cat <<'USAGE'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run android <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--serial:<adbSerial>] [--native] [--app-arg:<k=v>]... [--app-args-json:<abs_path>] [--no-build] [--no-install] [--no-run] [--mm:<orc>] [--orc]\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run ios <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run harmony <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n\nExamples:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run android examples/mobile_hello.cheng\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_too"
        out = out + "ling} chengc run ios examples/mobile_hello.cheng --name:demo_ios\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run harmony examples/mobile_hello.cheng\nUSAGE\n}\n\ndetect_jobs() {\n  jobs=\"\"\n  if command -v getconf >/dev/null 2>&1; then\n    jobs=\"$(getconf _NPROCESSORS_ONLN 2>/dev/null || true)\"\n  fi\n  if [ -z \"$jobs\" ] && command -v nproc >/dev/null 2>&1; then\n    jobs=\"$(nproc 2>/dev/null || true)\"\n  fi\n  if [ -z \"$jobs\" ] && command -v sysctl >/dev/null 2>&1; then\n    jobs=\"$(sysctl -n hw.logicalcpu 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || true)\"\n  fi\n  case \"$jobs\" in\n    ''|*[!0-9]*) jobs=\"4\" ;;\n  esac\n  if [ \"$jobs\" -lt 1 ] 2>/dev/null; then\n    jobs=\"4\"\n  fi\n  printf '%s\\n' \"$jobs\"\n}\n\ncleanup_backend_exe_sidecar() (\n  cleanup_out=\"$1\"\n  case \"${BACKEND_KEEP_EXE_OBJ:-0}\" in\n    1|true|TRUE|yes|YES|on|ON)\n      return 0\n      ;;\n  esac\n  cleanup_sidecar=\"${cleanup_out}.o\"\n  if [ -f \"$cleanup_sidecar\" ]; then\n    rm -f \"$cleanup_sidecar\"\n  fi\n)\n\nis_true_flag() {\n  case \"${1:-}\" in\n    1|true|TRUE|yes|YES|on|ON)\n      return 0\n      ;;\n  esac\n  return 1\n}\n\nhas_fuse_ld_flag() {\n  flags=\"$1\"\n  case \"$flags\" in\n    *-fuse-ld=*) return 0 ;;\n  esac\n  return 1\n}\n\nresolve_named_exe_out() {\n  name_in=\"$1\"\n  case \"$name_in\" in\n    /*|*/*)\n      printf '%s\\n' \"$name_in\"\n      return\n      ;;\n  esac\n  printf 'artifacts/chengc/%s\\n' \"$name_in\"\n}\n\nnor"
        out = out + "malize_output_path() {\n  raw=\"$1\"\n  case \"$raw\" in\n    ''|-) printf '%s\\n' \"$raw\" ;;\n    /*|*/*|*\\\\*) printf '%s\\n' \"$raw\" ;;\n    *) printf 'artifacts/chengc/%s\\n' \"$raw\" ;;\n  esac\n}\n\ntarget_supports_self_linker() {\n  t=\"$1\"\n  case \"$t\" in\n    *darwin*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*riscv64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$t\" in\n        *arm64*|*aarch64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nif [ \"${CHENGC_DAEMON:-0}\" = \"1\" ] && [ \"${CHENGC_DAEMON_ACTIVE:-0}\" != \"1\" ] && [ \"${1:-}\" != \"run\" ]; then\n  exec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc_daemon run -- \"$@\"\nfi\n\nif [ \"${1:-}\" = \"run\" ]; then\n  shift || true\n  mobile_platform=\"${1:-}\"\n  if [ \"$mobile_platform\" = \"\" ] || [ \"$mobile_platform\" = \"--help\" ] || [ \"$mobile_platform\" = \"-h\" ]; then\n    usage_run\n    exit 0\n  fi\n  shift || true\n  root=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\n  case \"$mobile_platform\" in\n    android)\n      exec \"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" mobile_run_android \"$@\"\n      ;;\n    ios)\n      e"
        out = out + "xec \"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" mobile_run_ios \"$@\"\n      ;;\n    harmony)\n      exec \"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" mobile_run_harmony \"$@\"\n      ;;\n    *)\n      echo \"[Error] unknown mobile platform: $mobile_platform\" 1>&2\n      usage_run 1>&2\n      exit 2\n      ;;\n  esac\nfi\n\nin=\"$1\"\nshift || true\n\nname=\"\"\njobs=\"\"\njobs_explicit=\"0\"\nmanifest=\"\"\nlock=\"\"\nregistry=\"\"\npackage_id=\"\"\nchannel=\"stable\"\nlock_format=\"toml\"\nmeta_out=\"\"\nbuildmeta=\"\"\npkg_cache=\"\"\nskip_pkg=\"\"\nverify_meta=\"\"\nledger=\"\"\nsource_listen=\"\"\nsource_peer_args=\"\"\nmm=\"\"\nemit_obj=\"\"\nobj_out=\"\"\nbackend=\"\"\nlinker=\"\"\ntarget_arg=\"\"\nabi=\"\"\nbuild_track_arg=\"\"\nlegacy_emit=\"\"\nlegacy_frontend=\"\"\nlegacy_out=\"\"\nlegacy_multi=\"\"\nlegacy_pkg_roots=\"\"\nlegacy_run=\"\"\nrun_mode=\"\"\npkg_tool=\"${PKG_TOOL:-chengcache/tools/cheng_pkg}\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*) name=\"${1#--name:}\" ;;\n    --jobs:*)\n      jobs=\"${1#--jobs:}\"\n      jobs_explicit=\"1\"\n      ;;\n    --manifest:*) manifest=\"${1#--manifest:}\" ;;\n    --lock:*) lock=\"${1#--lock:}\" ;;\n    --registry:*) registry=\"${1#--registry:}\" ;;\n    --package:*) package_id=\"${1#--package:}\" ;;\n    --channel:*) channel=\"${1#--channel:}\" ;;\n    --lock-format:*) lock_format=\"${1#--lock-format:}\" ;;\n    --meta-out:*) meta_out=\"${1#--meta-out:}\" ;;\n "
        out = out + "   --buildmeta:*) buildmeta=\"${1#--buildmeta:}\" ;;\n    --backend:obj) backend=\"obj\" ;;\n    --emit-obj)\n      emit_obj=\"1\"\n      backend=\"obj\"\n      ;;\n    --obj-out:*) obj_out=\"${1#--obj-out:}\" ;;\n    --abi:*) abi=\"${1#--abi:}\" ;;\n    --linker:*) linker=\"${1#--linker:}\" ;;\n    --target:*) target_arg=\"${1#--target:}\" ;;\n    --release) build_track_arg=\"release\" ;;\n    --emit:*) legacy_emit=\"${1#--emit:}\" ;;\n    --frontend:*) legacy_frontend=\"${1#--frontend:}\" ;;\n    --out:*) legacy_out=\"${1#--out:}\" ;;\n    --multi) legacy_multi=\"1\" ;;\n    --pkg-roots:*) legacy_pkg_roots=\"${1#--pkg-roots:}\" ;;\n    --run)\n      legacy_run=\"1\"\n      if [ \"$run_mode\" = \"\" ]; then\n        run_mode=\"host\"\n      fi\n      ;;\n    --run:file)\n      legacy_run=\"1\"\n      run_mode=\"file\"\n      ;;\n    --run:host)\n      legacy_run=\"1\"\n      run_mode=\"host\"\n      ;;\n    --pkg-cache:*) pkg_cache=\"${1#--pkg-cache:}\" ;;\n    --skip-pkg) skip_pkg=\"1\" ;;\n    --verify) verify_meta=\"1\" ;;\n    --ledger:*) ledger=\"${1#--ledger:}\" ;;\n    --source-listen:*) source_listen=\"${1#--source-listen:}\" ;;\n    --source-peer:*) source_peer_args=\"$source_peer_args --source-peer:${1#--source-peer:}\" ;;\n    --orc) mm=\"orc\" ;;\n    --mm:*) mm=\"${1#--mm:}\" ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\ncase \"$abi\" in\n  \"\"|v2_noptr) ;;\n  *)\n    echo \"[Error"
        out = out + "] invalid --abi:$abi (expected v2_noptr; enforced by ZRPC/)\" 1>&2\n    exit 2\n    ;;\nesac\n\ncase \"$legacy_emit\" in\n  \"\"|obj|exe) ;;\n  *)\n    echo \"[Error] invalid --emit:$legacy_emit (expected obj|exe)\" 1>&2\n    exit 2\n    ;;\nesac\n\ncase \"$legacy_frontend\" in\n  \"\"|stage1) ;;\n  *)\n    echo \"[Error] invalid --frontend:$legacy_frontend (expected stage1)\" 1>&2\n    exit 2\n    ;;\nesac\n\nif [ \"$legacy_emit\" = \"exe\" ] && [ \"$emit_obj\" != \"\" ]; then\n  echo \"[Error] conflicting emit flags: --emit:exe with --emit-obj/--obj-out\" 1>&2\n  exit 2\nfi\nif [ \"$legacy_emit\" = \"obj\" ]; then\n  emit_obj=\"1\"\n  backend=\"obj\"\nfi\nobj_requested=\"0\"\nif [ \"$emit_obj\" != \"\" ] || [ \"$backend\" = \"obj\" ] || [ \"$legacy_emit\" = \"obj\" ] || [ \"$obj_out\" != \"\" ]; then\n  obj_requested=\"1\"\nfi\nallow_emit_obj=\"${BACKEND_INTERNAL_ALLOW_EMIT_OBJ:-${BACKEND_INTERNAL_ALLOW_EMIT_OBJ:-0}}\"\nif [ \"$obj_requested\" = \"1\" ] && [ \"$allow_emit_obj\" != \"1\" ]; then\n  echo \"[Error] obj output path has been removed from production chain; use --emit:exe\" 1>&2\n  echo \"[Hint] set BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 for internal tooling only\" 1>&2\n  exit 2\nfi\nif [ \"$obj_requested\" = \"1\" ] && [ \"$obj_out\" = \"\" ]; then\n  echo \"[Error] --emit-obj requires --obj-out:<path>\" 1>&2\n  exit 2\nfi\n\nif [ \"$mm\" = \"\" ]; then\n  mm=\"${MM:-orc}\"\nfi\ncase \"$mm\" in\n  \"\"|orc)\n    mm=\"orc\"\n    ;;\n  *)\n"
        out = out + "    echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n    exit 2\n    ;;\nesac\nexport MM=\"$mm\"\n\nif [ \"$jobs\" = \"\" ]; then\n  jobs=\"$(detect_jobs)\"\nfi\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] file not found: $in\" 1>&2\n  exit 2\nfi\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\nexe_out_path=\"$(resolve_named_exe_out \"$name\")\"\nbuildmeta_output=\"$exe_out_path\"\nif [ \"$legacy_out\" != \"\" ]; then\n  buildmeta_output=\"$legacy_out\"\nfi\n\nif [ \"$backend\" = \"\" ]; then\n  case \"${CHENGC_DEFAULT_BACKEND:-}\" in\n    \"\"|auto|exe)\n      backend=\"exe\"\n      ;;\n    *)\n      echo \"[Error] invalid CHENGC_DEFAULT_BACKEND: ${CHENGC_DEFAULT_BACKEND} (expected auto|exe)\" 1>&2\n      exit 2\n      ;;\n  esac\nfi\n\nif [ \"$backend\" != \"exe\" ] && [ \"$backend\" != \"obj\" ]; then\n  echo \"[Error] unsupported backend: $backend (expected exe|obj)\" 1>&2\n  exit 2\nfi\nif [ \"$backend\" = \"obj\" ] && [ \"$allow_emit_obj\" != \"1\" ]; then\n  echo \"[Error] unsupported backend: obj (only --emit:exe is supported)\" 1>&2\n  echo \"[Hint] set BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 for internal tooling only\" 1>&2\n  exit 2\nfi\n\nif [ \"$manifest\" != \"\" ] || [ \"$lock\" != \"\" ] || [ \"$package_id\" != \"\" ]; then\n  if [ \"$registry\" = \"\" ]; then\n    registry=\"build/cheng_registry/registry.jsonl\"\n  fi\nfi\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a "
        out = out + "256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\ntoml_string() {\n  key=\"$1\"\n  file=\"$2\"\n  if [ ! -f \"$file\" ]; then\n    echo \"\"\n    return\n  fi\n  sed -n \"s/^[[:space:]]*$key[[:space:]]*=[[:space:]]*\\\"\\\\(.*\\\\)\\\"[[:space:]]*$/\\\\1/p\" \"$file\" | head -n 1\n}\n\ntoml_int() {\n  key=\"$1\"\n  file=\"$2\"\n  if [ ! -f \"$file\" ]; then\n    echo \"\"\n    return\n  fi\n  sed -n \"s/^[[:space:]]*$key[[:space:]]*=[[:space:]]*\\\\([0-9][0-9]*\\\\)[[:space:]]*$/\\\\1/p\" \"$file\" | head -n 1\n}\n\nensure_pkg_tool() {\n  if [ -x \"$pkg_tool\" ] && [ \"src/tooling/cheng_pkg.cheng\" -ot \"$pkg_tool\" ]; then\n    return\n  fi\n  pkg_tool_dir=\"$(dirname \"$pkg_tool\")\"\n  if [ \"$pkg_tool_dir\" != \"\" ] && [ ! -d \"$pkg_tool_dir\" ]; then\n    mkdir -p \"$pkg_tool_dir\"\n  fi\n  echo \"[pkg] build cheng_pkg\"\n  if ! ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc src/tooling/cheng_pkg.cheng --frontend:stage1 --emit:exe --out:\"$pkg_tool\" --skip-pkg >/dev/null; then\n    echo \"[Error] failed to build cheng_pkg via backend obj/exe pipeline\" 1>&2\n    exit 2\n  fi\n  if [ ! -x \"$pkg_tool\" ]; then\n    echo \"[Error] missing cheng_pkg executable after build\" 1>&2\n    exit 2\n  fi\n}\n\nif [ \"$skip_pkg\" = \"\" ]; then\n  if [ \"$manifest\" != \"\" ] || [ \"$lock\" != \"\" ] || [ \"$package_id\" != \"\" ]; then\n   "
        out = out + " ensure_pkg_tool\n  fi\nfi\n\nif [ \"$manifest\" != \"\" ] && [ \"$skip_pkg\" = \"\" ]; then\n  if [ ! -f \"$manifest\" ]; then\n    echo \"[Error] manifest not found: $manifest\" 1>&2\n    exit 2\n  fi\n  if [ \"$lock\" = \"\" ]; then\n    lock=\"chengcache/${name}.lock.${lock_format}\"\n  fi\n  echo \"[pkg] resolve lock: $lock\"\n  \"$pkg_tool\" resolve --manifest:\"$manifest\" --registry:\"$registry\" --out:\"$lock\" --format:\"$lock_format\"\nfi\n\nif [ \"$lock\" != \"\" ] && [ \"$skip_pkg\" = \"\" ]; then\n  if [ ! -f \"$lock\" ]; then\n    echo \"[Error] lock not found: $lock\" 1>&2\n    exit 2\n  fi\n  echo \"[pkg] verify lock\"\n  \"$pkg_tool\" verify --lock:\"$lock\" --registry:\"$registry\"\n\n  if [ -f \"src/tooling/cheng_pkg_fetch.sh\" ]; then\n    source_listen_arg=\"\"\n    if [ \"$source_listen\" != \"\" ]; then\n      source_listen_arg=\"--source-listen:$source_listen\"\n    fi\n    if [ \"$pkg_cache\" != \"\" ]; then\n      pkg_roots=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_pkg_fetch --lock:\"$lock\" --cache:\"$pkg_cache\" --print-roots \\\n        $source_listen_arg $source_peer_args)\"\n    else\n      pkg_roots=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_pkg_fetch --lock:\"$lock\" --print-roots \\\n        $source_listen_arg $source_peer_args)\"\n    fi\n    if [ \"$pkg_roots\" != \"\" ]; then\n      export PKG_ROOTS=\"$pkg_roots\"\n    fi\n  fi\nfi\n\nif [ \"$lock\" != \"\" ] && [ \"$package_id\" != \"\" ] "
        out = out + "&& [ \"$skip_pkg\" = \"\" ]; then\n  if [ \"$meta_out\" = \"\" ]; then\n    meta_out=\"chengcache/${name}.pkgmeta.toml\"\n  fi\n  echo \"[pkg] build meta: $meta_out\"\n  \"$pkg_tool\" meta --lock:\"$lock\" --package:\"$package_id\" --channel:\"$channel\" --registry:\"$registry\" --out:\"$meta_out\" --format:\"toml\"\nfi\n\nif [ \"$skip_pkg\" != \"\" ]; then\n  if [ \"$manifest\" != \"\" ] && [ \"$lock\" = \"\" ]; then\n    echo \"[Error] --skip-pkg requires --lock when --manifest is set\" 1>&2\n    exit 2\n  fi\n  if [ \"$lock\" != \"\" ] && [ ! -f \"$lock\" ]; then\n    echo \"[Error] lock not found: $lock\" 1>&2\n    exit 2\n  fi\n  if [ \"$package_id\" != \"\" ]; then\n    if [ \"$meta_out\" = \"\" ]; then\n      meta_out=\"chengcache/${name}.pkgmeta.toml\"\n    fi\n    if [ ! -f \"$meta_out\" ]; then\n      echo \"[Error] pkgmeta not found: $meta_out\" 1>&2\n      exit 2\n    fi\n  fi\nfi\n\nif [ \"$legacy_pkg_roots\" != \"\" ]; then\n  export PKG_ROOTS=\"$legacy_pkg_roots\"\nfi\n\nif [ \"$buildmeta\" = \"\" ] && { [ \"$lock\" != \"\" ] || [ \"$meta_out\" != \"\" ]; }; then\n  buildmeta=\"chengcache/${name}.buildmeta.toml\"\nfi\n\nfrontend=\"${BACKEND_FRONTEND:-stage1}\"\nif [ \"$legacy_frontend\" != \"\" ]; then\n  frontend=\"$legacy_frontend\"\nfi\nif [ \"$frontend\" = \"stage1\" ] && [ \"${STAGE1_SKIP_OWNERSHIP:-}\" = \"\" ]; then\n  export STAGE1_SKIP_OWNERSHIP=1\nfi\n\nbuild_track=\"${BACKEND_BUILD_TRACK:-}\"\nif [ \"$build_track_arg\" = \"release\" ]; then\n  build_"
        out = out + "track=\"release\"\nfi\nif [ \"$build_track\" = \"\" ]; then\n  build_track=\"dev\"\nfi\ncase \"$build_track\" in\n  dev|release) ;;\n  *)\n    echo \"[Error] invalid BACKEND_BUILD_TRACK: $build_track (expected dev|release)\" 1>&2\n    exit 2\n    ;;\nesac\n\nif [ \"$buildmeta\" != \"\" ]; then\n  buildmeta_dir=\"$(dirname \"$buildmeta\")\"\n  if [ \"$buildmeta_dir\" != \"\" ] && [ ! -d \"$buildmeta_dir\" ]; then\n    mkdir -p \"$buildmeta_dir\"\n  fi\n  lock_sha=\"\"\n  if [ \"$lock\" != \"\" ] && [ -f \"$lock\" ]; then\n    lock_sha=\"$(sha256_file \"$lock\")\"\n  fi\n  meta_sha=\"\"\n  if [ \"$meta_out\" != \"\" ] && [ -f \"$meta_out\" ]; then\n    meta_sha=\"$(sha256_file \"$meta_out\")\"\n  fi\n  snap_author=\"$(toml_string author_id \"$meta_out\")\"\n  snap_cid=\"$(toml_string cid \"$meta_out\")\"\n  snap_sig=\"$(toml_string signature \"$meta_out\")\"\n  snap_pubkey=\"$(toml_string pub_key \"$meta_out\")\"\n  snap_epoch=\"$(toml_int epoch \"$meta_out\")\"\n  ts=\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n  {\n    echo \"[build]\"\n    echo \"source = \\\"$in\\\"\"\n    echo \"frontend = \\\"$frontend\\\"\"\n    echo \"output = \\\"$buildmeta_output\\\"\"\n    echo \"created_ts = \\\"$ts\\\"\"\n    if [ \"$manifest\" != \"\" ]; then\n      echo \"manifest = \\\"$manifest\\\"\"\n    fi\n    if [ \"$registry\" != \"\" ]; then\n      echo \"registry = \\\"$registry\\\"\"\n    fi\n    if [ \"$package_id\" != \"\" ]; then\n      echo \"package_id = \\\"$package_id\\\"\"\n    fi\n    i"
        out = out + "f [ \"$channel\" != \"\" ]; then\n      echo \"channel = \\\"$channel\\\"\"\n    fi\n    if [ \"$lock\" != \"\" ]; then\n      echo \"\"\n      echo \"[lock]\"\n      echo \"path = \\\"$lock\\\"\"\n      if [ \"$lock_format\" != \"\" ]; then\n        echo \"format = \\\"$lock_format\\\"\"\n      fi\n      if [ \"$lock_sha\" != \"\" ]; then\n        echo \"sha256 = \\\"$lock_sha\\\"\"\n      fi\n    fi\n    if [ \"$meta_out\" != \"\" ]; then\n      echo \"\"\n      echo \"[pkgmeta]\"\n      echo \"path = \\\"$meta_out\\\"\"\n      if [ \"$meta_sha\" != \"\" ]; then\n        echo \"sha256 = \\\"$meta_sha\\\"\"\n      fi\n    fi\n    if [ \"$snap_cid\" != \"\" ] || [ \"$snap_author\" != \"\" ] || [ \"$snap_sig\" != \"\" ]; then\n      echo \"\"\n      echo \"[snapshot]\"\n      if [ \"$snap_epoch\" != \"\" ]; then\n        echo \"epoch = $snap_epoch\"\n      fi\n      if [ \"$snap_cid\" != \"\" ]; then\n        echo \"cid = \\\"$snap_cid\\\"\"\n      fi\n      if [ \"$snap_author\" != \"\" ]; then\n        echo \"author_id = \\\"$snap_author\\\"\"\n      fi\n      if [ \"$snap_pubkey\" != \"\" ]; then\n        echo \"pub_key = \\\"$snap_pubkey\\\"\"\n      fi\n      if [ \"$snap_sig\" != \"\" ]; then\n        echo \"signature = \\\"$snap_sig\\\"\"\n      fi\n    fi\n  } >\"$buildmeta\"\nfi\n\nif [ \"$verify_meta\" != \"\" ]; then\n  if [ \"$buildmeta\" = \"\" ]; then\n    echo \"[Error] --verify requires --buildmeta (or lock/meta inputs)\" 1>&2\n    exit 2\n  fi\n  if [ \"$ledge"
        out = out + "r\" != \"\" ]; then\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_buildmeta --buildmeta:\"$buildmeta\" --ledger:\"$ledger\"\n  else\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_buildmeta --buildmeta:\"$buildmeta\"\n  fi\nfi\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver_can_run() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=$?\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\nif [ -n \"${BACKEND_DRIVER:-}\" ]; then\n  driver=\"$BACKEND_DRIVER\"\nelif [ \"${BACKEND_DRIVER_DIRECT:-1}\" != \"0\" ] && [ -x \"./artifacts/backend_driver/cheng\" ] && driver_can_run \"./artifacts/backend_driver/cheng\"; then\n  driver=\"./artifacts/backend_driver/cheng\"\nelif [ \"${BACKEND_DRIVER_DIRECT:-1}\" != \"0\" ] && [ -x \"./cheng\" ] && driver_can_run \"./cheng\"; then\n  driver=\"./cheng\"\nelse\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\ndriver_exec=\"$driver\"\ndriver_real_env=\"\"\nif [ \"${BACKEND_DRIVER_USE_WRAPPER:-0}\" = \"1\" ]; then\n  echo \"[chengc] BACKEND_DRI"
        out = out + "VER_USE_WRAPPER=1 is deprecated; forcing direct driver path\" 1>&2\nfi\n\nbackend_emit=\"exe\"\nout_path=\"$exe_out_path\"\nif [ \"$legacy_out\" != \"\" ]; then\n  out_path=\"$legacy_out\"\nfi\nif [ \"$obj_requested\" = \"1\" ]; then\n  backend_emit=\"obj\"\n  if [ \"$obj_out\" != \"\" ]; then\n    out_path=\"$obj_out\"\n  elif [ \"$legacy_out\" != \"\" ]; then\n    out_path=\"$legacy_out\"\n  else\n    out_path=\"${name}.o\"\n  fi\nfi\nout_path=\"$(normalize_output_path \"$out_path\")\"\nout_dir=\"$(dirname \"$out_path\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\nbackend_target=\"${BACKEND_TARGET:-}\"\nif [ -n \"$target_arg\" ]; then\n  backend_target=\"$target_arg\"\nfi\nif [ -z \"$backend_target\" ]; then\n  backend_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\ncase \"$backend_target\" in\n  \"\"|auto|native|host)\n    backend_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\n    ;;\n  darwin_arm64|darwin_aarch64)\n    backend_target=\"arm64-apple-darwin\"\n    ;;\n  darwin_x86_64|darwin_amd64)\n    backend_target=\"x86_64-apple-darwin\"\n    ;;\n  linux_arm64|linux_aarch64)\n    backend_target=\"aarch64-unknown-linux-gnu\"\n    ;;\n  linux_x86_64|linux_amd64)\n    backend_target=\"x86_64-unknown-linux-gnu\"\n    ;;\n  linux_riscv64)\n    backend_target=\"riscv64-unknown-linux-gnu\"\n    ;;\n  windows_arm64|windows_aarch64)\n    backend_target=\"aarch64-pc-windows-msvc\"\n    ;;\n  windows_x86_64|windows_amd64)\n    backend_target=\"x86_64-pc-windows-msvc\"\n    ;;\nesac\n\nbackend_linker=\"$linker\"\nif [ \"$backend_linker\" = \"\" ]; then\n  backend_linker=\"${BACKEND_LINKER:-}\"\nfi\nif [ \"$backend_linker\" = \"\" ] && [ \"$backend_emit\" = \"exe\" ]; then\n  if [ \"$build_track\" = \"release\" ]; then\n    backend_linker=\"system\"\n  else\n    if target_supports_self_linker \"$backend_target\"; then\n      backend_linker=\"self\"\n    else\n      backend_linker=\"system\"\n    fi\n  fi\nfi\ncase \"$backend_linker\" in\n  \"\"|self|system) ;;\n  *)\n    echo \"[Error] invalid --linker:$backend_linker (expected self|system)\" 1>&2\n    exit 2\n    ;;\nesac\n\nbackend_runtime_obj=\""
        out = out + "${BACKEND_RUNTIME_OBJ:-}\"\n\nruntime_nm_has_sym() {\n  sym=\"$1\"\n  printf '%s\\n' \"$nm_out\" | awk '{print $NF}' | sed 's/^_//' | grep -Fxq \"$sym\"\n}\n\nruntime_has_core_symbols() {\n  obj=\"$1\"\n  [ -f \"$obj\" ] || return 1\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null || true)\"\n  [ \"$nm_out\" != \"\" ] || return 1\n  runtime_nm_has_sym cheng_strlen &&\n  runtime_nm_has_sym cheng_memcpy &&\n  runtime_nm_has_sym cheng_memset &&\n  runtime_nm_has_sym cheng_malloc &&\n  runtime_nm_has_sym cheng_free &&\n  runtime_nm_has_sym cheng_mem_retain &&\n  runtime_nm_has_sym cheng_mem_release &&\n  runtime_nm_has_sym cheng_seq_get &&\n  runtime_nm_has_sym cheng_seq_set &&\n  runtime_nm_has_sym cheng_strcmp &&\n  runtime_nm_has_sym cheng_f32_bits_to_i64 &&\n  runtime_nm_has_sym cheng_f64_bits_to_i64\n}\n\nresolve_runtime_obj() {\n  if [ \"$backend_runtime_obj\" != \"\" ]; then\n    printf '%s\\n' \"$backend_runtime_obj\"\n    return 0\n  fi\n  candidates=\"\nchengcache/runtime_selflink/system_helpers.backend.combined.${backend_target}.o\nartifacts/backend_mm/system_helpers.backend.combined.${backend_target}.o\nchengcache/system_helpers.backend.cheng.${backend_target}.o\nartifacts/backend_selfhost_self_obj/stage1.native.runtime.dedup.o\nartifacts/backend_selfhost_self_obj/system_helpers.backend.cheng.stage1shim.o\nchengcache/system_helpers.backend.cheng.o\nartifacts/backend_selfhost_self_obj/system_helpers.backend.cheng.o\n\"\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ] && runtime_has_core_symbols \"$cand\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ]; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nif [ \"$backend_emit\" = \"exe\" ] && [ \"$backend_linker\" = \"self\" ]; then\n  backend_runtime_obj=\"$(resolve_runtime_obj || true)\"\n  if [ \"$backend_runtime_obj\" = \"\" ] || [ ! -f \"$backend_runtime_obj\" ]; then\n    echo \"[Error] missing self-link runtime object for target=$backend_target\" 1>&2\n    echo \"        set BACKEND_RUNTIME_OBJ or prepare chengcache/runtime_selflink/system_helpers.backend.combined.${backend_target}.o\" 1>&2\n    exit 2\n  fi\n  if ! runtime_has_core_symbols \"$backend_runtime_obj\"; then\n    echo \"[Warn] self-link runtime object may be incomplete: $backend_runtime_obj\" 1>&2\n  fi\nfi\nruntime_env=\"\"\nif [ \"$backend_linker\" = \"self\" ] && [ \"$backend_runtime_obj\" != \"\" ]; then\n  runtime_env=\"BACKEND_RUNTIME_OBJ=$backend_runtime_obj\"\nfi\n\nabi_env=\"\"\nabi_effective=\"$abi\"\nif [ -z \"$abi_effective\" ]; then\n  abi_effective=\"${ABI:-}\"\nfi\nif [ -z \"$abi_effective\" ]; then\n  abi_effective=\"v2_noptr\"\nfi\nif [ \"$abi_effective\" != \"v2_noptr\" ]; then\n  echo \"[Error] ABI only supports v2_noptr (got: $abi_effective; enforced by ZRPC/)\" 1>&2\n  exit 2\nfi\nabi_env=\"ABI=$abi_effective\"\nabi_std_noptr_env=\"\"\nabi_std_noptr_strict_env=\"\"\nabi_no_ptr_non_c_abi_env=\"\"\nabi_no_ptr_non_c_abi_internal_env=\"\"\nif [ \"$abi_effective\" = \"v2_noptr\" ]; then\n  if [ -z \"${STAGE1_STD_NO_POINTERS+x}\" ]; then\n    abi_std_noptr_env=\"STAGE1_STD_NO_POINTERS=1\"\n  else\n    abi_s"
        out = out + "td_noptr_env=\"STAGE1_STD_NO_POINTERS=$STAGE1_STD_NO_POINTERS\"\n  fi\n  if [ -z \"${STAGE1_STD_NO_POINTERS_STRICT+x}\" ]; then\n    abi_std_noptr_strict_env=\"STAGE1_STD_NO_POINTERS_STRICT=0\"\n  else\n    abi_std_noptr_strict_env=\"STAGE1_STD_NO_POINTERS_STRICT=$STAGE1_STD_NO_POINTERS_STRICT\"\n  fi\n  if [ -z \"${STAGE1_NO_POINTERS_NON_C_ABI+x}\" ]; then\n    abi_no_ptr_non_c_abi_env=\"STAGE1_NO_POINTERS_NON_C_ABI=1\"\n  else\n    abi_no_ptr_non_c_abi_env=\"STAGE1_NO_POINTERS_NON_C_ABI=$STAGE1_NO_POINTERS_NON_C_ABI\"\n  fi\n  if [ -z \"${STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL+x}\" ]; then\n    abi_no_ptr_non_c_abi_internal_env=\"STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1\"\n  else\n    abi_no_ptr_non_c_abi_internal_env=\"STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=$STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL\"\n  fi\nfi\n\nlink_env=\"\"\nif [ \"$backend_emit\" = \"exe\" ]; then\n  if [ \"$backend_linker\" = \"self\" ]; then\n    link_env=\"BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1\"\n  else\n    if [ \"${BACKEND_NO_RUNTIME_C+x}\" = \"x\" ] && [ \"${BACKEND_NO_RUNTIME_C}\" != \"\" ]; then\n      link_env=\"BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=$BACKEND_NO_RUNTIME_C\"\n    elif [ \"$build_track\" = \"release\" ]; then\n      link_env=\"BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0\"\n    else\n      link_env=\"BACKEND_LINKER=system\"\n    fi\n  fi\nfi\n\nbackend_ldflags_final=\"${BACKEND_LDFLAGS:-}\"\nif [ \"$backend_emit\" = \"exe\" ] && [ \"$backend_linker\" = \"system\" ]; then\n  i"
        out = out + "f [ \"${BACKEND_LD:-}\" = \"\" ] && ! has_fuse_ld_flag \"$backend_ldflags_final\"; then\n    resolver_out=\"$(env \\\n      BACKEND_SYSTEM_LINKER_PRIORITY=\"${BACKEND_SYSTEM_LINKER_PRIORITY:-mold,lld,default}\" \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} resolve_system_linker)\"\n    resolver_kind=\"$(printf '%s\\n' \"$resolver_out\" | sed -n 's/^kind=//p' | head -n 1)\"\n    resolver_ldflags=\"$(printf '%s\\n' \"$resolver_out\" | sed -n 's/^ldflags=//p' | head -n 1)\"\n    if [ \"$resolver_ldflags\" != \"\" ]; then\n      backend_ldflags_final=\"$(append_token \"$backend_ldflags_final\" \"$resolver_ldflags\")\"\n    fi\n  fi\nfi\n\nbackend_multi_env=\"${BACKEND_MULTI:-}\"\nif [ \"$backend_multi_env\" = \"\" ]; then\n  if [ \"$build_track\" = \"release\" ]; then\n    backend_multi_env=\"${CHENGC_RELEASE_MULTI_DEFAULT:-0}\"\n  else\n    backend_multi_env=\"${CHENGC_DEV_MULTI_DEFAULT:-1}\"\n  fi\nfi\nbackend_inc_env=\"${BACKEND_INCREMENTAL:-1}\"\nbackend_multi_module_cache_env=\"${BACKEND_MULTI_MODULE_CACHE:-${BACKEND_MULTI_MODULE_CACHE:-0}}\"\nbackend_module_cache_unstable_allow_env=\"${BACKEND_MODULE_CACHE_UNSTABLE_ALLOW:-${BACKEND_MODULE_CACHE_UNSTABLE_ALLOW:-0}}\"\nchengc_allow_unstable_multi_module_cache_env=\"${CHENGC_ALLOW_UNSTABLE_MULTI_MODULE_CACHE:-0}\"\nif is_true_flag \"$backend_multi_module_cache_env\"; then\n  if ! is_true_flag \"$chengc_allow_unstable_multi_module_cache_env\" || ! is_true_flag \"$backend_module_cache_unstable_allow_env\"; t"
        out = out + "hen\n    echo \"[chengc] warn: BACKEND_MULTI_MODULE_CACHE is unstable and disabled by default; require CHENGC_ALLOW_UNSTABLE_MULTI_MODULE_CACHE=1 and BACKEND_MODULE_CACHE_UNSTABLE_ALLOW=1\" 1>&2\n    backend_multi_module_cache_env=\"0\"\n    backend_module_cache_unstable_allow_env=\"0\"\n  fi\nfi\nbackend_whole_program_env=\"${BACKEND_WHOLE_PROGRAM:-1}\"\nbackend_multi_force_env=\"${BACKEND_MULTI_FORCE:-0}\"\njobs_env=\"\"\njobs_unset_env=\"-u BACKEND_JOBS\"\nmodule_cache_unset_env=\"-u BACKEND_MODULE_CACHE\"\nmulti_module_cache_unset_env=\"-u BACKEND_MULTI_MODULE_CACHE\"\nif [ \"$jobs_explicit\" = \"1\" ]; then\n  jobs_env=\"BACKEND_JOBS=$jobs\"\n  jobs_unset_env=\"\"\nfi\nif [ \"$legacy_multi\" = \"1\" ]; then\n  backend_multi_env=\"1\"\n  backend_multi_force_env=\"1\"\nfi\n\nbackend_module_cache_env=\"${BACKEND_MODULE_CACHE:-${BACKEND_MODULE_CACHE:-}}\"\nmodule_cache_env=\"\"\nif [ \"$backend_module_cache_env\" != \"\" ]; then\n  module_cache_env=\"BACKEND_MODULE_CACHE=$backend_module_cache_env\"\nfi\nbackend_cstring_lowering_env=\"${BACKEND_ENABLE_CSTRING_LOWERING:-${BACKEND_ENABLE_CSTRING_LOWERING:-}}\"\nif [ \"$backend_cstring_lowering_env\" = \"\" ]; then\n  backend_cstring_lowering_env=\"0\"\n  if [ \"$backend_linker\" = \"system\" ]; then\n    no_runtime_c_effective=\"${BACKEND_NO_RUNTIME_C:-}\"\n    if [ \"$no_runtime_c_effective\" = \"\" ] && [ \"$build_track\" = \"release\" ]; then\n      no_runtime_c_effective=\"0\"\n    fi\n    case \"$no_runtime_c_effective\" i"
        out = out + "n\n      0|false|FALSE|off|OFF|no|NO)\n        backend_cstring_lowering_env=\"1\"\n        ;;\n    esac\n  fi\nfi\n\nrun_backend_driver() {\n  multi_now=\"$1\"\n  multi_force_now=\"$2\"\n  if [ -n \"$backend_target\" ]; then\n    # shellcheck disable=SC2086\n    env $jobs_unset_env $module_cache_unset_env $multi_module_cache_unset_env $runtime_env $link_env $abi_env $abi_std_noptr_env $abi_std_noptr_strict_env $abi_no_ptr_non_c_abi_env $abi_no_ptr_non_c_abi_internal_env $jobs_env $module_cache_env $driver_real_env \\\n      BACKEND_BUILD_TRACK=\"$build_track\" \\\n      BACKEND_LDFLAGS=\"$backend_ldflags_final\" \\\n      BACKEND_TARGET=\"$backend_target\" \\\n      BACKEND_MULTI=\"$multi_now\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force_now\" \\\n      BACKEND_MULTI_MODULE_CACHE=\"$backend_multi_module_cache_env\" \\\n      BACKEND_MODULE_CACHE_UNSTABLE_ALLOW=\"$backend_module_cache_unstable_allow_env\" \\\n      BACKEND_INCREMENTAL=\"$backend_inc_env\" \\\n      BACKEND_WHOLE_PROGRAM=\"$backend_whole_program_env\" \\\n      BACKEND_ENABLE_CSTRING_LOWERING=\"$backend_cstring_lowering_env\" \\\n      BACKEND_EMIT=\"$backend_emit\" \\\n      BACKEND_FRONTEND=\"$frontend\" \\\n      BACKEND_INPUT=\"$in\" \\\n      BACKEND_OUTPUT=\"$out_path\" \\\n      \"$driver_exec\"\n    return\n  fi\n  # shellcheck disable=SC2086\n  env $jobs_unset_env $module_cache_unset_env $multi_module_cache_unset_env $runtime_env $link_env $abi_env $abi_std_noptr_env $abi_std_noptr_strict_env $abi_no_"
        out = out + "ptr_non_c_abi_env $abi_no_ptr_non_c_abi_internal_env $jobs_env $module_cache_env $driver_real_env \\\n    BACKEND_BUILD_TRACK=\"$build_track\" \\\n    BACKEND_LDFLAGS=\"$backend_ldflags_final\" \\\n    BACKEND_MULTI=\"$multi_now\" \\\n    BACKEND_MULTI_FORCE=\"$multi_force_now\" \\\n    BACKEND_MULTI_MODULE_CACHE=\"$backend_multi_module_cache_env\" \\\n    BACKEND_MODULE_CACHE_UNSTABLE_ALLOW=\"$backend_module_cache_unstable_allow_env\" \\\n    BACKEND_INCREMENTAL=\"$backend_inc_env\" \\\n    BACKEND_WHOLE_PROGRAM=\"$backend_whole_program_env\" \\\n    BACKEND_ENABLE_CSTRING_LOWERING=\"$backend_cstring_lowering_env\" \\\n    BACKEND_EMIT=\"$backend_emit\" \\\n    BACKEND_FRONTEND=\"$frontend\" \\\n    BACKEND_INPUT=\"$in\" \\\n    BACKEND_OUTPUT=\"$out_path\" \\\n    \"$driver_exec\"\n}\n\nset +e\nrun_backend_driver \"$backend_multi_env\" \"$backend_multi_force_env\"\nbuild_status=\"$?\"\nset -e\nif [ \"$build_status\" -ne 0 ] && [ \"$backend_multi_env\" = \"1\" ] && [ \"${CHENGC_MULTI_RETRY_SERIAL:-1}\" = \"1\" ]; then\n  echo \"[chengc] warn: parallel compile failed (status=$build_status), retry serial once\" 1>&2\n  set +e\n  run_backend_driver \"0\" \"0\"\n  build_status=\"$?\"\n  set -e\nfi\nif [ \"$build_status\" -ne 0 ]; then\n  exit \"$build_status\"\nfi\n\nif [ \"$backend_emit\" = \"exe\" ]; then\n  cleanup_backend_exe_sidecar \"$out_path\"\nfi\n\nif [ \"$backend_emit\" = \"obj\" ]; then\n  echo \"chengc obj ok: $out_path\"\nelse\n  echo \"chengc exe ok: $out_path\"\n"
        out = out + "fi\n\nif [ \"$legacy_run\" != \"1\" ] || [ \"$backend_emit\" != \"exe\" ]; then\n  exit 0\nfi\nif [ \"$run_mode\" = \"\" ]; then\n  run_mode=\"host\"\nfi\n\ncase \"$backend_target\" in\n  *android*)\n    if [ \"$run_mode\" = \"host\" ]; then\n      echo \"[chengc] run(android) does not support host runner yet, fallback to file mode\" >&2\n    fi\n    if ! command -v adb >/dev/null 2>&1; then\n      echo \"[chengc] missing tool: adb (required for --run on android targets)\" 1>&2\n      exit 2\n    fi\n    serial=\"${ANDROID_SERIAL:-}\"\n    if [ -z \"$serial\" ]; then\n      serial=\"$(adb devices | awk 'NR>1 && $2 == \"device\" {print $1; exit}')\"\n    fi\n    if [ -z \"$serial\" ]; then\n      echo \"[chengc] no Android device/emulator detected (adb devices)\" 1>&2\n      exit 2\n    fi\n    remote_dir=\"/data/local/tmp/chengc\"\n    remote_path=\"$remote_dir/$(basename \"$out_path\")\"\n    adb -s \"$serial\" shell \"mkdir -p '$remote_dir'\" >/dev/null\n    adb -s \"$serial\" push \"$out_path\" \"$remote_path\" >/dev/null\n    adb -s \"$serial\" shell \"chmod 755 '$remote_path'\" >/dev/null\n    echo \"[chengc] run(android): $remote_path ($serial)\" >&2\n    adb -s \"$serial\" shell \"$remote_path\"\n    exit $?\n    ;;\nesac\n\nif [ \"$run_mode\" = \"host\" ]; then\n  echo \"[chengc] run(host-runner): $out_path\" >&2\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run-host --exe:\"$out_path\"\n  exit $?\nfi\n\necho \"[chengc] run(file): $ou"
        out = out + "t_path\" >&2\n\"$out_path\"\n"
        return out
    if id == "chengc_daemon":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc_daemon [status|start|stop|serve]\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc_daemon run -- <chengc args...>\n\nNotes:\n  - `run` enqueues one `chengc` request to a local daemon worker and waits for completion.\n  - Enable automatic routing from `chengc` via `CHENGC_DAEMON=1`.\n  - Daemon state dir default: `chengcache/chengc_daemon`.\nEOF\n}\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ndaemon_dir=\"${CHENGC_DAEMON_DIR:-$root/chengcache/chengc_daemon}\"\npid_file=\"$daemon_dir/daemon.pid\"\nlog_file=\"$daemon_dir/daemon.log\"\nqueue_dir=\"$daemon_dir/queue\"\npoll_interval=\"${CHENGC_DAEMON_POLL_INTERVAL:-0.05}\"\nwait_timeout=\"${CHENGC_DAEMON_WAIT_TIMEOUT:-60}\"\n\nquote_sh() {\n  text=\"$1\"\n  esc=\"$(printf '%s' \"$text\" | sed \"s/'/'\\\"'\\\"'/g\")\"\n  printf \"'%s'\" \"$esc\"\n}\n\npid_alive() {\n  pid=\"$1\"\n  [ \"$pid\" != \"\" ] || return 1\n  case \"$pid\" in\n    *[!0-9]*)\n      return 1\n      ;;\n  esac\n  kill -0 \"$pid\" 2>/dev/null\n}\n\nread_pid() {\n  if [ ! -f \"$pid_file\" ]; then\n    printf '%s\\n' \"\"\n    return\n  fi\n  cat \"$pid_file\" 2>/dev/null || true\n}\n\nstart_daemon() {\n  mkdir -p \"$queue_dir\"\n  old_pid=\"$(read_pid)\"\n  if pid_alive \"$old_pid\"; then\n    printf '[chengc_daemon] already ru"
        out = out + "nning pid=%s\\n' \"$old_pid\"\n    return 0\n  fi\n  rm -f \"$pid_file\"\n  nohup ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc_daemon serve >>\"$log_file\" 2>&1 &\n  daemon_pid=\"$!\"\n  printf '%s\\n' \"$daemon_pid\" >\"$pid_file\"\n  waits=0\n  while [ \"$waits\" -lt 40 ]; do\n    if pid_alive \"$daemon_pid\"; then\n      printf '[chengc_daemon] started pid=%s\\n' \"$daemon_pid\"\n      return 0\n    fi\n    waits=$((waits + 1))\n    sleep 0.05\n  done\n  echo \"[chengc_daemon] failed to start daemon worker\" 1>&2\n  return 1\n}\n\nstop_daemon() {\n  pid=\"$(read_pid)\"\n  if ! pid_alive \"$pid\"; then\n    rm -f \"$pid_file\"\n    printf '[chengc_daemon] not running\\n'\n    return 0\n  fi\n  kill \"$pid\" 2>/dev/null || true\n  waits=0\n  while pid_alive \"$pid\"; do\n    waits=$((waits + 1))\n    if [ \"$waits\" -gt 40 ]; then\n      kill -9 \"$pid\" 2>/dev/null || true\n      break\n    fi\n    sleep 0.05\n  done\n  rm -f \"$pid_file\"\n  printf '[chengc_daemon] stopped pid=%s\\n' \"$pid\"\n}\n\nstatus_daemon() {\n  pid=\"$(read_pid)\"\n  if pid_alive \"$pid\"; then\n    printf 'status=running\\npid=%s\\nlog=%s\\nqueue=%s\\n' \"$pid\" \"$log_file\" \"$queue_dir\"\n    return 0\n  fi\n  printf 'status=stopped\\nlog=%s\\nqueue=%s\\n' \"$log_file\" \"$queue_dir\"\n  return 1\n}\n\nserve_loop() {\n  mkdir -p \"$queue_dir\"\n  printf '[chengc_daemon] serve loop started pid=%s dir=%s\\n' \"$$\" \"$daemon_dir\"\n  while true; do\n    processed=\"0\"\n    for"
        out = out + " pending in \"$queue_dir\"/*/pending; do\n      [ -e \"$pending\" ] || continue\n      req_dir=\"$(dirname \"$pending\")\"\n      if ! mv \"$pending\" \"$req_dir/working\" 2>/dev/null; then\n        continue\n      fi\n      processed=\"1\"\n      req_script=\"$req_dir/request.sh\"\n      out_file=\"$req_dir/stdout.log\"\n      err_file=\"$req_dir/stderr.log\"\n      rc_file=\"$req_dir/rc\"\n      done_file=\"$req_dir/done\"\n      rm -f \"$done_file\" \"$rc_file\"\n      if [ ! -x \"$req_script\" ]; then\n        printf '[chengc_daemon] missing request script: %s\\n' \"$req_script\" >\"$err_file\"\n        printf '%s\\n' \"127\" >\"$rc_file\"\n      else\n        set +e\n        \"$req_script\" >\"$out_file\" 2>\"$err_file\"\n        req_rc=\"$?\"\n        set -e\n        printf '%s\\n' \"$req_rc\" >\"$rc_file\"\n      fi\n      touch \"$done_file\"\n      rm -f \"$req_dir/working\"\n    done\n    if [ \"$processed\" = \"0\" ]; then\n      sleep \"$poll_interval\"\n    fi\n  done\n}\n\nrun_request() {\n  if [ \"$#\" -le 0 ]; then\n    echo \"[chengc_daemon] missing chengc args for run\" 1>&2\n    exit 2\n  fi\n  start_daemon\n  mkdir -p \"$queue_dir\"\n  req_id=\"$(date +%s%N 2>/dev/null || date +%s).$$\"\n  req_dir=\"$queue_dir/$req_id\"\n  mkdir -p \"$req_dir\"\n  req_script=\"$req_dir/request.sh\"\n  out_file=\"$req_dir/stdout.log\"\n  err_file=\"$req_dir/stderr.log\"\n  rc_file=\"$req_dir/rc\"\n  done_file=\"$req_dir/done\"\n  {\n    echo '#!/usr/bin/env sh'\n    echo 's"
        out = out + "et -eu'\n    printf 'cd %s\\n' \"$(quote_sh \"$root\")\"\n    printf 'set --'\n    for arg in \"$@\"; do\n      printf ' %s' \"$(quote_sh \"$arg\")\"\n    done\n    printf '\\n'\n    echo 'exec env CHENGC_DAEMON_ACTIVE=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$@\"'\n  } >\"$req_script\"\n  chmod +x \"$req_script\"\n  : >\"$req_dir/pending\"\n\n  deadline=\"$(( $(date +%s) + wait_timeout ))\"\n  while [ ! -f \"$done_file\" ]; do\n    now=\"$(date +%s)\"\n    if [ \"$now\" -ge \"$deadline\" ]; then\n      echo \"[chengc_daemon] request timeout (${wait_timeout}s): $req_id\" 1>&2\n      exit 124\n    fi\n    sleep 0.05\n  done\n\n  if [ -f \"$out_file\" ]; then\n    cat \"$out_file\"\n  fi\n  if [ -f \"$err_file\" ]; then\n    cat \"$err_file\" 1>&2\n  fi\n  req_rc=\"1\"\n  if [ -f \"$rc_file\" ]; then\n    req_rc=\"$(cat \"$rc_file\" 2>/dev/null || echo 1)\"\n  fi\n  if [ \"${CHENGC_DAEMON_KEEP_REQUESTS:-0}\" != \"1\" ]; then\n    rm -rf \"$req_dir\"\n  fi\n  exit \"$req_rc\"\n}\n\ncmd=\"${1:-status}\"\ncase \"$cmd\" in\n  --help|-h|help)\n    usage\n    exit 0\n    ;;\n  start)\n    start_daemon\n    exit 0\n    ;;\n  stop)\n    stop_daemon\n    exit 0\n    ;;\n  status)\n    status_daemon\n    exit $?\n    ;;\n  serve)\n    serve_loop\n    exit 0\n    ;;\n  run)\n    shift || true\n    if [ \"${1:-}\" = \"--\" ]; then\n      shift || true\n    fi\n    run_request \"$@\"\n    ;;\n  *)\n    echo \"[chengc_daemon] unknown command: $cmd\" 1>&2\n    usage"
        out = out + " 1>&2\n    exit 2\n    ;;\nesac\n"
        return out
    if id == "cleanup_backend_obj_like_artifacts":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nscan_paths_csv=\"${BACKEND_NO_OBJ_SCAN_PATHS:-artifacts/backend_closedloop:artifacts/backend_profile_smoke:artifacts/backend_profile_schema:artifacts/backend_mem_contract:artifacts/backend_dod_contract:artifacts/backend_mem_image_core:artifacts/backend_mem_exe_emit:artifacts/backend_profile_baseline:artifacts/backend_linkerless_dev:artifacts/backend_hotpatch_meta:artifacts/backend_hotpatch_inplace:artifacts/backend_incr_patch_fastpath:artifacts/backend_mem_patch_regression:artifacts/backend_hotpatch:artifacts/backend_plugin_isolation:artifacts/backend_linker_abi_core:artifacts/backend_self_linker_elf:artifacts/backend_self_linker_coff:artifacts/backend_prod:dist/releases/current}\"\n\nout_dir=\"artifacts/backend_no_obj_artifacts\"\nmkdir -p \"$out_dir\"\ndeleted_file=\"$out_dir/backend_no_obj_artifacts.deleted.txt\"\n: >\"$deleted_file\"\n\nold_ifs=\"$IFS\"\nIFS=':'\nfor p in $scan_paths_csv; do\n  IFS=\"$old_ifs\"\n  [ \"$p\" != \"\" ] || continue\n  if [ ! -e \"$p\" ]; then\n    continue\n  fi\n  find \"$p\" \\( -type f -o -type d \\) \\\n    \\( -name '*.o' -o -name '*.obj' -o -name '*.objs' -o -name '*.objs.lock' -o -name '*.tmp.linkobj' \\) \\\n    -print >>\"$deleted_file\"\ndone\nIFS=\"$old_ifs\"\n\nif [ -s \"$deleted_file\" ]; then\n  LC_ALL=C sort -u \"$deleted_file\" -o \"$deleted_file\"\n  while IFS= rea"
        out = out + "d -r path; do\n    [ \"$path\" != \"\" ] || continue\n    rm -rf \"$path\" 2>/dev/null || true\n  done <\"$deleted_file\"\nfi\n\ndeleted_count=\"0\"\nif [ -s \"$deleted_file\" ]; then\n  deleted_count=\"$(wc -l < \"$deleted_file\" | tr -d ' ')\"\nfi\n\necho \"cleanup_backend_obj_like_artifacts ok (deleted=$deleted_count)\"\n"
        return out
    if id == "cleanup_cheng_local":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/cleanup_cheng_local.sh [--verbose]\n\nMoves local backend driver binaries and their debug symbol bundles out of the repo\nroot:\n  cheng*\n  chengcache/cheng*\n\nNotes:\n  - These are local build/debug artifacts (they are gitignored).\n  - Safe to run even when nothing matches.\nEOF\n}\n\ncase \"${1:-}\" in\n  --help|-h)\n    usage\n    exit 0\n    ;;\n  \"\"|--verbose)\n    ;;\n  *)\n    echo \"[Error] unknown arg: $1\" 1>&2\n    usage\n    exit 2\n    ;;\nesac\n\nverbose=\"0\"\nif [ \"${1:-}\" = \"--verbose\" ]; then\n  verbose=\"1\"\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\n\ndeleted=\"0\"\ntrash_dir=\"${TOOLING_TRASH_DIR:-$root/chengcache/_trash_cheng}\"\nmkdir -p \"$trash_dir\" 2>/dev/null || true\n\nmove_to_trash() {\n  path=\"$1\"\n  if [ ! -e \"$path\" ]; then\n    return\n  fi\n  base=\"$(basename \"$path\")\"\n  ts=\"$(date +%s 2>/dev/null || echo 0)\"\n  dst=\"$trash_dir/${base}.${ts}.$$\"\n  mv -f -- \"$path\" \"$dst\" 2>/dev/null || true\n  deleted=\"1\"\n}\n\nfor path in \\\n  \"$root\"/cheng \\\n  \"$root\"/cheng.* \\\n  \"$root\"/chengcache/cheng*.c \\\n  \"$root\"/chengcache/cheng*.c.key \\\n  \"$root\"/chengcache/cheng*.build.key \\\n  \"$root\"/chengcache/cheng*.deps.list \\\n  \"$root\"/chengcache/cheng*.modules; do\n  move_to_trash \"$path\"\ndone\n\nif [ \"$verbose\" = \"1\" ]; then\n  if [ \"$deleted\" = \"1\" ]; then\n    echo \"cleanup_cheng_local ok\"\n  else\n    echo \"cleanup_cheng_local noop\"\n  fi\nfi\n"
    if id == "closedloop":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport BACKEND_PROD_GATE_TIMEOUT=\"${BACKEND_PROD_GATE_TIMEOUT:-60}\"\nexport BACKEND_PROD_SELFHOST_TIMEOUT=\"${BACKEND_PROD_SELFHOST_TIMEOUT:-60}\"\nexport BACKEND_PROD_TIMEOUT_DIAG=\"${BACKEND_PROD_TIMEOUT_DIAG:-1}\"\nexport BACKEND_PROD_TIMEOUT_DIAG_SUMMARY=\"${BACKEND_PROD_TIMEOUT_DIAG_SUMMARY:-1}\"\nexport BACKEND_RUN_SELFHOST_PERF=\"${BACKEND_RUN_SELFHOST_PERF:-1}\"\n# stage1 fullspec gate default timeout; keep consistent with verify_stage1_fullspec.\nexport STAGE1_FULLSPEC_TIMEOUT=\"${STAGE1_FULLSPEC_TIMEOUT:-60}\"\n\nrun_cmd() {\n  local name=\"$1\"\n  shift\n  echo \"== ${name} ==\"\n  \"$@\"\n}\n\nif [ \"${CLOSEDLOOP_PROD:-0}\" = \"1\" ]; then\n  if [ \"${CLOSEDLOOP_STRICT:-}\" = \"\" ]; then\n    export CLOSEDLOOP_STRICT=1\n  fi\n  if [ \"${CLOSEDLOOP_BACKEND_PROD:-}\" = \"\" ]; then\n    export CLOSEDLOOP_BACKEND_PROD=1\n  fi\n  if [ \"${STAGE1_FULLSPEC:-}\" = \"\" ]; then\n    export STAGE1_FULLSPEC=\"${CLOSEDLOOP_STAGE1_FULLSPEC_DEFAULT:-0}\"\n  fi\n  export BACKEND_CLOSEDLOOP=1\n  export C_BACKEND_CLOSURE=1\n  export C_BACKEND_CLOSURE_ARGS=\"--no-bootstrap ${C_BACKEND_CLOSURE_ARGS:-}\"\n  export BOOTSTRAP_FORCE_DETERMINISM=1\nfi\n\nif [ \"${CLOSEDLOOP_DETERMINISM:-0}\" = \"1\" ]; then\n  export BOOTSTRAP_FORCE_DETERMINISM=1\nfi\n\nif [ \"${CLOSEDLOOP_SKIP_BOOTSTRAP:-0}\" != \"1\" ]; then\n  run_cmd \"bootstrap.fullspec\" $"
        out = out + "{TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} bootstrap_pure --fullspec\nfi\n\nif [ \"${CLOSEDLOOP_SKIP_VERIFY:-0}\" != \"1\" ]; then\n  run_cmd \"verify.core\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify\n  if [ \"${CLOSEDLOOP_BACKEND_PROD:-0}\" = \"1\" ]; then\n    backend_prod_args=\"${CLOSEDLOOP_BACKEND_PROD_ARGS:-}\"\n    if [ \"$backend_prod_args\" = \"\" ]; then\n      backend_prod_args=\"--no-publish\"\n    fi\n    if [ \"${CLOSEDLOOP_UIR_STABILITY:-0}\" = \"1\" ] && \\\n       ! printf '%s\\n' \"$backend_prod_args\" | grep -q -- \"--uir-stability\"; then\n      backend_prod_args=\"$backend_prod_args --uir-stability\"\n    fi\n    # shellcheck disable=SC2086\n    run_cmd \"backend.prod_closure\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure $backend_prod_args\n  fi\nfi\n\nfrontier_mode=\"${CLOSEDLOOP_FRONTIER:-auto}\"\nrun_frontier=\"0\"\ncase \"$frontier_mode\" in\n  1|true|TRUE|yes|YES|on|ON)\n    run_frontier=\"1\"\n    ;;\n  auto)\n    if [ -d \"$root/../cheng-libp2p\" ] || [ -d \"$HOME/cheng-libp2p\" ] || [ -d \"$HOME/.cheng-packages/cheng-libp2p\" ]; then\n      run_frontier=\"1\"\n    fi\n    ;;\n  0|false|FALSE|no|NO|off|OFF)\n    run_frontier=\"0\"\n    ;;\n  *)\n    echo \"[closedloop] invalid CLOSEDLOOP_FRONTIER=$frontier_mode (expected auto|0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n\nif [ \"$run_frontier\" = \"1\" ]; then\n  if [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage2\" ] && [ \"${BA"
        out = out + "CKEND_DRIVER:-}\" = \"\" ]; then\n    export BACKEND_DRIVER=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n  fi\n  frontier_soft_auto=\"${CLOSEDLOOP_FRONTIER_SOFT_AUTO:-1}\"\n  case \"$frontier_mode/$frontier_soft_auto\" in\n    auto/1|auto/true|auto/TRUE|auto/yes|auto/YES|auto/on|auto/ON)\n      echo \"== verify.libp2p_frontier (auto, non-blocking) ==\"\n      set +e\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_frontier\n      frontier_rc=\"$?\"\n      set -e\n      if [ \"$frontier_rc\" -ne 0 ]; then\n        echo \"== verify.libp2p_frontier (auto-soft-fail rc=$frontier_rc) ==\"\n      fi\n      ;;\n    *)\n      run_cmd \"verify.libp2p_frontier\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_frontier\n      ;;\n  esac\nelif [ \"$frontier_mode\" = \"auto\" ]; then\n  echo \"== verify.libp2p_frontier (skip: cheng-libp2p repo not found) ==\"\nfi\n\nif [ \"${CLOSEDLOOP_LIBP2P:-0}\" = \"1\" ]; then\n  if [ -x \"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" ]; then\n    run_cmd \"verify.libp2p.prod_closure\" env ROOT=\"$root\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_prod_closure\n  else\n    echo \"[closedloop] missing ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" 1>&2\n    exit 1\n  fi\nfi\n\nif [ \"${CLOSEDLOOP_TIMEOUT_SUMMARY:-1}\" = \"1\" ] && [ -f \"src/tooling/summarize_timeout_diag.sh\" ]; then\n  set +e\n  run_cmd \"diag.timeout_summary\" ${TOOLING_SE"
        out = out + "LF_BIN:-artifacts/tooling_cmd/cheng_tooling} summarize_timeout_diag --latest:3 --top:12\n  rc_diag=\"$?\"\n  set -e\n  if [ \"$rc_diag\" -ne 0 ]; then\n    echo \"== diag.timeout_summary (skip: no timeout diag files) ==\"\n  fi\nfi\n\nif [ \"${CLOSEDLOOP_STAGE1_TIMEOUT_SUMMARY:-1}\" = \"1\" ] && [ -f \"src/tooling/summarize_stage1_timeout_diag.sh\" ]; then\n  set +e\n  run_cmd \"diag.stage1_timeout_summary\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} summarize_stage1_timeout_diag --latest:3\n  rc_stage1_diag=\"$?\"\n  set -e\n  if [ \"$rc_stage1_diag\" -ne 0 ]; then\n    echo \"== diag.stage1_timeout_summary (skip: no stage1 timeout diag files) ==\"\n  fi\nfi\n\necho \"closedloop ok\"\n"
        return out
    if id == "demo_compute_settle":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"build/cheng_demo_compute\"\nMODE=\"local\"\nEPOCH=\"1\"\nCLEAN=\"0\"\nRESET_LEDGER=\"0\"\nSETTLEMENT_BUDGET=\"2.0\"\nRWAD_CHAIN_ROOT=\"${RWAD_CHAIN_ROOT:-/Users/lbcheng/.cheng-packages/RWAD-blockchain}\"\nALLOW_MISSING_RWAD=\"0\"\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\ncd \"$repo_root\"\n\nresolve_chengc_bin() {\n  local name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$repo_root\" \"$name\"\n}\n\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    --root:*)\n      ROOT=\"${1#--root:}\"\n      ;;\n    --mode:*)\n      MODE=\"${1#--mode:}\"\n      ;;\n    --epoch:*)\n      EPOCH=\"${1#--epoch:}\"\n      ;;\n    --clean)\n      CLEAN=\"1\"\n      ;;\n    --reset-ledger)\n      RESET_LEDGER=\"1\"\n      ;;\n    --points-budget:*)\n      SETTLEMENT_BUDGET=\"${1#--points-budget:}\"\n      ;;\n    --settlement-budget:*)\n      SETTLEMENT_BUDGET=\"${1#--settlement-budget:}\"\n      ;;\n    --allow-missing-rwad)\n      ALLOW_MISSING_RWAD=\"1\"\n      ;;\n    *)\n      echo \"unknown arg: $1\" 1>&2\n      exit 1\n      ;;\n  esac\n  shift\ndone\n\nif [ \"$CLEAN\" = \"1\" ]; then\n  rm -rf \"$ROOT\"\nfi\nmkdir -p \"$ROOT\"\n\nif [ ! -x \"$storage_bin\" ]; then\n  src/tooling/chengc.sh src/tooling/cheng_storage.cheng --name:cheng_storage\nfi\n"
        out = out + "\nLEDGER=\"$ROOT/ledger.jsonl\"\nif [ \"$RESET_LEDGER\" = \"1\" ] && [ -f \"$LEDGER\" ]; then\n  rm -f \"$LEDGER\"\nfi\n\nruntime_ok=\"1\"\nset +e\nreq_out=\"$(\"$storage_bin\" exec --task:job-gpu-demo --package:pkg://demo/compute --author:node:alice --requester:node:app-1 \\\n  --gpu_ms:120000 --gpu_mem_bytes:8589934592 --gpu_count:1 --gpu_type:A10G --workload:infer \\\n  --price_gpu:0.00002 --price_gpu_mem:0.15 --epoch:\"$EPOCH\" --root:\"$ROOT\" --mode:\"$MODE\" 2>/dev/null)\"\nif [ $? -ne 0 ]; then\n  runtime_ok=\"0\"\nfi\nset -e\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  req_id=\"$(printf '%s' \"$req_out\" | sed -n 's/^exec ok: //p')\"\n  if [ -z \"${req_id:-}\" ]; then\n    runtime_ok=\"0\"\n  fi\nfi\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  set +e\n  usage_out=\"$(\"$storage_bin\" meter --task:job-gpu-demo --package:pkg://demo/compute --author:node:alice --executor:node:exec-1 \\\n    --gpu_ms:110000 --gpu_mem_bytes:7516192768 --gpu_count:1 --gpu_type:A10G --workload:infer \\\n    --price_gpu:0.00002 --price_gpu_mem:0.15 --royalty:0.12 --treasury:0.03 \\\n    --epoch:\"$EPOCH\" --root:\"$ROOT\" --mode:\"$MODE\" 2>/dev/null)\"\n  if [ $? -ne 0 ]; then\n    runtime_ok=\"0\"\n  fi\n  set -e\nfi\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  usage_id=\"$(printf '%s' \"$usage_out\" | sed -n 's/^meter ok: //p')\"\n  if [ -z \"${usage_id:-}\" ]; then\n    runtime_ok=\"0\"\n  fi\nfi\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  set +e\n  rec_out=\"$(\"$storage_bin\" receipt --reques"
        out = out + "t:\"$req_id\" --task:job-gpu-demo --executor:node:exec-1 --status:ok \\\n    --usage:\"$usage_id\" --result:cid://result --epoch:\"$EPOCH\" --root:\"$ROOT\" --mode:\"$MODE\" 2>/dev/null)\"\n  if [ $? -ne 0 ]; then\n    runtime_ok=\"0\"\n  fi\n  set -e\nfi\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  rec_id=\"$(printf '%s' \"$rec_out\" | sed -n 's/^receipt ok: //p')\"\n  if [ -z \"${rec_id:-}\" ]; then\n    runtime_ok=\"0\"\n  fi\nfi\n\nif [ \"$runtime_ok\" = \"1\" ]; then\n  set +e\n  \"$storage_bin\" sample --root:\"$ROOT\" --epoch:\"$EPOCH\" --rate:1 --seed:demo \\\n    --auditor:node:auditor-1 --record --format:toml >/dev/null 2>/dev/null\n  [ $? -ne 0 ] && runtime_ok=\"0\"\n  \"$storage_bin\" audit --task:job-gpu-demo --executor:node:exec-1 --auditor:node:auditor-1 --status:bad \\\n    --penalty:0.10 --epoch:\"$EPOCH\" --note:demo --root:\"$ROOT\" --mode:\"$MODE\" >/dev/null 2>/dev/null\n  [ $? -ne 0 ] && runtime_ok=\"0\"\n  \"$storage_bin\" fraud --task:job-gpu-demo --executor:node:exec-1 --reporter:node:auditor-1 \\\n    --reason:demo --epoch:\"$EPOCH\" --root:\"$ROOT\" >/dev/null 2>/dev/null\n  [ $? -ne 0 ] && runtime_ok=\"0\"\n  set -e\nfi\n\nif [ \"$runtime_ok\" != \"1\" ]; then\n  echo \"warn: runtime write path unavailable, fallback to empty-ledger bridge verification\" 1>&2\n  : > \"$LEDGER\"\nfi\n\necho \"settle:\"\n\"$storage_bin\" settle --root:\"$ROOT\" --format:toml --top:5 --reconcile-csv:\"$ROOT/settle_reconcile.csv\"\n\nbatch_id=\"cheng-epoch-$EPOCH\"\n${TOO"
        out = out + "LING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_rwad_bridge export --root:\"$ROOT\" --epoch:\"$EPOCH\" --batch-id:\"$batch_id\" \\\n  --out:\"$ROOT/rwad_batch.json\" --top:0\n\nrwad_tool=\"$RWAD_CHAIN_ROOT/tools/rwad_cheng_points_settle.sh\"\nif [ -x \"$rwad_tool\" ]; then\n  \"$rwad_tool\" --batchFile:\"$ROOT/rwad_batch.json\" --budget:\"$SETTLEMENT_BUDGET\" \\\n    --stateIn:\"$ROOT/rwad_points_state.json\" --stateOut:\"$ROOT/rwad_points_state.json\" \\\n    --out:\"$ROOT/rwad_result.json\"\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_rwad_bridge apply --result:\"$ROOT/rwad_result.json\" \\\n    --batch:\"$ROOT/rwad_batch.json\" \\\n    --batch-id:\"$batch_id\" --require-status:finalized --out:\"$ROOT/rwad_ack.json\"\n  echo \"rwad-result:\"\n  cat \"$ROOT/rwad_result.json\"\nelse\n  if [ \"$ALLOW_MISSING_RWAD\" = \"1\" ]; then\n    echo \"warn: missing RWAD tool: $rwad_tool\" 1>&2\n  else\n    echo \"error: missing RWAD tool: $rwad_tool\" 1>&2\n    echo \"hint: pass --allow-missing-rwad for local-only demo mode\" 1>&2\n    exit 1\n  fi\nfi\n"
        return out
    if id == "demo_io_lease":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"build/cheng_demo\"\nMODE=\"local\"\nLISTEN=\"\"\nPEER=\"\"\nREQUIRE_LEASE=\"0\"\nCLEAN=\"0\"\nRESET_LEDGER=\"0\"\nFAIL_WITHOUT_LEASE=\"0\"\nREGEN_LEASE=\"0\"\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\ncd \"$repo_root\"\n\nresolve_chengc_bin() {\n  local name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$repo_root\" \"$name\"\n}\n\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\nregistry_bin=\"$(resolve_chengc_bin cheng_registry)\"\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    --root:*)\n      ROOT=\"${1#--root:}\"\n      ;;\n    --mode:*)\n      MODE=\"${1#--mode:}\"\n      ;;\n    --listen:*)\n      LISTEN=\"${1#--listen:}\"\n      ;;\n    --peer:*)\n      PEER=\"${1#--peer:}\"\n      ;;\n    --require-lease)\n      REQUIRE_LEASE=\"1\"\n      ;;\n    --clean)\n      CLEAN=\"1\"\n      ;;\n    --reset-ledger)\n      RESET_LEDGER=\"1\"\n      ;;\n    --fail-without-lease)\n      FAIL_WITHOUT_LEASE=\"1\"\n      ;;\n    --regen-lease)\n      REGEN_LEASE=\"1\"\n      ;;\n    *)\n      echo \"unknown arg: $1\" 1>&2\n      exit 1\n      ;;\n  esac\n  shift\ndone\nif [ \"$CLEAN\" = \"1\" ]; then\n  rm -rf \"$ROOT\"\nfi\nmkdir -p \"$ROOT\"\n\nif [ ! -x \"$storage_bin\" ]; then\n  src/tooling/chengc.sh src/tooling/cheng_storage.cheng --name:cheng_storage\nfi\n\nif [ ! -x \"$registry_bi"
        out = out + "n\" ]; then\n  src/tooling/chengc.sh src/tooling/cheng_registry.cheng --name:cheng_registry\nfi\n\nKEY_JSON=\"$ROOT/keypair.json\"\nif [ ! -f \"$KEY_JSON\" ]; then\n  \"$registry_bin\" keygen --out:\"$KEY_JSON\"\nfi\n\nLEDGER=\"$ROOT/ledger.jsonl\"\nif [ \"$RESET_LEDGER\" = \"1\" ] && [ -f \"$LEDGER\" ]; then\n  rm -f \"$LEDGER\"\nfi\npriv=\"$(sed -n 's/.*\"priv_key\"[[:space:]]*:[[:space:]]*\\\"\\\\([^\\\"]*\\\\)\\\".*/\\\\1/p' \"$KEY_JSON\")\"\nif [ -z \"${priv:-}\" ]; then\n  echo \"demo: missing priv_key\" 1>&2\n  exit 1\nfi\n\nLEASE_TOKEN=\"$ROOT/lease-token.json\"\nif [ \"$REGEN_LEASE\" = \"1\" ] || [ ! -f \"$LEASE_TOKEN\" ]; then\n  \"$storage_bin\" leasegen --package:pkg://demo/text --author:node:alice --provider:node:store-1 \\\n    --bytes:1048576 --days:30 --replicas:1 --price:0.25 --royalty:0.12 --treasury:0.03 \\\n    --priv:\"$priv\" --out:\"$LEASE_TOKEN\"\nfi\n\nif [ \"$REQUIRE_LEASE\" = \"1\" ]; then\n  export IO_REQUIRE_LEASE=1\nfi\nif [ \"$FAIL_WITHOUT_LEASE\" = \"1\" ] && [ \"$REQUIRE_LEASE\" != \"1\" ]; then\n  REQUIRE_LEASE=\"1\"\n  export IO_REQUIRE_LEASE=1\nfi\n\nif [ \"$MODE\" = \"p2p\" ]; then\n  if [ -z \"$LISTEN\" ] && [ -z \"$PEER\" ]; then\n    echo \"demo: p2p requires --listen or --peer\" 1>&2\n    exit 1\n  fi\nfi\n\nPUT_ARGS=(--root:\"$ROOT\" --mode:\"$MODE\")\nif [ -n \"$LISTEN\" ]; then\n  PUT_ARGS+=(--listen:\"$LISTEN\")\nfi\nif [ -n \"$PEER\" ]; then\n  PUT_ARGS+=(--peer:\"$PEER\")\nfi\n\nif [ \"$FAIL_WITHOUT_LEASE\" = \"1\" ]; then\n  ech"
        out = out + "o \"expect failure without lease:\"\n  set +e\n  \"$storage_bin\" put-text --text:\"no lease\" \"${PUT_ARGS[@]}\"\n  rc=$?\n  set -e\n  if [ \"$rc\" -eq 0 ]; then\n    echo \"demo: expected failure but succeeded\" 1>&2\n    exit 1\n  fi\nfi\n\ncid=\"$(\"$storage_bin\" put-text --text:\"hello lease\" --lease:\"$LEASE_TOKEN\" \"${PUT_ARGS[@]}\")\"\necho \"cid: $cid\"\n\necho \"cat:\"\n\"$storage_bin\" cat --cid:\"$cid\" \"${PUT_ARGS[@]}\"\n\necho \"cat raw:\"\n\"$storage_bin\" cat --cid:\"$cid\" --raw \"${PUT_ARGS[@]}\"\n\necho \"settle:\"\necho \"note: payouts are under payouts.authors/providers\"\n\"$storage_bin\" settle --root:\"$ROOT\" --format:toml --top:5\necho \"settle (yaml):\"\n\"$storage_bin\" settle --root:\"$ROOT\" --format:yaml --top:5\n"
        return out
    if id == "detect_host_target":
        return "#!/usr/bin/env sh\n:\nset -eu\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\ncase \"$host_os\" in\n  Darwin)\n    case \"$host_arch\" in\n      arm64|aarch64)\n        echo \"arm64-apple-darwin\"\n        exit 0\n        ;;\n      x86_64|amd64)\n        echo \"x86_64-apple-darwin\"\n        exit 0\n        ;;\n    esac\n    ;;\n  Linux)\n    case \"$host_arch\" in\n      arm64|aarch64)\n        echo \"aarch64-unknown-linux-gnu\"\n        exit 0\n        ;;\n      x86_64|amd64)\n        echo \"x86_64-unknown-linux-gnu\"\n        exit 0\n        ;;\n    esac\n    ;;\n  MINGW*|MSYS*|CYGWIN*)\n    case \"$host_arch\" in\n      arm64|aarch64)\n        echo \"aarch64-pc-windows-msvc\"\n        exit 0\n        ;;\n      x86_64|amd64)\n        echo \"x86_64-pc-windows-msvc\"\n        exit 0\n        ;;\n    esac\n    ;;\nesac\n\necho \"[Error] unsupported host for auto target detect: ${host_os}/${host_arch}\" 1>&2\necho \"  tip: pass --target:<triple> or set BACKEND_TARGET\" 1>&2\nexit 2\n"
    if id == "mobile_ci_android":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/mobile_ci_android.sh <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n\nBuilds the Android template and runs ./gradlew assembleDebug.\nEOF\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nname=\"\"\nout=\"\"\nassets=\"\"\nplugins=\"\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --assets:*)\n      assets=\"${1#--assets:}\"\n      ;;\n    --plugins:*)\n      plugins=\"${1#--plugins:}\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] file not found: $in\" 1>&2\n  exit 2\nfi\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\n\nroot=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\nif [ \"$out\" = \"\" ]; then\n  out=\"mobile_build/$name\"\nfi\ncase \"$out\" in\n  /*) ;;\n  *) out=\"$root/$out\" ;;\nesac\n\ncmd=\"src/tooling/"
        out = out + "build_mobile_export.sh\"\nargs=\"--with-android-project\"\nif [ \"$name\" != \"\" ]; then\n  args=\"$args --name:$name\"\nfi\nif [ \"$out\" != \"\" ]; then\n  args=\"$args --out:$out\"\nfi\nif [ \"$assets\" != \"\" ]; then\n  args=\"$args --assets:$assets\"\nfi\nif [ \"$plugins\" != \"\" ]; then\n  args=\"$args --plugins:$plugins\"\nfi\nif [ -n \"$mm\" ]; then\n  args=\"$args --mm:$mm\"\nfi\n\necho \"[ci-android] export: $in\"\nset -- $args\n\"$cmd\" \"$in\" \"$@\"\n\nproject=\"$out/android_project\"\nif [ ! -f \"$project/gradlew\" ]; then\n  echo \"[ci-android] gradlew not found: $project/gradlew\" 1>&2\n  exit 2\nfi\n\nverify_script=\"src/tooling/verify_android_kotlin_only.sh\"\nsh \"$verify_script\" --project:\"$project\"\n\necho \"[ci-android] build: $project\"\n(cd \"$project\" && ./gradlew assembleDebug)\necho \"[ci-android] ok\"\n"
        return out
    if id == "mobile_ci_harmony":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/mobile_ci_harmony.sh <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n\nBuilds the Harmony template and runs native C static smoke checks.\nEOF\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nname=\"\"\nout=\"\"\nassets=\"\"\nplugins=\"\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --assets:*)\n      assets=\"${1#--assets:}\"\n      ;;\n    --plugins:*)\n      plugins=\"${1#--plugins:}\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] file not found: $in\" 1>&2\n  exit 2\nfi\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\n\nroot=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\nif [ \"$out\" = \"\" ]; then\n  out=\"mobile_build/$name\"\nfi\ncase \"$out\" in\n  /*) ;;\n  *) out=\"$root/$out\" ;;\nesac\n\ncmd=\"src/too"
        out = out + "ling/build_mobile_export.sh\"\nargs=\"--with-harmony-project\"\nif [ \"$name\" != \"\" ]; then\n  args=\"$args --name:$name\"\nfi\nif [ \"$out\" != \"\" ]; then\n  args=\"$args --out:$out\"\nfi\nif [ \"$assets\" != \"\" ]; then\n  args=\"$args --assets:$assets\"\nfi\nif [ \"$plugins\" != \"\" ]; then\n  args=\"$args --plugins:$plugins\"\nfi\nif [ -n \"$mm\" ]; then\n  args=\"$args --mm:$mm\"\nfi\n\necho \"[ci-harmony] export: $in\"\nset -- $args\n\"$cmd\" \"$in\" \"$@\"\n\nproject=\"$out/harmony_project\"\nif [ ! -d \"$project\" ]; then\n  echo \"[ci-harmony] project not found: $project\" 1>&2\n  exit 2\nfi\n\nrequired_files=\"\n$project/CMakeLists.txt\n$project/cheng_mobile_harmony_bridge.c\n$project/cheng_mobile_host_harmony.c\n$project/cheng_mobile_host_api.c\n$project/cheng_mobile_host_core.c\n$project/native/cheng_mobile_harmony_napi.c\n\"\nfor f in $required_files; do\n  if [ ! -f \"$f\" ]; then\n    echo \"[ci-harmony] missing required file: $f\" 1>&2\n    exit 2\n  fi\ndone\n\necho \"[ci-harmony] native static check\"\ncc -I\"$project\" -Wall -Wextra -Werror -fsyntax-only \"$project/cheng_mobile_harmony_bridge.c\"\ncc -I\"$project\" -Wall -Wextra -Werror -fsyntax-only \"$project/cheng_mobile_host_harmony.c\"\ncc -I\"$project\" -Wall -Wextra -Werror -fsyntax-only \"$project/cheng_mobile_host_api.c\"\ncc -I\"$project\" -Wall -Wextra -Werror -fsyntax-only \"$project/cheng_mobile_host_core.c\"\n\nif command -v cmake >/dev/null 2>&1; then\n  echo \"[ci-harmony] cmake build"
        out = out + "\"\n  build_dir=\"$project/.cmake-smoke\"\n  rm -rf \"$build_dir\"\n  cmake -S \"$project\" -B \"$build_dir\" >/dev/null\n  cmake --build \"$build_dir\" >/dev/null\nfi\n\nif ! rg -n \"pollBusRequest|pushBusResponse\" \"$project/native/cheng_mobile_harmony_napi.c\" >/dev/null 2>&1; then\n  echo \"[ci-harmony] NAPI bus hooks missing in native/cheng_mobile_harmony_napi.c\" 1>&2\n  exit 2\nfi\n\necho \"[ci-harmony] ok\"\n"
        return out
    if id == "mobile_ci_ios":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/mobile_ci_ios.sh <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n\nBuilds the iOS template and runs xcodegen/xcodebuild if available.\nEOF\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nname=\"\"\nout=\"\"\nassets=\"\"\nplugins=\"\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --assets:*)\n      assets=\"${1#--assets:}\"\n      ;;\n    --plugins:*)\n      plugins=\"${1#--plugins:}\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] file not found: $in\" 1>&2\n  exit 2\nfi\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\n\nroot=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\nif [ \"$out\" = \"\" ]; then\n  out=\"mobile_build/$name\"\nfi\ncase \"$out\" in\n  /*) ;;\n  *) out=\"$root/$out\" ;;\nesac\n\ncmd=\"src/tooling"
        out = out + "/build_mobile_export.sh\"\nargs=\"--with-ios-project\"\nif [ \"$name\" != \"\" ]; then\n  args=\"$args --name:$name\"\nfi\nif [ \"$out\" != \"\" ]; then\n  args=\"$args --out:$out\"\nfi\nif [ \"$assets\" != \"\" ]; then\n  args=\"$args --assets:$assets\"\nfi\nif [ \"$plugins\" != \"\" ]; then\n  args=\"$args --plugins:$plugins\"\nfi\nif [ -n \"$mm\" ]; then\n  args=\"$args --mm:$mm\"\nfi\n\necho \"[ci-ios] export: $in\"\nset -- $args\n\"$cmd\" \"$in\" \"$@\"\n\nproject=\"$out/ios_project\"\nif [ ! -d \"$project\" ]; then\n  echo \"[ci-ios] project not found: $project\" 1>&2\n  exit 2\nfi\n\nif command -v xcodegen >/dev/null 2>&1; then\n  echo \"[ci-ios] xcodegen\"\n  (cd \"$project\" && sh ./generate_xcodeproj.sh)\nelse\n  echo \"[ci-ios] xcodegen not found; skip project generation\"\nfi\n\nif command -v xcodebuild >/dev/null 2>&1; then\n  if [ -d \"$project/ChengMobileApp.xcodeproj\" ]; then\n    echo \"[ci-ios] xcodebuild\"\n    (cd \"$project\" && xcodebuild -project ChengMobileApp.xcodeproj -scheme ChengMobileApp -configuration Debug -sdk iphonesimulator -destination \"generic/platform=iOS Simulator\" build)\n  else\n    echo \"[ci-ios] xcodeproj missing; run xcodegen first\"\n  fi\nelse\n  echo \"[ci-ios] xcodebuild not found; skip build\"\nfi\n\nif [ ! -d \"$project/ChengMobileApp.xcodeproj\" ] || ! command -v xcodebuild >/dev/null 2>&1; then\n  if command -v xcrun >/dev/null 2>&1; then\n    echo \"[ci-ios] fallback clang syntax check\"\n    src=\"$project/ChengMobileAp"
        out = out + "p\"\n    sdk=\"$(xcrun --sdk iphonesimulator --show-sdk-path)\"\n    xcrun --sdk iphonesimulator clang -fobjc-arc -fsyntax-only -isysroot \"$sdk\" -I\"$src\" \"$src/cheng_mobile_ios_glue.m\"\n    xcrun --sdk iphonesimulator clang -fobjc-arc -fsyntax-only -isysroot \"$sdk\" -I\"$src\" \"$src/ChengViewController.m\"\n  else\n    echo \"[ci-ios] xcrun not found; skip fallback syntax check\"\n  fi\nfi\n\necho \"[ci-ios] ok\"\n"
        return out
    if id == "mobile_run_android":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/mobile_run_android.sh <file.cheng> [--name:<appName>] [--out:<dir>] [--assets:<dir>] [--plugins:<csv>] [--mm:<orc>] [--orc]\n\nBuilds the Android Studio template (NDK) and runs it on a connected device:\n  - export .cheng -> Android project\n  - ./gradlew assembleDebug\n  - adb install -r\n  - adb shell am start\n\nNotes:\n  - Requires Android SDK (ANDROID_SDK_ROOT/ANDROID_HOME or default macOS path).\n  - If multiple devices are connected, set ANDROID_SERIAL.\nEOF\n}\n\nif [ \"${1:-}\" = \"\" ] || [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ]; then\n  usage\n  exit 0\nfi\n\nin=\"$1\"\nshift || true\n\nname=\"\"\nout=\"\"\nassets=\"\"\nplugins=\"\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --assets:*)\n      assets=\"${1#--assets:}\"\n      ;;\n    --plugins:*)\n      plugins=\"${1#--plugins:}\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nif [ ! -f \"$in\" ]; then\n  echo \"[Error] file not found: $in\" 1>&2\n  exit 2\nfi\n\nif ! command -v "
        out = out + "adb >/dev/null 2>&1; then\n  echo \"[Error] missing tool: adb\" 1>&2\n  exit 2\nfi\n\nserial=\"${ANDROID_SERIAL:-}\"\nif [ -z \"$serial\" ]; then\n  serial=\"$(adb devices | awk 'NR>1 && $2 == \"device\" {print $1; exit}')\"\nfi\nif [ -z \"$serial\" ]; then\n  echo \"[Error] no Android device/emulator detected (adb devices)\" 1>&2\n  echo \"[Error] set ANDROID_SERIAL to select a device\" 1>&2\n  exit 2\nfi\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$in\")\"\n  name=\"${base%.cheng}\"\nfi\nif [ \"$out\" = \"\" ]; then\n  out=\"mobile_build/$name\"\nfi\ncase \"$out\" in\n  /*) ;;\n  *) out=\"$root/$out\" ;;\nesac\n\nsdk=\"${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}\"\nif [ -z \"$sdk\" ]; then\n  if [ -d \"$HOME/Library/Android/sdk\" ]; then\n    sdk=\"$HOME/Library/Android/sdk\"\n  elif [ -d \"$HOME/Android/Sdk\" ]; then\n    sdk=\"$HOME/Android/Sdk\"\n  fi\nfi\nif [ -z \"$sdk\" ] || [ ! -d \"$sdk\" ]; then\n  echo \"[Error] missing Android SDK (set ANDROID_SDK_ROOT or install Android Studio SDK)\" 1>&2\n  exit 2\nfi\n\ncmd=\"src/tooling/build_mobile_export.sh\"\nargs=\"--with-android-project\"\nif [ \"$name\" != \"\" ]; then\n  args=\"$args --name:$name\"\nfi\nif [ \"$out\" != \"\" ]; then\n  args=\"$args --out:$out\"\nfi\nif [ \"$assets\" != \"\" ]; then\n  args=\"$args --assets:$assets\"\nfi\nif [ \"$plugins\" != \"\" ]; then\n  args=\"$args --plugins:$plugins\"\nfi\nif [ -n \"$mm\" ]; t"
        out = out + "hen\n  args=\"$args --mm:$mm\"\nfi\n\necho \"[run-android] export: $in\" >&2\nset -- $args\n\"$cmd\" \"$in\" \"$@\"\n\nproject=\"$out/android_project\"\nif [ ! -f \"$project/gradlew\" ]; then\n  echo \"[run-android] gradlew not found: $project/gradlew\" 1>&2\n  exit 2\nfi\n\nverify_script=\"src/tooling/verify_android_kotlin_only.sh\"\nsh \"$verify_script\" --project:\"$project\"\n\necho \"[run-android] local.properties sdk.dir=$sdk\" >&2\nprintf \"sdk.dir=%s\\n\" \"$sdk\" > \"$project/local.properties\"\n\necho \"[run-android] build: $project\" >&2\n(cd \"$project\" && ./gradlew assembleDebug)\n\napk=\"$project/app/build/outputs/apk/debug/app-debug.apk\"\nif [ ! -f \"$apk\" ]; then\n  echo \"[run-android] debug apk not found: $apk\" 1>&2\n  exit 1\nfi\n\necho \"[run-android] install: $apk\" >&2\nadb -s \"$serial\" install -r \"$apk\" >/dev/null\n\npkg=\"com.cheng.mobile\"\nactivity=\"com.cheng.mobile/.ChengActivity\"\necho \"[run-android] launch: $pkg ($serial)\" >&2\nadb -s \"$serial\" shell am force-stop \"$pkg\" >/dev/null 2>&1 || true\nadb -s \"$serial\" shell am start -n \"$activity\" >/dev/null\n\necho \"mobile_run_android ok\"\n"
        return out
    if id == "mobile_run_harmony":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport TOOLING_EXEC_WRAPPER_CALLER=\"mobile_run_harmony\"\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_harmony \"$@\"\n"
    if id == "mobile_run_ios":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport TOOLING_EXEC_WRAPPER_CALLER=\"mobile_run_ios\"\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_ios \"$@\"\n"
    if id == "package_ide":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/package_ide.sh [--out:<dir>] [--name:<prog>] [--compiler:auto|stage1] [--no-archive] [--mm:<orc>] [--orc]\n\nNotes:\n  - Build the native GUI IDE and generate a distribution directory.\n  - Default output is dist/<prog>-<platform>; optionally create .tar.gz.\nEOF\n}\n\nprog=\"cheng_ide_gui\"\nout=\"\"\ncompiler=\"stage1\"\narchive=\"1\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --name:*)\n      prog=\"${1#--name:}\"\n      ;;\n    --compiler:*)\n      compiler=\"${1#--compiler:}\"\n      ;;\n    --no-archive)\n      archive=\"0\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nhere=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")\" && pwd)\"\nroot=\"$(CDPATH= cd -- \"$here/../..\" && pwd)\"\nide_root=\"${IDE_ROOT:-}\"\nif [ -z \"$ide_root\" ] && [ -d \"$root/../cheng-ide\" ]; then\n  ide_root=\"$root/../cheng-ide\"\nfi\nif [ -z \"$ide_root\" ] || [ ! -d \"$ide_root\" ]; then\n  echo \"[Error] missing IDE root (set IDE_ROOT to /path/to/cheng-ide)\" 1>&2\n  exit 2\nfi\nexpor"
        out = out + "t IDE_ROOT=\"$ide_root\"\n\nuname_s=\"$(uname -s)\"\nplatform=\"unknown\"\ncase \"$uname_s\" in\n  Darwin)\n    platform=\"macos\"\n    ;;\n  Linux)\n    platform=\"linux\"\n    ;;\n  MINGW*|MSYS*|CYGWIN*|Windows_NT)\n    platform=\"windows\"\n    ;;\nesac\n\nif [ \"$out\" = \"\" ]; then\n  out=\"$root/dist/${prog}-${platform}\"\nfi\n\nbin_name=\"$prog\"\ncase \"$platform\" in\n  windows)\n    bin_name=\"${prog}.exe\"\n    ;;\nesac\nbin_path=\"$out/$bin_name\"\n\nmkdir -p \"$out\"\n\nmm_flag=\"\"\nif [ -n \"$mm\" ]; then\n  mm_flag=\"--mm:$mm\"\nfi\n\n\"src/tooling/build_ide_gui.sh\" --out:\"$bin_path\" --name:\"$prog\" --compiler:\"$compiler\" $mm_flag\n\nif [ -f \"$ide_root/README.md\" ]; then\n  cp \"$ide_root/README.md\" \"$out/\"\nfi\nif [ -f \"$ide_root/license.txt\" ]; then\n  cp \"$ide_root/license.txt\" \"$out/\"\nfi\nif [ -f \"$ide_root/docs/cheng-ide-dev-plan.md\" ]; then\n  cp \"$ide_root/docs/cheng-ide-dev-plan.md\" \"$out/\"\nfi\nif [ -f \"$ide_root/resources/fonts/codicon.ttf\" ]; then\n  mkdir -p \"$out/resources\"\n  cp \"$ide_root/resources/fonts/codicon.ttf\" \"$out/resources/codicon.ttf\"\nfi\n\necho \"[package] out: $out\"\necho \"[package] bin: $bin_path\"\n\nif [ \"$archive\" = \"1\" ]; then\n  parent_dir=\"$(dirname \"$out\")\"\n  base_name=\"$(basename \"$out\")\"\n  archive_path=\"${out}.tar.gz\"\n  (cd \"$parent_dir\" && tar -czf \"$archive_path\" \"$base_name\")\n  echo \"[package] archive: $archive_path\"\nfi\n"
        return out
    if id == "package_unimaker_desktop":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/package_unimaker_desktop.sh [--out:<dir>] [--name:<prog>] [--compiler:auto|stage1]\n                                           [--ide-compiler:auto|stage1] [--ide-bin:<path>] [--skip-ide]\n                                           [--no-archive] [--mm:<orc>] [--orc]\n\nNotes:\n  - Build Unimaker Desktop and generate a distribution directory.\n  - Package the IDE binary and ide/resources by default.\n  - Default output is dist/<prog>-<platform>; optionally create .tar.gz.\nEOF\n}\n\nprog=\"unimaker_desktop\"\nout=\"\"\ncompiler=\"stage1\"\nide_compiler=\"stage1\"\nide_bin=\"\"\nskip_ide=\"0\"\narchive=\"1\"\nmm=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    --out:*)\n      out=\"${1#--out:}\"\n      ;;\n    --name:*)\n      prog=\"${1#--name:}\"\n      ;;\n    --compiler:*)\n      compiler=\"${1#--compiler:}\"\n      ;;\n    --ide-compiler:*)\n      ide_compiler=\"${1#--ide-compiler:}\"\n      ;;\n    --ide-bin:*)\n      ide_bin=\"${1#--ide-bin:}\"\n      ;;\n    --skip-ide)\n      skip_ide=\"1\"\n      ;;\n    --no-archive)\n      archive=\"0\"\n      ;;\n    --orc)\n      mm=\"orc\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$mm\" != \"\" ] && [ \"$mm\" != \"orc\" ]; then\n  echo \"[E"
        out = out + "rror] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\n\nhere=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")\" && pwd)\"\nroot=\"$(CDPATH= cd -- \"$here/../..\" && pwd)\"\nide_root=\"${IDE_ROOT:-}\"\nif [ -z \"$ide_root\" ] && [ -d \"$root/../cheng-ide\" ]; then\n  ide_root=\"$root/../cheng-ide\"\nfi\nif [ -z \"$ide_root\" ] || [ ! -d \"$ide_root\" ]; then\n  echo \"[Error] missing IDE root (set IDE_ROOT to /path/to/cheng-ide)\" 1>&2\n  exit 2\nfi\nexport IDE_ROOT=\"$ide_root\"\n\nuname_s=\"$(uname -s)\"\nplatform=\"unknown\"\ncase \"$uname_s\" in\n  Darwin)\n    platform=\"macos\"\n    ;;\n  Linux)\n    platform=\"linux\"\n    ;;\n  MINGW*|MSYS*|CYGWIN*|Windows_NT)\n    platform=\"windows\"\n    ;;\nesac\n\nif [ \"$out\" = \"\" ]; then\n  out=\"$root/dist/${prog}-${platform}\"\nfi\n\nbin_name=\"$prog\"\nide_bin_name=\"main_local\"\ncase \"$platform\" in\n  windows)\n    bin_name=\"${prog}.exe\"\n    ide_bin_name=\"main_local.exe\"\n    ;;\nesac\nbin_path=\"$out/$bin_name\"\nide_out=\"$out/ide/$ide_bin_name\"\nide_manifest=\"$out/ide/manifest.txt\"\nide_prev_dir=\"$out/ide/previous\"\nide_prev_manifest=\"$ide_prev_dir/manifest.txt\"\n\nmkdir -p \"$out\"\n\nmm_flag=\"\"\nif [ -n \"$mm\" ]; then\n  mm_flag=\"--mm:$mm\"\nfi\n\n\"src/tooling/build_unimaker_desktop.sh\" --out:\"$bin_path\" --name:\"$prog\" --compiler:\"$compiler\" $mm_flag\n\nif [ \"$skip_ide\" = \"0\" ]; then\n  mkdir -p \"$out/ide\"\n  if [ -f \"$ide_out\" ]; then\n    mkdir -p \"$ide_prev_dir\"\n    cp "
        out = out + "-p \"$ide_out\" \"$ide_prev_dir/$ide_bin_name\"\n  fi\n  if [ -d \"$out/ide/resources\" ]; then\n    mkdir -p \"$ide_prev_dir\"\n    rm -rf \"$ide_prev_dir/resources\"\n    cp -R \"$out/ide/resources\" \"$ide_prev_dir/\"\n  fi\n  if [ -f \"$ide_manifest\" ]; then\n    mkdir -p \"$ide_prev_dir\"\n    cp -p \"$ide_manifest\" \"$ide_prev_manifest\"\n  fi\n  if [ -n \"$ide_bin\" ]; then\n    if [ ! -f \"$ide_bin\" ]; then\n      echo \"[Error] missing IDE binary: $ide_bin\" 1>&2\n      exit 2\n    fi\n    cp -p \"$ide_bin\" \"$ide_out\"\n    ide_source=\"copy\"\n  else\n    \"src/tooling/build_ide_gui.sh\" --out:\"$ide_out\" --name:\"cheng_ide_gui\" --compiler:\"$ide_compiler\" $mm_flag\n    ide_source=\"build\"\n  fi\n  if [ -d \"$ide_root/resources\" ]; then\n    cp -R \"$ide_root/resources\" \"$out/ide/\"\n  fi\n  build_ts=\"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\"\n  {\n    echo \"built_at=$build_ts\"\n    echo \"ide_bin=$ide_bin_name\"\n    echo \"ide_compiler=$ide_compiler\"\n    echo \"ide_source=$ide_source\"\n    if [ -n \"$mm\" ]; then\n      echo \"mm=$mm\"\n    fi\n  } > \"$ide_manifest\"\nfi\n\nif [ -f \"$root/examples/unimaker_desktop/README.md\" ]; then\n  cp \"$root/examples/unimaker_desktop/README.md\" \"$out/README.md\"\nfi\nif [ -f \"$root/doc/unimaker-desktop-dev-plan.md\" ]; then\n  cp \"$root/doc/unimaker-desktop-dev-plan.md\" \"$out/\"\nfi\nif [ -f \"$root/LICENSE\" ]; then\n  cp \"$root/LICENSE\" \"$out/\"\nfi\nif [ -f \"$root/LICENSE-MIT\" ]; then\n  cp \"$ro"
        out = out + "ot/LICENSE-MIT\" \"$out/\"\nfi\nif [ -f \"$root/LICENSE-APACHEv2\" ]; then\n  cp \"$root/LICENSE-APACHEv2\" \"$out/\"\nfi\n\necho \"[package] out: $out\"\necho \"[package] bin: $bin_path\"\nif [ \"$skip_ide\" = \"0\" ]; then\n  echo \"[package] ide: $ide_out\"\nfi\n\nif [ \"$archive\" = \"1\" ]; then\n  parent_dir=\"$(dirname \"$out\")\"\n  base_name=\"$(basename \"$out\")\"\n  archive_path=\"${out}.tar.gz\"\n  (cd \"$parent_dir\" && tar -czf \"$archive_path\" \"$base_name\")\n  echo \"[package] archive: $archive_path\"\nfi\n"
        return out
    if id == "prewarm_deps_parallel":
        return "#!/usr/bin/env sh\n:\nset -eu\n\necho \"[Error] legacy deps prewarm pipeline has been removed.\" 1>&2\necho \"  tip: backend-only pipeline no longer requires this step\" 1>&2\nexit 2\n"
    if id == "profile_backend_sample":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\nbuilder=\"$repo_root/src/tooling/build_profile_backend_sample.sh\"\nsrc_c=\"$repo_root/src/tooling/profile_backend_sample.c\"\nbin_path=\"${PROFILE_SAMPLE_BIN:-$repo_root/artifacts/bin/profile_backend_sample}\"\n\ncase \"$bin_path\" in\n  /*) ;;\n  *) bin_path=\"$PWD/$bin_path\" ;;\nesac\n\nneed_build=\"0\"\nif [ ! -x \"$bin_path\" ]; then\n  need_build=\"1\"\nelif [ \"$src_c\" -nt \"$bin_path\" ] || [ \"$builder\" -nt \"$bin_path\" ]; then\n  need_build=\"1\"\nfi\n\nif [ \"$need_build\" = \"1\" ]; then\n  sh \"$builder\" \"$bin_path\" >/dev/null\nfi\n\nexec \"$bin_path\" \"$@\"\n"
    if id == "rawptr_migrate_ffi":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexport TOOLING_EXEC_WRAPPER_CALLER=\"rawptr_migrate_ffi\"\nexec ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} rawptr_migrate_ffi \"$@\"\n"
    if id == "resolve_system_linker":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\ncontains_fuse_ld_flag() {\n  case \"${1:-}\" in\n    *-fuse-ld=*) return 0 ;;\n  esac\n  return 1\n}\n\ntool_available() {\n  command -v \"$1\" >/dev/null 2>&1\n}\n\nldflags_hint=\"${BACKEND_LDFLAGS:-}\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --ldflags:*)\n      ldflags_hint=\"${1#--ldflags:}\"\n      ;;\n    *)\n      echo \"[resolve_system_linker] unknown arg: $1\" 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"${BACKEND_LD:-}\" != \"\" ]; then\n  echo \"kind=explicit_ld\"\n  echo \"ldflags=\"\n  exit 0\nfi\n\nif contains_fuse_ld_flag \"$ldflags_hint\"; then\n  echo \"kind=user_ldflags\"\n  echo \"ldflags=\"\n  exit 0\nfi\n\npriority_raw=\"${BACKEND_SYSTEM_LINKER_PRIORITY:-mold,lld,default}\"\npriority_csv=\"$(printf '%s' \"$priority_raw\" | tr ';' ',' | tr '[:upper:]' '[:lower:]')\"\nkind=\"default\"\nldflags=\"\"\n\nold_ifs=\"$IFS\"\nIFS=','\nfor token in $priority_csv; do\n  case \"$token\" in\n    \"\"|\" \")\n      continue\n      ;;\n    mold)\n      if tool_available mold || tool_available ld.mold; then\n        kind=\"mold\"\n        ldflags=\"-fuse-ld=mold\"\n        break\n      fi\n      ;;\n    lld)\n      if tool_available ld.lld || tool_available lld || tool_available llvm-lld; then\n        kind=\"lld\"\n        ldflags=\"-fuse-ld=lld\"\n        break\n      fi\n      ;;\n    default)\n      kind=\"default\"\n      ldflags=\"\"\n      break\n      ;;\n    *)\n      ;;\n  esac\ndone\nIFS=\"$old_ifs\"\n\necho \"kind=$kind\"\necho \"ldflags=$ldflags\"\n"
    if id == "run_mdns_lan_two_node_smoke":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"$(cd \"$(dirname \"$0\")/..\" && pwd)\"\nROOT=\"${ROOT:-$ROOT}\"\nDEFAULT_BIN=\"${ROOT}/mdns_lan_two_node_smoke_mvp_exe\"\nBIN=\"${1:-${MDNS_LAN_SMOKE_BIN:-$DEFAULT_BIN}}\"\n\nLAN_IP_ENV=\"MDNS_LAN_IP\"\nLAN_IP=\"${!LAN_IP_ENV-}\"\nLAN_IP_SOURCE=\"environment:${LAN_IP_ENV}\"\n\nis_private_or_lan_ip() {\n  local ip=\"$1\"\n  if [ -z \"$ip\" ]; then\n    return 1\n  fi\n  case \"$ip\" in\n    127.*|169.254.*|0.*|255.*|::*)\n      return 1\n      ;;\n    10.*|192.168.*)\n      return 0\n      ;;\n    172.*)\n      local a b\n      a=\"${ip%%.*}\"\n      b=\"${ip#*.}\"\n      b=\"${b%%.*}\"\n      case \"$b\" in\n        1[6-9]|2[0-9]|3[0-1]) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nif [ -z \"$LAN_IP\" ]; then\n  ROUTE_IFACE=\"\"\n  if command -v route >/dev/null 2>&1; then\n    ROUTE_IFACE=\"$(route -n get default 2>/dev/null | awk '/interface:/{print $2; exit}')\"\n  fi\n\n  candidates=()\n  if [ -n \"$ROUTE_IFACE\" ] && [[ \"$ROUTE_IFACE\" != utun* ]]; then\n    candidates+=(\"$ROUTE_IFACE\")\n  fi\n  if command -v ifconfig >/dev/null 2>&1; then\n    for iface in en0 en1 en2 en3 en4 en5 en6 eth0 eth1 awdl0; do\n      candidates+=(\"$iface\")\n    done\n  fi\n\n  for iface in \"${candidates[@]:-}\"; do\n    [ -z \"$iface\" ] && continue\n    if [ ! -d \"/sys/class/net\" ] && [ \"$iface\" = \"eth0\" ]; then\n      continue\n    fi\n    if [ -z \"$LAN_IP\" ]; then\n      if command -v ip >/dev/"
        out = out + "null 2>&1 && uname -s | grep -qi \"linux\"; then\n        LAN_IP=\"$(ip -4 -o addr show dev \"$iface\" 2>/dev/null | awk '$1==\"inet\" {split($4,a,\"/\"); print a[1]; exit}')\"\n      elif command -v ifconfig >/dev/null 2>&1 && uname -s | grep -qi \"darwin\"; then\n        LAN_IP=\"$(ifconfig \"$iface\" 2>/dev/null | awk '/inet / && $2 !~ /^127\\\\./ && $2 !~ /^169\\\\.254\\\\./ {print $2; exit}')\"\n      fi\n      if is_private_or_lan_ip \"$LAN_IP\"; then\n        LAN_IP_SOURCE=\"interface:$iface\"\n        break\n      fi\n      LAN_IP=\"\"\n    fi\n  done\nfi\n\nif ! is_private_or_lan_ip \"$LAN_IP\"; then\n  echo \"ERROR: no usable LAN IPv4 found. Set MDNS_LAN_IP manually.\" >&2\n  echo \"Examples: export MDNS_LAN_IP=192.168.3.17\" >&2\n  exit 1\nfi\n\nif [ ! -f \"$BIN\" ] || [ ! -x \"$BIN\" ]; then\n  echo \"ERROR: mdns smoke binary missing or not executable: $BIN\" >&2\n  exit 2\nfi\n\necho \"mdns-lan smoke bin: $BIN\"\necho \"MDNS_LAN_IP=${LAN_IP} (source=${LAN_IP_SOURCE})\"\nexport MDNS_LAN_IP=\"$LAN_IP\"\nexec \"$BIN\"\n"
        return out
    if id == "summarize_stage1_timeout_diag":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/summarize_stage1_timeout_diag.sh [--dir:<diag_dir>] [--latest:<n>] [--file:<summary_or_log>]\n\nNotes:\n  - Summarizes stage1 fullspec timeout diagnostics generated by verify_stage1_fullspec.sh.\n  - Prefers <diag_dir>/summary.tsv when available, and falls back to parsing latest diag logs.\nEOF\n}\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ndiag_dir=\"chengcache/stage1_fullspec_timeout_diag\"\nlatest=\"3\"\nsingle_file=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --dir:*)\n      diag_dir=\"${1#--dir:}\"\n      ;;\n    --latest:*)\n      latest=\"${1#--latest:}\"\n      ;;\n    --file:*)\n      single_file=\"${1#--file:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[stage1_timeout_diag] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\ncase \"$latest\" in\n  ''|*[!0-9]*)\n    echo \"[stage1_timeout_diag] invalid --latest: $latest\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"$latest\" -lt 1 ]; then\n  latest=\"1\"\nfi\n\nhint_for_backend() {\n  backend=\"$1\"\n  case \"$backend\" in\n    module_cache.load)\n      echo \"likely stuck in build_module (frontend/semantics/generics/lowering).\"\n      ;;\n    build_module)\n      echo \"likely stuck after IR build (emit/link path).\"\n      ;;\n    single.emit_"
        out = out + "obj|single.link)\n      echo \"likely stuck in object emit or link stage.\"\n      ;;\n    *)\n      echo \"inspect profile tail + diag log for next missing stage transition.\"\n      ;;\n  esac\n}\n\nsummary_print_header() {\n  echo \"== stage1_timeout_diag.summary ==\"\n}\n\nsummary_print_row() {\n  ts=\"$1\"\n  label=\"$2\"\n  diag_status=\"$3\"\n  backend_after=\"$4\"\n  uir_after=\"$5\"\n  health=\"$6\"\n  hint=\"$7\"\n  log_file=\"$8\"\n  health_log=\"$9\"\n  printf \"ts=%s label=%s diag_status=%s backend_after=%s uir_after=%s health=%s\\n\" \\\n    \"$ts\" \"$label\" \"$diag_status\" \"$backend_after\" \"$uir_after\" \"$health\"\n  printf \"hint=%s\\n\" \"$hint\"\n  printf \"log=%s\\n\" \"$log_file\"\n  if [ \"$health_log\" != \"\" ]; then\n    printf \"health_log=%s\\n\" \"$health_log\"\n  fi\n}\n\nparse_log_last_label() {\n  log_file=\"$1\"\n  marker=\"$2\"\n  awk -F'\\t' -v marker=\"$marker\" '\n    $0 ~ marker {label=$2}\n    END {\n      if (label == \"\") {\n        print \"unknown\"\n      } else {\n        print label\n      }\n    }\n  ' \"$log_file\"\n}\n\nif [ \"$single_file\" != \"\" ]; then\n  if [ ! -f \"$single_file\" ]; then\n    echo \"[stage1_timeout_diag] missing file: $single_file\" 1>&2\n    exit 2\n  fi\n  case \"$single_file\" in\n    *.tsv)\n      summary_file=\"$single_file\"\n      ;;\n    *)\n      summary_print_header\n      backend_after=\"$(parse_log_last_label \"$single_file\" \"backend_profile\")\"\n      uir_after=\"$(parse_log_last_lab"
        out = out + "el \"$single_file\" \"uir_profile\")\"\n      hint=\"$(hint_for_backend \"$backend_after\")\"\n      summary_print_row \"unknown\" \"$(basename \"$single_file\")\" \"unknown\" \"$backend_after\" \"$uir_after\" \"unknown\" \"$hint\" \"$single_file\" \"\"\n      exit 0\n      ;;\n  esac\nelse\n  summary_file=\"$diag_dir/summary.tsv\"\nfi\n\nif [ -f \"$summary_file\" ]; then\n  summary_print_header\n  echo \"source=$summary_file\"\n  tmp_rows=\"$(mktemp \"$root/chengcache/.stage1_timeout_rows.XXXXXX\" 2>/dev/null || echo \"$root/chengcache/.stage1_timeout_rows.$$\")\"\n  trap 'rm -f \"$tmp_rows\"' EXIT\n  awk 'NR > 1 {print}' \"$summary_file\" | tail -n \"$latest\" >\"$tmp_rows\"\n  if [ ! -s \"$tmp_rows\" ]; then\n    echo \"[stage1_timeout_diag] no entries in summary file\" 1>&2\n    exit 2\n  fi\n  while IFS=\"$(printf '\\t')\" read -r ts label cmd diag_status backend_after uir_after health hint log_file health_log; do\n    [ \"$ts\" = \"\" ] && continue\n    summary_print_row \"$ts\" \"$label\" \"$diag_status\" \"$backend_after\" \"$uir_after\" \"$health\" \"$hint\" \"$log_file\" \"$health_log\"\n    if [ \"$cmd\" != \"\" ]; then\n      printf \"cmd=%s\\n\" \"$cmd\"\n    fi\n  done <\"$tmp_rows\"\n  exit 0\nfi\n\nif [ ! -d \"$diag_dir\" ]; then\n  echo \"[stage1_timeout_diag] missing diag dir: $diag_dir\" 1>&2\n  exit 2\nfi\n\ndiag_files=\"$(ls -1t \"$diag_dir\"/*.log 2>/dev/null | grep -v \"/health_probe_\" | head -n \"$latest\" || true)\"\nif [ \"$diag_files\" = \"\" ]; th"
        out = out + "en\n  echo \"[stage1_timeout_diag] no diag logs found in $diag_dir\" 1>&2\n  exit 2\nfi\n\nsummary_print_header\necho \"source=$diag_dir (log fallback)\"\nprintf \"%s\\n\" \"$diag_files\" | while IFS= read -r log_file; do\n  [ \"$log_file\" = \"\" ] && continue\n  log_base=\"$(basename \"$log_file\" .log)\"\n  ts=\"${log_base##*_}\"\n  label=\"${log_base%_$ts}\"\n  backend_after=\"$(parse_log_last_label \"$log_file\" \"backend_profile\")\"\n  uir_after=\"$(parse_log_last_label \"$log_file\" \"uir_profile\")\"\n  hint=\"$(hint_for_backend \"$backend_after\")\"\n  health_log=\"$diag_dir/health_probe_${label}_${ts}.log\"\n  health_obj=\"$diag_dir/health_probe_${label}_${ts}.o\"\n  health=\"unknown\"\n  if [ -s \"$health_obj\" ]; then\n    health=\"ok\"\n  elif [ -f \"$health_log\" ]; then\n    health=\"log-only\"\n  else\n    health=\"missing\"\n    health_log=\"\"\n  fi\n  summary_print_row \"$ts\" \"$label\" \"unknown\" \"$backend_after\" \"$uir_after\" \"$health\" \"$hint\" \"$log_file\" \"$health_log\"\ndone\n"
        return out
    if id == "summarize_timeout_diag":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/summarize_timeout_diag.sh [--file:<sample.txt> | --dir:<diag_dir>] [--latest:<n>] [--top:<n>] [--include-unknown]\n\nNotes:\n  - Summarizes macOS `sample` call-graph files and prints top hot frames.\n  - Default search dirs:\n      chengcache/backend_timeout_diag\n      chengcache/libp2p_frontier/logs/timeout_diag\n  - By default, `???` frames are filtered out; use `--include-unknown` to keep them.\nEOF\n}\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsingle_file=\"\"\ndiag_dir=\"\"\nlatest=\"1\"\ntop_n=\"12\"\ninclude_unknown=\"0\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --file:*)\n      single_file=\"${1#--file:}\"\n      ;;\n    --dir:*)\n      diag_dir=\"${1#--dir:}\"\n      ;;\n    --latest:*)\n      latest=\"${1#--latest:}\"\n      ;;\n    --top:*)\n      top_n=\"${1#--top:}\"\n      ;;\n    --include-unknown)\n      include_unknown=\"1\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[timeout_diag] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\ncase \"$latest\" in\n  ''|*[!0-9]*)\n    echo \"[timeout_diag] invalid --latest: $latest\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$top_n\" in\n  ''|*[!0-9]*)\n    echo \"[timeout_diag] invalid --top: $top_n\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"$latest\""
        out = out + " -lt 1 ]; then\n  latest=\"1\"\nfi\nif [ \"$top_n\" -lt 1 ]; then\n  top_n=\"1\"\nfi\n\ncollect_files() {\n  if [ \"$single_file\" != \"\" ]; then\n    if [ ! -f \"$single_file\" ]; then\n      echo \"[timeout_diag] missing file: $single_file\" 1>&2\n      exit 2\n    fi\n    printf '%s\\n' \"$single_file\"\n    return\n  fi\n\n  if [ \"$diag_dir\" != \"\" ]; then\n    ls -1t \"$diag_dir\"/*.sample.txt 2>/dev/null | head -n \"$latest\" || true\n    return\n  fi\n\n  {\n    ls -1t chengcache/backend_timeout_diag/*.sample.txt 2>/dev/null || true\n    ls -1t chengcache/libp2p_frontier/logs/timeout_diag/*.sample.txt 2>/dev/null || true\n  } | awk '!seen[$0]++' | head -n \"$latest\"\n}\n\nextract_counts() {\n  keep_unknown=\"$1\"\n  sample_file=\"$2\"\n  awk -v keep_unknown=\"$keep_unknown\" '\n    {\n      line = $0;\n      gsub(/^[[:space:]+!|:]*/, \"\", line);\n      if (line !~ /^[0-9]+[[:space:]]+/) next;\n\n      cnt = line;\n      sub(/[[:space:]].*$/, \"\", cnt);\n      line = substr(line, length(cnt) + 1);\n      sub(/^[[:space:]]+/, \"\", line);\n\n      frame = line;\n      sub(/[[:space:]]+\\(in .*/, \"\", frame);\n      sub(/[[:space:]]+$/, \"\", frame);\n      if (frame == \"\") next;\n      if (frame ~ /^Thread_/) next;\n      if (frame == \"start\") next;\n      if (keep_unknown != 1 && frame == \"???\") next;\n\n      print cnt \"\\t\" frame;\n    }\n  ' \"$sample_file\"\n}\n\nmkdir -p \"$root/chengcache\"\ntmp_files=\"$(mktemp \"$root/chengcache/.timeout_diag_fil"
        out = out + "es.XXXXXX\" 2>/dev/null || echo \"$root/chengcache/.timeout_diag_files.$$\")\"\ntmp_counts=\"$(mktemp \"$root/chengcache/.timeout_diag_counts.XXXXXX\" 2>/dev/null || echo \"$root/chengcache/.timeout_diag_counts.$$\")\"\ncleanup_tmp() {\n  rm -f \"$tmp_files\" \"$tmp_counts\"\n}\ntrap cleanup_tmp EXIT\n\ncollect_files >\"$tmp_files\"\nif [ ! -s \"$tmp_files\" ]; then\n  echo \"[timeout_diag] no sample files found\" 1>&2\n  exit 2\nfi\n\nfile_count=\"$(wc -l <\"$tmp_files\" | tr -d ' ')\"\necho \"== timeout_diag.summary ==\"\necho \"files=$file_count\"\nwhile IFS= read -r f; do\n  [ \"$f\" = \"\" ] && continue\n  echo \"file=$f\"\ndone <\"$tmp_files\"\n\n: >\"$tmp_counts\"\nwhile IFS= read -r sample_file; do\n  [ \"$sample_file\" = \"\" ] && continue\n  extract_counts \"$include_unknown\" \"$sample_file\" >>\"$tmp_counts\" 2>/dev/null || true\ndone <\"$tmp_files\"\nif [ ! -s \"$tmp_counts\" ] && [ \"$include_unknown\" = \"0\" ]; then\n  : >\"$tmp_counts\"\n  while IFS= read -r sample_file; do\n    [ \"$sample_file\" = \"\" ] && continue\n    extract_counts 1 \"$sample_file\" >>\"$tmp_counts\" 2>/dev/null || true\n  done <\"$tmp_files\"\nfi\n\nif [ ! -s \"$tmp_counts\" ]; then\n  echo \"top=none\"\n  exit 0\nfi\n\necho \"top=$top_n\"\nawk -F '\\t' '{sum[$2]+=$1} END{for (k in sum) printf \"%d\\t%s\\n\", sum[k], k}' \"$tmp_counts\" \\\n  | sort -nr -k1,1 \\\n  | head -n \"$top_n\" \\\n  | while IFS=\"$(printf '\\t')\" read -r cnt frame; do\n      [ \"$frame\" = \"\" ] && continue"
        out = out + "\n      echo \"$cnt\t$frame\"\n    done\n"
        return out
    if id == "web_build_native_server":
        return "#!/usr/bin/env sh\n:\nset -eu\n\necho \"[Error] legacy native C server builder has been removed.\" 1>&2\necho \"  tip: build backend executables via src/tooling/chengb.sh\" 1>&2\nexit 2\n"
    if id == "verify_android_kotlin_only":
        return "#!/usr/bin/env sh\nset -eu\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_android_kotlin_only.sh --project:<android_project_dir>\nEOF\n}\n\nproject=\"\"\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    --project:*)\n      project=\"${1#--project:}\"\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$project\" = \"\" ]; then\n  echo \"[Error] missing --project:<android_project_dir>\" 1>&2\n  exit 2\nfi\nif [ ! -d \"$project\" ]; then\n  echo \"[Error] Android project not found: $project\" 1>&2\n  exit 2\nfi\n\nmain_dir=\"$project/app/src/main\"\nkotlin_dir=\"$main_dir/kotlin\"\nif [ ! -d \"$kotlin_dir\" ]; then\n  echo \"[Error] Kotlin source directory not found: $kotlin_dir\" 1>&2\n  exit 2\nfi\n\njava_file=\"$(find \"$main_dir\" -type f -name '*.java' | head -n 1 || true)\"\nif [ \"$java_file\" != \"\" ]; then\n  echo \"[Error] Java source is not allowed for Android host: $java_file\" 1>&2\n  echo \"[Error] Android integration is Kotlin-only; move host sources to app/src/main/kotlin.\" 1>&2\n  exit 2\nfi\n\necho \"[verify-android-kotlin-only] ok project=$project\"\n"
    if id == "verify_backend_abi_v2_noptr":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  case \"$seconds\" in\n    ''|*[!0-9]*)\n      \"$@\"\n      return $?\n      ;;\n  esac\n  if command -v timeout >/dev/null 2>&1; then\n    timeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  if command -v gtimeout >/dev/null 2>&1; then\n    gtimeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndriver_help_ok() {\n  cand=\"$1\"\n  if [ \"$cand\" = \"\" ] || [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  set +e\n  \"$cand\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_has_no"
        out = out + "n_c_abi_diag() {\n  cand=\"$1\"\n  if [ \"$cand\" = \"\" ] || [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 1\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  local_driver=\"${BACKEND_LOCAL_DRIVER_REL:-artifacts/backend_driver/cheng}\"\n  if driver_help_ok \"$local_driver\"; then\n    driver=\"$local_driver\"\n  else\n    driver=\"$(env \\\n      ABI=v2_noptr \\\n      STAGE1_STD_NO_POINTERS=0 \\\n      STAGE1_STD_NO_POINTERS_STRICT=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n  fi\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[Error] backend driver not executable: $driver\" 1>&2\n  exit 2\nfi\n\ntarget=\"${BACKEND_TARGET:-}\"\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  target=\"$(${TOOLING_SELF_BIN:-artifacts/"
        out = out + "tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\n\nout_dir=\"artifacts/backend_abi_v2_noptr\"\nprobe_dir=\"src/std\"\nprobe=\"$probe_dir/abi_v2_noptr_probe_tmp.cheng\"\nobj=\"$out_dir/abi_v2_noptr_probe.o\"\nlog=\"$out_dir/abi_v2_noptr_probe.log\"\nprobe_non_c_abi=\"tests/cheng/backend/fixtures/abi_v2_noptr_non_c_abi_probe_tmp.cheng\"\nobj_non_c_abi=\"$out_dir/abi_v2_noptr_non_c_abi_probe.o\"\nlog_non_c_abi=\"$out_dir/abi_v2_noptr_non_c_abi_probe.log\"\nprobe_default_cli=\"tests/cheng/backend/fixtures/abi_v2_noptr_default_cli_probe_tmp.cheng\"\nobj_default_cli=\"$out_dir/abi_v2_noptr_default_cli_probe.o\"\nlog_default_cli=\"$out_dir/abi_v2_noptr_default_cli_probe.log\"\nbridge_src=\"src/std/c.cheng\"\nobj_bridge=\"$out_dir/abi_v2_noptr_c_bridge_probe.o\"\nlog_bridge=\"$out_dir/abi_v2_noptr_c_bridge_probe.log\"\nchengc_tool=\"src/tooling/chengc.sh\"\nmkdir -p \"$out_dir\"\ntimeout_s=\"${BACKEND_ABI_V2_NOPTR_TIMEOUT:-60}\"\nif [ \"${GENERIC_MODE:-}\" = \"\" ]; then\n  export GENERIC_MODE=dict\nfi\nif [ \"${GENERIC_SPEC_BUDGET:-}\" = \"\" ]; then\n  export GENERIC_SPEC_BUDGET=0\nfi\ngate_generic_mode=\"${BACKEND_ABI_V2_NOPTR_GENERIC_MODE:-dict}\"\ngate_generic_budget=\"${BACKEND_ABI_V2_NOPTR_GENERIC_SPEC_BUDGET:-0}\"\nif ! driver_has_non_c_abi_diag \"$driver\"; then\n  echo \"[Error] driver missing non-C-ABI no-pointer diagnostic marker: $driver\" 1>&2\n  exit 1\nfi\n\ncleanup_probe() {\n  rm -f \"$probe\"\n  rm -f \"$probe_non_c_abi\"\n  rm -f \"$probe_default_cli\"\n}\ntr"
        out = out + "ap cleanup_probe EXIT\n\ncat >\"$probe\" <<'EOF'\nfn main(): int32 =\n    var p: int32* = nil\n    return 0\nEOF\n\ncat >\"$probe_non_c_abi\" <<'EOF'\nfn main(): int32 =\n    var p: int32* = nil\n    return 0\nEOF\n\ncat >\"$probe_default_cli\" <<'EOF'\nfn main(): int32 =\n    var p: int32* = nil\n    return 0\nEOF\n\necho \"== backend.abi_v2_noptr.v2_noptr ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POINTERS_STRICT=1 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=1 \\\n  STAGE1_SKIP_SEM=0 \\\n  GENERIC_MODE=\"$gate_generic_mode\" \\\n  GENERIC_SPEC_BUDGET=\"$gate_generic_budget\" \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$probe\" \\\n  BACKEND_OUTPUT=\"$obj\" \\\n  \"$driver\" >\"$log\" 2>&1\nstatus=\"$?\"\nset -e\n\nif [ \"$status\" -eq 0 ]; then\n  echo \"[Error] expected v2_noptr to reject pointer usage under src/std: $probe\" 1>&2\n  exit 1\nfi\nif [ \"$status\" -eq 124 ]; then\n  echo \"[Error] v2_noptr gate timed out after ${timeout_s}s\" 1>&2\n  exit 1\nfi\nif ! grep -Fq \"std policy: pointer types are forbidden in standard library\" \"$log\" && \\\n   ! grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$log\"; then\n  echo \"[Error] missing expected pointer policy diagnostic in: $log\" 1>&2\n  exit 1\nfi\n\necho \"== backend.abi_v2_noptr.non_c_abi.v2_gate ==\"\nset +e\nrun_wit"
        out = out + "h_timeout \"$timeout_s\" env \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=1 \\\n  STAGE1_SKIP_SEM=0 \\\n  GENERIC_MODE=\"$gate_generic_mode\" \\\n  GENERIC_SPEC_BUDGET=\"$gate_generic_budget\" \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$probe_non_c_abi\" \\\n  BACKEND_OUTPUT=\"$obj_non_c_abi\" \\\n  \"$driver\" >\"$log_non_c_abi\" 2>&1\nstatus_non_c_abi=\"$?\"\nset -e\n\nif [ \"$status_non_c_abi\" -eq 0 ]; then\n  echo \"[Error] expected non-C-ABI probe to be rejected when STAGE1_NO_POINTERS_NON_C_ABI=1: $probe_non_c_abi\" 1>&2\n  exit 1\nfi\nif [ \"$status_non_c_abi\" -eq 124 ]; then\n  echo \"[Error] non-C-ABI pointer gate timed out after ${timeout_s}s\" 1>&2\n  exit 1\nfi\nif ! grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$log_non_c_abi\"; then\n  echo \"[Error] missing expected non-C-ABI pointer diagnostic in: $log_non_c_abi\" 1>&2\n  exit 1\nfi\n\necho \"== backend.abi_v2_noptr.default_cli.non_c_abi ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  -u STAGE1_NO_POINTERS_NON_C_ABI \\\n  -u STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" \"$probe_default_cli\" --backend:obj "
        out = out + "--emit-obj --obj-out:\"$obj_default_cli\" >\"$log_default_cli\" 2>&1\nstatus_default_cli=\"$?\"\nset -e\nif [ \"$status_default_cli\" -eq 124 ]; then\n  echo \"[Error] default chengc non-C-ABI pointer probe timed out after ${timeout_s}s\" 1>&2\n  exit 1\nfi\nif [ \"$status_default_cli\" -eq 0 ]; then\n  echo \"[Error] expected default chengc path to reject non-C-ABI pointer usage: $probe_default_cli\" 1>&2\n  exit 1\nfi\nif ! grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$log_default_cli\"; then\n  echo \"[Error] missing default chengc non-C-ABI pointer diagnostic in: $log_default_cli\" 1>&2\n  exit 1\nfi\n\necho \"== backend.abi_v2_noptr.c_abi_bridge ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_WHOLE_PROGRAM=0 \\\n  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" \"$bridge_src\" --backend:obj --emit-obj --obj-out:\"$obj_bridge\" >\"$log_bridge\" 2>&1\nstatus_bridge=\"$?\"\nset -e\nif [ \"$status_bridge\" -ne 0 ]; then\n  echo \"[Error] expected C ABI bridge probe to pass under v2_noptr: $bridge_src\" 1>&2\n  if [ \"$status_bridge\" -eq 124 ]; then\n    echo \"[Error] C ABI bridge probe timed out after ${timeout_s}s\" 1>&2\n  fi\n  tail -n 120 \"$log_bridge\" 1>&2 || true\n  exit 1\nfi\nif ["
        out = out + " ! -s \"$obj_bridge\" ]; then\n  echo \"[Error] missing C ABI bridge object output: $obj_bridge\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_abi_v2_noptr ok\"\n"
        return out
    if id == "verify_backend_android":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"aarch64-linux-android\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\n\n# Keep android gate focused on cross-target codegen/linking, independent of closure no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\n\ndetect_ndk_from_sdk() {\n  sdk=\"$1\"\n  if [ -z \"$sdk\" ]; then\n    return 1\n  fi\n  if [ -d \"$sdk/ndk-bundle\" ]; then\n    echo \"$sdk/ndk-bundle\"\n    return 0\n  fi\n  if [ -d \"$sdk/ndk\" ]; then\n    latest=\"$(find \"$sdk/ndk\" -maxdepth 1 -mindepth 1 -type d -print 2>/dev/null | LC_ALL=C sort | tail -n 1 || true)\"\n    if [ -n \"$latest\" ]; then"
        out = out + "\n      echo \"$latest\"\n      return 0\n    fi\n  fi\n  return 1\n}\n\nndk=\"${ANDROID_NDK_HOME:-${ANDROID_NDK_ROOT:-}}\"\nif [ -z \"$ndk\" ]; then\n  sdk=\"${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}\"\n  if [ -z \"$sdk\" ]; then\n    if [ -d \"$HOME/Library/Android/sdk\" ]; then\n      sdk=\"$HOME/Library/Android/sdk\"\n    elif [ -d \"$HOME/Android/Sdk\" ]; then\n      sdk=\"$HOME/Android/Sdk\"\n    fi\n  fi\n  ndk=\"$(detect_ndk_from_sdk \"$sdk\" || true)\"\nfi\nif [ -z \"$ndk\" ] || [ ! -d \"$ndk\" ]; then\n  echo \"[verify_backend_android] missing NDK (install via Android Studio -> SDK Manager -> SDK Tools -> NDK (Side by side))\" >&2\n  echo \"[verify_backend_android] set ANDROID_NDK_HOME or ANDROID_SDK_ROOT to run\" >&2\n  exit 2\nfi\n\nhost_prebuilt=\"\"\nfor candidate in darwin-arm64 darwin-x86_64 linux-x86_64 linux-arm64 linux-aarch64 windows-x86_64 windows-x64; do\n  if [ -d \"$ndk/toolchains/llvm/prebuilt/$candidate\" ]; then\n    host_prebuilt=\"$candidate\"\n    break\n  fi\ndone\nif [ -z \"$host_prebuilt\" ]; then\n  echo \"[verify_backend_android] missing NDK host prebuilt in $ndk\" >&2\n  exit 2\nfi\n\ntool_bin=\"$ndk/toolchains/llvm/prebuilt/$host_prebuilt/bin\"\napi=\"${ANDROID_API:-21}\"\nndk_cc=\"$tool_bin/aarch64-linux-android${api}-clang\"\nndk_readelf=\"$tool_bin/llvm-readelf\"\nndk_nm=\"$tool_bin/llvm-nm\"\n\nif [ ! -x \"$ndk_cc\" ]; then\n  echo \"[verify_backend_android] missing tool: $ndk_cc\" >&2\n  exit 2\nfi\nif [ ! -x \"$ndk_readelf\" ]; then\n  "
        out = out + "echo \"[verify_backend_android] missing tool: $ndk_readelf\" >&2\n  exit 2\nfi\nif [ ! -x \"$ndk_nm\" ]; then\n  echo \"[verify_backend_android] missing tool: $ndk_nm\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_android\"\nmkdir -p \"$out_dir\"\n\nis_bootstrap_darwin_only_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  grep -Eq \"bootstrap path only supports darwin target|supports darwin target only\" \"$log_file\"\n}\n\nif [ \"$linker_mode\" = \"self\" ]; then\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$runtime_obj\" ]; then\n    runtime_log=\"$out_dir/runtime_android.build.log\"\n    set +e\n    BACKEND_ALLOW_NO_MAIN=1 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n    BACKEND_OUTPUT=\"$runtime_obj\" \\\n    \"$driver\" >\"$runtime_log\" 2>&1\n    runtime_status=\"$?\"\n    set -e\n    if [ \"$runtime_status\" -ne 0 ]; then\n      if is_bootstrap_darwin_only_log \"$runtime_log\"; then\n        echo \"[verify_backend_android] skip android target: bootstrap darwin-only path\" >&2\n        exit 2\n      fi\n      echo \"[verify_backend_android] runtime object build failed: $runtime_obj\" >&2\n      tail -n 200 \"$runtime_log\" >&2 || true\n      exit \"$runtime_status\"\n    fi\n  fi\nfi\n\nfor fixture in tests/cheng/backend/fixtu"
        out = out + "res/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_object_copy_assign.cheng \\\n               tests/cheng/backend/fixtures/return_global_assign.cheng \\\n               tests/cheng/backend/fixtures/return_store_deref.cheng \\\n               tests/cheng/backend/fixtures/return_if.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng \\\n               tests/cheng/backend/fixtures/return_for_sum.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/hello_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_free.cheng\ndo\n  echo \"[verify_backend_android] build: $fixture\" >&2\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/${base}.android\"\n  build_log=\"$out_dir/${base}.build.log\"\n  pkg_roots=\"\"\n  multi=\"0\"\n  rm -f \"$exe_path\" \"$build_log\" \"$out_dir/${base}.readelf.txt\" \"$out_dir/${base}.nm.txt\"\n  if [ \"$linker_mode\" = \"self\" ]; then\n    set +e\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_MULTI=\"$multi\" \\\n    BACKEND_MULTI_FORCE=0 \\\n    PKG_ROOTS=\"$pkg_roots\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$build_log\" 2>&1\n    build_status=\"$"
        out = out + "?\"\n    set -e\n  else\n    set +e\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=system \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_CC=\"$ndk_cc\" \\\n    BACKEND_CFLAGS='-fPIE' \\\n    BACKEND_LDFLAGS='-fPIE -pie -llog' \\\n    BACKEND_MULTI=\"$multi\" \\\n    BACKEND_MULTI_FORCE=0 \\\n    PKG_ROOTS=\"$pkg_roots\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$build_log\" 2>&1\n    build_status=\"$?\"\n    set -e\n  fi\n\n  if [ \"$build_status\" -ne 0 ]; then\n    if is_bootstrap_darwin_only_log \"$build_log\"; then\n      echo \"[verify_backend_android] skip android target: bootstrap darwin-only path\" >&2\n      exit 2\n    fi\n    echo \"[verify_backend_android] compile failed: $fixture\" >&2\n    tail -n 200 \"$build_log\" >&2 || true\n    exit \"$build_status\"\n  fi\n\n  if [ ! -s \"$exe_path\" ]; then\n    echo \"[verify_backend_android] missing output: $exe_path\" >&2\n    exit 1\n  fi\n\n  if ! \"$ndk_readelf\" -h \"$exe_path\" > \"$out_dir/${base}.readelf.txt\" 2>&1; then\n    echo \"[verify_backend_android] readelf failed: $exe_path\" >&2\n    cat \"$out_dir/${base}.readelf.txt\" >&2 || true\n    exit 1\n  fi\n  if ! grep -q \"Machine:[[:space:]]*AArch64\" \"$out_dir/${base}.readelf.txt\"; then\n    echo \"[verify_backend_android] unexpected readelf machine: $exe_path\" >&2\n    cat \"$out_dir/${base}.readelf.txt\" >&2 || true\n    exit 1\n  fi\n\n  if ! \"$ndk_nm\" -g \"$exe_path\" > \"$out_dir/${base}.nm.t"
        out = out + "xt\" 2>&1; then\n    echo \"[verify_backend_android] nm failed: $exe_path\" >&2\n    cat \"$out_dir/${base}.nm.txt\" >&2 || true\n    exit 1\n  fi\n  if grep -qi \"no symbols\" \"$out_dir/${base}.nm.txt\"; then\n    :\n  else\n    if ! grep -Eq \"(_)?main$\" \"$out_dir/${base}.nm.txt\"; then\n      echo \"[verify_backend_android] missing main symbol: $exe_path\" >&2\n      cat \"$out_dir/${base}.nm.txt\" >&2 || true\n      exit 1\n    fi\n  fi\ndone\n\necho \"verify_backend_android ok\"\n"
        return out
    if id == "verify_backend_android_run":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v adb >/dev/null 2>&1; then\n  echo \"[verify_backend_android_run] missing tool: adb\" >&2\n  exit 2\nfi\n\nserial=\"${ANDROID_SERIAL:-}\"\nif [ -z \"$serial\" ]; then\n  serial=\"$(adb devices | awk 'NR>1 && $2 == \"device\" {print $1; exit}')\"\nfi\nif [ -z \"$serial\" ]; then\n  echo \"[verify_backend_android_run] no Android device/emulator detected (adb devices)\" >&2\n  echo \"[verify_backend_android_run] set ANDROID_SERIAL to select a device\" >&2\n  exit 2\nfi\n\nif [ \"${ANDROID_REBUILD:-0}\" = \"1\" ] || ! ls artifacts/backend_android/*.android >/dev/null 2>&1; then\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_android\nfi\n\nremote_dir=\"/data/local/tmp/cheng_backend\"\nadb -s \"$serial\" shell \"mkdir -p '$remote_dir'\"\n\nfor fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_object_copy_assign.cheng \\\n               tests/cheng/backend/fixtures/return_global_assign.cheng \\\n               tests/cheng/backend/fixtures/return_store_deref.cheng \\\n               tests/cheng/backend/fixtures/return_if.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng \\\n               tests/cheng/backend/fixtures/return_for_sum.cheng \\\n               tests/cheng/backend/fixtures/return_c"
        out = out + "all9.cheng \\\n               tests/cheng/backend/fixtures/hello_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_free.cheng \\\n               tests/cheng/backend/fixtures/return_pkg_import_call.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"artifacts/backend_android/${base}.android\"\n  if [ ! -s \"$exe_path\" ]; then\n    echo \"[verify_backend_android_run] missing output: $exe_path\" >&2\n    exit 1\n  fi\n  remote_path=\"$remote_dir/${base}.android\"\n  echo \"[verify_backend_android_run] push: ${base}.android\" >&2\n  adb -s \"$serial\" push \"$exe_path\" \"$remote_path\" >/dev/null 2>&1\n  adb -s \"$serial\" shell \"chmod 755 '$remote_path'\"\n\n  echo \"[verify_backend_android_run] run: ${base}.android\" >&2\n  adb -s \"$serial\" shell \"$remote_path\"\ndone\n\necho \"verify_backend_android_run ok\"\n"
        return out
    if id == "verify_backend_ci_obj_only":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_ci_obj_only.sh [--seed:<path>] [--seed-id:<id>] [--seed-tar:<path>]\n                                            [--require-seed]\n                                            [--strict]\n\nNotes:\n  - Runs the backend .o-only bootstrap + fullchain tool smoke.\n  - Backend-only CI gate (C frontend path disabled).\n  - Includes selfhost performance regression gate (`verify_backend_selfhost_perf_regression.sh`).\n  - Selfhost perf limits default to `src/tooling/selfhost_perf_baseline.env` (override via `SELFHOST_PERF_BASELINE` / `SELFHOST_PERF_MAX_*`).\n  - Includes multi compile performance regression gate (`verify_backend_multi_perf_regression.sh`).\n  - Multi perf limits default to `src/tooling/multi_perf_baseline.env` (override via `MULTI_PERF_BASELINE` / `MULTI_PERF_MAX_*`).\n  - Also validates the self-linker output format for ELF/COFF (best-effort; use --strict to forbid skip).\n  - Requires:\n    - Darwin/arm64 host\n    - `codesign` (self-link output on macOS 15+ must be signed)\n    - a seed backend driver binary (typically from dist/releases)\n\nDefaults:\n  - If no seed is provided, uses:\n      dist/releases/current_id.txt -> dist/releases/<id>/backend_release.tar.gz\n  - Does not fall back to local artifacts seed paths automatically.\nEOF\n}\n\nseed=\"\"\nseed_id=\"\"\nseed_tar=\"\"\nrequire_seed=\"0\"\nstrict=\"0\"\nwhil"
        out = out + "e [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --seed:*)\n      seed=\"${1#--seed:}\"\n      ;;\n    --seed-id:*)\n      seed_id=\"${1#--seed-id:}\"\n      ;;\n    --seed-tar:*)\n      seed_tar=\"${1#--seed-tar:}\"\n      ;;\n    --require-seed)\n      require_seed=\"1\"\n      ;;\n    --strict)\n      strict=\"1\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\ncase \"$host_os/$host_arch\" in\n  Darwin/arm64)\n    ;;\n  *)\n    echo \"verify_backend_ci_obj_only skip: host=$host_os/$host_arch\" 1>&2\n    exit 2\n    ;;\nesac\n\nif ! command -v codesign >/dev/null 2>&1; then\n  echo \"verify_backend_ci_obj_only skip: missing codesign\" 1>&2\n  exit 2\nfi\n\nrun_step() {\n  name=\"$1\"\n  shift\n  echo \"== ${name} ==\"\n  set +e\n  \"$@\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ]; then\n    return 0\n  fi\n  if [ \"$status\" -eq 2 ]; then\n    if [ \"$strict\" = \"1\" ]; then\n      echo \"[verify_backend_ci_obj_only] ${name} returned skip (strict mode)\" 1>&2\n      exit 1\n    fi\n    echo \"== ${name} (skip) ==\"\n    return 0\n  fi\n  exit \"$status\"\n}\n\nseed_from_tar() {\n  tar_path=\"$1\"\n  if [ ! -f \"$tar_path\" ]; then\n    "
        out = out + "echo \"[Error] seed tar not found: $tar_path\" 1>&2\n    exit 2\n  fi\n  out_dir=\"chengcache/backend_seed_ci_$$\"\n  mkdir -p \"$out_dir\"\n  tar -xzf \"$tar_path\" -C \"$out_dir\"\n  extracted=\"$out_dir/cheng\"\n  if [ ! -f \"$extracted\" ]; then\n    echo \"[Error] seed tar missing cheng: $tar_path\" 1>&2\n    exit 2\n  fi\n  chmod +x \"$extracted\" 2>/dev/null || true\n  printf \"%s\\n\" \"$extracted\"\n}\n\nif [ \"$seed\" = \"\" ]; then\n  if [ \"$seed_tar\" != \"\" ]; then\n    seed=\"$(seed_from_tar \"$seed_tar\")\"\n  else\n    if [ \"$seed_id\" = \"\" ] && [ -f \"dist/releases/current_id.txt\" ]; then\n      seed_id=\"$(cat dist/releases/current_id.txt | tr -d '\\r\\n')\"\n    fi\n    if [ \"$seed_id\" != \"\" ]; then\n      for try_tar in \"dist/releases/$seed_id/backend_release.tar.gz\"; do\n        if [ -f \"$try_tar\" ]; then\n          seed_tar=\"$try_tar\"\n          seed=\"$(seed_from_tar \"$seed_tar\")\"\n          break\n        fi\n      done\n    fi\n  fi\nfi\n\nif [ \"$seed\" = \"\" ] && [ \"$require_seed\" = \"1\" ]; then\n  echo \"[Error] missing seed: pass --seed:<path> or provide dist/releases/current_id.txt\" 1>&2\n  exit 2\nfi\n\nif [ \"$seed\" = \"\" ]; then\n  echo \"[Error] missing seed: pass --seed/--seed-id/--seed-tar or provide dist/releases/current_id.txt\" 1>&2\n  exit 2\nfi\n\nseed_path=\"$seed\"\ncase \"$seed_path\" in\n  /*) ;;\n  *) seed_path=\"$root/$seed_path\" ;;\nesac\nif [ ! -x \"$seed_path\" ]; then\n  echo \"[Error] seed driver i"
        out = out + "s not executable: $seed_path\" 1>&2\n  exit 2\nfi\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ] && [ \"$seed_path\" = \"$root/cheng\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nrun_step \"backend.ci.selfhost_bootstrap_self_obj\" env \\\n  SELF_OBJ_BOOTSTRAP_STAGE0=\"$seed_path\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n\nperf_session=\"${SELFHOST_PERF_SESSION:-${SELF_OBJ_BOOTSTRAP_SESSION:-default}}\"\nrun_step \"backend.ci.selfhost_perf_regression\" env \\\n  SELFHOST_PERF_SESSION=\"$perf_session\" \\\n  SELFHOST_PERF_AUTO_BUILD=0 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_perf_regression\n\nrun_step \"backend.ci.multi_perf_regression\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_multi_perf_regression\n\nstage2=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\nif [ ! -x \"$stage2\" ]; then\n  echo \"[Error] missing stage2 backend driver: $stage2\" 1>&2\n  exit 1\nfi\nexport BACKEND_DRIVER=\"$stage2\"\n\nrun_step \"backend.ci.self_linker.elf\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_elf\nrun_step \"backend.ci.self_linker.coff\""
        out = out + " ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_coff\n\nrun_step \"backend.ci.fullchain_obj_only\" env \\\n  FULLCHAIN_OBJ_ONLY=1 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_fullchain_bootstrap\n\nrun_step \"backend.ci.obj_fullspec_gate\" env MM=orc ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_obj_fullspec_gate\n\necho \"verify_backend_ci_obj_only ok\"\n"
        return out
    if id == "verify_backend_closedloop":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nstrict=\"${BACKEND_MATRIX_STRICT:-0}\"\nrun_fullspec=\"${BACKEND_RUN_FULLSPEC:-0}\"\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    BACKEND_DRIVER_ALLOW_FALLBACK=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_closedloop] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\nlinkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"\nmulti_gate_driver=\"${BACKEND_MULTI_DRIVER:-}\"\nstage1_smoke_driver=\"${BACKEND_STAGE1_SMOKE_DRIVER:-$driver}\"\nmm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"\nif [ \"$linkerless_gate_driver\" != \"\" ] && [ ! -x \"$linkerless_gate_driver\" ];"
        out = out + " then\n  echo \"[verify_backend_closedloop] backend.linkerless_dev driver not executable: $linkerless_gate_driver\" 1>&2\n  exit 1\nfi\nif [ \"$multi_gate_driver\" != \"\" ] && [ ! -x \"$multi_gate_driver\" ]; then\n  echo \"[verify_backend_closedloop] backend.multi driver not executable: $multi_gate_driver\" 1>&2\n  exit 1\nfi\nif [ ! -x \"$stage1_smoke_driver\" ]; then\n  echo \"[verify_backend_closedloop] stage1 smoke driver not executable: $stage1_smoke_driver\" 1>&2\n  exit 1\nfi\nif [ \"$mm_gate_driver\" != \"\" ] && [ ! -x \"$mm_gate_driver\" ]; then\n  echo \"[verify_backend_closedloop] backend.mm driver not executable: $mm_gate_driver\" 1>&2\n  exit 1\nfi\nexport BACKEND_DRIVER=\"$driver\"\nbackend_mm=\"${BACKEND_MM:-${MM:-orc}}\"\nbackend_linker=\"${BACKEND_LINKER:-self}\"\nbackend_target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nsafe_target=\"$(printf '%s' \"$backend_target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nbackend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\nstage1_skip_sem=\"${STAGE1_SKIP_SEM:-0}\"\nstage1_skip_ownership=\"${STAGE1_SKIP_OWNERSHIP:-1}\"\ncase \"$backend_mm\" in\n  \"\"|orc)\n    backend_mm=\"orc\"\n    ;;\n  *)\n    echo \"[verify_backend_closedloop] invalid BACKEND_MM/MM: $backend_mm (expected orc)\" 1>&2\n    exit 2\n    ;;\nesac\n\ncase \"$backend_linker\" in\n  self|system)\n    ;;\n"
        out = out + "  *)\n    echo \"[verify_backend_closedloop] invalid BACKEND_LINKER: $backend_linker (expected self|system)\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"$backend_linker\" = \"self\" ] && [ ! -f \"$backend_runtime_obj\" ]; then\n  echo \"[verify_backend_closedloop] missing self-link runtime object: $backend_runtime_obj\" 1>&2\n  exit 2\nfi\n\nrun_step() {\n  name=\"$1\"\n  shift\n  echo \"== ${name} ==\"\n  set +e\n  \"$@\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ]; then\n    return 0\n  fi\n  if [ \"$status\" -eq 2 ]; then\n    if [ \"$strict\" = \"1\" ]; then\n      echo \"[verify_backend_closedloop] ${name} returned skip (strict mode)\" 1>&2\n      exit 1\n    fi\n    echo \"== ${name} (skip) ==\"\n    return 0\n  fi\n  exit \"$status\"\n}\n\nrun_step_allow_skip() {\n  name=\"$1\"\n  shift\n  echo \"== ${name} ==\"\n  set +e\n  \"$@\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ]; then\n    return 0\n  fi\n  if [ \"$status\" -eq 2 ]; then\n    echo \"== ${name} (skip) ==\"\n    return 0\n  fi\n  exit \"$status\"\n}\n\nprofile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$profile_smoke_fixture\" ]; then\n  profile_smoke_fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\n\nrun_step \"backend.profile_smoke\" env \\\n  BACKEND_PROFILE=1 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n  STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\"
        out = out + "\n  BACKEND_LINKER=self \\\n  BACKEND_NO_RUNTIME_C=1 \\\n  BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$backend_target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$profile_smoke_fixture\" \\\n  BACKEND_OUTPUT=artifacts/backend_closedloop/profile_smoke \\\n  \"$driver\"\nrun_step \"backend.profile_schema\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_profile_schema\nrun_step \"tooling.cmdline_runner\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_tooling_cmdline\nrun_step \"backend.import_cycle_predeclare\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_import_cycle_predeclare\nrun_step \"backend.rawptr_hard_gate\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_rawptr_contract\nrun_step \"backend.rawptr_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_rawptr_contract\nrun_step \"backend.rawptr_surface_forbid\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_rawptr_surface_forbid\nrun_step \"backend.ffi_slice_shim\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_ffi_slice_shim\nrun_step \"backend.ffi_outptr_tuple\" env BACKEND_FFI_OUTPTR_TUPLE_ALLOW_RUN_FAIL=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_ffi_outptr_tuple\nrun_step \"backend.ffi_handle_sandbox\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} ver"
        out = out + "ify_backend_ffi_handle_sandbox\nrun_step \"backend.ffi_borrow_bridge\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_ffi_borrow_bridge\nrun_step \"backend.mem_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_mem_contract\nrun_step \"backend.dod_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dod_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\nrun_step \"backend.mem_image_core\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_mem_image_core\nrun_step \"backend.mem_exe_emit\" env BACKEND_LINKER=self BACKEND_MEM_EXE_EMIT_REQUIRE_DRIVER_SIDECAR_ZERO=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_mem_exe_emit\nrun_step \"backend.profile_baseline\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_profile_baseline\nrun_step \"backend.dual_track\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dual_track\nrun_step \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_noalias_opt\nrun_step \"backend.egraph_cost\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIR"
        out = out + "E_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_egraph_cost\nrun_step \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dod_opt_regression\nif [ \"$linkerless_gate_driver\" != \"\" ]; then\n  run_step \"backend.linkerless_dev\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev BACKEND_DRIVER=\"$linkerless_gate_driver\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_linkerless_dev\nelse\n  run_step \"backend.linkerless_dev\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_linkerless_dev\nfi\nrun_step \"backend.hotpatch_meta\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch_meta\nrun_step \"backend.hotpatch_inplace\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch_inplace\nrun_step \"backend.incr_patch_fastpath\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_incr_patch_fastpath\nrun_step \"backend.mem_patch_regression\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} v"
        out = out + "erify_backend_mem_patch_regression\nrun_step \"backend.hotpatch\" env BACKEND_LINKER=self BACKEND_BUILD_TRACK=dev ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch\nrun_step \"backend.release_system_link\" env BACKEND_BUILD_TRACK=release BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_release_c_o3_lto\nrun_step \"backend.plugin_isolation\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_plugin_isolation\nrun_step \"backend.noptr_exemption_scope\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_noptr_exemption_scope\nself_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_seed/cheng.stage2}\"\nif [ \"$self_linker_gate_driver\" != \"\" ] && [ -x \"$self_linker_gate_driver\" ]; then\n  run_step \"backend.self_linker.elf\" env BACKEND_SELF_LINKER_DRIVER=\"$self_linker_gate_driver\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_elf\n  run_step \"backend.self_linker.coff\" env BACKEND_SELF_LINKER_DRIVER=\"$self_linker_gate_driver\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_coff\nelse\n  run_step \"backend.self_linker.elf\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_elf\n  run_step \"backend.self_linker.coff\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_self_linker_coff\nfi"
        out = out + "\n\nrm -rf artifacts/backend_closedloop\nmkdir -p artifacts/backend_closedloop\n\nstage1_smoke_multi=\"${BACKEND_MULTI:-0}\"\nstage1_smoke_multi_force=\"${BACKEND_MULTI_FORCE:-$stage1_smoke_multi}\"\nstage1_generic_mode=\"${BACKEND_CLOSEDLOOP_STAGE1_GENERIC_MODE:-dict}\"\nstage1_generic_budget=\"${BACKEND_CLOSEDLOOP_STAGE1_GENERIC_SPEC_BUDGET:-${GENERIC_SPEC_BUDGET:-0}}\"\nstage1_smoke_name=\"backend.closedloop_stage1_smoke\"\nstage1_smoke_input=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nstage1_smoke_output=\"artifacts/backend_closedloop/stage1_smoke\"\n\ncompile_stage1_smoke_self() {\n  set +e\n  env \\\n      MM=\"$backend_mm\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n      GENERIC_MODE=\"$stage1_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$stage1_generic_budget\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n    BACKEND_MULTI=\"$stage1_smoke_multi\" \\\n    BACKEND_MULTI_FORCE=\"$stage1_smoke_multi_force\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n    BACKEND_TARGET=\"$backend_target\" \\\n    BACKEND_INPUT=\"$stage1_smoke_input\" \\\n    BACKEND_OUTPUT=\"$stage1_smoke_output\" \\\n    \"$stage1_smoke_driver\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] && [ \"$stage1_smoke_multi\" != \"0\" ]; then\n    ech"
        out = out + "o \"[Warn] ${stage1_smoke_name}.compile parallel failed, retry serial\" 1>&2\n    env \\\n      MM=\"$backend_mm\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n      GENERIC_MODE=\"$stage1_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$stage1_generic_budget\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n      BACKEND_TARGET=\"$backend_target\" \\\n      BACKEND_INPUT=\"$stage1_smoke_input\" \\\n      BACKEND_OUTPUT=\"$stage1_smoke_output\" \\\n      \"$stage1_smoke_driver\"\n    return \"$?\"\n  fi\n  return \"$status\"\n}\n\ncompile_stage1_smoke_system() {\n  set +e\n  env \\\n    MM=\"$backend_mm\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n    GENERIC_MODE=\"$stage1_generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$stage1_generic_budget\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n    BACKEND_MULTI=\"$stage1_smoke_multi\" \\\n    BACKEND_MULTI_FORCE=\"$stage1_smoke_multi_force\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n"
        out = out + "    BACKEND_TARGET=\"$backend_target\" \\\n    BACKEND_INPUT=\"$stage1_smoke_input\" \\\n    BACKEND_OUTPUT=\"$stage1_smoke_output\" \\\n    \"$stage1_smoke_driver\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] && [ \"$stage1_smoke_multi\" != \"0\" ]; then\n    echo \"[Warn] ${stage1_smoke_name}.compile(system) parallel failed, retry serial\" 1>&2\n    env \\\n      MM=\"$backend_mm\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n      GENERIC_MODE=\"$stage1_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$stage1_generic_budget\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n      BACKEND_TARGET=\"$backend_target\" \\\n      BACKEND_INPUT=\"$stage1_smoke_input\" \\\n      BACKEND_OUTPUT=\"$stage1_smoke_output\" \\\n      \"$stage1_smoke_driver\"\n    return \"$?\"\n  fi\n  return \"$status\"\n}\n\nif [ \"$backend_linker\" = \"self\" ]; then\n  run_step \"${stage1_smoke_name}.compile\" compile_stage1_smoke_self\nelse\n  run_step \"${stage1_smoke_name}.compile\" compile_stage1_smoke_system\nfi\nrun_step \"${stage1_smoke_name}.run\" test -x \"$stage1_smoke_output\"\n\nstage1_smoke_name=\"backend.closedloop_stage1_std_os_smoke\"\nstage1_smoke_input=\"tests/"
        out = out + "cheng/backend/fixtures/return_import_std_os.cheng\"\nstage1_smoke_output=\"artifacts/backend_closedloop/stage1_std_os_smoke\"\nif [ \"$backend_linker\" = \"self\" ]; then\n  run_step \"${stage1_smoke_name}.compile\" compile_stage1_smoke_self\nelse\n  run_step \"${stage1_smoke_name}.compile\" compile_stage1_smoke_system\nfi\nrun_step \"${stage1_smoke_name}.run\" test -x \"$stage1_smoke_output\"\n\nverify_fullspec_no_seqbytes_undef() {\n  bin=\"artifacts/backend_closedloop/fullspec_backend\"\n  if [ ! -f \"$bin\" ]; then\n    echo \"[verify_backend_closedloop] fullspec output missing: $bin\" 1>&2\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    echo \"[verify_backend_closedloop] warn: nm not found, skip seqBytesOf undef check\" 1>&2\n    return 0\n  fi\n  if nm \"$bin\" 2>/dev/null | rg -q \"U[[:space:]].*seqBytesOf_T\"; then\n    echo \"[verify_backend_closedloop] unresolved seqBytesOf_T symbol in fullspec binary\" 1>&2\n    return 1\n  fi\n  return 0\n}\n\nis_known_fullspec_link_instability() {\n  log=\"$1\"\n  if [ ! -f \"$log\" ]; then\n    return 1\n  fi\n  if rg -q \"duplicate symbol: ___cheng_sym_3d_3d\" \"$log\"; then\n    return 0\n  fi\n  if rg -q \"Undefined symbols for architecture\" \"$log\" && rg -q \"L_cheng_str_\" \"$log\"; then\n    return 0\n  fi\n  if rg -q \"Symbol not found: _cheng_\" \"$log\"; then\n    return 0\n  fi\n  return 1\n}\n\nif [ \"$run_fullspec\" = \"1\" ]; then\n  fullspec_skip_sem=\"${BACKEND_FULLSPEC_SKIP_SEM:-1}\"\n  ful"
        out = out + "lspec_skip_ownership=\"${BACKEND_FULLSPEC_SKIP_OWNERSHIP:-$stage1_skip_ownership}\"\n  fullspec_generic_mode=\"${BACKEND_FULLSPEC_GENERIC_MODE:-dict}\"\n  fullspec_generic_budget=\"${BACKEND_FULLSPEC_GENERIC_SPEC_BUDGET:-0}\"\n  fullspec_validate=\"${BACKEND_FULLSPEC_VALIDATE:-0}\"\n  # Fullspec defaults to serial compile for stability; multi path is covered by\n  # dedicated backend.multi/backend.multi_lto gates.\n  fullspec_multi=\"${BACKEND_CLOSEDLOOP_FULLSPEC_MULTI:-0}\"\n  fullspec_multi_force=\"${BACKEND_CLOSEDLOOP_FULLSPEC_MULTI_FORCE:-$fullspec_multi}\"\n  fullspec_input=\"${BACKEND_CLOSEDLOOP_FULLSPEC_INPUT:-examples/backend_closedloop_fullspec.cheng}\"\n  fullspec_out=\"artifacts/backend_closedloop/fullspec_backend\"\n  fullspec_compile_only_out=\"${fullspec_out}.compile_only\"\n  fullspec_log=\"artifacts/backend_closedloop/fullspec_backend.compile.log\"\n  fullspec_compile_only_ok=\"0\"\n\n  compile_fullspec_compile_only_fallback() {\n    rm -f \"$fullspec_compile_only_out\" \"$fullspec_log\"\n    set +e\n    env \\\n      MM=\"$backend_mm\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"$fullspec_skip_sem\" \\\n      GENERIC_MODE=\"$fullspec_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$fullspec_generic_budget\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$fullspec_skip_ownership\" \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_LINKER=self"
        out = out + " \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_VALIDATE=\"$fullspec_validate\" \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_TARGET=\"$backend_target\" \\\n      BACKEND_INPUT=\"$fullspec_input\" \\\n      BACKEND_OUTPUT=\"$fullspec_compile_only_out\" \\\n      \"$driver\" >\"$fullspec_log\" 2>&1\n    status=\"$?\"\n    set -e\n    if [ \"$status\" -ne 0 ] || [ ! -s \"$fullspec_compile_only_out\" ]; then\n      tail -n 200 \"$fullspec_log\" 1>&2 || true\n      return 1\n    fi\n    fullspec_compile_only_ok=\"1\"\n    return 0\n  }\n\n  compile_fullspec_self() {\n    echo \"[verify_backend_closedloop] fullspec self-link uses compile-only profile\" 1>&2\n    compile_fullspec_compile_only_fallback\n    return \"$?\"\n  }\n\n  compile_fullspec_system() {\n    rm -f \"$fullspec_out\" \"$fullspec_log\"\n    rm -rf \"${fullspec_out}.objs\" \"${fullspec_out}.objs.lock\"\n    set +e\n    env \\\n      MM=\"$backend_mm\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"$fullspec_skip_sem\" \\\n      GENERIC_MODE=\"$fullspec_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$fullspec_generic_budget\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$fullspec_skip_ownership\" \\\n      BACKEND_MULTI=\"$fullspec_multi\" \\\n      BACKEND_MULTI_FORCE=\"$fullspec_multi_force\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=exe \\\n      B"
        out = out + "ACKEND_VALIDATE=\"$fullspec_validate\" \\\n      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_TARGET=\"$backend_target\" \\\n      BACKEND_INPUT=\"$fullspec_input\" \\\n      BACKEND_OUTPUT=\"$fullspec_out\" \\\n      \"$driver\" >\"$fullspec_log\" 2>&1\n    status=\"$?\"\n    if [ \"$status\" -ne 0 ] && [ \"$fullspec_multi\" != \"0\" ]; then\n      echo \"[Warn] backend.closedloop_fullspec.compile(system) parallel failed, retry serial\" 1>&2\n      env \\\n        MM=\"$backend_mm\" \\\n        STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n        STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n        STAGE1_SKIP_SEM=\"$fullspec_skip_sem\" \\\n        GENERIC_MODE=\"$fullspec_generic_mode\" \\\n        GENERIC_SPEC_BUDGET=\"$fullspec_generic_budget\" \\\n        STAGE1_SKIP_OWNERSHIP=\"$fullspec_skip_ownership\" \\\n        BACKEND_MULTI=0 \\\n        BACKEND_MULTI_FORCE=0 \\\n        BACKEND_FRONTEND=stage1 \\\n        BACKEND_EMIT=exe \\\n        BACKEND_VALIDATE=\"$fullspec_validate\" \\\n        BACKEND_LINKER=system \\\n        BACKEND_NO_RUNTIME_C=1 \\\n        BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n        BACKEND_WHOLE_PROGRAM=1 \\\n        BACKEND_TARGET=\"$backend_target\" \\\n        BACKEND_INPUT=\"$fullspec_input\" \\\n        BACKEND_OUTPUT=\"$fullspec_out\" \\\n        \"$driver\" >\"$fullspec_log\" 2>&1\n      status=\"$?\"\n    fi\n    if [ \"$sta"
        out = out + "tus\" -ne 0 ]; then\n      if is_known_fullspec_link_instability \"$fullspec_log\"; then\n        echo \"[verify_backend_closedloop] fullspec system-link unstable, fallback to compile-only check\" 1>&2\n        compile_fullspec_compile_only_fallback\n        return \"$?\"\n      fi\n      tail -n 200 \"$fullspec_log\" 1>&2 || true\n    fi\n    return \"$status\"\n  }\n\n  if [ \"$backend_linker\" = \"self\" ]; then\n    run_step \"backend.closedloop_fullspec.compile\" compile_fullspec_self\n  else\n    run_step \"backend.closedloop_fullspec.compile\" compile_fullspec_system\n  fi\n  if [ \"$fullspec_compile_only_ok\" = \"1\" ]; then\n    echo \"== backend.closedloop_fullspec.run (compile-only fallback) ==\"\n  elif [ -x \"$fullspec_out\" ]; then\n    run_step \"backend.closedloop_fullspec.symcheck\" verify_fullspec_no_seqbytes_undef\n    run_step \"backend.closedloop_fullspec.run\" sh -c '\n      ./artifacts/backend_closedloop/fullspec_backend | grep -Fq \"fullspec ok\"\n    '\n  else\n    echo \"[verify_backend_closedloop] fullspec compile did not produce runnable binary\" 1>&2\n    exit 1\n  fi\nelse\n  echo \"== backend.closedloop_fullspec (skip: set BACKEND_RUN_FULLSPEC=1 to enable) ==\"\nfi\n\nrun_step \"backend.no_obj_artifacts\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_no_obj_artifacts\n\necho \"verify_backend_closedloop ok\"\n"
        return out
    if id == "verify_backend_coff_lld_link":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\n\nfind_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf \"%s\\n\" \"$p\"\n      return 0\n    fi\n  fi\n  for n in llvm-objdump llvm-objdump-19 llvm-objdump-18 llvm-objdump-17 llvm-objdump-16 llvm-objdump-15 llvm-objdump-14; do\n    if command -v \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nobjdump=\"$(find_objdump || true)\"\nif [ \"$objdump\" = \"\" ]; then\n  echo \"[verify_backend_coff_lld_link] missing llvm-objdump\" >&2\n  exit 2\nfi\n\nlld_kind=\"\"\nlld_cmd=\"\"\nif command -v lld-link >/dev/null 2>&1; then\n  lld_kind=\"lld-link\"\n  lld_cmd=\"lld-link\"\nelif command -v llvm-lld >/dev/null 2>&1; then\n  lld_kind=\"llvm-lld\"\n"
        out = out + "  lld_cmd=\"llvm-lld -flavor link\"\nelif command -v ld.lld >/dev/null 2>&1; then\n  lld_kind=\"ld.lld\"\n  lld_cmd=\"ld.lld -flavor link\"\nelif command -v lld >/dev/null 2>&1; then\n  lld_kind=\"lld\"\n  lld_cmd=\"lld -flavor link\"\nelse\n  lld_kind=\"missing\"\nfi\n\ncheck_obj() {\n  obj=\"$1\"\n  machine=\"$2\"\n  stem=\"$3\"\n  if [ ! -s \"$obj\" ]; then\n    echo \"[verify_backend_coff_lld_link] missing output: $obj\" >&2\n    exit 1\n  fi\n  \"$objdump\" -h \"$obj\" > \"$out_dir/${stem}.objdump.h.txt\"\n  grep -q \"$machine\" \"$out_dir/${stem}.objdump.h.txt\"\n  grep -q \"\\\\.text\" \"$out_dir/${stem}.objdump.h.txt\"\n  \"$objdump\" -t \"$obj\" > \"$out_dir/${stem}.objdump.t.txt\" || true\n  grep -q \"main\" \"$out_dir/${stem}.objdump.t.txt\" || {\n    echo \"[verify_backend_coff_lld_link] missing symbol main in object: $obj\" >&2\n    exit 1\n  }\n}\n\nis_darwin_only_bootstrap_reject() {\n  log=\"$1\"\n  if [ ! -f \"$log\" ]; then\n    return 1\n  fi\n  rg -q \"uir_codegen: bootstrap path only supports darwin target|supports darwin target only\" \"$log\"\n}\n\nbuild_obj_or_skip() {\n  target=\"$1\"\n  output=\"$2\"\n  log=\"$3\"\n  set +e\n  BACKEND_EMIT=obj \\\n  BACKEND_OBJ_WRITER=coff \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$output\" \\\n  \"$driver\" >\"$log\" 2>&1\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -eq 0 ]; then\n    return 0\n  fi\n  if is_darwin_only_bootstrap_reject \"$log\"; then\n    echo \"verify_backe"
        out = out + "nd_coff_lld_link ok (bootstrap darwin-only path for $target)\"\n    exit 0\n  fi\n  echo \"[verify_backend_coff_lld_link] failed to build object ($target): $log\" >&2\n  sed -n '1,120p' \"$log\" >&2 || true\n  exit 1\n}\n\nout_dir=\"artifacts/backend_coff_lld_link\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\nobj_path=\"$out_dir/return_add.self.coff.arm64.obj\"\ndll_path=\"$out_dir/return_add.self.coff.arm64.dll\"\nobj_path_x64=\"$out_dir/return_add.self.coff.x86_64.obj\"\ndll_path_x64=\"$out_dir/return_add.self.coff.x86_64.dll\"\nobj_log=\"$out_dir/return_add.self.coff.arm64.build.log\"\nobj_log_x64=\"$out_dir/return_add.self.coff.x86_64.build.log\"\n\nbuild_obj_or_skip \"aarch64-pc-windows-msvc\" \"$obj_path\" \"$obj_log\"\n\ncheck_obj \"$obj_path\" \"coff-arm64\" \"return_add.self.coff.arm64.obj\"\n\nbuild_obj_or_skip \"x86_64-pc-windows-msvc\" \"$obj_path_x64\" \"$obj_log_x64\"\n\ncheck_obj \"$obj_path_x64\" \"coff-x86-64\" \"return_add.self.coff.x86_64.obj\"\n\nif [ \"$lld_kind\" = \"missing\" ]; then\n  echo \"verify_backend_coff_lld_link ok (lld=missing, mode=obj-only)\"\n  exit 0\nfi\n\n# Link a DLL without CRT/system libs (best-effort); exports `main` for symbol presence checks.\nif [ -f \"$dll_path\" ]; then mv \"$dll_path\" \"$dll_path.prev.$$\" 2>/dev/null || true; fi\nif [ -f \"$dll_path.lib\" ]; then mv \"$dll_path.lib\" \"$dl"
        out = out + "l_path.lib.prev.$$\" 2>/dev/null || true; fi\nsh -c \"$lld_cmd /DLL /NOENTRY /NOIMPLIB /OUT:$dll_path /EXPORT:main $obj_path\"\n\nif [ ! -s \"$dll_path\" ]; then\n  echo \"[verify_backend_coff_lld_link] missing output: $dll_path\" >&2\n  exit 1\nfi\n\n\"$objdump\" -h \"$dll_path\" > \"$out_dir/return_add.self.coff.dll.objdump.h.txt\"\ngrep -q \"coff-arm64\" \"$out_dir/return_add.self.coff.dll.objdump.h.txt\"\ngrep -q \"\\\\.text\" \"$out_dir/return_add.self.coff.dll.objdump.h.txt\"\n\n\"$objdump\" -t \"$dll_path\" > \"$out_dir/return_add.self.coff.dll.objdump.t.txt\" || true\ngrep -q \"main\" \"$out_dir/return_add.self.coff.dll.objdump.t.txt\" || {\n  echo \"[verify_backend_coff_lld_link] missing symbol main in dll (lld=$lld_kind)\" >&2\n  exit 1\n}\n\nif [ -f \"$dll_path_x64\" ]; then mv \"$dll_path_x64\" \"$dll_path_x64.prev.$$\" 2>/dev/null || true; fi\nif [ -f \"$dll_path_x64.lib\" ]; then mv \"$dll_path_x64.lib\" \"$dll_path_x64.lib.prev.$$\" 2>/dev/null || true; fi\nsh -c \"$lld_cmd /DLL /NOENTRY /NOIMPLIB /OUT:$dll_path_x64 /EXPORT:main $obj_path_x64\"\n\nif [ ! -s \"$dll_path_x64\" ]; then\n  echo \"[verify_backend_coff_lld_link] missing output: $dll_path_x64\" >&2\n  exit 1\nfi\n\n\"$objdump\" -h \"$dll_path_x64\" > \"$out_dir/return_add.self.coff.x86_64.dll.objdump.h.txt\"\ngrep -q \"coff-x86-64\" \"$out_dir/return_add.self.coff.x86_64.dll.objdump.h.txt\"\ngrep -q \"\\\\.text\" \"$out_dir/return_add.self.coff.x86_64.dll.objdump.h.txt\"\n\n\"$objdump\" -t \"$dll_path"
        out = out + "_x64\" > \"$out_dir/return_add.self.coff.x86_64.dll.objdump.t.txt\" || true\ngrep -q \"main\" \"$out_dir/return_add.self.coff.x86_64.dll.objdump.t.txt\" || {\n  echo \"[verify_backend_coff_lld_link] missing symbol main in x86_64 dll (lld=$lld_kind)\" >&2\n  exit 1\n}\n\necho \"verify_backend_coff_lld_link ok (lld=$lld_kind)\"\n"
        return out
    if id == "verify_backend_concurrency_stress":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooli"
        out = out + "ng} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\nif [ \"${BACKEND_CONCURRENCY_STRESS_ENABLED:-0}\" != \"1\" ]; then\n  echo \"verify_backend_concurrency_stress ok (skip: set BACKEND_CONCURRENCY_STRESS_ENABLED=1 to enable)\"\n  exit 0\nfi\n\nn=\"${BACKEND_CONCURRENCY_N:-50}\"\ntimeout_s=\"${BACKEND_CONCURRENCY_TIMEOUT:-60}\"\nout_dir=\"artifacts/backend_concurrency_stress\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_spawn_chan_i32.cheng\"\nexe_path=\"$out_dir/spawn_chan\"\n\n# shellcheck disable=SC2086\nset +e\nrun_with_timeout \"$timeout_s\" env $link_env \\\n  MM=orc \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\"\nstatus=$?\nset -e\nif [ \"$status\" = \"124\" ]; then\n  echo \"[Error] verify_backend_concurrency_stress compile timed out after ${timeout_s}s\" 1>&2\n  exit 124\nfi\nif [ \"$status\" != \"0\" ]; then\n  exit \"$status\"\nfi\n\ni=0\nwhile [ \"$i\" -lt \"$n\" ]; do\n  set +e\n  run_with_timeout \"$timeout_s\" \"$exe_path\"\n  status=$?\n  set -e\n  if [ \"$status\" = \"124\" ]; then\n    echo \"[Error] verify_backend_concurrency_stress run timed out after ${timeout_s}s (iter=$i)\" 1>&2\n    exit 124\n  fi\n  if [ \"$status\" != \"0\" ]; then\n    exit \"$status\"\n  fi\n  i=$((i + 1))\ndone\n\necho \"verify_backend_concurrency_stress ok (n=$n)\"\n"
        return out
    if id == "verify_backend_debug":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nif [ \"$host_os\" != \"Darwin\" ]; then\n  echo \"verify_backend_debug skip: darwin-only (host_os=$host_os)\" 1>&2\n  exit 2\nfi\nif ! command -v dsymutil >/dev/null 2>&1; then\n  echo \"verify_backend_debug skip: missing dsymutil\" 1>&2\n  exit 2\nfi\nif ! command -v nm >/dev/null 2>&1; then\n  echo \"verify_backend_debug skip: missing nm\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_debug\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\n\nbuild_and_check_dsym() {\n  target=\"$1\"\n  exe=\"$2\"\n  dsym=\"$exe.dSYM\"\n  link_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n  multi=\"${BACKEND_MULTI:-0}\"\n  multi_force=\"${BACKEND_MULTI_FORCE:-$multi}\"\n\n  rm -rf "
        out = out + "\"$exe\" \"$dsym\"\n\n  set +e\n  env $link_env \\\n    BACKEND_MULTI=\"$multi\" \\\n    BACKEND_MULTI_FORCE=\"$multi_force\" \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe\" \\\n    \"$driver\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] && [ \"$multi\" != \"0\" ]; then\n    echo \"[Warn] verify_backend_debug parallel compile failed, retry serial (target=$target)\" 1>&2\n    env $link_env \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_VALIDATE=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe\" \\\n      \"$driver\"\n  elif [ \"$status\" -ne 0 ]; then\n    exit \"$status\"\n  fi\n\n  if [ ! -x \"$exe\" ]; then\n    echo \"[Error] missing exe output: $exe\" 1>&2\n    exit 1\n  fi\n\n  dsym_log=\"$out_dir/dsymutil.$(basename \"$exe\").txt\"\n  dsymutil \"$exe\" -o \"$dsym\" >\"$dsym_log\" 2>&1 || {\n    echo \"[Error] dsymutil failed: $exe\" 1>&2\n    tail -n 80 \"$dsym_log\" 1>&2 || true\n    exit 1\n  }\n\n  dwarf=\"$dsym/Contents/Resources/DWARF/$(basename \"$exe\")\"\n  if [ ! -s \"$dwarf\" ]; then\n    echo \"[Error] missing dSYM DWARF file: $dwarf\" 1>&2\n    exit 1\n  fi\n\n  nm -g \"$dwarf\" | grep -q \"_main\" || {\n    echo \"[Error] missing _main in dSYM: $dwarf\" 1>&2\n    exit 1\n  }\n}\n\nbuild_and_check_dsym \"arm64-apple-darwin\" \"$ou"
        out = out + "t_dir/hello_puts.debug.arm64\"\nbuild_and_check_dsym \"x86_64-apple-darwin\" \"$out_dir/hello_puts.debug.x86_64\"\n\necho \"verify_backend_debug ok\"\n"
        return out
    if id == "verify_backend_determinism":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n# Keep determinism gate focused on artifact reproducibility, not closure-level no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\n\nfixture=\"tests/cheng/backend/fixtures/return_object_fields.cheng\"\nout_dir=\"artifacts/backend_determinism\"\nmkdir -p \"$out_dir\"\n\nout_a=\"$out_dir/a.o\"\nout_b=\"$out_dir/b.o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_TARGET=arm64-apple-darwin \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$out_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_TARGET=arm64-apple-darwin \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$out_b\" \\\n\"$driver\"\n\ncmp \"$out_a\" \"$out_b\" >/dev/null 2>&1 || {\n  echo \"[verify_backend_determinism] mismatch: $out_a vs $out_b\" >&2\n  exit 1\n}\n\necho \"verify_backend_determinism ok\"\n"
    if id == "verify_backend_determinism_strict":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_exe_determinism_strict\n"
    if id == "verify_backend_dod_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dod_contract [--baseline:<path>] [--doc:<path>]\n\nNotes:\n  - Verifies DOPAR-01 DOD contract freeze baseline.\n  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_dod_contract\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nbaseline=\"src/tooling/backend_dod_contract.env\"\ndoc=\"docs/cheng-plan-full.md\"\nprod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      baseline=\"${1#--baseline:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_dod_contract] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$doc\" ]; then\n  echo \"[verify_backend_dod_contract]"
        out = out + " missing doc file: $doc\" 1>&2\n  exit 2\nfi\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_dod_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_dod_contract\"\nmkdir -p \"$out_dir\"\n\ngenerated=\"$out_dir/backend_dod_contract.generated.env\"\nreport=\"$out_dir/backend_dod_contract.report.txt\"\nsnapshot=\"$out_dir/backend_dod_contract.snapshot.env\"\ndiff_file=\"$out_dir/backend_dod_contract.diff.txt\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_dod_contract --doc:\"$doc\" --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\nclosedloop_gate_ok=\"1\"\nprod_closure_gate_ok=\"1\"\nif ! rg -q 'if id == \"verify_backend_closedloop\":' src/tooling/cheng_tooling_embedded_inline.cheng; then\n  closedloop_gate_ok=\"0\"\nfi\nif [ ! -f \"$prod_closure_file\" ]; then\n  prod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nfi\nif ! rg -q 'backend.dod_contract' \"$prod_closure_file\"; then\n  prod_closure_gate_ok=\"0\"\nfi\nif [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(hash_file \"$generated\")\"\n"
        out = out + "\n{\n  echo \"verify_backend_dod_contract report\"\n  echo \"status=$status\"\n  echo \"doc=$doc\"\n  echo \"baseline=$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_dod_contract_status=$status\"\n  echo \"backend_dod_contract_baseline_sha256=$baseline_sha\"\n  echo \"backend_dod_contract_generated_sha256=$generated_sha\"\n  echo \"backend_dod_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"backend_dod_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"backend_dod_contract_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_dod_contract] DOD contract baseline drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_dod_contract --doc:$doc --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_dod_contract ok\"\n"
        return out
    if id == "verify_backend_dod_opt_regression":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_dod_opt_regression] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_has_marker() {\n  cand=\"$1\"\n  marker=\"$2\"\n  if [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 0\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  rg -F -q \"$marker\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    BACKEND_D"
        out = out + "RIVER_ALLOW_FALLBACK=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_dod_opt_regression] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\n\nrefresh_missing_marker=\"${PAR05_DRIVER_REFRESH:-0}\"\ncase \"$refresh_missing_marker\" in\n  0|1) ;;\n  *) refresh_missing_marker=\"0\" ;;\nesac\n\nrefresh_driver_if_needed() {\n  marker=\"$1\"\n  if driver_has_marker \"$driver\" \"$marker\"; then\n    return 0\n  fi\n  if [ \"$refresh_missing_marker\" != \"1\" ]; then\n    return 1\n  fi\n  refreshed_driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=1 \\\n    BACKEND_DRIVER_ALLOW_FALLBACK=0 \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  if [ -x \"$refreshed_driver\" ] && driver_has_marker \"$refreshed_driver\" \"$marker\"; then\n    echo \"[verify_backend_dod_opt_regression] use refreshed backend driver: $refreshed_driver\" 1>&2\n    driver=\"$refreshed_driver\"\n    return 0\n  fi\n  return 1\n}\n\nif ! refresh_driver_if_needed \"uir_opt2.noalias\" && ! driver_has_marker \"$driver\" \"uir_opt2.noalias\"; then\n  echo \"[verify_backend_dod_opt_regression] backend driver missing noalias marker: $driver\" 1>&2\n  exit 1\nfi\nif ! refresh_driver_if_needed \"uir_opt2.egraph\" && ! driver_has_marker \"$driver\" \"uir_opt2.egraph\"; then\n  echo \"[verify_backend_dod_opt_"
        out = out + "regression] backend driver missing egraph marker: $driver\" 1>&2\n  exit 1\nfi\nif ! refresh_driver_if_needed \"high_uir_checked_funcs\" && ! driver_has_marker \"$driver\" \"high_uir_checked_funcs\"; then\n  echo \"[verify_backend_dod_opt_regression] backend driver missing phase generics marker: $driver\" 1>&2\n  exit 1\nfi\nif ! refresh_driver_if_needed \"p4_phase_v1\" && ! driver_has_marker \"$driver\" \"p4_phase_v1\"; then\n  echo \"[verify_backend_dod_opt_regression] backend driver missing phase contract marker: $driver\" 1>&2\n  exit 1\nfi\nif ! refresh_driver_if_needed \"single_ir_dual_phase\" && ! driver_has_marker \"$driver\" \"single_ir_dual_phase\"; then\n  echo \"[verify_backend_dod_opt_regression] backend driver missing phase model marker: $driver\" 1>&2\n  exit 1\nfi\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*) return 1 ;;\n  esac\n  return 0\n}\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nguard_fixture=\"${BACKEND_DOD_OPT_GUARD_FIXTURE:-tests/cheng/backend/fixtures/return_store_deref.cheng}\"\ndet_fixture=\"${BACKEND_DOD_OPT_DET_FIXTURE:-tests/cheng/backend/fixtures/return_opt2_inline_dce.cheng}\"\nbenefit_fixture=\"${BACKEND_DOD_OPT_BENEFIT_FIXTURE:-tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng}\"\niters=\"${UIR_EGRAPH_ITERS:-3}\"\ngoal_raw=\"${UIR_EGRAPH_GOAL:-balanced}\"\nbaseline_file=\"${BACKEND_DOD_OPT_BASELINE:-src/tooling/backend_d"
        out = out + "od_opt_regression_baseline.env}\"\n\nif [ ! -f \"$guard_fixture\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing guard fixture: $guard_fixture\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$det_fixture\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing deterministic fixture: $det_fixture\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$benefit_fixture\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing benefit fixture: $benefit_fixture\" 1>&2\n  exit 2\nfi\nif ! is_uint \"$iters\" || [ \"$iters\" -le 0 ] || [ \"$iters\" -gt 32 ]; then\n  echo \"[verify_backend_dod_opt_regression] invalid UIR_EGRAPH_ITERS: $iters (expected 1..32)\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$baseline_file\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing baseline file: $baseline_file\" 1>&2\n  exit 2\nfi\n\nnormalize_goal() {\n  g=\"$1\"\n  lower=\"$(printf '%s' \"$g\" | tr 'A-Z' 'a-z')\"\n  case \"$lower\" in\n    balanced|latency|size) printf '%s\\n' \"$lower\" ;;\n    *) printf 'balanced\\n' ;;\n  esac\n}\ngoal=\"$(normalize_goal \"$goal_raw\")\"\n\n# shellcheck disable=SC1090\n. \"$baseline_file\"\n\nmin_benefit_obj_size_delta=\"${BACKEND_DOD_OPT_MIN_BENEFIT_OBJ_SIZE_DELTA:-${BACKEND_DOD_OPT_MIN_BENEFIT_OBJ_SIZE_DELTA:-1}}\"\nmin_benefit_noalias_total_changes=\"${BACKEND_DOD_OPT_MIN_BENEFIT_NOALIAS_TOTAL_CHANGES:-${BACKEND_DOD_OPT_MIN_BENEFIT_NOALIAS_TOTAL_CHANGES:-1}}\"\nmin_benefit_noalias_changed_funcs=\"${BACKEND_DOD_OPT_MIN_BENEFIT_NOALIAS_CHANGED_FUNCS:-${BACKEND_DOD"
        out = out + "_OPT_MIN_BENEFIT_NOALIAS_CHANGED_FUNCS:-1}}\"\ndrift_alert_min_ratio_pct=\"${BACKEND_DOD_OPT_DRIFT_ALERT_MIN_RATIO_PCT:-${BACKEND_DOD_OPT_DRIFT_ALERT_MIN_RATIO_PCT:-80}}\"\ndrift_alert_strict=\"${BACKEND_DOD_OPT_DRIFT_ALERT_STRICT:-${BACKEND_DOD_OPT_DRIFT_ALERT_STRICT:-0}}\"\nbaseline_benefit_obj_size_delta=\"${BACKEND_DOD_OPT_BASELINE_BENEFIT_OBJ_SIZE_DELTA:-${BACKEND_DOD_OPT_BASELINE_BENEFIT_OBJ_SIZE_DELTA:-0}}\"\nbaseline_benefit_noalias_total_changes=\"${BACKEND_DOD_OPT_BASELINE_BENEFIT_NOALIAS_TOTAL_CHANGES:-${BACKEND_DOD_OPT_BASELINE_BENEFIT_NOALIAS_TOTAL_CHANGES:-0}}\"\nbaseline_benefit_noalias_changed_funcs=\"${BACKEND_DOD_OPT_BASELINE_BENEFIT_NOALIAS_CHANGED_FUNCS:-${BACKEND_DOD_OPT_BASELINE_BENEFIT_NOALIAS_CHANGED_FUNCS:-0}}\"\n\nfor numeric_pair in \\\n  \"min_benefit_obj_size_delta:$min_benefit_obj_size_delta\" \\\n  \"min_benefit_noalias_total_changes:$min_benefit_noalias_total_changes\" \\\n  \"min_benefit_noalias_changed_funcs:$min_benefit_noalias_changed_funcs\" \\\n  \"drift_alert_min_ratio_pct:$drift_alert_min_ratio_pct\" \\\n  \"baseline_benefit_obj_size_delta:$baseline_benefit_obj_size_delta\" \\\n  \"baseline_benefit_noalias_total_changes:$baseline_benefit_noalias_total_changes\" \\\n  \"baseline_benefit_noalias_changed_funcs:$baseline_benefit_noalias_changed_funcs\"; do\n  metric_name=\"${numeric_pair%%:*}\"\n  metric_value=\"${numeric_pair#*:}\"\n  if ! is_uint \"$metric_value\"; then\n    echo \"[verify_backend_dod_opt_regression] invalid numeric setti"
        out = out + "ng ${metric_name}: ${metric_value}\" 1>&2\n    exit 2\n  fi\ndone\nif [ \"$min_benefit_obj_size_delta\" -le 0 ] || [ \"$min_benefit_noalias_total_changes\" -le 0 ] || [ \"$min_benefit_noalias_changed_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] minimal benefit thresholds must be > 0\" 1>&2\n  exit 2\nfi\nif [ \"$drift_alert_min_ratio_pct\" -le 0 ] || [ \"$drift_alert_min_ratio_pct\" -gt 100 ]; then\n  echo \"[verify_backend_dod_opt_regression] drift alert min ratio pct out of range: $drift_alert_min_ratio_pct (expected 1..100)\" 1>&2\n  exit 2\nfi\ncase \"$drift_alert_strict\" in\n  0|1) ;;\n  *)\n    echo \"[verify_backend_dod_opt_regression] invalid drift alert strict switch: $drift_alert_strict (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n\nfor required in \\\n  \"src/backend/uir/uir_noalias_pass.cheng\" \\\n  \"src/backend/uir/uir_egraph_rewrite.cheng\" \\\n  \"src/backend/uir/uir_egraph_cost.cheng\" \\\n  \"src/backend/uir/uir_opt.cheng\" \\\n  \"src/backend/tooling/backend_driver.cheng\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[verify_backend_dod_opt_regression] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\nrequire_marker() {\n  file=\"$1\"\n  pat=\"$2\"\n  label=\"$3\"\n  if ! rg -q \"$pat\" \"$file\"; then\n    echo \"[verify_backend_dod_opt_regression] missing marker ($label) in $file\" 1>&2\n    exit 1\n  fi\n}\n\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"fn uirRunNoAliasPrep\\\\(\" \"noalias_pass_e"
        out = out + "ntry\"\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"proof_backed_changes=\" \"noalias_proof_backed_report_surface\"\nrequire_marker \"src/backend/uir/uir_egraph_rewrite.cheng\" \"fn uirRunEGraphRewrite\\\\(\" \"egraph_rewrite_entry\"\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphScore\\\\(\" \"egraph_cost_score\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.noalias\" \"noalias_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.noalias\\\\.proof_required\" \"noalias_proof_required_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.egraph\\\\.proof_required\" \"egraph_proof_required_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.egraph\" \"egraph_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.cost_model\" \"cost_model_profile_surface\"\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" \"high_uir_checked_funcs=\" \"driver_generics_phase_checked_surface\"\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" \"low_uir_lowered_funcs=\" \"driver_generics_phase_low_surface\"\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" \"high_uir_fallback_funcs=\" \"driver_generics_phase_fallback_surface\"\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" \"phase_contract_version=p4_phase_v1\" \"driver_generics_phase_contract_surface\"\nrequire_marker \"src/backend/tooling/bac"
        out = out + "kend_driver.cheng\" \"uir_phase_model=single_ir_dual_phase\" \"driver_stamp_phase_model_surface\"\n\nout_dir=\"artifacts/backend_dod_opt_regression\"\nmkdir -p \"$out_dir\"\nguard_obj_off=\"$out_dir/guard.noalias_off.o\"\nguard_obj_on=\"$out_dir/guard.noalias_on.o\"\nguard_log_off=\"$out_dir/guard.noalias_off.log\"\nguard_log_on=\"$out_dir/guard.noalias_on.log\"\ndet_obj_a=\"$out_dir/det.noalias_on.a.o\"\ndet_obj_b=\"$out_dir/det.noalias_on.b.o\"\ndet_log_a=\"$out_dir/det.noalias_on.a.log\"\ndet_log_b=\"$out_dir/det.noalias_on.b.log\"\nbenefit_obj_off=\"$out_dir/benefit.noalias_off.o\"\nbenefit_obj_on=\"$out_dir/benefit.noalias_on.o\"\nbenefit_log_off=\"$out_dir/benefit.noalias_off.log\"\nbenefit_log_on=\"$out_dir/benefit.noalias_on.log\"\nphase_default_obj=\"$out_dir/phase.default.noalias_on.o\"\nphase_default_log=\"$out_dir/phase.default.noalias_on.log\"\nphase_default_stamp=\"$out_dir/phase.default.noalias_on.compile_stamp.txt\"\nphase_on_obj=\"$out_dir/phase.ownership_on.noalias_on.o\"\nphase_on_log=\"$out_dir/phase.ownership_on.noalias_on.log\"\nphase_on_stamp=\"$out_dir/phase.ownership_on.noalias_on.compile_stamp.txt\"\nreport=\"$out_dir/backend_dod_opt_regression.report.txt\"\nsnapshot=\"$out_dir/backend_dod_opt_regression.snapshot.env\"\nrm -f \\\n  \"$guard_obj_off\" \"$guard_obj_on\" \"$guard_log_off\" \"$guard_log_on\" \\\n  \"$det_obj_a\" \"$det_obj_b\" \"$det_log_a\" \"$det_log_b\" \\\n  \"$benefit_obj_off\" \"$benefit_obj_on\" \"$benefit_log_off\" \"$benefit_log"
        out = out + "_on\" \\\n  \"$phase_default_obj\" \"$phase_default_log\" \"$phase_default_stamp\" \\\n  \"$phase_on_obj\" \"$phase_on_log\" \"$phase_on_stamp\"\n\nbuild_one() {\n  fixture=\"$1\"\n  noalias=\"$2\"\n  out_obj=\"$3\"\n  out_log=\"$4\"\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    STAGE1_STD_NO_POINTERS=0 \\\n    STAGE1_STD_NO_POINTERS_STRICT=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    UIR_PROFILE=1 \\\n    UIR_NOALIAS=\"$noalias\" \\\n    UIR_EGRAPH_ITERS=\"$iters\" \\\n    UIR_EGRAPH_GOAL=\"$goal\" \\\n    BACKEND_OPT_LEVEL=2 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out_obj\" \\\n    \"$driver\" >\"$out_log\" 2>&1\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nbuild_phase_probe() {\n  fixture=\"$1\"\n  out_obj=\"$2\"\n  out_log=\"$3\"\n  out_stamp=\"$4\"\n  ownership_mode=\"$5\"\n  rm -f \"$out_obj\" \"$out_log\" \"$out_stamp\"\n  set +e\n  if [ \"$ownership_mode\" = \"default\" ]; then\n    env \\\n      ABI=v2_noptr \\\n      STAGE1_STD_NO_POINTERS=0 \\\n      STAGE1_STD_NO_POINTERS_STRICT=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      UIR_PROFILE=1 \\\n      STAGE1_SKIP_OWNERSHIP= \\\n      "
        out = out + "UIR_NOALIAS=1 \\\n      UIR_NOALIAS_REQUIRE_PROOF=1 \\\n      UIR_EGRAPH_ITERS=\"$iters\" \\\n      UIR_EGRAPH_GOAL=\"$goal\" \\\n      UIR_EGRAPH_REQUIRE_PROOF=1 \\\n      BACKEND_COMPILE_STAMP_OUT=\"$out_stamp\" \\\n      BACKEND_OPT_LEVEL=2 \\\n      BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1\n  elif [ \"$ownership_mode\" = \"forced_on\" ]; then\n    env \\\n      ABI=v2_noptr \\\n      STAGE1_STD_NO_POINTERS=0 \\\n      STAGE1_STD_NO_POINTERS_STRICT=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      UIR_PROFILE=1 \\\n      STAGE1_SKIP_OWNERSHIP=0 \\\n      UIR_NOALIAS=1 \\\n      UIR_NOALIAS_REQUIRE_PROOF=1 \\\n      UIR_EGRAPH_ITERS=\"$iters\" \\\n      UIR_EGRAPH_GOAL=\"$goal\" \\\n      UIR_EGRAPH_REQUIRE_PROOF=1 \\\n      BACKEND_COMPILE_STAMP_OUT=\"$out_stamp\" \\\n      BACKEND_OPT_LEVEL=2 \\\n      BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n "
        out = out + "     BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1\n  else\n    echo \"[verify_backend_dod_opt_regression] invalid phase probe ownership mode: $ownership_mode\" 1>&2\n    set -e\n    return 2\n  fi\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nprofile_metric() {\n  file=\"$1\"\n  event=\"$2\"\n  field=\"$3\"\n  awk -v target_event=\"$event\" -v target_field=\"$field\" '\n    $1 == \"uir_profile\" && $2 == target_event {\n      for (i = 3; i <= NF; i++) {\n        split($i, kv, \"=\")\n        if (kv[1] == target_field) {\n          print kv[2]\n          found = 1\n          exit\n        }\n      }\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nprofile_label_int_value() {\n  file=\"$1\"\n  label_prefix=\"$2\"\n  awk -v target_prefix=\"$label_prefix\" '\n    $1 == \"uir_profile\" && index($2, target_prefix) == 1 {\n      value = $2\n      sub(\"^\" target_prefix, \"\", value)\n      print value\n      found = 1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nextract_tab_metric() {\n  line=\"$1\"\n  key=\"$2\"\n  printf '%s\\n' \"$line\" | tr '\\t' '\\n' | awk -F= -v target_key=\"$key\" '$1==target_key{print $2; exit}'\n}\n\nextract_stamp_field() {\n  file=\"$1\"\n  key=\"$2\"\n  awk -F= -v target_key=\"$key\" '\n    $1 == target_key {\n      print substr($0, index($0, \"=\") + 1)\n      found = 1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nr"
        out = out + "equire_stamp_field_exact() {\n  file=\"$1\"\n  key=\"$2\"\n  expected=\"$3\"\n  got=\"$(extract_stamp_field \"$file\" \"$key\")\"\n  if [ \"$got\" != \"$expected\" ]; then\n    echo \"[verify_backend_dod_opt_regression] compile stamp mismatch ($file): $key=$got expected=$expected\" 1>&2\n    exit 1\n  fi\n}\n\nif ! build_one \"$guard_fixture\" 0 \"$guard_obj_off\" \"$guard_log_off\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (guard/noalias=0): $guard_fixture\" 1>&2\n  tail -n 200 \"$guard_log_off\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$guard_fixture\" 1 \"$guard_obj_on\" \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (guard/noalias=1): $guard_fixture\" 1>&2\n  tail -n 200 \"$guard_log_on\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$guard_obj_off\" ] || [ ! -s \"$guard_obj_on\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing guard outputs\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.disabled([[:space:]]+|$)' \"$guard_log_off\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias disabled event: $guard_log_off\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias([[:space:]]+|$)' \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias event: $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.safe\\.copy_prop([[:space:]]+|$)' \"$guard_log_on\"; then\n  echo \"[verify"
        out = out + "_backend_dod_opt_regression] missing copy_prop event: $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph([[:space:]]+|$)' \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph event: $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.changed([[:space:]]+|$)' \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph changed event: $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.cost_model([[:space:]]+|$)' \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing cost_model event: $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q \"^uir_profile[[:space:]]+uir_opt2\\\\.cost_model\\\\.${goal}([[:space:]]+|$)\" \"$guard_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing goal cost_model event (${goal}): $guard_log_on\" 1>&2\n  exit 1\nfi\nif ! cmp -s \"$guard_obj_off\" \"$guard_obj_on\"; then\n  echo \"[verify_backend_dod_opt_regression] guard object mismatch (expected fallback-stable): $guard_obj_off vs $guard_obj_on\" 1>&2\n  exit 1\nfi\n\nif ! build_one \"$benefit_fixture\" 0 \"$benefit_obj_off\" \"$benefit_log_off\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (benefit/noalias=0): $benefit_fixture\" 1>&2\n  tail -n 200 \"$benefit_log_off\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$benefit_fixture\" 1 \"$benefit_obj_on\" \"$benefit_log_on\"; then\n "
        out = out + " echo \"[verify_backend_dod_opt_regression] compile failed (benefit/noalias=1): $benefit_fixture\" 1>&2\n  tail -n 200 \"$benefit_log_on\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$benefit_obj_off\" ] || [ ! -s \"$benefit_obj_on\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing benefit outputs\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.disabled([[:space:]]+|$)' \"$benefit_log_off\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias disabled event: $benefit_log_off\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias([[:space:]]+|$)' \"$benefit_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias event: $benefit_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph([[:space:]]+|$)' \"$benefit_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph event: $benefit_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.changed([[:space:]]+|$)' \"$benefit_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph changed event: $benefit_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.cost_model([[:space:]]+|$)' \"$benefit_log_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing cost_model event: $benefit_log_on\" 1>&2\n  exit 1\nfi\nif ! rg -q \"^uir_profile[[:space:]]+uir_opt2\\\\.cost_model\\\\.${goal}([[:space:]]+|$)\" \"$benefit_l"
        out = out + "og_on\"; then\n  echo \"[verify_backend_dod_opt_regression] missing goal cost_model event (${goal}): $benefit_log_on\" 1>&2\n  exit 1\nfi\nbenefit_noalias_report_line=\"$(rg '^noalias_report[[:space:]]+' \"$benefit_log_on\" | tail -n 1 || true)\"\nif [ \"$benefit_noalias_report_line\" = \"\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias_report line: $benefit_log_on\" 1>&2\n  exit 1\nfi\n\nbenefit_noalias_forwarded_loads=\"$(printf '%s\\n' \"$benefit_noalias_report_line\" | tr '\\t' '\\n' | awk -F= '$1==\"forward_loads\"{print $2; exit}')\"\nbenefit_noalias_mem2reg_loads=\"$(printf '%s\\n' \"$benefit_noalias_report_line\" | tr '\\t' '\\n' | awk -F= '$1==\"mem2reg_loads\"{print $2; exit}')\"\nbenefit_noalias_mem2reg_stores=\"$(printf '%s\\n' \"$benefit_noalias_report_line\" | tr '\\t' '\\n' | awk -F= '$1==\"mem2reg_stores\"{print $2; exit}')\"\nbenefit_noalias_changed_funcs=\"$(printf '%s\\n' \"$benefit_noalias_report_line\" | tr '\\t' '\\n' | awk -F= '$1==\"changed_funcs\"{print $2; exit}')\"\n\nfor metric_pair in \\\n  \"forward_loads:$benefit_noalias_forwarded_loads\" \\\n  \"mem2reg_loads:$benefit_noalias_mem2reg_loads\" \\\n  \"mem2reg_stores:$benefit_noalias_mem2reg_stores\" \\\n  \"changed_funcs:$benefit_noalias_changed_funcs\"; do\n  metric_name=\"${metric_pair%%:*}\"\n  metric_value=\"${metric_pair#*:}\"\n  if ! is_uint \"$metric_value\"; then\n    echo \"[verify_backend_dod_opt_regression] invalid noalias_report metric ${metric_name}: ${metric_"
        out = out + "value}\" 1>&2\n    exit 1\n  fi\ndone\n\nbenefit_noalias_total_changes=$((benefit_noalias_forwarded_loads + benefit_noalias_mem2reg_loads + benefit_noalias_mem2reg_stores))\nif [ \"$benefit_noalias_total_changes\" -le 0 ] || [ \"$benefit_noalias_changed_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] no effective noalias benefit signal: $benefit_noalias_report_line\" 1>&2\n  exit 1\nfi\n\nif ! build_one \"$det_fixture\" 1 \"$det_obj_a\" \"$det_log_a\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (determinism/a): $det_fixture\" 1>&2\n  tail -n 200 \"$det_log_a\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$det_fixture\" 1 \"$det_obj_b\" \"$det_log_b\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (determinism/b): $det_fixture\" 1>&2\n  tail -n 200 \"$det_log_b\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$det_obj_a\" ] || [ ! -s \"$det_obj_b\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing deterministic outputs\" 1>&2\n  exit 1\nfi\nif ! cmp -s \"$det_obj_a\" \"$det_obj_b\"; then\n  echo \"[verify_backend_dod_opt_regression] deterministic object mismatch: $det_obj_a vs $det_obj_b\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias([[:space:]]+|$)' \"$det_log_a\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias event: $det_log_a\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph([[:space:]]+|$)' \"$det_log_a\"; then\n  echo \"[verify_b"
        out = out + "ackend_dod_opt_regression] missing egraph event: $det_log_a\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.changed([[:space:]]+|$)' \"$det_log_a\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph changed event: $det_log_a\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.cost_model([[:space:]]+|$)' \"$det_log_a\"; then\n  echo \"[verify_backend_dod_opt_regression] missing cost_model event: $det_log_a\" 1>&2\n  exit 1\nfi\nif ! rg -q \"^uir_profile[[:space:]]+uir_opt2\\\\.cost_model\\\\.${goal}([[:space:]]+|$)\" \"$det_log_a\"; then\n  echo \"[verify_backend_dod_opt_regression] missing goal cost_model event (${goal}): $det_log_a\" 1>&2\n  exit 1\nfi\n\nif ! build_phase_probe \"$benefit_fixture\" \"$phase_default_obj\" \"$phase_default_log\" \"$phase_default_stamp\" \"default\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (phase/default ownership policy): $benefit_fixture\" 1>&2\n  tail -n 200 \"$phase_default_log\" 1>&2 || true\n  exit 1\nfi\nif ! build_phase_probe \"$benefit_fixture\" \"$phase_on_obj\" \"$phase_on_log\" \"$phase_on_stamp\" \"forced_on\"; then\n  echo \"[verify_backend_dod_opt_regression] compile failed (phase/ownership-on): $benefit_fixture\" 1>&2\n  tail -n 200 \"$phase_on_log\" 1>&2 || true\n  exit 1\nfi\nfor required in \\\n  \"$phase_default_obj\" \"$phase_on_obj\" \\\n  \"$phase_default_stamp\" \"$phase_on_stamp\"; do\n  if [ ! -s \"$required\" ]; then\n    echo \"["
        out = out + "verify_backend_dod_opt_regression] missing phase artifact: $required\" 1>&2\n    exit 1\n  fi\ndone\n\nphase_default_generics_line=\"$(rg '^generics_report[[:space:]]+' \"$phase_default_log\" | tail -n 1 || true)\"\nphase_on_generics_line=\"$(rg '^generics_report[[:space:]]+' \"$phase_on_log\" | tail -n 1 || true)\"\nif [ \"$phase_default_generics_line\" = \"\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing generics_report in phase default log: $phase_default_log\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_generics_line\" = \"\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing generics_report in phase ownership-on log: $phase_on_log\" 1>&2\n  exit 1\nfi\n\nphase_default_high_uir_checked_funcs=\"$(extract_tab_metric \"$phase_default_generics_line\" \"high_uir_checked_funcs\")\"\nphase_default_low_uir_lowered_funcs=\"$(extract_tab_metric \"$phase_default_generics_line\" \"low_uir_lowered_funcs\")\"\nphase_default_high_uir_fallback_funcs=\"$(extract_tab_metric \"$phase_default_generics_line\" \"high_uir_fallback_funcs\")\"\nphase_default_contract_version=\"$(extract_tab_metric \"$phase_default_generics_line\" \"phase_contract_version\")\"\nphase_on_high_uir_checked_funcs=\"$(extract_tab_metric \"$phase_on_generics_line\" \"high_uir_checked_funcs\")\"\nphase_on_low_uir_lowered_funcs=\"$(extract_tab_metric \"$phase_on_generics_line\" \"low_uir_lowered_funcs\")\"\nphase_on_high_uir_fallback_funcs=\"$(extract_tab_metric \"$phase_on_generics_line\" \"high_uir_f"
        out = out + "allback_funcs\")\"\nphase_on_contract_version=\"$(extract_tab_metric \"$phase_on_generics_line\" \"phase_contract_version\")\"\n\nfor metric_pair in \\\n  \"phase_default_high_uir_checked_funcs:$phase_default_high_uir_checked_funcs\" \\\n  \"phase_default_low_uir_lowered_funcs:$phase_default_low_uir_lowered_funcs\" \\\n  \"phase_default_high_uir_fallback_funcs:$phase_default_high_uir_fallback_funcs\" \\\n  \"phase_on_high_uir_checked_funcs:$phase_on_high_uir_checked_funcs\" \\\n  \"phase_on_low_uir_lowered_funcs:$phase_on_low_uir_lowered_funcs\" \\\n  \"phase_on_high_uir_fallback_funcs:$phase_on_high_uir_fallback_funcs\"; do\n  metric_name=\"${metric_pair%%:*}\"\n  metric_value=\"${metric_pair#*:}\"\n  if ! is_uint \"$metric_value\"; then\n    echo \"[verify_backend_dod_opt_regression] invalid phase generics metric ${metric_name}: ${metric_value}\" 1>&2\n    exit 1\n  fi\ndone\n\nif [ \"$phase_default_contract_version\" != \"p4_phase_v1\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase contract version mismatch (default probe): $phase_default_contract_version\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_contract_version\" != \"p4_phase_v1\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase contract version mismatch (ownership-on probe): $phase_on_contract_version\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_low_uir_lowered_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default probe expected low_uir_lowered_funcs>0, got $phase_default"
        out = out + "_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_low_uir_lowered_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on probe expected low_uir_lowered_funcs>0, got $phase_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ $((phase_default_high_uir_checked_funcs + phase_default_high_uir_fallback_funcs)) -ne \"$phase_default_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default totals mismatch: checked=$phase_default_high_uir_checked_funcs fallback=$phase_default_high_uir_fallback_funcs low=$phase_default_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ $((phase_on_high_uir_checked_funcs + phase_on_high_uir_fallback_funcs)) -ne \"$phase_on_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on totals mismatch: checked=$phase_on_high_uir_checked_funcs fallback=$phase_on_high_uir_fallback_funcs low=$phase_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_high_uir_checked_funcs\" -ne 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default probe expected high_uir_checked_funcs=0, got $phase_default_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_high_uir_fallback_funcs\" -ne \"$phase_default_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default probe expected all lowered funcs fallback, fallback=$phase_default_high_uir_fallback_funcs low=$phase_default_low_uir_lowered_f"
        out = out + "uncs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_high_uir_fallback_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default probe expected fallback funcs > 0\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_high_uir_checked_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on probe expected high_uir_checked_funcs>0, got $phase_on_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\n\nphase_default_noalias_report_line=\"$(rg '^noalias_report[[:space:]]+' \"$phase_default_log\" | tail -n 1 || true)\"\nphase_on_noalias_report_line=\"$(rg '^noalias_report[[:space:]]+' \"$phase_on_log\" | tail -n 1 || true)\"\nif [ \"$phase_default_noalias_report_line\" = \"\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias_report in phase default log: $phase_default_log\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_noalias_report_line\" = \"\" ]; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias_report in phase ownership-on log: $phase_on_log\" 1>&2\n  exit 1\nfi\n\nphase_default_noalias_proof_checked_funcs=\"$(extract_tab_metric \"$phase_default_noalias_report_line\" \"proof_checked_funcs\")\"\nphase_default_noalias_proof_skipped_funcs=\"$(extract_tab_metric \"$phase_default_noalias_report_line\" \"proof_skipped_funcs\")\"\nphase_default_noalias_proof_required=\"$(extract_tab_metric \"$phase_default_noalias_report_line\" \"proof_required\")\"\nphase_on_noalias_proof_checked_funcs=\"$(extract_tab_metric \"$phase_on_noalias_r"
        out = out + "eport_line\" \"proof_checked_funcs\")\"\nphase_on_noalias_proof_skipped_funcs=\"$(extract_tab_metric \"$phase_on_noalias_report_line\" \"proof_skipped_funcs\")\"\nphase_on_noalias_proof_required=\"$(extract_tab_metric \"$phase_on_noalias_report_line\" \"proof_required\")\"\n\nfor metric_pair in \\\n  \"phase_default_noalias_proof_checked_funcs:$phase_default_noalias_proof_checked_funcs\" \\\n  \"phase_default_noalias_proof_skipped_funcs:$phase_default_noalias_proof_skipped_funcs\" \\\n  \"phase_default_noalias_proof_required:$phase_default_noalias_proof_required\" \\\n  \"phase_on_noalias_proof_checked_funcs:$phase_on_noalias_proof_checked_funcs\" \\\n  \"phase_on_noalias_proof_skipped_funcs:$phase_on_noalias_proof_skipped_funcs\" \\\n  \"phase_on_noalias_proof_required:$phase_on_noalias_proof_required\"; do\n  metric_name=\"${metric_pair%%:*}\"\n  metric_value=\"${metric_pair#*:}\"\n  if ! is_uint \"$metric_value\"; then\n    echo \"[verify_backend_dod_opt_regression] invalid phase noalias proof metric ${metric_name}: ${metric_value}\" 1>&2\n    exit 1\n  fi\ndone\n\nif [ \"$phase_default_noalias_proof_required\" -ne 1 ] || [ \"$phase_on_noalias_proof_required\" -ne 1 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase probes must enforce noalias proof-required mode\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_noalias_proof_checked_funcs\" -ne \"$phase_default_high_uir_checked_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default proof checked mi"
        out = out + "smatch: noalias=$phase_default_noalias_proof_checked_funcs high_checked=$phase_default_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_noalias_proof_skipped_funcs\" -ne \"$phase_default_high_uir_fallback_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default proof skipped mismatch: noalias=$phase_default_noalias_proof_skipped_funcs fallback=$phase_default_high_uir_fallback_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_noalias_proof_skipped_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default probe expected proof_skipped_funcs>0\" 1>&2\n  exit 1\nfi\nif [ \"$phase_on_noalias_proof_checked_funcs\" -le 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on probe expected proof_checked_funcs>0\" 1>&2\n  exit 1\nfi\nif [ $((phase_on_noalias_proof_checked_funcs + phase_on_noalias_proof_skipped_funcs)) -ne \"$phase_on_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on proof totals mismatch: checked=$phase_on_noalias_proof_checked_funcs skipped=$phase_on_noalias_proof_skipped_funcs low=$phase_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\n\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.proof_required([[:space:]]+|$)' \"$phase_default_log\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias proof-required profile event: $phase_default_log\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.proo"
        out = out + "f_required([[:space:]]+|$)' \"$phase_on_log\"; then\n  echo \"[verify_backend_dod_opt_regression] missing noalias proof-required profile event: $phase_on_log\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.proof_required([[:space:]]+|$)' \"$phase_default_log\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph proof-required profile event: $phase_default_log\" 1>&2\n  exit 1\nfi\nif ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.proof_required([[:space:]]+|$)' \"$phase_on_log\"; then\n  echo \"[verify_backend_dod_opt_regression] missing egraph proof-required profile event: $phase_on_log\" 1>&2\n  exit 1\nfi\n\nphase_default_egraph_proof_backed_funcs=\"$(profile_label_int_value \"$phase_default_log\" \"uir_opt2.egraph.proof_backed_funcs=\")\"\nphase_on_egraph_proof_backed_funcs=\"$(profile_label_int_value \"$phase_on_log\" \"uir_opt2.egraph.proof_backed_funcs=\")\"\nif ! is_uint \"$phase_default_egraph_proof_backed_funcs\" || ! is_uint \"$phase_on_egraph_proof_backed_funcs\"; then\n  echo \"[verify_backend_dod_opt_regression] invalid egraph proof_backed_funcs profile metric in phase probes\" 1>&2\n  exit 1\nfi\nif [ \"$phase_default_egraph_proof_backed_funcs\" -ne \"$phase_default_high_uir_checked_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase default egraph proof-backed mismatch: egraph=$phase_default_egraph_proof_backed_funcs high_checked=$phase_default_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\nif [ "
        out = out + "\"$phase_on_egraph_proof_backed_funcs\" -ne \"$phase_on_high_uir_checked_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] phase ownership-on egraph proof-backed mismatch: egraph=$phase_on_egraph_proof_backed_funcs high_checked=$phase_on_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\n\nrequire_stamp_field_exact \"$phase_default_stamp\" \"uir_phase_model\" \"single_ir_dual_phase\"\nrequire_stamp_field_exact \"$phase_default_stamp\" \"uir_high_phase_contract\" \"ownership_func_v1\"\nrequire_stamp_field_exact \"$phase_default_stamp\" \"uir_phase_contract_version\" \"p4_phase_v1\"\nrequire_stamp_field_exact \"$phase_default_stamp\" \"stage1_skip_ownership_raw\" \"\"\nrequire_stamp_field_exact \"$phase_default_stamp\" \"stage1_skip_ownership_effective\" \"1\"\nrequire_stamp_field_exact \"$phase_default_stamp\" \"stage1_skip_ownership_default\" \"1\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"uir_phase_model\" \"single_ir_dual_phase\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"uir_high_phase_contract\" \"ownership_func_v1\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"uir_phase_contract_version\" \"p4_phase_v1\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"stage1_skip_ownership_raw\" \"0\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"stage1_skip_ownership_effective\" \"0\"\nrequire_stamp_field_exact \"$phase_on_stamp\" \"stage1_skip_ownership_default\" \"0\"\n\nphase_contract_ok=\"1\"\nphase_fallback_ok=\"1\"\nphase_contract_hint=\"dual_phase_contr"
        out = out + "act_enforced\"\nphase_fallback_hint=\"default_policy_fallback_audited\"\n\nguard_size_off=\"$(wc -c < \"$guard_obj_off\" | tr -d ' ')\"\nguard_size_on=\"$(wc -c < \"$guard_obj_on\" | tr -d ' ')\"\nguard_size_delta=\"$((guard_size_off - guard_size_on))\"\ndet_size_a=\"$(wc -c < \"$det_obj_a\" | tr -d ' ')\"\ndet_size_b=\"$(wc -c < \"$det_obj_b\" | tr -d ' ')\"\nbenefit_size_off=\"$(wc -c < \"$benefit_obj_off\" | tr -d ' ')\"\nbenefit_size_on=\"$(wc -c < \"$benefit_obj_on\" | tr -d ' ')\"\nbenefit_size_delta=\"$((benefit_size_off - benefit_size_on))\"\nif [ \"$benefit_size_delta\" -lt 0 ]; then\n  echo \"[verify_backend_dod_opt_regression] benefit fixture regressed object size: off=$benefit_size_off on=$benefit_size_on\" 1>&2\n  exit 1\nfi\nif [ \"$benefit_size_delta\" -lt \"$min_benefit_obj_size_delta\" ]; then\n  echo \"[verify_backend_dod_opt_regression] minimal benefit threshold failed (obj_size_delta): observed=$benefit_size_delta required>=$min_benefit_obj_size_delta\" 1>&2\n  exit 1\nfi\nif [ \"$benefit_noalias_total_changes\" -lt \"$min_benefit_noalias_total_changes\" ]; then\n  echo \"[verify_backend_dod_opt_regression] minimal benefit threshold failed (noalias_total_changes): observed=$benefit_noalias_total_changes required>=$min_benefit_noalias_total_changes\" 1>&2\n  exit 1\nfi\nif [ \"$benefit_noalias_changed_funcs\" -lt \"$min_benefit_noalias_changed_funcs\" ]; then\n  echo \"[verify_backend_dod_opt_regression] minimal benefit threshold failed (noalias_changed_fun"
        out = out + "cs): observed=$benefit_noalias_changed_funcs required>=$min_benefit_noalias_changed_funcs\" 1>&2\n  exit 1\nfi\n\nratio_pct_or_na() {\n  observed=\"$1\"\n  baseline=\"$2\"\n  if ! is_uint \"$observed\" || ! is_uint \"$baseline\" || [ \"$baseline\" -le 0 ]; then\n    echo \"na\"\n    return 0\n  fi\n  echo $((observed * 100 / baseline))\n}\n\ndrift_alert_count=0\ndrift_alert_status=\"ok\"\ndrift_alert_details=\"\"\nappend_drift_alert() {\n  metric_name=\"$1\"\n  observed=\"$2\"\n  baseline=\"$3\"\n  ratio_pct=\"$4\"\n  drift_alert_count=$((drift_alert_count + 1))\n  if [ \"$drift_alert_details\" = \"\" ]; then\n    drift_alert_details=\"${metric_name}:observed=${observed},baseline=${baseline},ratio_pct=${ratio_pct}\"\n  else\n    drift_alert_details=\"${drift_alert_details};${metric_name}:observed=${observed},baseline=${baseline},ratio_pct=${ratio_pct}\"\n  fi\n}\n\ncheck_drift_alert() {\n  metric_name=\"$1\"\n  observed=\"$2\"\n  baseline=\"$3\"\n  if ! is_uint \"$observed\" || ! is_uint \"$baseline\" || [ \"$baseline\" -le 0 ]; then\n    return 0\n  fi\n  ratio_pct=$((observed * 100 / baseline))\n  if [ \"$ratio_pct\" -lt \"$drift_alert_min_ratio_pct\" ]; then\n    append_drift_alert \"$metric_name\" \"$observed\" \"$baseline\" \"$ratio_pct\"\n  fi\n}\n\ncheck_drift_alert \"benefit_obj_size_delta\" \"$benefit_size_delta\" \"$baseline_benefit_obj_size_delta\"\ncheck_drift_alert \"benefit_noalias_total_changes\" \"$benefit_noalias_total_changes\" \"$baseline_benefit_noalias_to"
        out = out + "tal_changes\"\ncheck_drift_alert \"benefit_noalias_changed_funcs\" \"$benefit_noalias_changed_funcs\" \"$baseline_benefit_noalias_changed_funcs\"\n\nbenefit_obj_size_ratio_pct=\"$(ratio_pct_or_na \"$benefit_size_delta\" \"$baseline_benefit_obj_size_delta\")\"\nbenefit_noalias_total_changes_ratio_pct=\"$(ratio_pct_or_na \"$benefit_noalias_total_changes\" \"$baseline_benefit_noalias_total_changes\")\"\nbenefit_noalias_changed_funcs_ratio_pct=\"$(ratio_pct_or_na \"$benefit_noalias_changed_funcs\" \"$baseline_benefit_noalias_changed_funcs\")\"\n\nif [ \"$drift_alert_count\" -gt 0 ]; then\n  drift_alert_status=\"alert\"\n  echo \"[verify_backend_dod_opt_regression] benefit drift alert: count=$drift_alert_count min_ratio_pct=$drift_alert_min_ratio_pct baseline=$baseline_file\" 1>&2\n  printf '%s\\n' \"$drift_alert_details\" | tr ';' '\\n' | sed '/^$/d; s/^/  - /' 1>&2\n  if [ \"$drift_alert_strict\" = \"1\" ]; then\n    echo \"[verify_backend_dod_opt_regression] drift alert strict mode enabled; failing gate\" 1>&2\n    exit 1\n  fi\nfi\n\nguard_total_ms_off=\"$(profile_metric \"$guard_log_off\" \"single.emit_obj\" \"total_ms\")\"\nguard_total_ms_on=\"$(profile_metric \"$guard_log_on\" \"single.emit_obj\" \"total_ms\")\"\ndet_total_ms_a=\"$(profile_metric \"$det_log_a\" \"single.emit_obj\" \"total_ms\")\"\ndet_total_ms_b=\"$(profile_metric \"$det_log_b\" \"single.emit_obj\" \"total_ms\")\"\nbenefit_total_ms_off=\"$(profile_metric \"$benefit_log_off\" \"single.emit_obj\" \"total_ms\""
        out = out + ")\"\nbenefit_total_ms_on=\"$(profile_metric \"$benefit_log_on\" \"single.emit_obj\" \"total_ms\")\"\nnoalias_step_ms_on=\"$(profile_metric \"$guard_log_on\" \"uir_opt2.noalias\" \"step_ms\")\"\negraph_step_ms_on=\"$(profile_metric \"$guard_log_on\" \"uir_opt2.egraph\" \"step_ms\")\"\ncost_model_step_ms_on=\"$(profile_metric \"$guard_log_on\" \"uir_opt2.cost_model\" \"step_ms\")\"\nnoalias_disabled_hits=\"$(rg -c '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.disabled([[:space:]]+|$)' \"$guard_log_off\" || true)\"\nnoalias_enabled_hits=\"$(rg -c '^uir_profile[[:space:]]+uir_opt2\\.noalias([[:space:]]+|$)' \"$guard_log_on\" || true)\"\ndeterminism_hint=\"deterministic_obj_equal\"\nfallback_hint=\"fallback_stable_guard_phase_audited\"\nbenefit_hint=\"noalias_effective_size_stable\"\nif [ \"$benefit_size_delta\" -gt 0 ]; then\n  benefit_hint=\"obj_size_reduced\"\nfi\n\n{\n  echo \"verify_backend_dod_opt_regression report\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"goal=$goal\"\n  echo \"guard_fixture=$guard_fixture\"\n  echo \"det_fixture=$det_fixture\"\n  echo \"benefit_fixture=$benefit_fixture\"\n  echo \"egraph_iters=$iters\"\n  echo \"guard_obj_off=$guard_obj_off\"\n  echo \"guard_obj_on=$guard_obj_on\"\n  echo \"det_obj_a=$det_obj_a\"\n  echo \"det_obj_b=$det_obj_b\"\n  echo \"benefit_obj_off=$benefit_obj_off\"\n  echo \"benefit_obj_on=$benefit_obj_on\"\n  echo \"guard_log_off=$guard_log_off\"\n  echo \"guard_log_on=$guard_log_on\"\n  echo \"det_log_a=$d"
        out = out + "et_log_a\"\n  echo \"det_log_b=$det_log_b\"\n  echo \"benefit_log_off=$benefit_log_off\"\n  echo \"benefit_log_on=$benefit_log_on\"\n  echo \"phase_default_log=$phase_default_log\"\n  echo \"phase_on_log=$phase_on_log\"\n  echo \"phase_default_stamp=$phase_default_stamp\"\n  echo \"phase_on_stamp=$phase_on_stamp\"\n  echo \"guard_total_ms_off=${guard_total_ms_off:-na}\"\n  echo \"guard_total_ms_on=${guard_total_ms_on:-na}\"\n  echo \"det_total_ms_a=${det_total_ms_a:-na}\"\n  echo \"det_total_ms_b=${det_total_ms_b:-na}\"\n  echo \"benefit_total_ms_off=${benefit_total_ms_off:-na}\"\n  echo \"benefit_total_ms_on=${benefit_total_ms_on:-na}\"\n  echo \"noalias_step_ms_on=${noalias_step_ms_on:-na}\"\n  echo \"egraph_step_ms_on=${egraph_step_ms_on:-na}\"\n  echo \"cost_model_step_ms_on=${cost_model_step_ms_on:-na}\"\n  echo \"noalias_disabled_hits=${noalias_disabled_hits:-0}\"\n  echo \"noalias_enabled_hits=${noalias_enabled_hits:-0}\"\n  echo \"benefit_noalias_report=$benefit_noalias_report_line\"\n  echo \"benefit_noalias_forwarded_loads=$benefit_noalias_forwarded_loads\"\n  echo \"benefit_noalias_mem2reg_loads=$benefit_noalias_mem2reg_loads\"\n  echo \"benefit_noalias_mem2reg_stores=$benefit_noalias_mem2reg_stores\"\n  echo \"benefit_noalias_changed_funcs=$benefit_noalias_changed_funcs\"\n  echo \"benefit_noalias_total_changes=$benefit_noalias_total_changes\"\n  echo \"phase_default_generics_report=$phase_default_generics_line\"\n  echo \"phase_on_generics_report=$phase_on_generi"
        out = out + "cs_line\"\n  echo \"phase_default_noalias_report=$phase_default_noalias_report_line\"\n  echo \"phase_on_noalias_report=$phase_on_noalias_report_line\"\n  echo \"phase_default_high_uir_checked_funcs=$phase_default_high_uir_checked_funcs\"\n  echo \"phase_default_low_uir_lowered_funcs=$phase_default_low_uir_lowered_funcs\"\n  echo \"phase_default_high_uir_fallback_funcs=$phase_default_high_uir_fallback_funcs\"\n  echo \"phase_on_high_uir_checked_funcs=$phase_on_high_uir_checked_funcs\"\n  echo \"phase_on_low_uir_lowered_funcs=$phase_on_low_uir_lowered_funcs\"\n  echo \"phase_on_high_uir_fallback_funcs=$phase_on_high_uir_fallback_funcs\"\n  echo \"phase_default_noalias_proof_checked_funcs=$phase_default_noalias_proof_checked_funcs\"\n  echo \"phase_default_noalias_proof_skipped_funcs=$phase_default_noalias_proof_skipped_funcs\"\n  echo \"phase_default_noalias_proof_required=$phase_default_noalias_proof_required\"\n  echo \"phase_on_noalias_proof_checked_funcs=$phase_on_noalias_proof_checked_funcs\"\n  echo \"phase_on_noalias_proof_skipped_funcs=$phase_on_noalias_proof_skipped_funcs\"\n  echo \"phase_on_noalias_proof_required=$phase_on_noalias_proof_required\"\n  echo \"phase_default_egraph_proof_backed_funcs=$phase_default_egraph_proof_backed_funcs\"\n  echo \"phase_on_egraph_proof_backed_funcs=$phase_on_egraph_proof_backed_funcs\"\n  echo \"phase_contract_ok=$phase_contract_ok\"\n  echo \"phase_fallback_ok=$phase_fallback_ok\"\n  echo \"phase_contract_hint=$phase_contract_hint"
        out = out + "\"\n  echo \"phase_fallback_hint=$phase_fallback_hint\"\n  echo \"guard_obj_size_off=$guard_size_off\"\n  echo \"guard_obj_size_on=$guard_size_on\"\n  echo \"guard_obj_size_delta=$guard_size_delta\"\n  echo \"det_obj_size_a=$det_size_a\"\n  echo \"det_obj_size_b=$det_size_b\"\n  echo \"benefit_obj_size_off=$benefit_size_off\"\n  echo \"benefit_obj_size_on=$benefit_size_on\"\n  echo \"benefit_obj_size_delta=$benefit_size_delta\"\n  echo \"baseline_file=$baseline_file\"\n  echo \"min_benefit_obj_size_delta=$min_benefit_obj_size_delta\"\n  echo \"min_benefit_noalias_total_changes=$min_benefit_noalias_total_changes\"\n  echo \"min_benefit_noalias_changed_funcs=$min_benefit_noalias_changed_funcs\"\n  echo \"drift_alert_min_ratio_pct=$drift_alert_min_ratio_pct\"\n  echo \"drift_alert_strict=$drift_alert_strict\"\n  echo \"baseline_benefit_obj_size_delta=$baseline_benefit_obj_size_delta\"\n  echo \"baseline_benefit_noalias_total_changes=$baseline_benefit_noalias_total_changes\"\n  echo \"baseline_benefit_noalias_changed_funcs=$baseline_benefit_noalias_changed_funcs\"\n  echo \"benefit_obj_size_ratio_pct=$benefit_obj_size_ratio_pct\"\n  echo \"benefit_noalias_total_changes_ratio_pct=$benefit_noalias_total_changes_ratio_pct\"\n  echo \"benefit_noalias_changed_funcs_ratio_pct=$benefit_noalias_changed_funcs_ratio_pct\"\n  echo \"drift_alert_status=$drift_alert_status\"\n  echo \"drift_alert_count=$drift_alert_count\"\n  echo \"drift_alert_details=$drift_alert_details\"\n  echo \"benefit"
        out = out + "_hint=$benefit_hint\"\n  echo \"fallback_hint=$fallback_hint\"\n  echo \"determinism_hint=$determinism_hint\"\n} >\"$report\"\n\n{\n  echo \"backend_dod_opt_regression_driver=$driver\"\n  echo \"backend_dod_opt_regression_target=$target\"\n  echo \"backend_dod_opt_regression_goal=$goal\"\n  echo \"backend_dod_opt_regression_guard_fixture=$guard_fixture\"\n  echo \"backend_dod_opt_regression_det_fixture=$det_fixture\"\n  echo \"backend_dod_opt_regression_benefit_fixture=$benefit_fixture\"\n  echo \"backend_dod_opt_regression_iters=$iters\"\n  echo \"backend_dod_opt_regression_report=$report\"\n  echo \"backend_dod_opt_regression_guard_total_ms_off=${guard_total_ms_off:-}\"\n  echo \"backend_dod_opt_regression_guard_total_ms_on=${guard_total_ms_on:-}\"\n  echo \"backend_dod_opt_regression_det_total_ms_a=${det_total_ms_a:-}\"\n  echo \"backend_dod_opt_regression_det_total_ms_b=${det_total_ms_b:-}\"\n  echo \"backend_dod_opt_regression_benefit_total_ms_off=${benefit_total_ms_off:-}\"\n  echo \"backend_dod_opt_regression_benefit_total_ms_on=${benefit_total_ms_on:-}\"\n  echo \"backend_dod_opt_regression_phase_default_log=$phase_default_log\"\n  echo \"backend_dod_opt_regression_phase_on_log=$phase_on_log\"\n  echo \"backend_dod_opt_regression_phase_default_stamp=$phase_default_stamp\"\n  echo \"backend_dod_opt_regression_phase_on_stamp=$phase_on_stamp\"\n  echo \"backend_dod_opt_regression_noalias_step_ms_on=${noalias_step_ms_on:-}\"\n  echo \"backend_dod_opt_regression_egraph_ste"
        out = out + "p_ms_on=${egraph_step_ms_on:-}\"\n  echo \"backend_dod_opt_regression_cost_model_step_ms_on=${cost_model_step_ms_on:-}\"\n  echo \"backend_dod_opt_regression_guard_obj_size_off=$guard_size_off\"\n  echo \"backend_dod_opt_regression_guard_obj_size_on=$guard_size_on\"\n  echo \"backend_dod_opt_regression_guard_obj_size_delta=$guard_size_delta\"\n  echo \"backend_dod_opt_regression_det_obj_size_a=$det_size_a\"\n  echo \"backend_dod_opt_regression_det_obj_size_b=$det_size_b\"\n  echo \"backend_dod_opt_regression_benefit_obj_size_off=$benefit_size_off\"\n  echo \"backend_dod_opt_regression_benefit_obj_size_on=$benefit_size_on\"\n  echo \"backend_dod_opt_regression_benefit_obj_size_delta=$benefit_size_delta\"\n  echo \"backend_dod_opt_regression_baseline_file=$baseline_file\"\n  echo \"backend_dod_opt_regression_min_benefit_obj_size_delta=$min_benefit_obj_size_delta\"\n  echo \"backend_dod_opt_regression_min_benefit_noalias_total_changes=$min_benefit_noalias_total_changes\"\n  echo \"backend_dod_opt_regression_min_benefit_noalias_changed_funcs=$min_benefit_noalias_changed_funcs\"\n  echo \"backend_dod_opt_regression_drift_alert_min_ratio_pct=$drift_alert_min_ratio_pct\"\n  echo \"backend_dod_opt_regression_drift_alert_strict=$drift_alert_strict\"\n  echo \"backend_dod_opt_regression_baseline_benefit_obj_size_delta=$baseline_benefit_obj_size_delta\"\n  echo \"backend_dod_opt_regression_baseline_benefit_noalias_total_changes=$baseline_benefit_noalias_total_changes\"\n  echo \"backend"
        out = out + "_dod_opt_regression_baseline_benefit_noalias_changed_funcs=$baseline_benefit_noalias_changed_funcs\"\n  echo \"backend_dod_opt_regression_benefit_obj_size_ratio_pct=$benefit_obj_size_ratio_pct\"\n  echo \"backend_dod_opt_regression_benefit_noalias_total_changes_ratio_pct=$benefit_noalias_total_changes_ratio_pct\"\n  echo \"backend_dod_opt_regression_benefit_noalias_changed_funcs_ratio_pct=$benefit_noalias_changed_funcs_ratio_pct\"\n  echo \"backend_dod_opt_regression_drift_alert_status=$drift_alert_status\"\n  echo \"backend_dod_opt_regression_drift_alert_count=$drift_alert_count\"\n  echo \"backend_dod_opt_regression_drift_alert_details=$drift_alert_details\"\n  echo \"backend_dod_opt_regression_benefit_noalias_forwarded_loads=$benefit_noalias_forwarded_loads\"\n  echo \"backend_dod_opt_regression_benefit_noalias_mem2reg_loads=$benefit_noalias_mem2reg_loads\"\n  echo \"backend_dod_opt_regression_benefit_noalias_mem2reg_stores=$benefit_noalias_mem2reg_stores\"\n  echo \"backend_dod_opt_regression_benefit_noalias_changed_funcs=$benefit_noalias_changed_funcs\"\n  echo \"backend_dod_opt_regression_benefit_noalias_total_changes=$benefit_noalias_total_changes\"\n  echo \"backend_dod_opt_regression_phase_default_high_uir_checked_funcs=$phase_default_high_uir_checked_funcs\"\n  echo \"backend_dod_opt_regression_phase_default_low_uir_lowered_funcs=$phase_default_low_uir_lowered_funcs\"\n  echo \"backend_dod_opt_regression_phase_default_high_uir_fallback_funcs=$phase_default_high_uir_"
        out = out + "fallback_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_high_uir_checked_funcs=$phase_on_high_uir_checked_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_low_uir_lowered_funcs=$phase_on_low_uir_lowered_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_high_uir_fallback_funcs=$phase_on_high_uir_fallback_funcs\"\n  echo \"backend_dod_opt_regression_phase_default_noalias_proof_checked_funcs=$phase_default_noalias_proof_checked_funcs\"\n  echo \"backend_dod_opt_regression_phase_default_noalias_proof_skipped_funcs=$phase_default_noalias_proof_skipped_funcs\"\n  echo \"backend_dod_opt_regression_phase_default_noalias_proof_required=$phase_default_noalias_proof_required\"\n  echo \"backend_dod_opt_regression_phase_on_noalias_proof_checked_funcs=$phase_on_noalias_proof_checked_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_noalias_proof_skipped_funcs=$phase_on_noalias_proof_skipped_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_noalias_proof_required=$phase_on_noalias_proof_required\"\n  echo \"backend_dod_opt_regression_phase_default_egraph_proof_backed_funcs=$phase_default_egraph_proof_backed_funcs\"\n  echo \"backend_dod_opt_regression_phase_on_egraph_proof_backed_funcs=$phase_on_egraph_proof_backed_funcs\"\n  echo \"backend_dod_opt_regression_phase_contract_ok=$phase_contract_ok\"\n  echo \"backend_dod_opt_regression_phase_fallback_ok=$phase_fallback_ok\"\n  echo \"backend_dod_opt_regression_phase_contract_hint=$phase_contract_hint\"\n  echo \"backe"
        out = out + "nd_dod_opt_regression_phase_fallback_hint=$phase_fallback_hint\"\n  echo \"backend_dod_opt_regression_noalias_disabled_hits=${noalias_disabled_hits:-0}\"\n  echo \"backend_dod_opt_regression_noalias_enabled_hits=${noalias_enabled_hits:-0}\"\n  echo \"backend_dod_opt_regression_benefit_hint=$benefit_hint\"\n  echo \"backend_dod_opt_regression_fallback_hint=$fallback_hint\"\n  echo \"backend_dod_opt_regression_determinism_hint=$determinism_hint\"\n} >\"$snapshot\"\n\necho \"verify_backend_dod_opt_regression ok\"\n"
        return out
    if id == "verify_backend_dod_soa":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    rc=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$rc\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_dod_soa] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_dod_soa] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_has_marker() {\n  cand=\"$1\"\n  marker=\"$2\"\n  if [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 0\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  rg -F -q \"$marker\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0"
        out = out + " ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nparse_stage1_total_ms() {\n  printf '%s\\n' \"$1\" | sed -n 's/.* total=\\([0-9][0-9]*\\)ms.*/\\1/p'\n}\n\nnormalize_fixture_lines() {\n  printf '%s\\n' \"$1\" | tr ';' '\\n' | tr '\\r' '\\n' | sed -e '/^[[:space:]]*$/d'\n}\n\nsafe_name() {\n  printf '%s' \"$1\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_'\n}\n\nrequire_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  name=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    echo \"[verify_backend_dod_soa] missing marker ($name) in $file\" 1>&2\n    exit 1\n  fi\n}\n\nrefresh_missing_marker=\"${PAR03_DRIVER_REFRESH:-0}\"\ncase \"$refresh_missing_marker\" in\n  0|1) ;;\n  *) refresh_missing_marker=\"0\" ;;\nesac\n\nif ! driver_has_marker \"$driver\" \"uir_profile\" || ! driver_has_marker \"$driver\" \"generics_report\"; then\n  if [ \"$refresh_missing_marker\" = \"1\" ]; then\n    refreshed_driver=\"$(env \\\n      BACKEND_DRIVER_PATH_PREFER_REBUILD=1 \\\n      BACKEND_DRIVER_ALLOW_FALLBACK=0 \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n    refreshed_uir_profile=\"0\"\n    refreshed_generics_report=\"0\"\n    if [ -x \"$refreshed_driver\" ]; then\n      if driver_has_marker \"$refreshed_driver\" \"uir_profile\"; then\n        refreshed_uir_profile=\"1\"\n      fi\n      if driver_has_ma"
        out = out + "rker \"$refreshed_driver\" \"generics_report\"; then\n        refreshed_generics_report=\"1\"\n      fi\n    fi\n    if [ -x \"$refreshed_driver\" ] && [ \"$refreshed_uir_profile\" = \"1\" ] && [ \"$refreshed_generics_report\" = \"1\" ]; then\n      echo \"[verify_backend_dod_soa] use refreshed backend driver: $refreshed_driver\" 1>&2\n      driver=\"$refreshed_driver\"\n    fi\n  fi\nfi\n\nif ! driver_has_marker \"$driver\" \"uir_profile\"; then\n  echo \"[verify_backend_dod_soa] backend driver missing uir_profile marker: $driver\" 1>&2\n  exit 1\nfi\nif ! driver_has_marker \"$driver\" \"generics_report\"; then\n  echo \"[verify_backend_dod_soa] backend driver missing generics_report marker: $driver\" 1>&2\n  exit 1\nfi\n\nbaseline_file=\"${BACKEND_DOD_SOA_BASELINE:-src/tooling/backend_dod_soa_baseline.env}\"\nif [ ! -f \"$baseline_file\" ]; then\n  echo \"[verify_backend_dod_soa] missing baseline file: $baseline_file\" 1>&2\n  exit 2\nfi\n\n# shellcheck disable=SC1090\n. \"$baseline_file\"\n\nruns=\"${BACKEND_DOD_SOA_RUNS:-${BACKEND_DOD_SOA_RUNS:-3}}\"\nbaseline_total_ms=\"${BACKEND_DOD_SOA_BASELINE_TOTAL_MS:-${BACKEND_DOD_SOA_BASELINE_TOTAL_MS:-240}}\"\nmin_improvement_pct=\"${BACKEND_DOD_SOA_MIN_IMPROVEMENT_PCT:-${BACKEND_DOD_SOA_MIN_IMPROVEMENT_PCT:-25}}\"\nfixtures_raw=\"${BACKEND_DOD_SOA_FIXTURES:-${BACKEND_DOD_SOA_FIXTURES:-tests/cheng/backend/fixtures/return_object_fields.cheng;tests/cheng/backend/fixtures/return_hashmaps_bracket.cheng;tests/cheng/backend/fixtures/re"
        out = out + "turn_opt2_licm_while_cond.cheng}}\"\ntarget=\"${BACKEND_TARGET:-${BACKEND_DOD_SOA_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}}\"\n\nif ! is_uint \"$runs\" || [ \"$runs\" -le 0 ] || [ \"$runs\" -gt 12 ]; then\n  echo \"[verify_backend_dod_soa] invalid runs: $runs (expected 1..12)\" 1>&2\n  exit 2\nfi\nif ! is_uint \"$baseline_total_ms\" || [ \"$baseline_total_ms\" -le 0 ]; then\n  echo \"[verify_backend_dod_soa] invalid baseline total ms: $baseline_total_ms\" 1>&2\n  exit 2\nfi\nif ! is_uint \"$min_improvement_pct\" || [ \"$min_improvement_pct\" -ge 100 ]; then\n  echo \"[verify_backend_dod_soa] invalid min improvement pct: $min_improvement_pct\" 1>&2\n  exit 2\nfi\n\nrequired_max_ms=$((baseline_total_ms * (100 - min_improvement_pct) / 100))\nif [ \"$required_max_ms\" -le 0 ]; then\n  required_max_ms=1\nfi\n\nrequire_marker \"src/stage1/ast.cheng\" 'nodeArena: Node\\[\\]' 'stage1_node_arena'\nrequire_marker \"src/stage1/ast.cheng\" 'nodeArenaEnabled: bool = true' 'stage1_node_arena_enabled'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'localIndex: int32' 'uir_local_index_int32'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'slot: int32' 'uir_slot_index_int32'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'frameOff: int32' 'uir_frame_offset_int32'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_ssa.cheng\" 'rpoIndex:"
        out = out + " int32\\[\\]' 'uir_ssa_rpo_index_int32'\n\nfixture_lines=\"$(normalize_fixture_lines \"$fixtures_raw\")\"\nif [ \"$fixture_lines\" = \"\" ]; then\n  echo \"[verify_backend_dod_soa] no fixtures configured\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_dod_soa\"\nmkdir -p \"$out_dir\"\nreport_file=\"$out_dir/backend_dod_soa.report.txt\"\nsnapshot_file=\"$out_dir/backend_dod_soa.snapshot.env\"\nper_fixture_file=\"$out_dir/backend_dod_soa.per_fixture.tsv\"\n: >\"$per_fixture_file\"\n\noverall_sum=0\noverall_n=0\n\nwhile IFS= read -r fixture; do\n  [ \"$fixture\" = \"\" ] && continue\n  if [ ! -f \"$fixture\" ]; then\n    echo \"[verify_backend_dod_soa] missing fixture: $fixture\" 1>&2\n    exit 2\n  fi\n\n  base=\"$(basename \"$fixture\" .cheng)\"\n  safe_base=\"$(safe_name \"$base\")\"\n  fixture_sum=0\n  run_idx=1\n\n  while [ \"$run_idx\" -le \"$runs\" ]; do\n    log_path=\"$out_dir/${safe_base}.r${run_idx}.log\"\n    obj_path=\"$out_dir/${safe_base}.r${run_idx}.o\"\n    rm -f \"$log_path\" \"$obj_path\"\n\n    set +e\n    env \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$obj_path\" \\\n      BACKEND_PROFILE=1 \\\n      UIR_PROFILE=1 \\\n      STAGE1_PROFILE=1 \\\n      STAGE1_STD_NO_POINTERS=0 \\\n      STAGE1_STD_NO_POINTERS_STRICT=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_OWNERSHIP="
        out = out + "\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      \"$driver\" >\"$log_path\" 2>&1\n    rc=$?\n    set -e\n\n    if [ \"$rc\" -ne 0 ]; then\n      echo \"[verify_backend_dod_soa] compile failed: fixture=$fixture run=$run_idx status=$rc\" 1>&2\n      sed -n '1,120p' \"$log_path\" 1>&2 || true\n      exit 1\n    fi\n    if [ ! -s \"$obj_path\" ]; then\n      echo \"[verify_backend_dod_soa] missing obj output: $obj_path\" 1>&2\n      exit 1\n    fi\n\n    if ! rg -q '^backend_profile[[:space:]]+build_module[[:space:]]+' \"$log_path\"; then\n      echo \"[verify_backend_dod_soa] missing backend_profile build_module: $log_path\" 1>&2\n      exit 1\n    fi\n    if ! rg -q '^uir_profile[[:space:]]+build_module[[:space:]]+' \"$log_path\"; then\n      echo \"[verify_backend_dod_soa] missing uir_profile build_module: $log_path\" 1>&2\n      exit 1\n    fi\n    if ! rg -q '^generics_report[[:space:]]+ir=uir[[:space:]]+' \"$log_path\"; then\n      echo \"[verify_backend_dod_soa] missing generics_report: $log_path\" 1>&2\n      exit 1\n    fi\n\n    stage1_line=\"$(rg '^\\[stage1\\] profile:' \"$log_path\" | tail -n 1 || true)\"\n    if [ \"$stage1_line\" = \"\" ]; then\n      echo \"[verify_backend_dod_soa] missing stage1 profile line: $log_path\" 1>&2\n      exit 1\n    fi\n    total_ms=\"$(parse_stage1_total_ms \"$stage1_line\")\"\n    if ! is_uint \"$total_ms\"; then\n      echo \"[ver"
        out = out + "ify_backend_dod_soa] invalid stage1 total ms in profile: $stage1_line\" 1>&2\n      exit 1\n    fi\n\n    fixture_sum=$((fixture_sum + total_ms))\n    overall_sum=$((overall_sum + total_ms))\n    overall_n=$((overall_n + 1))\n    run_idx=$((run_idx + 1))\n  done\n\n  fixture_avg_ms=$((fixture_sum / runs))\n  printf '%s\\t%s\\t%s\\n' \"$fixture\" \"$fixture_avg_ms\" \"$runs\" >>\"$per_fixture_file\"\ndone <<EOF\n$fixture_lines\nEOF\n\nif [ \"$overall_n\" -le 0 ]; then\n  echo \"[verify_backend_dod_soa] no fixture runs executed\" 1>&2\n  exit 2\nfi\n\nobserved_avg_ms=$((overall_sum / overall_n))\nimprovement_pct=$(( (baseline_total_ms - observed_avg_ms) * 100 / baseline_total_ms ))\n\nif [ \"$observed_avg_ms\" -gt \"$required_max_ms\" ]; then\n  echo \"[verify_backend_dod_soa] performance regression: avg=${observed_avg_ms}ms required<=${required_max_ms}ms baseline=${baseline_total_ms}ms min_improvement=${min_improvement_pct}%\" 1>&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_dod_soa report\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"baseline_file=$baseline_file\"\n  echo \"runs=$runs\"\n  echo \"baseline_total_ms=$baseline_total_ms\"\n  echo \"min_improvement_pct=$min_improvement_pct\"\n  echo \"required_max_ms=$required_max_ms\"\n  echo \"observed_avg_ms=$observed_avg_ms\"\n  echo \"improvement_pct=$improvement_pct\"\n  echo \"per_fixture=$per_fixture_file\"\n} >\"$report_file\"\n\n{\n  echo \"backend_dod_soa_target=$target\"\n  echo \"backend_dod_soa_ba"
        out = out + "seline_file=$baseline_file\"\n  echo \"backend_dod_soa_runs=$runs\"\n  echo \"backend_dod_soa_baseline_total_ms=$baseline_total_ms\"\n  echo \"backend_dod_soa_required_max_ms=$required_max_ms\"\n  echo \"backend_dod_soa_observed_avg_ms=$observed_avg_ms\"\n  echo \"backend_dod_soa_improvement_pct=$improvement_pct\"\n  echo \"backend_dod_soa_report=$report_file\"\n} >\"$snapshot_file\"\n\necho \"verify_backend_dod_soa ok\"\n"
        return out
    if id == "verify_backend_driver_cli_parity":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\nfi\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_driver_cli_parity] backend driver not executable: ${driver:-<unset>}\" 1>&2\n  exit 1\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nfixture=\"${BACKEND_CLI_PARITY_FIXTURE:-tests/cheng/backend/fixtures/return_i64.cheng}\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\nout_dir=\"artifacts/backend_driver_cli_parity\"\nreport=\"$out_dir/backend_driver_cli_parity.report.txt\"\nenv_exe=\"$out_dir/env_path.bin\"\ncli_exe=\"$out_dir/cli_path.bin\"\nenv_stamp=\"$out_dir/env_path.compile_stamp.txt\"\ncli_stamp=\"$out_dir/cli_path.compile_stamp.txt\"\nstamp_diff=\"$out_dir/compile_stamp.diff\"\n\nmkdir -p \"$out_dir\"\nrm -f \"$env_exe\" \"$cli_exe\" \"$env_stamp\" \"$cli_stamp\" \"$stamp_diff\" \"$report\"\n\nif [ ! -f \"$runtime_obj\" ]; then\n  echo \"[verify_backend_driver_cli_parity] missing runtime object for self-link:"
        out = out + " $runtime_obj\" 1>&2\n  exit 2\nfi\n\necho \"== backend.driver_cli_parity.env_path ==\"\nenv \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_LINKER=self \\\n  BACKEND_NO_RUNTIME_C=1 \\\n  BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  BACKEND_VALIDATE=0 \\\n  GENERIC_MODE=dict \\\n  GENERIC_SPEC_BUDGET=0 \\\n  ABI=v2_noptr \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$env_exe\" \\\n  BACKEND_COMPILE_STAMP_OUT=\"$env_stamp\" \\\n  \"$driver\"\n\necho \"== backend.driver_cli_parity.cli_path ==\"\nenv \\\n  -u BACKEND_INPUT \\\n  BACKEND_ENABLE_CLI=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_LINKER=self \\\n  BACKEND_NO_RUNTIME_C=1 \\\n  BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  BACKEND_VALIDATE=0 \\\n  GENERIC_MODE=dict \\\n  GENERIC_SPEC_BUDGET=0 \\\n  ABI=v2_noptr \\\n  BACKEND_OUTPUT=\"$cli_exe\" \\\n  BACKEND_COMPILE_STAMP_OUT=\"$cli_stamp\" \\\n  \"$driver\" \\\n  \"$fixture\"\n\nif [ ! -s \"$env_exe\" ]; then\n  echo \"[verify_backend_driver_cli_parity] missing env executable: $env_exe\" 1>&2\n  exit 1\nfi\nif [ ! -s \"$cli_exe\" ]; then\n  echo \"[verify_backend_driver_cli_parity] missing cli executable: $cli_exe\" 1>&2\n  exit 1\nfi\nif [ ! -s \"$env_stamp\" ] || [ ! -s \"$cli_stamp\" ]; then\n  echo "
        out = out + "\"[verify_backend_driver_cli_parity] missing compile stamp outputs\" 1>&2\n  exit 1\nfi\n\nif ! cmp -s \"$env_stamp\" \"$cli_stamp\"; then\n  diff -u \"$env_stamp\" \"$cli_stamp\" >\"$stamp_diff\" 2>/dev/null || true\n  echo \"[verify_backend_driver_cli_parity] compile stamp mismatch between env and cli paths\" 1>&2\n  if [ -s \"$stamp_diff\" ]; then\n    tail -n 120 \"$stamp_diff\" 1>&2 || true\n  fi\n  exit 1\nfi\n\nstatus_env=0\nstatus_cli=0\nif [ \"${BACKEND_DRIVER_CLI_PARITY_RUN:-0}\" = \"1\" ]; then\n  set +e\n  \"$env_exe\"\n  status_env=\"$?\"\n  \"$cli_exe\"\n  status_cli=\"$?\"\n  set -e\n  if [ \"$status_env\" -ne \"$status_cli\" ]; then\n    echo \"[verify_backend_driver_cli_parity] executable exit status mismatch: env=$status_env cli=$status_cli\" 1>&2\n    exit 1\n  fi\n  if [ \"$status_cli\" -ne 0 ]; then\n    echo \"[verify_backend_driver_cli_parity] expected zero exit from parity sample, got $status_cli\" 1>&2\n    exit 1\n  fi\nfi\n\n{\n  echo \"target=$target\"\n  echo \"driver=$driver\"\n  echo \"fixture=$fixture\"\n  echo \"env_exe=$env_exe\"\n  echo \"cli_exe=$cli_exe\"\n  echo \"env_stamp=$env_stamp\"\n  echo \"cli_stamp=$cli_stamp\"\n  echo \"exit_status=$status_cli\"\n  echo \"result=ok\"\n} >\"$report\"\n\necho \"verify_backend_driver_cli_parity ok\"\n"
        return out
    if id == "verify_backend_driver_selfbuild_smoke":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_driver_selfbuild_smoke.sh [--help]\n\nEnv:\n  DRIVER_SELFBUILD_SMOKE_STAGE0=<path>             optional stage0 override\n  DRIVER_SELFBUILD_SMOKE_TIMEOUT=<seconds>         default: 55\n  DRIVER_SELFBUILD_SMOKE_OUTPUT=<path>             default: artifacts/backend_driver/cheng.selfbuild_smoke\n  DRIVER_SELFBUILD_SMOKE_REPORT=<path>             default: artifacts/backend_driver_selfbuild_smoke/selfbuild_smoke_report.tsv\n  DRIVER_SELFBUILD_SMOKE_REQUIRE_REBUILD=<0|1>     default: 0\n  DRIVER_SELFBUILD_SMOKE_MAX_STAGE0_ATTEMPTS=<N>   default: 1\n  DRIVER_SELFBUILD_SMOKE_FORCE=<0|1>               default: auto (1 when REQUIRE_REBUILD=1, else 0)\n  DRIVER_SELFBUILD_SMOKE_NO_RECOVER=<0|1>          default: auto (1 when REQUIRE_REBUILD=1, else 0)\n  DRIVER_SELFBUILD_SMOKE_MULTI=<0|1>               default: 0\n  DRIVER_SELFBUILD_SMOKE_MULTI_FORCE=<0|1>         default: 0\n  DRIVER_SELFBUILD_SMOKE_INCREMENTAL=<0|1>         default: 1\n  DRIVER_SELFBUILD_SMOKE_JOBS=<N>                  default: 0\n  DRIVER_SELFBUILD_SMOKE_STAGE1_TIMEOUT=<seconds>  default: 30\n  DRIVER_SELFBUILD_SMOKE_TARGETS=<csv>             default: host\n\nNotes:\n  - Default mode blocks on runnable smoke and reuses seeded output when available.\n  - Strict mode (`REQUIRE_REBUILD=1`) forces a fresh selfbuild and disables recover fallback.\n  - On failure it emits a structu"
        out = out + "red root-cause report with build log / attempts log / crash report paths.\nEOF\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end = time + 1;\n        while (time < $grace_end) {\n          my $r = waitpid($pid, WNOHANG);\n          if ($r == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndriver_help_ok() {\n  bin=\"$1\"\n  [ -x \"$bin\" ] || return 1\n  set +e\n  run_with_timeout 5 \"$bin\" --help >/dev/null 2>&1\n  rc=\"$?\"\n  set -e\n  case \"$rc\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_stage1_smoke_ok() {\n "
        out = out + " bin=\"$1\"\n  smoke_timeout=\"$2\"\n  [ -x \"$bin\" ] || return 1\n  smoke_src=\"$root/tests/cheng/backend/fixtures/return_add.cheng\"\n  if [ ! -f \"$smoke_src\" ]; then\n    smoke_src=\"$root/tests/cheng/backend/fixtures/return_i64.cheng\"\n  fi\n  [ -f \"$smoke_src\" ] || return 1\n  smoke_targets=\"${DRIVER_SELFBUILD_SMOKE_TARGETS:-host}\"\n  old_ifs=\"$IFS\"\n  IFS=','\n  for smoke_target in $smoke_targets; do\n    IFS=\"$old_ifs\"\n    case \"$smoke_target\" in\n      \"\"|host|auto)\n        smoke_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo auto)\"\n        ;;\n    esac\n    safe_target=\"$(printf '%s' \"$smoke_target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n    smoke_out=\"$root/chengcache/.driver_selfbuild_smoke.stage1.${safe_target}.bin\"\n    rm -f \"$smoke_out\" \"$smoke_out.tmp\" \"$smoke_out.tmp.linkobj\" \"$smoke_out.o\"\n    rm -rf \"$smoke_out.objs\" \"$smoke_out.objs.lock\"\n    set +e\n    run_with_timeout \"$smoke_timeout\" env \\\n      MM=orc \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      BACKEND_VALIDATE=0 \\\n      STAGE1_SKIP_SEM=1 \\\n      STAGE1_SKIP_CPROFILE=1 \\\n      STAGE1_SKIP_OWNERSHIP=1 \\\n      GENERIC_MODE=dict \\\n      GENERIC_SPEC_BUDGET=0 \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$smoke_target\" \\\n      BACK"
        out = out + "END_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$smoke_src\" \\\n      BACKEND_OUTPUT=\"$smoke_out\" \\\n      \"$bin\" >/dev/null 2>&1\n    rc=\"$?\"\n    set -e\n    if [ \"$rc\" -ne 0 ] || [ ! -s \"$smoke_out\" ]; then\n      IFS=\"$old_ifs\"\n      return 1\n    fi\n  done\n  IFS=\"$old_ifs\"\n  return 0\n}\n\nlatest_attempt_report() {\n  set +e\n  latest=\"$(ls -1t \"$root\"/chengcache/build_backend_driver/attempts.*.tsv 2>/dev/null | head -n 1)\"\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -ne 0 ]; then\n    latest=\"\"\n  fi\n  printf '%s\\n' \"$latest\"\n}\n\nlatest_file_mtime() {\n  file=\"$1\"\n  if [ \"$file\" = \"\" ] || [ ! -f \"$file\" ]; then\n    printf '0\\n'\n    return 0\n  fi\n  set +e\n  mtime=\"$(stat -f %m \"$file\" 2>/dev/null)\"\n  rc=\"$?\"\n  if [ \"$rc\" -ne 0 ] || [ \"$mtime\" = \"\" ]; then\n    mtime=\"$(stat -c %Y \"$file\" 2>/dev/null)\"\n    rc=\"$?\"\n  fi\n  set -e\n  case \"$mtime\" in\n    ''|*[!0-9]*) mtime=0 ;;\n  esac\n  printf '%s\\n' \"$mtime\"\n}\n\nlatest_crash_report() {\n  crash_dir=\"$HOME/Library/Logs/DiagnosticReports\"\n  if [ ! -d \"$crash_dir\" ]; then\n    printf '\\n'\n    return 0\n  fi\n  set +e\n  latest=\"$(ls -1t \\\n    \"$crash_dir\"/cheng.selfbuild_smoke-*.ips \\\n    \"$crash_dir\"/cheng.tmp-*.ips \\\n    \"$crash_dir\"/cheng-*.ips \\\n    2>/dev/null | head -n 1)\"\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -ne 0 ]; then\n    latest=\"\"\n  fi\n  printf '%s\\n' \"$latest\"\n}\n\nseed_output_from_stage0() {\n  src=\"$1\"\n  dst=\"$2\"\n  [ -x \"$src\" ] || return 1\n  mkdir -p \"$(dirname \"$dst\")\"\n  cp \"$src\" \"$dst\"\n  chmod +x \"$dst\" 2>/dev/null || true\n  src_obj=\"${src}.o\"\n  dst_obj=\"${dst}.o\"\n  if [ -s \"$src_obj\" ] && [ ! -e \"$dst_obj\" ]; then\n    cp \"$src_obj\" \"$dst_obj\" 2>/dev/null || true\n  fi\n  return 0\n}\n\nfirst_match_line() {\n  f=\"$1\"\n  if [ \"$f\" = \"\" ] || [ ! -f \"$f\" ]; then\n    printf '\\n'\n    re"
        out = out + "turn 0\n  fi\n  set +e\n  line=\"$(grep -E -m 1 \\\n    'unsupported expr kind|Symbol not found|dyld|EXC_BAD_ACCESS|Segmentation fault|Abort trap|unresolved|timed out|timeout' \\\n    \"$f\" 2>/dev/null)\"\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -ne 0 ]; then\n    line=\"\"\n  fi\n  printf '%s\\n' \"$line\"\n}\n\nclassify_cause() {\n  build_rc=\"$1\"\n  smoke_rc=\"$2\"\n  attempt_status=\"$3\"\n  hint=\"$4\"\n  build_elapsed=\"$5\"\n  build_timeout=\"$6\"\n  case \"$build_rc:$smoke_rc:$attempt_status\" in\n    124:*:*|*:124:*|*:*:124)\n      printf 'timeout\\n'\n      return 0\n      ;;\n    *:139:*|*:*:139|*:*:86|*:*:87)\n      printf 'smoke_crash_or_segv\\n'\n      return 0\n      ;;\n    *:134:*|*:*:134)\n      printf 'abort_or_dyld\\n'\n      return 0\n      ;;\n  esac\n  case \"$attempt_status\" in\n    ''|*[!0-9]*)\n      ;;\n    *)\n      if [ \"$attempt_status\" -ge 128 ]; then\n        case \"$attempt_status\" in\n          137|143)\n            case \"$build_elapsed:$build_timeout\" in\n              *[!0-9:]*)\n                printf 'timeout_or_killed\\n'\n                return 0\n                ;;\n            esac\n            if [ \"$build_elapsed\" -ge \"$build_timeout\" ]; then\n              printf 'timeout_or_killed\\n'\n            else\n              printf 'driver_crash_or_killed\\n'\n            fi\n            return 0\n            ;;\n        esac\n        printf 'driver_crash_or_killed\\n'\n        return 0\n      fi\n      ;;\n  esac\n  case \"$bui"
        out = out + "ld_rc\" in\n    ''|*[!0-9]*)\n      ;;\n    *)\n      if [ \"$build_rc\" -ge 128 ]; then\n        printf 'driver_crash_or_killed\\n'\n        return 0\n      fi\n      ;;\n  esac\n  case \"$hint\" in\n    *\"unsupported expr kind\"*)\n      printf 'stage0_legacy_lowering_regression\\n'\n      return 0\n      ;;\n    *\"Symbol not found\"*|*\"dyld\"*)\n      printf 'dyld_symbol_unresolved\\n'\n      return 0\n      ;;\n    *\"EXC_BAD_ACCESS\"*|*\"Segmentation fault\"*)\n      printf 'segv_or_bad_access\\n'\n      return 0\n      ;;\n    *\"timed out\"*|*\"timeout\"*)\n      printf 'timeout\\n'\n      return 0\n      ;;\n  esac\n  if [ \"$build_rc\" -ne 0 ]; then\n    printf 'driver_rebuild_failed\\n'\n    return 0\n  fi\n  if [ \"$smoke_rc\" -ne 0 ]; then\n    printf 'stage1_smoke_failed\\n'\n    return 0\n  fi\n  printf 'unknown\\n'\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[driver_selfbuild_smoke] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nstage0=\"${DRIVER_SELFBUILD_SMOKE_STAGE0:-}\"\nbuild_timeout=\"${DRIVER_SELFBUILD_SMOKE_TIMEOUT:-55}\"\noutput_rel=\"${DRIVER_SELFBUILD_SMOKE_OUTPUT:-artifacts/backend_driver/cheng.selfbuild_smoke}\"\nreport=\"${DRIVER_SELFBUILD_SMOKE_REPORT:-artifacts/backend_driver_selfbuild_smoke/selfbuild_smoke_report.tsv}\"\nreq"
        out = out + "uire_rebuild=\"${DRIVER_SELFBUILD_SMOKE_REQUIRE_REBUILD:-0}\"\nmax_stage0_attempts=\"${DRIVER_SELFBUILD_SMOKE_MAX_STAGE0_ATTEMPTS:-1}\"\nforce_rebuild=\"${DRIVER_SELFBUILD_SMOKE_FORCE:-}\"\nbuild_no_recover=\"${DRIVER_SELFBUILD_SMOKE_NO_RECOVER:-}\"\ndriver_multi=\"${DRIVER_SELFBUILD_SMOKE_MULTI:-0}\"\ndriver_multi_force=\"${DRIVER_SELFBUILD_SMOKE_MULTI_FORCE:-0}\"\ndriver_incremental=\"${DRIVER_SELFBUILD_SMOKE_INCREMENTAL:-1}\"\ndriver_jobs=\"${DRIVER_SELFBUILD_SMOKE_JOBS:-0}\"\nstage1_timeout=\"${DRIVER_SELFBUILD_SMOKE_STAGE1_TIMEOUT:-30}\"\n\nif [ \"$force_rebuild\" = \"\" ]; then\n  force_rebuild=\"$require_rebuild\"\nfi\nif [ \"$build_no_recover\" = \"\" ]; then\n  build_no_recover=\"$require_rebuild\"\nfi\n\nreport_dir=\"$(dirname \"$report\")\"\nmkdir -p \"$report_dir\" chengcache\nif [ ! -f \"$report\" ]; then\n  printf 'ts\\tresult\\tcause\\tstage0\\tbuild_rc\\tsmoke_rc\\tattempt_status\\tattempt_file\\tattempt_log\\tbuild_log\\tcrash_report\\thint\\n' >\"$report\"\nfi\n\nchoose_stage0() {\n  if [ \"$stage0\" != \"\" ]; then\n    printf '%s\\n' \"$stage0\"\n    return 0\n  fi\n  if [ \"${BACKEND_DRIVER:-}\" != \"\" ] && [ -x \"${BACKEND_DRIVER:-}\" ]; then\n    printf '%s\\n' \"${BACKEND_DRIVER:-}\"\n    return 0\n  fi\n  if [ -x \"artifacts/backend_driver/cheng\" ]; then\n    printf '%s\\n' \"artifacts/backend_driver/cheng\"\n    return 0\n  fi\n  if [ \"${TOOLING_STAGE0_ALLOW_LEGACY_FALLBACK:-0}\" != \"1\" ]; then\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path\n    return 0\n  fi\n  if [ -x \"dist/releases/current/cheng\" ]; then\n    printf '%s\\n' \"dist/releases/current/cheng\"\n    return 0\n  fi\n  if [ -x \"artifacts/backend_seed/cheng.stage2\" ]; then\n    printf '%s\\n' \"artifacts/backend_seed/cheng.stage2\"\n    return 0\n  fi\n  if [ -x \"artifacts/backend_selfhost_self_obj/cheng_stage0_default\" ]; then\n    printf '%s\\n' \"artifacts/b"
        out = out + "ackend_selfhost_self_obj/cheng_stage0_default\"\n    return 0\n  fi\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path\n}\n\nstage0=\"$(choose_stage0)\"\nif [ ! -x \"$stage0\" ]; then\n  echo \"[driver_selfbuild_smoke] stage0 not executable: $stage0\" 1>&2\n  exit 1\nfi\nif ! driver_help_ok \"$stage0\"; then\n  echo \"[driver_selfbuild_smoke] stage0 not runnable: $stage0\" 1>&2\n  exit 1\nfi\n\ncase \"$output_rel\" in\n  /*) output=\"$output_rel\" ;;\n  *) output=\"$root/$output_rel\" ;;\nesac\nmkdir -p \"$(dirname \"$output\")\"\nrm -f \"$output\" \"${output}.o\" \"${output}.tmp\" \"${output}.tmp.o\"\n\nif [ \"$require_rebuild\" != \"1\" ] && [ ! -x \"$output\" ]; then\n  seed_output_from_stage0 \"$stage0\" \"$output\" >/dev/null 2>&1 || true\nfi\n\nbuild_log=\"$report_dir/selfbuild_smoke.$$.log\"\nattempt_before=\"$(latest_attempt_report)\"\nattempt_before_mtime=\"$(latest_file_mtime \"$attempt_before\")\"\n\necho \"== backend.driver_selfbuild_smoke ==\"\necho \"[driver_selfbuild_smoke] stage0=$stage0 timeout=${build_timeout}s output=$output\"\n\nset +e\nbuild_start=\"$(date +%s)\"\nenv \\\n  BACKEND_BUILD_DRIVER_SELFHOST=1 \\\n  BACKEND_BUILD_DRIVER_LINKER=system \\\n  BACKEND_BUILD_DRIVER_STAGE0=\"$stage0\" \\\n  BACKEND_BUILD_DRIVER_TIMEOUT=\"$build_timeout\" \\"
        out = out + "\n  BACKEND_BUILD_DRIVER_SMOKE=1 \\\n  BACKEND_BUILD_DRIVER_REQUIRE_SMOKE=1 \\\n  BACKEND_BUILD_DRIVER_FORCE=\"$force_rebuild\" \\\n  BACKEND_BUILD_DRIVER_NO_RECOVER=\"$build_no_recover\" \\\n  BACKEND_BUILD_DRIVER_MAX_STAGE0_ATTEMPTS=\"$max_stage0_attempts\" \\\n  BACKEND_BUILD_DRIVER_MULTI=\"$driver_multi\" \\\n  BACKEND_BUILD_DRIVER_MULTI_FORCE=\"$driver_multi_force\" \\\n  BACKEND_BUILD_DRIVER_INCREMENTAL=\"$driver_incremental\" \\\n  BACKEND_BUILD_DRIVER_JOBS=\"$driver_jobs\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_driver --name:\"$output\" >\"$build_log\" 2>&1\nbuild_rc=\"$?\"\nbuild_end=\"$(date +%s)\"\nset -e\nbuild_elapsed=\"$((build_end - build_start))\"\n\nsmoke_rc=0\nif [ \"$build_rc\" -eq 0 ]; then\n  set +e\n  driver_stage1_smoke_ok \"$output\" \"$stage1_timeout\"\n  smoke_rc=\"$?\"\n  set -e\nfi\n\nattempt_file=\"$(latest_attempt_report)\"\nattempt_status=\"\"\nattempt_log=\"\"\nattempt_fresh=\"0\"\nif [ \"$attempt_file\" != \"\" ] && [ -f \"$attempt_file\" ]; then\n  attempt_mtime=\"$(latest_file_mtime \"$attempt_file\")\"\n  case \"$attempt_mtime\" in\n    ''|*[!0-9]*) attempt_mtime=0 ;;\n  esac\n  if [ \"$attempt_mtime\" -ge \"$build_start\" ]; then\n    if [ \"$attempt_file\" != \"$attempt_before\" ]; then\n      attempt_fresh=\"1\"\n    elif [ \"$attempt_mtime\" -gt \"${attempt_before_mtime:-0}\" ]; then\n      attempt_fresh=\"1\"\n    fi\n  fi\n  if [ \"$attempt_fresh\" = \"1\" ]; then\n    attempt_status=\"$(sed -n 's/.*status=\\([0-9][0-9]*\\).*/\\1/p' \"$attempt_file\" | tail -n 1)\"\n    attempt_log=\"$(sed -n 's/.*\\tlog=\\(.*\\)$/\\1/p' \"$attempt_file\" | tail -n 1)\"\n  else\n    attempt_file=\"\"\n  fi\nfi\n\ncrash_report=\"$(latest_crash_report)\"\nhint=\"$(first_"
        out = out + "match_line \"$build_log\")\"\nif [ \"$hint\" = \"\" ]; then\n  hint=\"$(first_match_line \"$attempt_log\")\"\nfi\nif [ \"$hint\" = \"\" ]; then\n  hint=\"$(first_match_line \"$crash_report\")\"\nfi\nif [ \"$hint\" = \"\" ]; then\n  if [ \"${attempt_status:-}\" != \"\" ]; then\n    hint=\"attempt_status=${attempt_status},elapsed=${build_elapsed}s,timeout=${build_timeout}s\"\n  elif [ \"$build_rc\" -ne 0 ]; then\n    hint=\"build_rc=${build_rc},elapsed=${build_elapsed}s,timeout=${build_timeout}s\"\n  elif [ \"$smoke_rc\" -ne 0 ]; then\n    hint=\"smoke_rc=${smoke_rc}\"\n  fi\nfi\ncause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\n\nts=\"$(date +%Y-%m-%dT%H:%M:%S)\"\nresult=\"ok\"\nif [ \"$build_rc\" -ne 0 ] || [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\n\nprintf '%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n' \\\n  \"$ts\" \"$result\" \"$cause\" \"$stage0\" \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"${attempt_file:-}\" \"${attempt_log:-}\" \"$build_log\" \"${crash_report:-}\" \"${hint:-}\" \\\n  >>\"$report\"\n\nif [ \"$result\" = \"ok\" ]; then\n  echo \"[driver_selfbuild_smoke] ok (report=$report, log=$build_log)\"\n  exit 0\nfi\n\necho \"[driver_selfbuild_smoke] fail: cause=$cause build_rc=$build_rc smoke_rc=$smoke_rc stage0=$stage0\" 1>&2\necho \"[driver_selfbuild_smoke] build_log=$build_log\" 1>&2\nif [ \"$attempt_file\" != \"\" ]; then\n  echo \"[driver_selfbu"
        out = out + "ild_smoke] attempt_report=$attempt_file\" 1>&2\nfi\nif [ \"$attempt_log\" != \"\" ]; then\n  echo \"[driver_selfbuild_smoke] attempt_log=$attempt_log\" 1>&2\nfi\nif [ \"$crash_report\" != \"\" ]; then\n  echo \"[driver_selfbuild_smoke] crash_report=$crash_report\" 1>&2\nfi\nif [ \"$hint\" != \"\" ]; then\n  echo \"[driver_selfbuild_smoke] hint=$hint\" 1>&2\nfi\necho \"[driver_selfbuild_smoke] report=$report\" 1>&2\nexit 1\n"
        return out
    if id == "verify_backend_dual_track":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ntarget_supports_self_linker() {\n  t=\"$1\"\n  case \"$t\" in\n    *darwin*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$t\" in\n        *arm64*|*aarch64*|*riscv64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$t\" in\n        *arm64*|*aarch64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nstamp_read() {\n  key=\"$1\"\n  file=\"$2\"\n  sed -n \"s/^${key}=//p\" \"$file\" | head -n 1\n}\n\nassert_eq() {\n  name=\"$1\"\n  got=\"$2\"\n  want=\"$3\"\n  if [ \"$got\" != \"$want\" ]; then\n    echo \"[verify_backend_dual_track] $name mismatch: got '$got', want '$want'\" 1>&2\n    exit 1\n  fi\n}\n\ntarget=\"${BACKEND_TARGET:-}\"\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\nif ["
        out = out + " \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  echo \"[verify_backend_dual_track] failed to resolve target\" 1>&2\n  exit 1\nfi\n\nfixture=\"${BACKEND_DUAL_TRACK_FIXTURE:-tests/cheng/backend/fixtures/return_add.cheng}\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\nif [ ! -f \"$fixture\" ]; then\n  echo \"[verify_backend_dual_track] missing fixture: $fixture\" 1>&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_dual_track\"\nmkdir -p \"$out_dir\"\n\nrun_chengc_with_stamp() {\n  label=\"$1\"\n  allow_fail=\"$2\"\n  shift 2\n  out=\"$out_dir/${label}\"\n  stamp=\"$out_dir/${label}.compile_stamp.txt\"\n  rm -f \"$out\" \"$out.o\" \"$stamp\"\n  rm -rf \"${out}.objs\" \"${out}.objs.lock\"\n  set +e\n  env -u BACKEND_LINKER -u BACKEND_BUILD_TRACK -u BACKEND_NO_RUNTIME_C \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_COMPILE_STAMP_OUT=\"$stamp\" \\\n    BACKEND_SYSTEM_LINKER_PRIORITY=\"${BACKEND_SYSTEM_LINKER_PRIORITY:-mold,lld,default}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --skip-pkg --out:\"$out\" \"$@\" >/dev/null\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] && [ \"$allow_fail\" != \"1\" ]; then\n    echo \"[verify_backend_dual_track] chengc failed (label=$label, status=$status)\" 1>&2\n    exit \"$status\"\n  fi\n  if [ ! -s \"$stamp\" ]; then\n    echo \"[verify_backend_dual_track] missing compile stamp: $stamp\" 1>&2\n    exit 1\n  fi\n}\n\nexpected_de"
        out = out + "fault_linker=\"system\"\nif target_supports_self_linker \"$target\"; then\n  expected_default_linker=\"self\"\nfi\n\nrun_chengc_with_stamp \"default_dev\" \"0\"\ndefault_stamp=\"$out_dir/default_dev.compile_stamp.txt\"\nassert_eq \"default.build_track\" \"$(stamp_read build_track \"$default_stamp\")\" \"dev\"\nassert_eq \"default.resolved_linker\" \"$(stamp_read resolved_linker \"$default_stamp\")\" \"$expected_default_linker\"\n\nrun_chengc_with_stamp \"release_default\" \"1\" --release\nrelease_stamp=\"$out_dir/release_default.compile_stamp.txt\"\nassert_eq \"release.build_track\" \"$(stamp_read build_track \"$release_stamp\")\" \"release\"\nassert_eq \"release.resolved_linker\" \"$(stamp_read resolved_linker \"$release_stamp\")\" \"system\"\nassert_eq \"release.no_runtime_c\" \"$(stamp_read no_runtime_c \"$release_stamp\")\" \"0\"\n\nif target_supports_self_linker \"$target\"; then\n  out=\"$out_dir/cli_override\"\n  stamp=\"$out_dir/cli_override.compile_stamp.txt\"\n  rm -f \"$out\" \"$out.o\" \"$stamp\"\n  rm -rf \"${out}.objs\" \"${out}.objs.lock\"\n  set +e\n  env -u BACKEND_BUILD_TRACK -u BACKEND_NO_RUNTIME_C \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=system \\\n    BACKEND_COMPILE_STAMP_OUT=\"$stamp\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --skip-pkg --out:\"$out\" --linker:self >/dev/null\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    echo \"[verify_backend_dual_track] warn: cli override"
        out = out + " compile failed (self override), continue with stamp check\" 1>&2\n  fi\n  assert_eq \"override.resolved_linker\" \"$(stamp_read resolved_linker \"$stamp\")\" \"self\"\nelse\n  out=\"$out_dir/cli_override\"\n  stamp=\"$out_dir/cli_override.compile_stamp.txt\"\n  rm -f \"$out\" \"$out.o\" \"$stamp\"\n  rm -rf \"${out}.objs\" \"${out}.objs.lock\"\n  set +e\n  env -u BACKEND_BUILD_TRACK -u BACKEND_NO_RUNTIME_C \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=self \\\n    BACKEND_COMPILE_STAMP_OUT=\"$stamp\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --skip-pkg --out:\"$out\" --linker:system >/dev/null\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    echo \"[verify_backend_dual_track] warn: cli override compile failed (system override), continue with stamp check\" 1>&2\n  fi\n  assert_eq \"override.resolved_linker\" \"$(stamp_read resolved_linker \"$stamp\")\" \"system\"\nfi\n\nreport=\"$out_dir/backend_dual_track.report.txt\"\n{\n  echo \"gate=backend.dual_track\"\n  echo \"target=$target\"\n  echo \"fixture=$fixture\"\n  echo \"default_expected_linker=$expected_default_linker\"\n  echo \"default_build_track=$(stamp_read build_track \"$default_stamp\")\"\n  echo \"default_resolved_linker=$(stamp_read resolved_linker \"$default_stamp\")\"\n  echo \"release_build_track=$(stamp_read build_track \"$release_stamp\")\"\n  echo \"release_resolved_linker=$(stamp_read resolved_linker \"$release_stamp\")\"\n  echo \"relea"
        out = out + "se_no_runtime_c=$(stamp_read no_runtime_c \"$release_stamp\")\"\n} >\"$report\"\n\necho \"verify_backend_dual_track ok\"\n"
        return out
    if id == "verify_backend_egraph_cost":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_egraph_cost] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_has_marker() {\n  cand=\"$1\"\n  marker=\"$2\"\n  if [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 0\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  rg -F -q \"$marker\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    BACKEND_DRIVER_A"
        out = out + "LLOW_FALLBACK=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_egraph_cost] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\nrefresh_missing_marker=\"${PAR05_DRIVER_REFRESH:-0}\"\ncase \"$refresh_missing_marker\" in\n  0|1) ;;\n  *) refresh_missing_marker=\"0\" ;;\nesac\ndriver_marker_egraph=\"uir_opt2.egraph\"\ndriver_marker_weights=\"uir_opt2.cost_model.weights\"\nif ! driver_has_marker \"$driver\" \"$driver_marker_egraph\" || ! driver_has_marker \"$driver\" \"$driver_marker_weights\"; then\n  if [ \"$refresh_missing_marker\" = \"1\" ]; then\n    refreshed_driver=\"$(env \\\n      BACKEND_DRIVER_PATH_PREFER_REBUILD=1 \\\n      BACKEND_DRIVER_ALLOW_FALLBACK=0 \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n    if [ -x \"$refreshed_driver\" ] \\\n      && driver_has_marker \"$refreshed_driver\" \"$driver_marker_egraph\" \\\n      && driver_has_marker \"$refreshed_driver\" \"$driver_marker_weights\"; then\n      echo \"[verify_backend_egraph_cost] use refreshed backend driver: $refreshed_driver\" 1>&2\n      driver=\"$refreshed_driver\"\n    fi\n  fi\nfi\nif ! driver_has_marker \"$driver\" \"$driver_marker_egraph\"; then\n  echo \"[verify_backend_egraph_cost] backend driver missing egraph marker (${driver_marker_egraph}): $driver\" 1>&2\n  exit 1\nfi\nif ! driver_ha"
        out = out + "s_marker \"$driver\" \"$driver_marker_weights\"; then\n  echo \"[verify_backend_egraph_cost] backend driver missing weight marker (${driver_marker_weights}): $driver\" 1>&2\n  exit 1\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nfixture=\"${BACKEND_EGRAPH_FIXTURE:-tests/cheng/backend/fixtures/return_egraph_goal_rewrite.cheng}\"\niters=\"${UIR_EGRAPH_ITERS:-3}\"\ngoals_raw=\"${UIR_EGRAPH_GOALS:-balanced,latency,size}\"\nweight_expect_balanced=\"${UIR_EGRAPH_WEIGHT_EXPECT_BALANCED:-balanced.n4_o3_i1}\"\nweight_expect_latency=\"${UIR_EGRAPH_WEIGHT_EXPECT_LATENCY:-latency.n3_o5_i1}\"\nweight_expect_size=\"${UIR_EGRAPH_WEIGHT_EXPECT_SIZE:-size.n8_o2_i1}\"\nif [ ! -f \"$fixture\" ]; then\n  echo \"[verify_backend_egraph_cost] missing fixture: $fixture\" 1>&2\n  exit 2\nfi\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*) return 1 ;;\n  esac\n  return 0\n}\nif ! is_uint \"$iters\" || [ \"$iters\" -le 0 ] || [ \"$iters\" -gt 32 ]; then\n  echo \"[verify_backend_egraph_cost] invalid UIR_EGRAPH_ITERS: $iters (expected 1..32)\" 1>&2\n  exit 2\nfi\n\nnormalize_goal() {\n  g=\"$1\"\n  lower=\"$(printf '%s' \"$g\" | tr 'A-Z' 'a-z')\"\n  case \"$lower\" in\n    balanced|latency|size) printf '%s\\n' \"$lower\" ;;\n    *) printf 'balanced\\n' ;;\n  esac\n}\n\ngoal_weight_signature() {\n  case \"$1\" in\n    balanced) printf '%s\\n' \"$weight_expect_balanced\" ;;\n    latency) printf "
        out = out + "'%s\\n' \"$weight_expect_latency\" ;;\n    size) printf '%s\\n' \"$weight_expect_size\" ;;\n    *) printf '%s\\n' \"$weight_expect_balanced\" ;;\n  esac\n}\n\ngoals=\"\"\nfor raw_goal in $(printf '%s' \"$goals_raw\" | tr ',;' '  '); do\n  goal=\"$(normalize_goal \"$raw_goal\")\"\n  case \" $goals \" in\n    *\" $goal \"*) ;;\n    *) goals=\"$goals $goal\" ;;\n  esac\ndone\nif [ \"$goals\" = \"\" ]; then\n  goals=\" balanced latency size\"\nfi\n\nfor required in \\\n  \"src/backend/uir/uir_egraph_cost.cheng\" \\\n  \"src/backend/uir/uir_egraph_rewrite.cheng\" \\\n  \"src/backend/uir/uir_opt.cheng\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[verify_backend_egraph_cost] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\nrequire_marker() {\n  file=\"$1\"\n  pat=\"$2\"\n  label=\"$3\"\n  if ! rg -q \"$pat\" \"$file\"; then\n    echo \"[verify_backend_egraph_cost] missing marker ($label) in $file\" 1>&2\n    exit 1\n  fi\n}\n\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphScore\\\\(\" \"egraph_cost_score\"\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphCostAccept\\\\(\" \"egraph_cost_accept\"\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphNodeWeight\\\\(\" \"egraph_cost_node_weight\"\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphOpWeight\\\\(\" \"egraph_cost_op_weight\"\nrequire_marker \"src/backend/uir/uir_egraph_cost.cheng\" \"fn uirEGraphGoalWeightSignature\\\\(\""
        out = out + " \"egraph_cost_weight_signature\"\nrequire_marker \"src/backend/uir/uir_egraph_rewrite.cheng\" \"fn uirRunEGraphRewrite\\\\(\" \"egraph_rewrite_entry\"\nrequire_marker \"src/backend/uir/uir_egraph_rewrite.cheng\" \"fn uirTryFoldConstIntAlgebra\\\\(\" \"egraph_rewrite_const_int_fold\"\nrequire_marker \"src/backend/uir/uir_egraph_rewrite.cheng\" \"fn uirTryRewriteIntAlgebra\\\\(\" \"egraph_rewrite_int_algebra_subset\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.egraph\" \"egraph_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.egraph\\\\.proof_required\" \"egraph_proof_required_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.egraph\\\\.proof_backed_funcs=\" \"egraph_proof_backed_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.cost_model\" \"cost_model_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.cost_model\\\\.weights\" \"cost_model_weight_profile_surface\"\n\nout_dir=\"artifacts/backend_egraph_cost\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/egraph_cost.report.txt\"\nsnapshot=\"$out_dir/egraph_cost.snapshot.env\"\nper_goal=\"$out_dir/egraph_cost.per_goal.tsv\"\nrm -f \"$report\" \"$snapshot\" \"$per_goal\"\nprintf \"goal\\tobj_a\\tobj_b\\tsize_a\\tsize_b\\ttotal_ms_a\\ttotal_ms_b\\tegraph_changed_hits\\tproof_backed_funcs\\tweight_signature\\tweight_event_hits\\n\" >\"$per_goal\"\n\nbuild_one() {\n  out_obj=\"$1\"\n  out_log=\"$2\"\n"
        out = out + "  goal=\"$3\"\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    STAGE1_STD_NO_POINTERS=0 \\\n    STAGE1_STD_NO_POINTERS_STRICT=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_OWNERSHIP=0 \\\n    UIR_PROFILE=1 \\\n    UIR_NOALIAS=1 \\\n    UIR_NOALIAS_REQUIRE_PROOF=1 \\\n    UIR_EGRAPH_ITERS=\"$iters\" \\\n    UIR_EGRAPH_GOAL=\"$goal\" \\\n    UIR_EGRAPH_REQUIRE_PROOF=1 \\\n    BACKEND_OPT_LEVEL=2 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out_obj\" \\\n    \"$driver\" >\"$out_log\" 2>&1\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nprofile_metric() {\n  file=\"$1\"\n  event=\"$2\"\n  field=\"$3\"\n  awk -v target_event=\"$event\" -v target_field=\"$field\" '\n    $1 == \"uir_profile\" && $2 == target_event {\n      for (i = 3; i <= NF; i++) {\n        split($i, kv, \"=\")\n        if (kv[1] == target_field) {\n          print kv[2]\n          found = 1\n          exit\n        }\n      }\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nprofile_event_hits() {\n  file=\"$1\"\n  event=\"$2\"\n  awk -v target_event=\"$event\" '\n    $1 == \"uir_profile\" && $2 == target_event {\n      n = n + 1\n    }\n    END {\n      prin"
        out = out + "t n + 0\n    }\n  ' \"$file\"\n}\n\nprofile_label_int_value() {\n  file=\"$1\"\n  label_prefix=\"$2\"\n  awk -v target_prefix=\"$label_prefix\" '\n    $1 == \"uir_profile\" && index($2, target_prefix) == 1 {\n      value = $2\n      sub(\"^\" target_prefix, \"\", value)\n      print value\n      found = 1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\ngoals_verified=0\ngoals_changed=0\ngoals_weight_verified=0\nfor goal in $goals; do\n  obj_a=\"$out_dir/egraph_cost.${goal}.a.o\"\n  obj_b=\"$out_dir/egraph_cost.${goal}.b.o\"\n  log_a=\"$out_dir/egraph_cost.${goal}.a.log\"\n  log_b=\"$out_dir/egraph_cost.${goal}.b.log\"\n  rm -f \"$obj_a\" \"$obj_b\" \"$log_a\" \"$log_b\"\n\n  if ! build_one \"$obj_a\" \"$log_a\" \"$goal\"; then\n    echo \"[verify_backend_egraph_cost] compile failed (goal=$goal run=a): $fixture\" 1>&2\n    tail -n 200 \"$log_a\" 1>&2 || true\n    exit 1\n  fi\n  if ! build_one \"$obj_b\" \"$log_b\" \"$goal\"; then\n    echo \"[verify_backend_egraph_cost] compile failed (goal=$goal run=b): $fixture\" 1>&2\n    tail -n 200 \"$log_b\" 1>&2 || true\n    exit 1\n  fi\n  if [ ! -s \"$obj_a\" ] || [ ! -s \"$obj_b\" ]; then\n    echo \"[verify_backend_egraph_cost] missing object outputs for goal=$goal\" 1>&2\n    exit 1\n  fi\n  if ! cmp -s \"$obj_a\" \"$obj_b\"; then\n    echo \"[verify_backend_egraph_cost] deterministic object mismatch for goal=$goal: $obj_a vs $obj_b\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:spac"
        out = out + "e:]]+uir_opt2\\.egraph([[:space:]]+|$)' \"$log_a\"; then\n    echo \"[verify_backend_egraph_cost] missing egraph profile event for goal=$goal: $log_a\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.changed([[:space:]]+|$)' \"$log_a\"; then\n    echo \"[verify_backend_egraph_cost] missing egraph changed event for goal=$goal: $log_a\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.egraph\\.proof_required([[:space:]]+|$)' \"$log_a\"; then\n    echo \"[verify_backend_egraph_cost] missing egraph proof-required profile event for goal=$goal: $log_a\" 1>&2\n    exit 1\n  fi\n  proof_backed_funcs=\"$(profile_label_int_value \"$log_a\" \"uir_opt2.egraph.proof_backed_funcs=\")\"\n  if ! is_uint \"${proof_backed_funcs:-}\" || [ \"${proof_backed_funcs:-0}\" -le 0 ]; then\n    echo \"[verify_backend_egraph_cost] invalid proof-backed funcs for goal=$goal: ${proof_backed_funcs:-<empty>} ($log_a)\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.cost_model([[:space:]]+|$)' \"$log_a\"; then\n    echo \"[verify_backend_egraph_cost] missing cost model profile event for goal=$goal: $log_a\" 1>&2\n    exit 1\n  fi\n  if ! rg -q \"^uir_profile[[:space:]]+uir_opt2\\\\.cost_model\\\\.${goal}([[:space:]]+|$)\" \"$log_a\"; then\n    echo \"[verify_backend_egraph_cost] missing goal cost profile event for goal=$goal: $log_a\" 1>&2\n    exit 1\n  fi\n  expected_weight_sig=\"$(goal_weight_signature \"$goal\")\"\n  weight"
        out = out + "_event=\"uir_opt2.cost_model.weights.${expected_weight_sig}\"\n  weight_hits=\"$(profile_event_hits \"$log_a\" \"$weight_event\")\"\n  if [ \"${weight_hits:-0}\" -le 0 ]; then\n    echo \"[verify_backend_egraph_cost] missing cost model weight profile event for goal=$goal (${weight_event}): $log_a\" 1>&2\n    exit 1\n  fi\n\n  size_a=\"$(wc -c < \"$obj_a\" | tr -d ' ')\"\n  size_b=\"$(wc -c < \"$obj_b\" | tr -d ' ')\"\n  total_ms_a=\"$(profile_metric \"$log_a\" \"single.emit_obj\" \"total_ms\")\"\n  total_ms_b=\"$(profile_metric \"$log_b\" \"single.emit_obj\" \"total_ms\")\"\n  changed_hits=\"$(profile_event_hits \"$log_a\" \"uir_opt2.egraph.changed\")\"\n  if [ \"${changed_hits:-0}\" -gt 0 ]; then\n    goals_changed=$((goals_changed + 1))\n  fi\n  goals_weight_verified=$((goals_weight_verified + 1))\n  goals_verified=$((goals_verified + 1))\n  printf \"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\" \\\n    \"$goal\" \"$obj_a\" \"$obj_b\" \"$size_a\" \"$size_b\" \"${total_ms_a:-na}\" \"${total_ms_b:-na}\" \"${changed_hits:-0}\" \"${proof_backed_funcs:-0}\" \"$expected_weight_sig\" \"${weight_hits:-0}\" >>\"$per_goal\"\ndone\n\nif [ \"$goals_verified\" -le 0 ]; then\n  echo \"[verify_backend_egraph_cost] no valid egraph goals configured: $goals_raw\" 1>&2\n  exit 1\nfi\nif [ \"$goals_changed\" -le 0 ]; then\n  echo \"[verify_backend_egraph_cost] egraph changed signal missing for all goals\" 1>&2\n  exit 1\nfi\nif [ \"$goals_weight_verified\" -ne \"$goals_verified\" ]"
        out = out + "; then\n  echo \"[verify_backend_egraph_cost] cost model weight profile coverage mismatch: verified=$goals_weight_verified expected=$goals_verified\" 1>&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_egraph_cost report\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"fixture=$fixture\"\n  echo \"egraph_iters=$iters\"\n  echo \"weight_expect_balanced=$weight_expect_balanced\"\n  echo \"weight_expect_latency=$weight_expect_latency\"\n  echo \"weight_expect_size=$weight_expect_size\"\n  echo \"proof_mode=require_high_uir\"\n  echo \"goals=$(printf '%s' \"$goals\" | sed 's/^ //')\"\n  echo \"goals_verified=$goals_verified\"\n  echo \"goals_changed=$goals_changed\"\n  echo \"goals_weight_verified=$goals_weight_verified\"\n  echo \"per_goal=$per_goal\"\n  echo \"sample_log=$out_dir/egraph_cost.balanced.a.log\"\n} >\"$report\"\n\n{\n  echo \"backend_egraph_cost_driver=$driver\"\n  echo \"backend_egraph_cost_target=$target\"\n  echo \"backend_egraph_cost_fixture=$fixture\"\n  echo \"backend_egraph_cost_iters=$iters\"\n  echo \"backend_egraph_cost_weight_expect_balanced=$weight_expect_balanced\"\n  echo \"backend_egraph_cost_weight_expect_latency=$weight_expect_latency\"\n  echo \"backend_egraph_cost_weight_expect_size=$weight_expect_size\"\n  echo \"backend_egraph_cost_proof_mode=require_high_uir\"\n  echo \"backend_egraph_cost_goals=$(printf '%s' \"$goals\" | sed 's/^ //')\"\n  echo \"backend_egraph_cost_goals_verified=$goals_verified\"\n  echo \"backend_egraph_cost_"
        out = out + "goals_changed=$goals_changed\"\n  echo \"backend_egraph_cost_goals_weight_verified=$goals_weight_verified\"\n  echo \"backend_egraph_cost_per_goal=$per_goal\"\n  echo \"backend_egraph_cost_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_egraph_cost ok\"\n"
        return out
    if id == "verify_backend_emit_obj_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_emit_obj_contract] rg is required\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_emit_obj_contract\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\n\nemit_scripts=\"$out_dir/backend_emit_obj.scripts.txt\"\nmissing_bridge=\"$out_dir/backend_emit_obj.missing_bridge.txt\"\nbad_allow=\"$out_dir/backend_emit_obj.bad_allow.txt\"\nreport=\"$out_dir/backend_emit_obj_contract.report.txt\"\nbridge_file=\"src/tooling/env_prefix_bridge.sh\"\n\nrg -l --glob '*.sh' --glob 'cheng_tooling_embedded_inline.cheng' \"BACKEND_EMIT=obj\" src/tooling \\\n  | rg -v 'verify_backend_emit_obj_contract(\\.inline|\\.sh)?$' \\\n  | LC_ALL=C sort >\"$emit_scripts\"\n\nif [ ! -s \"$emit_scripts\" ]; then\n  echo \"[verify_backend_emit_obj_contract] no tooling scripts use BACKEND_EMIT=obj\" >&2\n  exit 1\nfi\n\n: >\"$missing_bridge\"\n: >\"$bad_allow\"\nwhile IFS= read -r file; do\n  [ \"$file\" != \"\" ] || continue\n  if [ \"$file\" != \"src/tooling/cheng_tooling_embedded_inline.cheng\" ] && ! rg -q \"env_prefix_bridge.sh\" \"$file\"; then\n    printf '%s\\n' \"$file\" >>\"$missing_bridge\"\n  fi\n  if rg -q '^[[:space:]]*(export[[:space:]]+)?(BACKEND_INTERNAL_ALLOW_EMIT_OBJ|BACKEND_INTERNAL_ALLOW_EMIT_OBJ)=0([[:space:]]|$)' \"$file\"; then\n    printf '%s\\n' \"$file\" >>\"$ba"
        out = out + "d_allow\"\n  fi\ndone <\"$emit_scripts\"\n\nif [ -s \"$missing_bridge\" ]; then\n  echo \"[verify_backend_emit_obj_contract] scripts using BACKEND_EMIT=obj must source env_prefix_bridge.sh\" >&2\n  sed -n '1,200p' \"$missing_bridge\" >&2\n  exit 1\nfi\nif [ -s \"$bad_allow\" ]; then\n  echo \"[verify_backend_emit_obj_contract] scripts using BACKEND_EMIT=obj must not disable BACKEND_INTERNAL_ALLOW_EMIT_OBJ\" >&2\n  sed -n '1,200p' \"$bad_allow\" >&2\n  exit 1\nfi\n\nif ! rg -q 'BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1' \"$bridge_file\"; then\n  echo \"[verify_backend_emit_obj_contract] env_prefix_bridge missing BACKEND_INTERNAL_ALLOW_EMIT_OBJ central gate\" >&2\n  exit 1\nfi\nif ! rg -q 'BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1' \"$bridge_file\"; then\n  echo \"[verify_backend_emit_obj_contract] env_prefix_bridge missing BACKEND_INTERNAL_ALLOW_EMIT_OBJ central gate\" >&2\n  exit 1\nfi\n\nemit_count=\"$(wc -l <\"$emit_scripts\" | tr -d ' ')\"\nexplicit_allow_lines=\"$(rg -n --glob '*.sh' --glob 'cheng_tooling_embedded_inline.cheng' 'BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1|BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1' src/tooling | wc -l | tr -d ' ')\"\n\n{\n  echo \"verify_backend_emit_obj_contract report\"\n  echo \"status=ok\"\n  echo \"emit_obj_script_count=$emit_count\"\n  echo \"missing_bridge_count=0\"\n  echo \"bad_allow_count=0\"\n  echo \"explicit_allow_lines=$explicit_allow_lines\"\n  echo \"emit_scripts=$emit_scripts\"\n  echo \"bridge_file=$bridge_file\"\n} >\"$report\"\n\necho \"verify_backend_e"
        out = out + "mit_obj_contract ok\"\n"
        return out
    if id == "verify_backend_exe_determinism":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\n\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nldflags=\"\"\ncase \"$host_os\" in\n  Darwin)\n    ldflags=\"-Wl,-no_uuid\"\n    ;;\n  Linux)\n    ldflags=\"-Wl,--build-id=none\"\n    ;;\n  *)\n    echo \"verify_backend_exe_determinism skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixture"
        out = out + "s/return_i64.cheng\"\nfi\nout_dir=\"artifacts/backend_exe_determinism\"\nmkdir -p \"$out_dir\"\n\nexe_path=\"$out_dir/out\"\nruntime_env_log=\"$out_dir/runtime_env.log\"\nruntime_env_line=\"\"\nif [ \"$linker_mode\" = \"self\" ]; then\n  set +e\n  runtime_env_line=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:self 2>\"$runtime_env_log\")\"\n  runtime_env_status=\"$?\"\n  set -e\n  if [ \"$runtime_env_status\" -ne 0 ]; then\n    echo \"[verify_backend_exe_determinism] backend_link_env failed for target=$target (log: $runtime_env_log)\" >&2\n    exit 1\n  fi\nfi\n\nrun_exe() {\n  if [ \"$linker_mode\" = \"self\" ]; then\n    # shellcheck disable=SC2086\n    env $runtime_env_line \\\n      BACKEND_EMIT=exe \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LDFLAGS=\"$ldflags\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe_path\" \\\n      \"$driver\"\n    return\n  fi\n  env \\\n    BACKEND_EMIT=exe \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=system \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LDFLAGS=\"$ldflags\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\"\n}\n\nrun_exe\n\nsha_a=\"$(sha256_file \"$exe_path\")\"\n\nrun_exe\n\nsha_b=\""
        out = out + "$(sha256_file \"$exe_path\")\"\nif [ \"$sha_a\" = \"\" ] || [ \"$sha_b\" = \"\" ]; then\n  echo \"verify_backend_exe_determinism skip: missing sha256 tool\" 1>&2\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ]; then\n  echo \"[verify_backend_exe_determinism] mismatch: $sha_a vs $sha_b\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_exe_determinism ok\"\n"
        return out
    if id == "verify_backend_exe_determinism_strict":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nldflags=\"\"\ncase \"$host_os\" in\n  Darwin)\n    ldflags=\"-Wl,-no_uuid\"\n    ;;\n  Linux)\n    ldflags=\"-Wl,--build-id=none\"\n    ;;\n  *)\n    echo \"verify_backend_exe_determinism_strict skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/"
        out = out + "fixtures/return_i64.cheng\"\nfi\nout_dir=\"artifacts/backend_exe_determinism_strict\"\nmkdir -p \"$out_dir\"\nmkdir -p \"$out_dir/tmp_a\" \"$out_dir/tmp_b\" \"$out_dir/tmp_c\"\n\nexe_path=\"$out_dir/out\"\nruntime_env_log=\"$out_dir/runtime_env.log\"\nruntime_env_line=\"\"\nif [ \"$linker_mode\" = \"self\" ]; then\n  set +e\n  runtime_env_line=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:self 2>\"$runtime_env_log\")\"\n  runtime_env_status=\"$?\"\n  set -e\n  if [ \"$runtime_env_status\" -ne 0 ]; then\n    echo \"[verify_backend_exe_determinism_strict] backend_link_env failed for target=$target (log: $runtime_env_log)\" >&2\n    exit 1\n  fi\nfi\n\nrun_exe() {\n  if [ \"$linker_mode\" = \"self\" ]; then\n    # shellcheck disable=SC2086\n    env $runtime_env_line \\\n      BACKEND_EMIT=exe \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LDFLAGS=\"$ldflags\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe_path\" \\\n      \"$@\" \\\n      \"$driver\"\n  else\n    env \\\n      BACKEND_EMIT=exe \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_LINKER=system \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LDFLAGS=\"$ldflags\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTP"
        out = out + "UT=\"$exe_path\" \\\n      \"$@\" \\\n      \"$driver\"\n  fi\n}\n\nrun_exe env LANG=C LC_ALL=C TZ=UTC TMPDIR=\"$out_dir/tmp_a\"\nsha_a=\"$(sha256_file \"$exe_path\")\"\n\nrun_exe env LANG=C LC_ALL=C TZ=Asia/Shanghai TMPDIR=\"$out_dir/tmp_b\"\nsha_b=\"$(sha256_file \"$exe_path\")\"\n\nrun_exe env LANG=C LC_ALL=C TZ=UTC TMPDIR=\"$out_dir/tmp_c\" BACKEND_JOBS=1\nsha_c=\"$(sha256_file \"$exe_path\")\"\n\nif [ \"$sha_a\" = \"\" ] || [ \"$sha_b\" = \"\" ] || [ \"$sha_c\" = \"\" ]; then\n  echo \"verify_backend_exe_determinism_strict skip: missing sha256 tool\" 1>&2\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ] || [ \"$sha_b\" != \"$sha_c\" ]; then\n  echo \"[verify_backend_exe_determinism_strict] mismatch: $sha_a vs $sha_b vs $sha_c\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_exe_determinism_strict ok\"\n"
        return out
    if id == "verify_backend_ffi_abi":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nout_dir=\"artifacts/backend_ffi_abi\"\nmkdir -p \"$out_dir\"\n\nfor fixture in tests/cheng/backend/fixtures/ffi_importc_sum9_i64.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_sum9_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_varargs_sum10_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_varargs_direct_sum_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_sum16_i64.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_sum16_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_mix_i32_i64.cheng \\\n               tests/cheng/backend/fixtures/ffi_"
        out = out + "importc_ptr_store_load_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_callback_ctx_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_aggret_pair_i32.cheng \\\n               tests/cheng/backend/fixtures/ffi_importc_out_pair_i32.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/$base\"\n  env $link_env \\\n    BACKEND_EMIT=exe \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\"\n  \"$exe_path\"\ndone\n\necho \"verify_backend_ffi_abi ok\"\n"
        return out
    if id == "verify_backend_ffi_borrow_bridge":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_ffi_borrow_bridge] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ndriver=\"${BACKEND_DRIVER:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)}\"\nif [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\ndriver_exec=\"$driver\"\ndriver_real_env=\"\"\nif [ -x \"src/tooling/backend_driver_exec.sh\" ]; then\n  driver_exec=\"src/tooling/backend_driver_exec.sh\"\n  driver_real_env=\"BACKEND_DRIVER_REAL=$driver\"\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\ngate_linker=\"${BACKEND_FFI_BORROW_BRIDGE_LINKER:-system}\"\ncase \"$gate_linker\" in\n  \"\"|auto|system)\n    link_env=\"BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0\"\n    gate_linker=\"system\"\n    ;;\n  self)\n    link_env=\"$(${TOOLING_SELF_BIN:-artifacts/tool"
        out = out + "ing_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:self)\"\n    ;;\n  *)\n    fail \"invalid BACKEND_FFI_BORROW_BRIDGE_LINKER: $gate_linker (expected self|system|auto)\"\n    ;;\nesac\n\nfixture_ok=\"tests/cheng/backend/fixtures/ffi_importc_borrow_mut_pair_i32.cheng\"\nfixture_fail=\"tests/cheng/backend/fixtures/compile_fail_ffi_importc_borrow_mut_pair_i32_non_lvalue.cheng\"\nfor f in \"$fixture_ok\" \"$fixture_fail\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing fixture: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_ffi_borrow_bridge\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nexe_path=\"$out_dir/ffi_importc_borrow_mut_pair_i32.$safe_target\"\ncase \"$target\" in\n  *windows*|*msvc*) exe_path=\"$exe_path.exe\" ;;\nesac\nbuild_ok_log=\"$out_dir/ffi_borrow_bridge.$safe_target.build_ok.log\"\nrun_log=\"$out_dir/ffi_borrow_bridge.$safe_target.run.log\"\nbuild_fail_log=\"$out_dir/ffi_borrow_bridge.$safe_target.build_fail.log\"\nsymbol_log=\"$out_dir/ffi_borrow_bridge.$safe_target.symbol.log\"\nreport=\"$out_dir/backend_ffi_borrow_bridge.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_ffi_borrow_bridge.$safe_target.snapshot.env\"\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$build_ok_log\" \"$run_log\" \"$build_fail_log\" \"$symbol_log\" \"$report\" \"$snapshot\"\nrm -rf \"${exe_path}.objs\" \"${exe_path}.objs.lock\"\n\nset +e\nenv $link_env \\\n  $driver_real_env \\"
        out = out + "\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_ok\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver_exec\" >\"$build_ok_log\" 2>&1\nbuild_ok_status=\"$?\"\nset -e\nif [ \"$build_ok_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$build_ok_log\" >&2 || true\n  fail \"positive fixture build failed (status=$build_ok_status)\"\nfi\nif [ ! -x \"$exe_path\" ]; then\n  fail \"missing executable output: $exe_path\"\nfi\n\nset +e\n\"$exe_path\" >\"$run_log\" 2>&1\nrun_status=\"$?\"\nset -e\nif [ \"$run_status\" -ne 0 ]; then\n  sed -n '1,120p' \"$run_log\" >&2 || true\n  fail \"positive fixture run failed (status=$run_status)\"\nfi\n\nsymbol_pattern='_cheng_abi_borrow_mut_pair_i32'\nsymbol_ok=\"0\"\nset +e\nnm -m \"$exe_path\" >\"$symbol_log\" 2>/dev/null\nnm_status=\"$?\"\nif [ \"$nm_status\" -ne 0 ]; then\n  nm -g \"$exe_path\" >\"$symbol_log\" 2>/dev/null\n  nm_status=\"$?\"\nfi\nset -e\nif [ \"$nm_status\" -ne 0 ]; then\n  fail \"failed to inspect executable symbols via nm\"\nfi\nif rg -q \"$symbol_pattern\" \"$symbol_log\"; then\n  symbol_ok=\"1\"\nelse\n  sed -n '1,200p' \"$symbol_log\" >&2 || true\n  fail \"missing expected borrow bridge symbol: $symbol_pattern\"\nfi\n\nfail_out=\"$out_dir/compile_fail_ffi_importc_borrow_mut_pair_i32_non_lvalue.$safe_target\"\nset +e\nenv $link_env \\\n  $driver_real_env \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_"
        out = out + "MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_fail\" \\\n  BACKEND_OUTPUT=\"$fail_out\" \\\n  \"$driver_exec\" >\"$build_fail_log\" 2>&1\nbuild_fail_status=\"$?\"\nset -e\ndiag_pattern='var parameter requires a mutable borrow \\(lvalue\\)'\ndiag_supported=\"0\"\ndiag_mode=\"not_supported_in_backend_driver\"\nif rg -q \"$diag_pattern\" \"$build_fail_log\"; then\n  diag_supported=\"1\"\n  diag_mode=\"sem_diag\"\nfi\n\n{\n  echo \"verify_backend_ffi_borrow_bridge report\"\n  echo \"target=$target\"\n  echo \"gate_linker=$gate_linker\"\n  echo \"link_env=$link_env\"\n  echo \"driver=$driver\"\n  echo \"driver_exec=$driver_exec\"\n  echo \"fixture_ok=$fixture_ok\"\n  echo \"fixture_fail=$fixture_fail\"\n  echo \"build_ok_status=$build_ok_status\"\n  echo \"run_status=$run_status\"\n  echo \"symbol_pattern=$symbol_pattern\"\n  echo \"symbol_ok=$symbol_ok\"\n  echo \"build_fail_status=$build_fail_status\"\n  echo \"diag_pattern=$diag_pattern\"\n  echo \"diag_supported=$diag_supported\"\n  echo \"diag_mode=$diag_mode\"\n  echo \"build_ok_log=$build_ok_log\"\n  echo \"run_log=$run_log\"\n  echo \"symbol_log=$symbol_log\"\n  echo \"build_fail_log=$build_fail_log\"\n} >\"$report\"\n\n{\n  echo \"backend_ffi_borrow_bridge_target=$target\"\n  echo \"backend_ffi_borrow_bridge_symbol_ok=$symbol_ok\"\n  echo \"backend_ffi_borrow_bridge_diag_supported=$diag_supported\"\n  echo \"backend_ffi_borrow_bridge_diag_mode=$diag_mode\"\n  e"
        out = out + "cho \"backend_ffi_borrow_bridge_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_ffi_borrow_bridge ok\"\n"
        return out
    if id == "verify_backend_ffi_handle_sandbox":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_ffi_handle_sandbox] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ncc_bin=\"${CC:-cc}\"\nif ! command -v \"$cc_bin\" >/dev/null 2>&1; then\n  fail \"C compiler not found: $cc_bin\"\nfi\n\nheader_file=\"src/runtime/native/system_helpers.h\"\nc_runtime_file=\"src/runtime/native/system_helpers.c\"\nbackend_runtime_file=\"src/std/system_helpers_backend.cheng\"\n\nfor runtime_file in \"$header_file\" \"$c_runtime_file\" \"$backend_runtime_file\"; do\n  if [ ! -f \"$runtime_file\" ]; then\n    fail \"missing runtime file: $runtime_file\"\n  fi\ndone\n\nfor sym in \\\n  cheng_ffi_handle_register_ptr \\\n  cheng_ffi_handle_resolve_ptr \\\n  cheng_ffi_handle_invalidate \\\n  cheng_ffi_handle_new_i32 \\\n  cheng_ffi_handle_get_i32 \\\n  cheng_ffi_handle_add_i32 \\\n  cheng_ffi_handle_release_i32; do\n  if ! rg -q \"$sym\" \"$header_file\"; then\n    fail \"missing header symbol: $sym\"\n  f"
        out = out + "i\n  if ! rg -q \"$sym\" \"$c_runtime_file\"; then\n    fail \"missing C runtime symbol: $sym\"\n  fi\n  if ! rg -q \"$sym\" \"$backend_runtime_file\"; then\n    fail \"missing backend runtime symbol: $sym\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_ffi_handle_sandbox\"\nmkdir -p \"$out_dir\"\n\nprobe_src=\"$out_dir/ffi_handle_sandbox_probe.c\"\nprobe_bin=\"$out_dir/ffi_handle_sandbox_probe\"\nprobe_compile_log=\"$out_dir/ffi_handle_sandbox_probe.build.log\"\nprobe_run_log=\"$out_dir/ffi_handle_sandbox_probe.run.log\"\nreport=\"$out_dir/backend_ffi_handle_sandbox.report.txt\"\nsnapshot=\"$out_dir/backend_ffi_handle_sandbox.snapshot.env\"\n\ncat >\"$probe_src\" <<'PROBE_C'\n#include <stdint.h>\n#include \"system_helpers.h\"\n\nint main(void) {\n    uint64_t h0 = cheng_ffi_handle_new_i32(40);\n    if (h0 == 0ULL) {\n        return 1;\n    }\n\n    int32_t out = 0;\n    if (cheng_ffi_handle_get_i32(h0, &out) != 0 || out != 40) {\n        return 2;\n    }\n    if (cheng_ffi_handle_add_i32(h0, 2, &out) != 0 || out != 42) {\n        return 3;\n    }\n    if (cheng_ffi_handle_release_i32(h0) != 0) {\n        return 4;\n    }\n\n    if (cheng_ffi_handle_get_i32(h0, &out) != -1) {\n        return 5;\n    }\n    if (cheng_ffi_handle_add_i32(h0, 1, &out) != -1) {\n        return 6;\n    }\n    if (cheng_ffi_handle_release_i32(h0) != -1) {\n        return 7;\n    }\n\n    uint64_t h1 = cheng_ffi_handle_new_i32(7);\n    if (h1 == 0ULL) {\n        return 8;\n    }\n    if (cheng_ffi_handl"
        out = out + "e_get_i32(h1, &out) != 0 || out != 7) {\n        return 9;\n    }\n    if (cheng_ffi_handle_get_i32(h0, &out) != -1) {\n        return 10;\n    }\n    if (cheng_ffi_handle_release_i32(h1) != 0) {\n        return 11;\n    }\n\n    return 0;\n}\nPROBE_C\n\nrm -f \"$probe_bin\" \"$probe_compile_log\" \"$probe_run_log\" \"$report\" \"$snapshot\"\n\nextra_ldflags=\"\"\ncase \"$(uname -s 2>/dev/null || echo unknown)\" in\n  Linux)\n    extra_ldflags=\"-ldl\"\n    ;;\nesac\n\nset +e\n# shellcheck disable=SC2086\n\"$cc_bin\" -std=c11 -O2 -I src/runtime/native \\\n  \"$c_runtime_file\" \\\n  \"$probe_src\" \\\n  -o \"$probe_bin\" $extra_ldflags >\"$probe_compile_log\" 2>&1\ncompile_status=\"$?\"\nset -e\nif [ \"$compile_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$probe_compile_log\" >&2 || true\n  fail \"probe compile failed (status=$compile_status)\"\nfi\n\nset +e\n\"$probe_bin\" >\"$probe_run_log\" 2>&1\nrun_status=\"$?\"\nset -e\nif [ \"$run_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$probe_run_log\" >&2 || true\n  fail \"probe run failed (status=$run_status)\"\nfi\n\n{\n  echo \"verify_backend_ffi_handle_sandbox report\"\n  echo \"cc=$cc_bin\"\n  echo \"header_file=$header_file\"\n  echo \"c_runtime_file=$c_runtime_file\"\n  echo \"backend_runtime_file=$backend_runtime_file\"\n  echo \"probe_src=$probe_src\"\n  echo \"probe_bin=$probe_bin\"\n  echo \"compile_status=$compile_status\"\n  echo \"run_status=$run_status\"\n  echo \"probe_compile_log=$probe_compile_log\"\n  echo \"pro"
        out = out + "be_run_log=$probe_run_log\"\n} >\"$report\"\n\n{\n  echo \"backend_ffi_handle_sandbox_report=$report\"\n  echo \"backend_ffi_handle_sandbox_run_status=$run_status\"\n} >\"$snapshot\"\n\necho \"verify_backend_ffi_handle_sandbox ok\"\n"
        return out
    if id == "verify_backend_ffi_outptr_tuple":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_ffi_outptr_tuple] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ndriver=\"${BACKEND_DRIVER:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)}\"\nif [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\ndriver_exec=\"$driver\"\ndriver_real_env=\"\"\nif [ -x \"src/tooling/backend_driver_exec.sh\" ]; then\n  driver_exec=\"src/tooling/backend_driver_exec.sh\"\n  driver_real_env=\"BACKEND_DRIVER_REAL=$driver\"\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\nfixture_run=\"tests/cheng/backend/fixtures/ffi_outptr_tuple_importc_pair_i32.cheng\"\nfixture_st"
        out = out + "atus_obj=\"tests/cheng/backend/fixtures/ffi_outptr_tuple_importc_status_i32_objonly.cheng\"\nfixture_fail=\"tests/cheng/backend/fixtures/compile_fail_ffi_outptr_tuple_arity_mismatch.cheng\"\nfor f in \"$fixture_run\" \"$fixture_status_obj\" \"$fixture_fail\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing fixture: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_ffi_outptr_tuple\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n\nexe_path=\"$out_dir/ffi_outptr_tuple_importc_pair_i32.$safe_target\"\nobj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.o\"\ncase \"$target\" in\n  *windows*|*msvc*)\n    exe_path=\"$exe_path.exe\"\n    obj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.obj\"\n    ;;\nesac\n\nbuild_run_log=\"$out_dir/ffi_outptr_tuple.$safe_target.build_run.log\"\nrun_log=\"$out_dir/ffi_outptr_tuple.$safe_target.run.log\"\nbuild_obj_log=\"$out_dir/ffi_outptr_tuple.$safe_target.build_obj.log\"\nbuild_fail_log=\"$out_dir/ffi_outptr_tuple.$safe_target.build_fail.log\"\nreport=\"$out_dir/backend_ffi_outptr_tuple.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_ffi_outptr_tuple.$safe_target.snapshot.env\"\n\nrm -f \"$exe_path\" \"$obj_path\" \"$build_run_log\" \"$run_log\" \"$build_obj_log\" \"$build_fail_log\" \"$report\" \"$snapshot\"\nrm -rf \"${exe_path}.objs\" \"${exe_path}.objs.lock\"\n\nset +e\nenv $link_env \\\n  $driver_real_env \\\n  BACKEND_EMIT=exe \\\n  BAC"
        out = out + "KEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_run\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver_exec\" >\"$build_run_log\" 2>&1\nbuild_run_status=\"$?\"\nset -e\nif [ \"$build_run_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$build_run_log\" >&2 || true\n  fail \"runtime fixture build failed (status=$build_run_status)\"\nfi\nif [ ! -x \"$exe_path\" ]; then\n  fail \"missing executable output: $exe_path\"\nfi\n\nset +e\n\"$exe_path\" >\"$run_log\" 2>&1\nrun_status=\"$?\"\nset -e\nrun_mode=\"host\"\nif [ \"$run_status\" -ne 0 ]; then\n  allow_run_fail=\"${BACKEND_FFI_OUTPTR_TUPLE_ALLOW_RUN_FAIL:-0}\"\n  if [ \"$allow_run_fail\" = \"1\" ] || rg -q 'Symbol not found: _cheng_memcpy' \"$run_log\"; then\n    run_mode=\"runtime_symbol_missing_skip\"\n    run_status=\"0\"\n  else\n    sed -n '1,120p' \"$run_log\" >&2 || true\n    fail \"runtime fixture run failed (status=$run_status)\"\n  fi\nfi\n\nset +e\nenv $link_env \\\n  $driver_real_env \\\n  BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_status_obj\" \\\n  BACKEND_OUTPUT=\"$obj_path\" \\\n  \"$driver_exec\" >\"$build_obj_log\" 2>&1\nbuild_obj_status=\"$?\"\nset -e\nif [ \"$build_obj_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$build_obj_log\" >&2 || true\n  fail \"status fixture obj-only build failed (status=$bui"
        out = out + "ld_obj_status)\"\nfi\nif [ ! -f \"$obj_path\" ]; then\n  fail \"missing obj output: $obj_path\"\nfi\n\nfail_out=\"$out_dir/compile_fail_ffi_outptr_tuple_arity_mismatch.$safe_target\"\nset +e\nenv $link_env \\\n  $driver_real_env \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_fail\" \\\n  BACKEND_OUTPUT=\"$fail_out\" \\\n  \"$driver_exec\" >\"$build_fail_log\" 2>&1\nbuild_fail_status=\"$?\"\nset -e\nif [ \"$build_fail_status\" -eq 0 ]; then\n  fail \"negative fixture unexpectedly compiled\"\nfi\n\ndiag_pattern='ffi_out_ptrs tuple arity mismatch'\ndiag_ok=\"0\"\nif rg -q \"$diag_pattern\" \"$build_fail_log\"; then\n  diag_ok=\"1\"\nelse\n  sed -n '1,220p' \"$build_fail_log\" >&2 || true\n  fail \"missing expected ffi_out_ptrs diagnostic in negative fixture log\"\nfi\n\n{\n  echo \"verify_backend_ffi_outptr_tuple report\"\n  echo \"target=$target\"\n  echo \"driver=$driver\"\n  echo \"driver_exec=$driver_exec\"\n  echo \"fixture_run=$fixture_run\"\n  echo \"fixture_status_obj=$fixture_status_obj\"\n  echo \"fixture_fail=$fixture_fail\"\n  echo \"build_run_status=$build_run_status\"\n  echo \"run_status=$run_status\"\n  echo \"run_mode=$run_mode\"\n  echo \"build_obj_status=$build_obj_status\"\n  echo \"build_fail_status=$build_fail_status\"\n  echo \"diag_pattern=$diag_pattern\"\n  echo \"diag_ok=$diag_ok\"\n  echo \"build_run_log=$build_run_log\"\n  echo \"run"
        out = out + "_log=$run_log\"\n  echo \"build_obj_log=$build_obj_log\"\n  echo \"build_fail_log=$build_fail_log\"\n} >\"$report\"\n\n{\n  echo \"backend_ffi_outptr_tuple_target=$target\"\n  echo \"backend_ffi_outptr_tuple_diag_ok=$diag_ok\"\n  echo \"backend_ffi_outptr_tuple_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_ffi_outptr_tuple ok\"\n"
        return out
    if id == "verify_backend_ffi_slice_shim":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_ffi_slice_shim] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ndriver=\"${BACKEND_DRIVER:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)}\"\nif [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nbackend_linker_mode=\"${BACKEND_LINKER:-system}\"\nif [ \"$backend_linker_mode\" = \"auto\" ] || [ \"$backend_linker_mode\" = \"\" ]; then\n  backend_linker_mode=\"system\"\nfi\nbackend_no_runtime_c=\"${BACKEND_NO_RUNTIME_C:-0}\"\nbackend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-}\"\nrun_positive=\"${BACKEND_FFI_SLICE_SHIM_RUN:-0}\"\n\nfixture_ok=\"tests/cheng/backend/fixtures/ffi_importc_slice_seq_i32.cheng\"\nfixture_fail_legacy=\"tests/cheng/backend/fixtures/compile_fail_ffi_imp"
        out = out + "ortc_slice_openarray_i32.cheng\"\nfixture_fail_surface=\"tests/cheng/backend/fixtures/compile_fail_ffi_slice_user_raw_ptr_surface.cheng\"\nfor f in \"$fixture_ok\" \"$fixture_fail_legacy\" \"$fixture_fail_surface\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing fixture: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_ffi_slice_shim\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nexe_path=\"$out_dir/ffi_importc_slice_seq_i32.$safe_target\"\ncase \"$target\" in\n  *windows*|*msvc*) exe_path=\"$exe_path.exe\" ;;\nesac\nbuild_ok_log=\"$out_dir/ffi_slice_shim.$safe_target.build_ok.log\"\nrun_log=\"$out_dir/ffi_slice_shim.$safe_target.run.log\"\nbuild_fail_legacy_log=\"$out_dir/ffi_slice_shim.$safe_target.build_fail_legacy.log\"\nbuild_fail_surface_log=\"$out_dir/ffi_slice_shim.$safe_target.build_fail_surface.log\"\nsurface_scan_log=\"$out_dir/ffi_slice_shim.$safe_target.surface_scan.log\"\nreport=\"$out_dir/backend_ffi_slice_shim.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_ffi_slice_shim.$safe_target.snapshot.env\"\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$build_ok_log\" \"$run_log\" \\\n  \"$build_fail_legacy_log\" \"$build_fail_surface_log\" \"$surface_scan_log\" \\\n  \"$report\" \"$snapshot\"\nrm -rf \"${exe_path}.objs\" \"${exe_path}.objs.lock\"\n\nsurface_pattern='void\\*|ptr_add\\(|load_ptr\\(|store_ptr\\('\nsurface_ok=\"1\"\nif rg -n \"$surface_pattern\" \"$fixture_ok\" >\"$surface_scan_log\"; the"
        out = out + "n\n  surface_ok=\"0\"\n  fail \"positive fixture leaks raw pointer surface (see $surface_scan_log)\"\nfi\n\nset +e\nenv \\\n  BACKEND_LINKER=\"$backend_linker_mode\" \\\n  BACKEND_NO_RUNTIME_C=\"$backend_no_runtime_c\" \\\n  BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_ok\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\" >\"$build_ok_log\" 2>&1\nbuild_ok_status=\"$?\"\nset -e\nif [ \"$build_ok_status\" -ne 0 ]; then\n  sed -n '1,200p' \"$build_ok_log\" >&2 || true\n  fail \"positive fixture build failed (status=$build_ok_status)\"\nfi\nif [ ! -x \"$exe_path\" ]; then\n  fail \"missing executable output: $exe_path\"\nfi\n\nimportc_symbol=\"cheng_abi_sum_seq_i32\"\nsymbol_check=\"skip\"\nif command -v nm >/dev/null 2>&1; then\n  symbol_check=\"0\"\n  if nm \"$exe_path\" 2>/dev/null | rg -q \"$importc_symbol\"; then\n    symbol_check=\"1\"\n  else\n    fail \"missing expected importc symbol in positive artifact: $importc_symbol\"\n  fi\nfi\n\nrun_status=\"0\"\nrun_mode=\"compile_only\"\nruntime_symbol_blocked=\"0\"\nif [ \"$run_positive\" != \"1\" ]; then\n  : >\"$run_log\"\nfi\nif [ \"$run_positive\" = \"1\" ]; then\n  set +e\n  \"$exe_path\" >\"$run_log\" 2>&1\n  run_status=\"$?\"\n  set -e\n  run_mode=\"run\"\n  if [ \"$run_status\" -ne 0 ]; then\n    if rg -q 'Symbol not found: _memRetain' \"$run_log\"; th"
        out = out + "en\n      run_mode=\"compile_only\"\n      runtime_symbol_blocked=\"1\"\n    else\n      sed -n '1,120p' \"$run_log\" >&2 || true\n      fail \"positive fixture run failed (status=$run_status)\"\n    fi\n  fi\nfi\n\nfail_legacy_out=\"$out_dir/compile_fail_ffi_importc_slice_openarray_i32.$safe_target\"\nset +e\nenv \\\n  BACKEND_LINKER=\"$backend_linker_mode\" \\\n  BACKEND_NO_RUNTIME_C=\"$backend_no_runtime_c\" \\\n  BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_fail_legacy\" \\\n  BACKEND_OUTPUT=\"$fail_legacy_out\" \\\n  \"$driver\" >\"$build_fail_legacy_log\" 2>&1\nbuild_fail_legacy_status=\"$?\"\nset -e\nif [ \"$build_fail_legacy_status\" -eq 0 ]; then\n  fail \"legacy openArray negative fixture unexpectedly compiled\"\nfi\nlegacy_diag_pattern=\"Legacy type syntax is removed; use 'T\\\\[\\\\]' instead of 'openArray\\\\[T\\\\]'\"\nlegacy_diag_ok=\"0\"\nif rg -q \"$legacy_diag_pattern\" \"$build_fail_legacy_log\"; then\n  legacy_diag_ok=\"1\"\nelse\n  sed -n '1,200p' \"$build_fail_legacy_log\" >&2 || true\n  fail \"missing expected legacy openArray diagnostic\"\nfi\n\nfail_surface_out=\"$out_dir/compile_fail_ffi_slice_user_raw_ptr_surface.$safe_target\"\nset +e\nenv \\\n  BACKEND_LINKER=\"$backend_linker_mode\" \\\n  BACKEND_NO_RUNTIME_C=\"$backend_no_runtime_c\" \\\n  BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj"
        out = out + "\" \\\n  STAGE1_NO_POINTERS_NON_C_ABI=1 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture_fail_surface\" \\\n  BACKEND_OUTPUT=\"$fail_surface_out\" \\\n  \"$driver\" >\"$build_fail_surface_log\" 2>&1\nbuild_fail_surface_status=\"$?\"\nset -e\nif [ \"$build_fail_surface_status\" -eq 0 ]; then\n  fail \"raw pointer surface negative fixture unexpectedly compiled\"\nfi\nsurface_diag_pattern='no-pointer policy: pointer (types are|dereference is|operation is) forbidden outside C ABI modules'\nsurface_diag_ok=\"0\"\nif rg -q \"$surface_diag_pattern\" \"$build_fail_surface_log\"; then\n  surface_diag_ok=\"1\"\nelse\n  sed -n '1,200p' \"$build_fail_surface_log\" >&2 || true\n  fail \"missing expected no-pointer policy diagnostic\"\nfi\n\n{\n  echo \"verify_backend_ffi_slice_shim report\"\n  echo \"target=$target\"\n  echo \"driver=$driver\"\n  echo \"fixture_ok=$fixture_ok\"\n  echo \"fixture_fail_legacy=$fixture_fail_legacy\"\n  echo \"fixture_fail_surface=$fixture_fail_surface\"\n  echo \"build_ok_status=$build_ok_status\"\n  echo \"importc_symbol=$importc_symbol\"\n  echo \"symbol_check=$symbol_check\"\n  echo \"run_status=$run_status\"\n  echo \"run_mode=$run_mode\"\n  echo \"run_positive=$run_positive\"\n  echo \"runtime_symbol_blocked=$runtime_symbol_blocked\"\n  echo \"build_fail_legacy_status=$build_fail_legacy_statu"
        out = out + "s\"\n  echo \"build_fail_surface_status=$build_fail_surface_status\"\n  echo \"surface_pattern=$surface_pattern\"\n  echo \"surface_ok=$surface_ok\"\n  echo \"legacy_diag_pattern=$legacy_diag_pattern\"\n  echo \"legacy_diag_ok=$legacy_diag_ok\"\n  echo \"surface_diag_pattern=$surface_diag_pattern\"\n  echo \"surface_diag_ok=$surface_diag_ok\"\n  echo \"build_ok_log=$build_ok_log\"\n  echo \"run_log=$run_log\"\n  echo \"build_fail_legacy_log=$build_fail_legacy_log\"\n  echo \"build_fail_surface_log=$build_fail_surface_log\"\n  echo \"surface_scan_log=$surface_scan_log\"\n} >\"$report\"\n\n{\n  echo \"backend_ffi_slice_shim_target=$target\"\n  echo \"backend_ffi_slice_shim_surface_ok=$surface_ok\"\n  echo \"backend_ffi_slice_shim_symbol_check=$symbol_check\"\n  echo \"backend_ffi_slice_shim_run_mode=$run_mode\"\n  echo \"backend_ffi_slice_shim_run_positive=$run_positive\"\n  echo \"backend_ffi_slice_shim_runtime_symbol_blocked=$runtime_symbol_blocked\"\n  echo \"backend_ffi_slice_shim_legacy_diag_ok=$legacy_diag_ok\"\n  echo \"backend_ffi_slice_shim_surface_diag_ok=$surface_diag_ok\"\n  echo \"backend_ffi_slice_shim_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_ffi_slice_shim ok\"\n"
        return out
    if id == "verify_backend_float":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\n\n# Keep float gate focused on float/runtime behavior, independent of closure no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\n\nout_dir=\"artifacts/backend_float\"\n\nmkdir -p \"$out_dir\"\n\nis_known_float_skip_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"macho_linker: duplicate symbol: ___cheng_sym_3d_3d\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Undefined symbols for architecture\" \"$log_file\" && grep -q \"L_cheng_str_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Symbol not found:\" \"$log"
        out = out + "_file\"; then\n    return 0\n  fi\n  return 1\n}\n\ncompile_fixture_compile_only() {\n  fixture=\"$1\"\n  log_prefix=\"$2\"\n  compile_only_out=\"${log_prefix}.compile_only.o\"\n  compile_only_log=\"${log_prefix}.compile_only.log\"\n  rm -f \"$compile_only_out\" \"$compile_only_log\"\n  env \\\n    BACKEND_EMIT=obj \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$compile_only_out\" \\\n    \"$driver\" >\"$compile_only_log\" 2>&1\n  [ -s \"$compile_only_out\" ]\n}\n\ncompile_and_run_fixture() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  log_prefix=\"$3\"\n  build_log=\"${log_prefix}.build.log\"\n  run_log=\"${log_prefix}.run.log\"\n\n  rm -f \"$exe_path\" \"$exe_path.o\" \"$build_log\" \"$run_log\"\n  rm -rf \"${exe_path}.objs\" \"${exe_path}.objs.lock\"\n\n  set +e\n  if [ \"$linker_mode\" = \"self\" ]; then\n    BACKEND_EMIT=exe \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_RUNTIME=off \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$build_log\" 2>&1\n  else\n    BACKEND_EMIT=exe \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=system \\\n"
        out = out + "    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$build_log\" 2>&1\n  fi\n  build_status=\"$?\"\n  set -e\n  if [ \"$build_status\" -ne 0 ]; then\n    if is_known_float_skip_log \"$build_log\"; then\n      echo \"[verify_backend_float] known link instability, fallback compile-only: $fixture\" 1>&2\n      compile_fixture_compile_only \"$fixture\" \"$log_prefix\"\n      return\n    fi\n    tail -n 200 \"$build_log\" >&2 || true\n    exit \"$build_status\"\n  fi\n\n  set +e\n  \"$exe_path\" >\"$run_log\" 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ne 0 ]; then\n    if is_known_float_skip_log \"$run_log\"; then\n      echo \"[verify_backend_float] known runtime-symbol instability, fallback compile-only: $fixture\" 1>&2\n      compile_fixture_compile_only \"$fixture\" \"$log_prefix\"\n      return\n    fi\n    cat \"$run_log\" >&2 || true\n    exit \"$run_status\"\n  fi\n}\n\nfor fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/hello_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_puts.cheng \\\n               tests/cheng/backend/fixtures/void_fn_return.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng \\\n               tests/cheng/backend/fixtures/return_for_sum.cheng \\\n               tests/cheng/backend/fixtures"
        out = out + "/return_deref.cheng \\\n               tests/cheng/backend/fixtures/return_store_deref.cheng \\\n               tests/cheng/backend/fixtures/return_float64_ops.cheng \\\n               tests/cheng/backend/fixtures/return_float32_roundtrip.cheng \\\n               tests/cheng/backend/fixtures/return_float_mixed_int_cast.cheng \\\n               tests/cheng/backend/fixtures/return_float_compare_cast.cheng \\\n               tests/cheng/backend/fixtures/return_float32_arith_chain.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/${base}\"\n  compile_and_run_fixture \"$fixture\" \"$exe_path\" \"$out_dir/${base}\"\ndone\n\necho \"verify_backend_float ok\"\n"
        return out
    if id == "verify_backend_hotpatch":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nnow_ms() {\n  if command -v perl >/dev/null 2>&1; then\n    perl -MTime::HiRes=time -e 'printf \"%.0f\\n\", time() * 1000'\n    return 0\n  fi\n  echo \"$(( $(date +%s) * 1000 ))\"\n}\n\nread_kv() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1 \":\" $2}'\n}\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nif [ \"$host_target\" = \"\" ]; then\n  host_target=\"unknown\"\nfi\n\nis_supported_target() {\n  target=\"$1\"\n  case \"$target\" in\n   "
        out = out + " *apple*darwin*|*darwin*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*riscv64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nselect_default_target() {\n  if [ \"${BACKEND_HOTPATCH_TARGET:-}\" != \"\" ]; then\n    echo \"${BACKEND_HOTPATCH_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"unknown\" ]; then\n    echo \"$host_target\"\n    return\n  fi\n  echo \"arm64-apple-darwin\"\n}\n\ntarget=\"${BACKEND_TARGET:-}\"\ntarget_explicit=\"0\"\nif [ \"$target\" = \"\" ]; then\n  target=\"$(select_default_target)\"\nelse\n  target_explicit=\"1\"\nfi\n\nout_dir=\"artifacts/backend_hotpatch\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nreport=\"$out_dir/hotpatch.$safe_target.report.txt\"\n\nif ! is_supported_target \"$target\"; then\n  if [ \"$target_explicit\" = \"1\" ]; then\n    echo \"[verify_backend_hotpatch] unsupported BACKEND_TARGET: $target\" >&2\n    exit 1\n  fi\n  {\n    echo \"verify_backend_hotpatch report\"\n    echo \"status=skip\"\n    echo \"reason=unsupported_target\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n  } >\"$report\"\n  echo \"verify_backend_hotpatch skip: unsupported target ($target)\"\n  exit 0\nfi\n\nfixture_v1=\"tests/cheng/backend/fixtures/hotpatch_s"
        out = out + "lot_v1.cheng\"\nfixture_v2=\"tests/cheng/backend/fixtures/hotpatch_slot_v2.cheng\"\nfixture_v3=\"tests/cheng/backend/fixtures/hotpatch_slot_v3_overflow.cheng\"\nfor f in \"$fixture_v1\" \"$fixture_v2\" \"$fixture_v3\"; do\n  if [ ! -f \"$f\" ]; then\n    echo \"[verify_backend_hotpatch] missing fixture: $f\" >&2\n    exit 1\n  fi\ndone\n\ncompile_fixture() {\n  fixture=\"$1\"\n  out_exe=\"$2\"\n  out_log=\"$3\"\n  preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-system}\"\n  no_runtime_c=\"1\"\n  if [ \"$preferred_linker\" = \"system\" ]; then\n    no_runtime_c=\"0\"\n  fi\n  set +e\n  env \\\n    MM=\"${MM:-orc}\" \\\n    ABI=v2_noptr \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=\"$preferred_linker\" \\\n    BACKEND_LINKER_SYMTAB=all \\\n    BACKEND_RUNTIME=off \\\n    BACKEND_NO_RUNTIME_C=\"$no_runtime_c\" \\\n    BACKEND_CODESIGN=${BACKEND_HOTPATCH_CODESIGN:-1} \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_KEEP_EXE_OBJ=0 \\\n    BACKEND_OPT=0 \\\n    BACKEND_OPT2=0 \\\n    BACKEND_OPT_LEVEL=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$out_exe\" >\"$out_log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" -ne 0 ] && [ \"$preferred_linker"
        out = out + "\" = \"self\" ]; then\n    env \\\n      MM=\"${MM:-orc}\" \\\n      ABI=v2_noptr \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LINKER=system \\\n      BACKEND_LINKER_SYMTAB=all \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_CODESIGN=${BACKEND_HOTPATCH_CODESIGN:-1} \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_INCREMENTAL=0 \\\n      BACKEND_KEEP_EXE_OBJ=0 \\\n      BACKEND_OPT=0 \\\n      BACKEND_OPT2=0 \\\n      BACKEND_OPT_LEVEL=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$out_exe\" >>\"$out_log\" 2>&1\n    status=\"$?\"\n  fi\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    echo \"[verify_backend_hotpatch] build failed: fixture=$fixture status=$status log=$out_log\" >&2\n    sed -n '1,200p' \"$out_log\" >&2 || true\n    exit 1\n  fi\n  if [ ! -s \"$out_exe\" ]; then\n    echo \"[verify_backend_hotpatch] missing output executable: $out_exe\" >&2\n    exit 1\n  fi\n}\n\nbase_exe=\"$out_dir/hotpatch_slot.base.$safe_target\"\npatch_v2=\"$out_dir/hotpatch_slot.v2.$safe_target\"\npatch_v3=\"$out_dir/hotpatch_slot.v3.$safe_target\"\npatch_v3_growth=\"$out_dir/hotpatch_slot.v3_growth.$safe_target\"\nstate_dir=\"$out_dir/runn"
        out = out + "er_state.$safe_target\"\nbuild_log_v1=\"$out_dir/hotpatch_slot.v1.build.log\"\nbuild_log_v2=\"$out_dir/hotpatch_slot.v2.build.log\"\nbuild_log_v3=\"$out_dir/hotpatch_slot.v3.build.log\"\ninit_log=\"$out_dir/hotpatch_slot.init.log\"\napply_log=\"$out_dir/hotpatch_slot.apply.log\"\ncompile_fail_log=\"$out_dir/hotpatch_slot.compile_fail.log\"\ngrowth_restart_log=\"$out_dir/hotpatch_slot.max_growth_restart.log\"\nlayout_restart_log=\"$out_dir/hotpatch_slot.layout_restart.log\"\nrun_v1_log=\"$out_dir/hotpatch_slot.run.v1.log\"\nrun_v2_log=\"$out_dir/hotpatch_slot.run.v2.log\"\nrun_v3_log=\"$out_dir/hotpatch_slot.run.v3.log\"\nrun_after_fail_log=\"$out_dir/hotpatch_slot.run.after_fail.log\"\nrun_after_layout_restart_log=\"$out_dir/hotpatch_slot.run.after_layout_restart.log\"\n\nrm -f \\\n  \"$base_exe\" \"$patch_v2\" \"$patch_v3\" \"$patch_v3_growth\" \\\n  \"$base_exe.o\" \"$patch_v2.o\" \"$patch_v3.o\" \"$patch_v3_growth.o\" \\\n  \"$build_log_v1\" \"$build_log_v2\" \"$build_log_v3\" \\\n  \"$init_log\" \"$apply_log\" \"$compile_fail_log\" \"$growth_restart_log\" \"$layout_restart_log\" \\\n  \"$run_v1_log\" \"$run_v2_log\" \"$run_v3_log\" \"$run_after_fail_log\" \"$run_after_layout_restart_log\" \\\n  \"$report\"\nrm -rf \"$state_dir\"\n\ncompile_fixture \"$fixture_v1\" \"$base_exe\" \"$build_log_v1\"\ncompile_fixture \"$fixture_v2\" \"$patch_v2\" \"$build_log_v2\"\ncompile_fixture \"$fixture_v3\" \"$patch_v3\" \"$build_log_v3\"\ncp \"$patch_v3\" \"$patch_v3_growth\"\ndd if=/dev"
        out = out + "/zero bs=4096 count=1 >>\"$patch_v3_growth\" 2>/dev/null || true\n\nlayout_hash_same=\"$(hash_file \"$fixture_v1\")\"\nlayout_hash_changed=\"$(hash_file \"$fixture_v3\")\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner init \\\n  --state:\"$state_dir\" \\\n  --base:\"$base_exe\" \\\n  --layout-hash:\"$layout_hash_same\" \\\n  --pool-mb:\"${BACKEND_HOSTRUNNER_POOL_MB:-512}\" >\"$init_log\"\nhost_pid_init=\"$(read_kv host_pid \"$init_log\")\"\nif [ \"$host_pid_init\" = \"\" ]; then\n  echo \"[verify_backend_hotpatch] failed to resolve host_pid from init log\" >&2\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run --state:\"$state_dir\" >\"$run_v1_log\" 2>&1\nrun_v1_status=\"$?\"\nset -e\nif [ \"$run_v1_status\" -ne 11 ]; then\n  echo \"[verify_backend_hotpatch] expected v1 run exit=11, got $run_v1_status\" >&2\n  sed -n '1,120p' \"$run_v1_log\" >&2 || true\n  exit 1\nfi\n\napply_start_ms=\"$(now_ms)\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_hotpatch_apply \\\n  --base:\"$base_exe\" \\\n  --patch:\"$patch_v2\" \\\n  --symbol:hotpatch_target \\\n  --state:\"$state_dir\" \\\n  --layout-hash:\"$layout_hash_same\" >\"$apply_log\" 2>&1\napply_end_ms=\"$(now_ms)\"\napply_ms=$((apply_end_ms - apply_start_ms))\napply_commit_kind=\"$(read_kv commit_kind \"$apply_log\")\"\nif [ \"$apply_commit_kind\" != \"append\" ]; then\n  echo \"[verify_backend_hotpatch] expected append com"
        out = out + "mit for v2 patch, got: $apply_commit_kind\" >&2\n  sed -n '1,120p' \"$apply_log\" >&2 || true\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run --state:\"$state_dir\" >\"$run_v2_log\" 2>&1\nrun_v2_status=\"$?\"\nset -e\nif [ \"$run_v2_status\" -ne 22 ]; then\n  echo \"[verify_backend_hotpatch] expected v2 run exit=22, got $run_v2_status\" >&2\n  sed -n '1,120p' \"$run_v2_log\" >&2 || true\n  exit 1\nfi\n\nhost_pid_after_append=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner status --state:\"$state_dir\" | awk -F= '$1==\"host_pid\"{print $2; exit}')\"\nif [ \"$host_pid_after_append\" != \"$host_pid_init\" ]; then\n  echo \"[verify_backend_hotpatch] host pid drift after append commit: init=$host_pid_init current=$host_pid_after_append\" >&2\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_hotpatch_apply \\\n  --base:\"$base_exe\" \\\n  --patch:\"$out_dir/missing.patch.$safe_target\" \\\n  --symbol:hotpatch_target \\\n  --state:\"$state_dir\" \\\n  --layout-hash:\"$layout_hash_same\" >\"$compile_fail_log\" 2>&1\ncompile_fail_status=\"$?\"\nset -e\nif [ \"$compile_fail_status\" -eq 0 ]; then\n  echo \"[verify_backend_hotpatch] expected missing patch commit to fail\" >&2\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run --state:\"$state_dir\" >\"$run_after_fail_log\" 2>&1\nrun_after_fail_status=\"$"
        out = out + "?\"\nset -e\nif [ \"$run_after_fail_status\" -ne 22 ]; then\n  echo \"[verify_backend_hotpatch] compile failure should keep old runnable version (expected 22, got $run_after_fail_status)\" >&2\n  sed -n '1,120p' \"$run_after_fail_log\" >&2 || true\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_hotpatch_apply \\\n  --base:\"$base_exe\" \\\n  --patch:\"$patch_v3_growth\" \\\n  --symbol:hotpatch_target \\\n  --state:\"$state_dir\" \\\n  --layout-hash:\"$layout_hash_same\" \\\n  --max-growth:0 >\"$growth_restart_log\" 2>&1\ngrowth_restart_status=\"$?\"\nset -e\nif [ \"$growth_restart_status\" -ne 0 ]; then\n  echo \"[verify_backend_hotpatch] max-growth restart commit failed unexpectedly\" >&2\n  sed -n '1,160p' \"$growth_restart_log\" >&2 || true\n  exit 1\nfi\ngrowth_commit_kind=\"$(read_kv commit_kind \"$growth_restart_log\")\"\ncase \"$growth_commit_kind\" in\n  restart_*) ;;\n  *)\n    echo \"[verify_backend_hotpatch] expected max-growth path to restart, got commit_kind=$growth_commit_kind\" >&2\n    exit 1\n    ;;\nesac\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run --state:\"$state_dir\" >\"$run_v3_log\" 2>&1\nrun_v3_status=\"$?\"\nset -e\nif [ \"$run_v3_status\" -ne 33 ]; then\n  echo \"[verify_backend_hotpatch] expected v3 run exit=33 after max-growth restart, got $run_v3_status\" >&2\n  sed -n '1,120p' \"$run_v3_log\" >&2 || true\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/"
        out = out + "tooling_cmd/cheng_tooling} backend_hotpatch_apply \\\n  --base:\"$base_exe\" \\\n  --patch:\"$patch_v2\" \\\n  --symbol:hotpatch_target \\\n  --state:\"$state_dir\" \\\n  --layout-hash:\"$layout_hash_changed\" >\"$layout_restart_log\" 2>&1\nlayout_restart_status=\"$?\"\nset -e\nif [ \"$layout_restart_status\" -ne 0 ]; then\n  echo \"[verify_backend_hotpatch] layout-change restart commit failed unexpectedly\" >&2\n  sed -n '1,160p' \"$layout_restart_log\" >&2 || true\n  exit 1\nfi\nlayout_commit_kind=\"$(read_kv commit_kind \"$layout_restart_log\")\"\nif [ \"$layout_commit_kind\" != \"restart_layout_change\" ]; then\n  echo \"[verify_backend_hotpatch] expected layout restart commit_kind=restart_layout_change, got $layout_commit_kind\" >&2\n  exit 1\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner run --state:\"$state_dir\" >\"$run_after_layout_restart_log\" 2>&1\nrun_after_layout_restart_status=\"$?\"\nset -e\nif [ \"$run_after_layout_restart_status\" -ne 22 ]; then\n  echo \"[verify_backend_hotpatch] expected run exit=22 after layout-change restart, got $run_after_layout_restart_status\" >&2\n  sed -n '1,120p' \"$run_after_layout_restart_log\" >&2 || true\n  exit 1\nfi\n\nstatus_log=\"$out_dir/hotpatch_slot.status.log\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_host_runner status --state:\"$state_dir\" >\"$status_log\"\nhost_pid_final=\"$(read_kv host_pid \"$status_log\")\"\nrestart_count=\"$(read_kv restart_c"
        out = out + "ount \"$status_log\")\"\ncommit_epoch=\"$(read_kv commit_epoch \"$status_log\")\"\npool_used_bytes=\"$(read_kv pool_used_bytes \"$status_log\")\"\npool_limit_bytes=\"$(read_kv pool_limit_bytes \"$status_log\")\"\n\nif [ \"$host_pid_final\" != \"$host_pid_init\" ]; then\n  echo \"[verify_backend_hotpatch] host pid drift detected: init=$host_pid_init final=$host_pid_final\" >&2\n  exit 1\nfi\n\nmax_ms=\"${BACKEND_HOTPATCH_MAX_MS:-2000}\"\ncase \"$max_ms\" in\n  ''|*[!0-9]*)\n    max_ms=\"2000\"\n    ;;\nesac\nif [ \"$apply_ms\" -gt \"$max_ms\" ]; then\n  echo \"[verify_backend_hotpatch] patch latency exceeded threshold: apply_ms=$apply_ms threshold_ms=$max_ms\" >&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_hotpatch report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"fixture_v1=$fixture_v1\"\n  echo \"fixture_v2=$fixture_v2\"\n  echo \"fixture_v3=$fixture_v3\"\n  echo \"base_exe=$base_exe\"\n  echo \"patch_v2=$patch_v2\"\n  echo \"patch_v3=$patch_v3\"\n  echo \"patch_v3_growth=$patch_v3_growth\"\n  echo \"state_dir=$state_dir\"\n  echo \"host_pid=$host_pid_init\"\n  echo \"host_pid_final=$host_pid_final\"\n  echo \"append_commit_kind=$apply_commit_kind\"\n  echo \"growth_restart_commit_kind=$growth_commit_kind\"\n  echo \"layout_restart_commit_kind=$layout_commit_kind\"\n  echo \"apply_ms=$apply_ms\"\n  echo \"max_ms=$max_ms\"\n  echo \"run_v1_status=$run_v1_status\"\n  echo \"run_v2_status=$run_v2_status\"\n  echo \"run_v3_"
        out = out + "status=$run_v3_status\"\n  echo \"run_after_fail_status=$run_after_fail_status\"\n  echo \"run_after_layout_restart_status=$run_after_layout_restart_status\"\n  echo \"compile_fail_status=$compile_fail_status\"\n  echo \"growth_restart_status=$growth_restart_status\"\n  echo \"layout_restart_status=$layout_restart_status\"\n  echo \"rollback_status=$compile_fail_status\"\n  echo \"overflow_status=$growth_restart_status\"\n  echo \"restart_count=$restart_count\"\n  echo \"commit_epoch=$commit_epoch\"\n  echo \"pool_used_bytes=$pool_used_bytes\"\n  echo \"pool_limit_bytes=$pool_limit_bytes\"\n  echo \"layout_hash_same=$layout_hash_same\"\n  echo \"layout_hash_changed=$layout_hash_changed\"\n  echo \"build_log_v1=$build_log_v1\"\n  echo \"build_log_v2=$build_log_v2\"\n  echo \"build_log_v3=$build_log_v3\"\n  echo \"init_log=$init_log\"\n  echo \"apply_log=$apply_log\"\n  echo \"compile_fail_log=$compile_fail_log\"\n  echo \"growth_restart_log=$growth_restart_log\"\n  echo \"layout_restart_log=$layout_restart_log\"\n  echo \"status_log=$status_log\"\n} >\"$report\"\n\necho \"verify_backend_hotpatch ok\"\n"
        return out
    if id == "verify_backend_hotpatch_inplace":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_hotpatch_inplace] $1\" >&2\n  exit 1\n}\n\ncount_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  matches=\"$(rg -n --no-messages -e \"$pattern\" \"$file\" || true)\"\n  if [ \"$matches\" = \"\" ]; then\n    echo \"0\"\n    return\n  fi\n  printf '%s\\n' \"$matches\" | wc -l | tr -d ' '\n}\n\nread_report_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nif [ \"$host_target\" = \"\" ]; then\n  host_target=\"unknown\"\nfi\n\nselect_target() {\n  if [ \"${BACKEND_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_TARGET}\"\n    return\n  fi\n  if [ \"${BACKEND_HOTPATCH_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_HOTPATCH"
        out = out + "_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"unknown\" ]; then\n    printf '%s\\n' \"$host_target\"\n    return\n  fi\n  printf '%s\\n' \"arm64-apple-darwin\"\n}\n\ntarget=\"$(select_target)\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n\nout_dir=\"artifacts/backend_hotpatch_inplace\"\nmkdir -p \"$out_dir\"\ninner_log=\"$out_dir/hotpatch_inplace.$safe_target.inner.log\"\nreport=\"$out_dir/backend_hotpatch_inplace.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_hotpatch_inplace.$safe_target.snapshot.env\"\n\nrm -f \"$inner_log\" \"$report\" \"$snapshot\"\n\nrunner_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\napply_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nif [ ! -f \"$runner_file\" ]; then\n  fail \"missing host runner script: $runner_file\"\nfi\nif [ ! -f \"$apply_file\" ]; then\n  fail \"missing apply script: $apply_file\"\nfi\n\nmarker_append=\"$(count_marker \"$runner_file\" 'commit_kind')\"\nmarker_restart_layout=\"$(count_marker \"$runner_file\" 'layout_change')\"\nmarker_restart_pool=\"$(count_marker \"$runner_file\" 'pool_exhausted')\"\nmarker_backup_meta=\"$(count_marker \"$runner_file\" 'meta.env.bak')\"\nmarker_backup_pool=\"$(count_marker \"$runner_file\" 'code_pool.bin.bak')\"\nmarker_backup_exec=\"$(count_marker \"$runner_file\" 'current.exe.bak')\"\nmarker_apply_delegate=\"$(count_marker \"$apply_file\" 'commit_args=')\"\nmarker_append_total=$((marker_append + marker_restar"
        out = out + "t_layout + marker_restart_pool))\nmarker_tx_total=$((marker_backup_meta + marker_backup_pool + marker_backup_exec + marker_apply_delegate))\n\nif [ \"$marker_append_total\" -lt 3 ]; then\n  fail \"missing append/restart transaction markers in $runner_file\"\nfi\nif [ \"$marker_tx_total\" -lt 4 ]; then\n  fail \"missing rollback safety markers in runner/apply scripts\"\nfi\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch >\"$inner_log\" 2>&1\ninner_status=\"$?\"\nset -e\nif [ \"$inner_status\" -ne 0 ]; then\n  echo \"[verify_backend_hotpatch_inplace] underlying hotpatch gate failed (status=$inner_status): $inner_log\" >&2\n  sed -n '1,200p' \"$inner_log\" >&2 || true\n  exit 1\nfi\n\ninner_report=\"artifacts/backend_hotpatch/hotpatch.$safe_target.report.txt\"\nif [ ! -f \"$inner_report\" ]; then\n  fail \"missing underlying report: $inner_report\"\nfi\n\nstatus=\"$(read_report_value \"status\" \"$inner_report\")\"\nappend_commit_kind=\"$(read_report_value \"append_commit_kind\" \"$inner_report\")\"\ngrowth_commit_kind=\"$(read_report_value \"growth_restart_commit_kind\" \"$inner_report\")\"\nlayout_commit_kind=\"$(read_report_value \"layout_restart_commit_kind\" \"$inner_report\")\"\ncompile_fail_status=\"$(read_report_value \"compile_fail_status\" \"$inner_report\")\"\napply_ms=\"$(read_report_value \"apply_ms\" \"$inner_report\")\"\nhost_pid=\"$(read_report_value \"host_pid\" \"$inner_report\")\"\nhost_pid_final=\"$(read_report_valu"
        out = out + "e \"host_pid_final\" \"$inner_report\")\"\n\nif [ \"$status\" = \"\" ]; then\n  fail \"underlying report missing status field: $inner_report\"\nfi\nif [ \"$status\" = \"ok\" ]; then\n  if [ \"$append_commit_kind\" != \"append\" ]; then\n    fail \"append commit kind mismatch: $append_commit_kind\"\n  fi\n  case \"$growth_commit_kind\" in\n    restart_*) ;;\n    *) fail \"growth path must restart, got: $growth_commit_kind\" ;;\n  esac\n  if [ \"$layout_commit_kind\" != \"restart_layout_change\" ]; then\n    fail \"layout-change path must restart_layout_change, got: $layout_commit_kind\"\n  fi\n  if [ \"$compile_fail_status\" = \"0\" ]; then\n    fail \"compile failure path did not fail\"\n  fi\n  if [ \"$host_pid\" = \"\" ] || [ \"$host_pid_final\" = \"\" ] || [ \"$host_pid\" != \"$host_pid_final\" ]; then\n    fail \"host pid drift detected: host_pid=$host_pid host_pid_final=$host_pid_final\"\n  fi\nfi\n\n{\n  echo \"verify_backend_hotpatch_inplace report\"\n  echo \"status=$status\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"inner_gate=${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch\"\n  echo \"inner_status=$inner_status\"\n  echo \"inner_report=$inner_report\"\n  echo \"inner_log=$inner_log\"\n  echo \"apply_ms=$apply_ms\"\n  echo \"append_commit_kind=$append_commit_kind\"\n  echo \"growth_restart_commit_kind=$growth_commit_kind\"\n  echo \"layout_restart_commit_kind=$layout_commit_kind\"\n  echo \"compile_fail"
        out = out + "_status=$compile_fail_status\"\n  echo \"host_pid=$host_pid\"\n  echo \"host_pid_final=$host_pid_final\"\n  echo \"marker_append=$marker_append\"\n  echo \"marker_restart_layout=$marker_restart_layout\"\n  echo \"marker_restart_pool=$marker_restart_pool\"\n  echo \"marker_backup_meta=$marker_backup_meta\"\n  echo \"marker_backup_pool=$marker_backup_pool\"\n  echo \"marker_backup_exec=$marker_backup_exec\"\n  echo \"marker_apply_delegate=$marker_apply_delegate\"\n  echo \"marker_append_total=$marker_append_total\"\n  echo \"marker_tx_total=$marker_tx_total\"\n} >\"$report\"\n\n{\n  echo \"backend_hotpatch_inplace_status=$status\"\n  echo \"backend_hotpatch_inplace_target=$target\"\n  echo \"backend_hotpatch_inplace_report=$report\"\n  echo \"backend_hotpatch_inplace_marker_append_total=$marker_append_total\"\n  echo \"backend_hotpatch_inplace_marker_tx_total=$marker_tx_total\"\n  echo \"backend_hotpatch_inplace_host_pid=$host_pid\"\n  echo \"backend_hotpatch_inplace_host_pid_final=$host_pid_final\"\n} >\"$snapshot\"\n\nif [ \"$status\" = \"skip\" ]; then\n  echo \"verify_backend_hotpatch_inplace skip: target=$target\"\n  exit 2\nfi\n\nif [ \"$status\" != \"ok\" ]; then\n  fail \"underlying hotpatch gate status=$status (see $inner_report)\"\nfi\n\necho \"verify_backend_hotpatch_inplace ok\"\n"
        return out
    if id == "verify_backend_hotpatch_meta":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1 \":\" $2}'\n}\n\nhash_text() {\n  text=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    printf '%s' \"$text\" | shasum -a 256 | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    printf '%s' \"$text\" | sha256sum | awk '{print $1}'\n    return\n  fi\n  printf '%s' \"$text\" | cksum | awk '{print $1}'\n}\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nhex_to_dec() {\n  raw=\"$1\"\n  raw=\"${raw#0x}\"\n  raw=\"${raw#0X}\"\n  echo $((16#$raw))\n}\n\ndetect_format() {\n  file_path=\"$1\"\n  if command -v otool >/dev/null 2>&1 && otool -h \"$file_path\" >/dev/null 2>&1; then\n    echo \"ma"
        out = out + "cho\"\n    return 0\n  fi\n  if command -v readelf >/dev/null 2>&1 && readelf -h \"$file_path\" >/dev/null 2>&1; then\n    echo \"elf\"\n    return 0\n  fi\n  echo \"unknown\"\n  return 1\n}\n\nread_text_layout() {\n  file_path=\"$1\"\n  fmt=\"$2\"\n  if [ \"$fmt\" = \"macho\" ]; then\n    info=\"$(otool -l \"$file_path\" | awk '\n      $1==\"sectname\" && $2==\"__text\" { in_text=1; next }\n      in_text && $1==\"addr\" && addr==\"\" { addr=$2; next }\n      in_text && $1==\"size\" && size==\"\" { size=$2; next }\n      in_text && $1==\"offset\" && off==\"\" { off=$2; print addr, off, size; exit }\n    ')\"\n    if [ \"$info\" = \"\" ]; then\n      return 1\n    fi\n    addr_hex=\"$(echo \"$info\" | awk '{print $1}')\"\n    off_dec=\"$(echo \"$info\" | awk '{print $2}')\"\n    size_hex=\"$(echo \"$info\" | awk '{print $3}')\"\n    printf '%s %s %s\\n' \"$(hex_to_dec \"$addr_hex\")\" \"$off_dec\" \"$(hex_to_dec \"$size_hex\")\"\n    return 0\n  fi\n  if [ \"$fmt\" = \"elf\" ]; then\n    info=\"$(readelf -W -S \"$file_path\" | awk '\n      $0 ~ /] \\.text[[:space:]]/ { print $4, $5, $6; exit }\n    ')\"\n    if [ \"$info\" = \"\" ]; then\n      return 1\n    fi\n    addr_hex=\"$(echo \"$info\" | awk '{print $1}')\"\n    off_hex=\"$(echo \"$info\" | awk '{print $2}')\"\n    size_hex=\"$(echo \"$info\" | awk '{print $3}')\"\n    printf '%s %s %s\\n' \"$(hex_to_dec \"$addr_hex\")\" \"$(hex_to_dec \"$off_hex\")\" \"$(hex_to_dec \"$size_hex\")\"\n    return 0\n  fi\n  return 1\n}\n"
        out = out + "\nread_window_fingerprint() {\n  file_path=\"$1\"\n  file_off=\"$2\"\n  size_bytes=\"$3\"\n  if ! is_uint \"$file_off\" || ! is_uint \"$size_bytes\"; then\n    return 1\n  fi\n  if [ \"$size_bytes\" -le 0 ]; then\n    return 1\n  fi\n  tmp=\"$(mktemp \"${TMPDIR:-/tmp}/cheng-hotpatch-meta-bytes.XXXXXX\")\"\n  dd if=\"$file_path\" of=\"$tmp\" bs=1 skip=\"$file_off\" count=\"$size_bytes\" 2>/dev/null\n  fp=\"$(hash_file \"$tmp\")\"\n  rm -f \"$tmp\"\n  printf '%s\\n' \"$fp\"\n}\n\nresolve_symbol_row() {\n  map_file=\"$1\"\n  symbol=\"$2\"\n  row=\"$(awk -F'\\t' -v sym=\"$symbol\" '\n    NR == 1 { next }\n    {\n      raw = $1\n      norm = raw\n      while (substr(norm, 1, 1) == \"_\") norm = substr(norm, 2)\n      req = sym\n      while (substr(req, 1, 1) == \"_\") req = substr(req, 2)\n      if (raw == sym || norm == req) {\n        print $0\n        exit\n      }\n    }\n  ' \"$map_file\")\"\n  printf '%s\\n' \"$row\"\n}\n\nbuild_thunk_map() {\n  exe=\"$1\"\n  abi=\"$2\"\n  out=\"$3\"\n  fmt=\"$(detect_format \"$exe\" || true)\"\n  if [ \"$fmt\" = \"\" ] || [ \"$fmt\" = \"unknown\" ]; then\n    echo \"[verify_backend_hotpatch_meta] unsupported binary format: $exe\" >&2\n    return 1\n  fi\n  text_layout=\"$(read_text_layout \"$exe\" \"$fmt\" || true)\"\n  if [ \"$text_layout\" = \"\" ]; then\n    echo \"[verify_backend_hotpatch_meta] failed to resolve .text layout: $exe\" >&2\n    return 1\n  fi\n  text_vaddr=\"$(echo \"$text_layout\" | awk '{print $1}')\"\n  text_fileoff=\"$"
        out = out + "(echo \"$text_layout\" | awk '{print $2}')\"\n  text_size=\"$(echo \"$text_layout\" | awk '{print $3}')\"\n  text_end=$((text_vaddr + text_size))\n\n  raw_syms=\"$(mktemp \"${TMPDIR:-/tmp}/cheng-hotpatch-syms.XXXXXX\")\"\n  spans=\"$(mktemp \"${TMPDIR:-/tmp}/cheng-hotpatch-spans.XXXXXX\")\"\n  cleanup_map() {\n    rm -f \"$raw_syms\" \"$spans\"\n  }\n\n  nm -n \"$exe\" 2>/dev/null | awk '\n    /^[0-9A-Fa-f]+ [A-Za-z] / {\n      if ($2 == \"T\" || $2 == \"t\") {\n        print $1 \"\\t\" $3\n      }\n    }\n  ' >\"$raw_syms\"\n  if [ ! -s \"$raw_syms\" ]; then\n    echo \"[verify_backend_hotpatch_meta] no text symbols found: $exe\" >&2\n    return 1\n  fi\n\n  awk -F'\\t' '\n    {\n      if (NR > 1) {\n        print prev_addr \"\\t\" prev_sym \"\\t\" $1\n      }\n      prev_addr = $1\n      prev_sym = $2\n      count = NR\n    }\n    END {\n      if (count > 0) {\n        print prev_addr \"\\t\" prev_sym \"\\t-\"\n      }\n    }\n  ' \"$raw_syms\" >\"$spans\"\n\n  {\n    echo \"symbol\tthunk_id\ttarget_slot_fileoff_or_memoff\tcode_pool_offset\tsize\tformat\tfingerprint\tabi\"\n  } >\"$out\"\n\n  idx=0\n  while IFS=\"$(printf '\\t')\" read -r start_hex sym next_hex; do\n    start_dec=\"$(hex_to_dec \"$start_hex\")\"\n    if [ \"$next_hex\" = \"-\" ]; then\n      next_dec=\"$text_end\"\n    else\n      next_dec=\"$(hex_to_dec \"$next_hex\")\"\n    fi\n    if [ \"$next_dec\" -le \"$start_dec\" ]; then\n      continue\n    fi\n    rel_off=$((start_dec - text_vaddr))\n    if [ \"$r"
        out = out + "el_off\" -lt 0 ]; then\n      continue\n    fi\n    file_off=$((text_fileoff + rel_off))\n    size_bytes=$((next_dec - start_dec))\n    fp=\"$(read_window_fingerprint \"$exe\" \"$file_off\" \"$size_bytes\" || true)\"\n    if [ \"$fp\" = \"\" ]; then\n      fp=\"-\"\n    fi\n    printf '%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n' \\\n      \"$sym\" \"$idx\" \"$file_off\" \"0\" \"$size_bytes\" \"$fmt\" \"$fp\" \"$abi\" >>\"$out\"\n    idx=$((idx + 1))\n  done <\"$spans\"\n  cleanup_map\n}\n\ncompute_meta_hash() {\n  thunk_id=\"$1\"\n  target_slot=\"$2\"\n  code_pool_offset=\"$3\"\n  layout_hash=\"$4\"\n  commit_epoch=\"$5\"\n  abi=\"$6\"\n  symbol=\"$7\"\n  canon=\"patch_meta.thunk_id=$thunk_id\npatch_meta.target_slot_fileoff_or_memoff=$target_slot\npatch_meta.code_pool_offset=$code_pool_offset\npatch_meta.layout_hash=$layout_hash\npatch_meta.commit_epoch=$commit_epoch\npatch_meta.abi=$abi\npatch_meta.symbol=$symbol\"\n  hash_text \"$canon\"\n}\n\nwrite_patch_meta() {\n  out_file=\"$1\"\n  thunk_id=\"$2\"\n  target_slot=\"$3\"\n  code_pool_offset=\"$4\"\n  layout_hash=\"$5\"\n  commit_epoch=\"$6\"\n  abi=\"$7\"\n  symbol=\"$8\"\n  meta_hash=\"$(compute_meta_hash \"$thunk_id\" \"$target_slot\" \"$code_pool_offset\" \"$layout_hash\" \"$commit_epoch\" \"$abi\" \"$symbol\")\"\n  cat >\"$out_file\" <<EOF\npatch_meta.schema.version=2\npatch_meta.thunk_id=$thunk_id\npatch_meta.target_slot_fileoff_or_memoff=$target_slot\npatch_meta.code_pool_offset=$code_pool_offset\npatch_meta.layout_ha"
        out = out + "sh=$layout_hash\npatch_meta.commit_epoch=$commit_epoch\npatch_meta.abi=$abi\npatch_meta.symbol=$symbol\npatch_meta.hash=$meta_hash\nEOF\n}\n\nread_meta_value() {\n  key=\"$1\"\n  file_path=\"$2\"\n  awk -F= -v key=\"$key\" '\n    $1 == key {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      exit\n    }\n  ' \"$file_path\"\n}\n\nprecheck_meta() {\n  meta_file=\"$1\"\n  expected_abi=\"$2\"\n  expected_symbol=\"$3\"\n  expected_layout_hash=\"$4\"\n\n  if [ ! -f \"$meta_file\" ]; then\n    echo \"[verify_backend_hotpatch_meta] missing metadata file: $meta_file\" >&2\n    return 1\n  fi\n  schema=\"$(read_meta_value patch_meta.schema.version \"$meta_file\")\"\n  thunk_id=\"$(read_meta_value patch_meta.thunk_id \"$meta_file\")\"\n  target_slot=\"$(read_meta_value patch_meta.target_slot_fileoff_or_memoff \"$meta_file\")\"\n  code_pool_offset=\"$(read_meta_value patch_meta.code_pool_offset \"$meta_file\")\"\n  layout_hash=\"$(read_meta_value patch_meta.layout_hash \"$meta_file\")\"\n  commit_epoch=\"$(read_meta_value patch_meta.commit_epoch \"$meta_file\")\"\n  abi=\"$(read_meta_value patch_meta.abi \"$meta_file\")\"\n  symbol=\"$(read_meta_value patch_meta.symbol \"$meta_file\")\"\n  meta_hash=\"$(read_meta_value patch_meta.hash \"$meta_file\")\"\n\n  if [ \"$schema\" != \"2\" ]; then\n    echo \"[verify_backend_hotpatch_meta] invalid schema version: $schema\" >&2\n    return 1\n  fi\n  for n in \"$thunk_id\" \"$target_slot\" \"$code_pool_offset\" \"$commit_epoch\"; do\n    if "
        out = out + "! is_uint \"$n\"; then\n      echo \"[verify_backend_hotpatch_meta] non-numeric field in patch meta\" >&2\n      return 1\n    fi\n  done\n  if [ \"$abi\" != \"$expected_abi\" ]; then\n    echo \"[verify_backend_hotpatch_meta] abi mismatch: expected=$expected_abi got=$abi\" >&2\n    return 1\n  fi\n  if [ \"$symbol\" != \"$expected_symbol\" ]; then\n    echo \"[verify_backend_hotpatch_meta] symbol mismatch: expected=$expected_symbol got=$symbol\" >&2\n    return 1\n  fi\n  if [ \"$layout_hash\" != \"$expected_layout_hash\" ]; then\n    echo \"[verify_backend_hotpatch_meta] layout hash mismatch: expected=$expected_layout_hash got=$layout_hash\" >&2\n    return 1\n  fi\n  expected_hash=\"$(compute_meta_hash \"$thunk_id\" \"$target_slot\" \"$code_pool_offset\" \"$layout_hash\" \"$commit_epoch\" \"$abi\" \"$symbol\")\"\n  if [ \"$expected_hash\" != \"$meta_hash\" ]; then\n    echo \"[verify_backend_hotpatch_meta] patch meta hash mismatch\" >&2\n    return 1\n  fi\n  return 0\n}\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nif [ \"$host_target\" = \"\" ]; then\n  host_target=\"unknown\"\nfi\n\nis_supported_target() {\n  target=\"$1\"\n  case \"$target\" in\n    *apple*darwin*|*darwin*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*riscv64*) return 0 ;;\n   "
        out = out + "   esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nselect_default_target() {\n  if [ \"${BACKEND_HOTPATCH_TARGET:-}\" != \"\" ]; then\n    echo \"${BACKEND_HOTPATCH_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"unknown\" ]; then\n    echo \"$host_target\"\n    return\n  fi\n  echo \"arm64-apple-darwin\"\n}\n\ntarget=\"${BACKEND_TARGET:-}\"\ntarget_explicit=\"0\"\nif [ \"$target\" = \"\" ]; then\n  target=\"$(select_default_target)\"\nelse\n  target_explicit=\"1\"\nfi\n\nout_dir=\"artifacts/backend_hotpatch_meta\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nreport=\"$out_dir/backend_hotpatch_meta.$safe_target.report.txt\"\n\nif ! is_supported_target \"$target\"; then\n  if [ \"$target_explicit\" = \"1\" ]; then\n    echo \"[verify_backend_hotpatch_meta] unsupported BACKEND_TARGET: $target\" >&2\n    exit 1\n  fi\n  {\n    echo \"verify_backend_hotpatch_meta report\"\n    echo \"status=skip\"\n    echo \"reason=unsupported_target\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n  } >\"$report\"\n  echo \"verify_backend_hotpatch_meta skip: unsupported target ($target)\"\n  exit 0\nfi\n\nif ! command -v nm >/dev/null 2>&1; then\n  echo \"[verify_backend_hotpatch_meta] nm is required\" >&2\n  exit 2\nfi\n\nfixture_v1=\"tests/cheng/backend/fixtures/hotpatch_slot_v1.cheng\"\nfixture_v2=\"tests/cheng/backend/fixtures/hotpatch_slot_v2.cheng\"\nfor f in \"$fixture_v1\" \"$fixture_v"
        out = out + "2\"; do\n  if [ ! -f \"$f\" ]; then\n    echo \"[verify_backend_hotpatch_meta] missing fixture: $f\" >&2\n    exit 1\n  fi\ndone\n\ncompile_fixture() {\n  fixture=\"$1\"\n  out_exe=\"$2\"\n  out_log=\"$3\"\n  preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-self}\"\n  no_runtime_c=\"1\"\n  if [ \"$preferred_linker\" = \"system\" ]; then\n    no_runtime_c=\"0\"\n  fi\n\n  set +e\n  env \\\n    MM=\"${MM:-orc}\" \\\n    ABI=v2_noptr \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=\"$preferred_linker\" \\\n    BACKEND_LINKER_SYMTAB=all \\\n    BACKEND_RUNTIME=off \\\n    BACKEND_NO_RUNTIME_C=\"$no_runtime_c\" \\\n    BACKEND_CODESIGN=0 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_KEEP_EXE_OBJ=0 \\\n    BACKEND_OPT=0 \\\n    BACKEND_OPT2=0 \\\n    BACKEND_OPT_LEVEL=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$out_exe\" >\"$out_log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" -ne 0 ] && [ \"$preferred_linker\" = \"self\" ]; then\n    env \\\n      MM=\"${MM:-orc}\" \\\n      ABI=v2_noptr \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LINKER=system \\\n      BACKEND_LINKER_SYMTAB=all \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_R"
        out = out + "UNTIME_C=0 \\\n      BACKEND_CODESIGN=0 \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_INCREMENTAL=0 \\\n      BACKEND_KEEP_EXE_OBJ=0 \\\n      BACKEND_OPT=0 \\\n      BACKEND_OPT2=0 \\\n      BACKEND_OPT_LEVEL=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$out_exe\" >>\"$out_log\" 2>&1\n    status=\"$?\"\n  fi\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    echo \"[verify_backend_hotpatch_meta] build failed: fixture=$fixture status=$status log=$out_log\" >&2\n    sed -n '1,200p' \"$out_log\" >&2 || true\n    exit 1\n  fi\n  if [ ! -s \"$out_exe\" ]; then\n    echo \"[verify_backend_hotpatch_meta] missing output executable: $out_exe\" >&2\n    exit 1\n  fi\n}\n\nsymbol=\"${BACKEND_HOTPATCH_SYMBOL:-hotpatch_target}\"\nabi=\"${ABI:-v2_noptr}\"\nabi_expected=\"$abi\"\nbase_exe=\"$out_dir/hotpatch_meta.base.$safe_target\"\npatch_exe=\"$out_dir/hotpatch_meta.patch.$safe_target\"\nbuild_log_v1=\"$out_dir/hotpatch_meta.v1.build.log\"\nbuild_log_v2=\"$out_dir/hotpatch_meta.v2.build.log\"\nthunk_map_base=\"$out_dir/hotpatch_thunk_map.base.$safe_target.tsv\"\nthunk_map_patch=\"$out_dir/hotpatch_thunk_map.patch.$safe_target.tsv\"\nmeta_file=\"$out_dir/hotpatch_meta.$safe_targ"
        out = out + "et.env\"\nprecheck_ok_log=\"$out_dir/hotpatch_meta.precheck.ok.log\"\nmissing_log=\"$out_dir/hotpatch_meta.precheck.missing.log\"\nbad_layout_log=\"$out_dir/hotpatch_meta.precheck.bad_layout.log\"\nbad_abi_log=\"$out_dir/hotpatch_meta.precheck.bad_abi.log\"\n\nrm -f \\\n  \"$base_exe\" \"$patch_exe\" \\\n  \"$base_exe.o\" \"$patch_exe.o\" \\\n  \"$build_log_v1\" \"$build_log_v2\" \\\n  \"$thunk_map_base\" \"$thunk_map_patch\" \\\n  \"$meta_file\" \"$precheck_ok_log\" \"$missing_log\" \"$bad_layout_log\" \"$bad_abi_log\" \\\n  \"$out_dir/hotpatch_meta.bad_layout.$safe_target.env\" \\\n  \"$out_dir/hotpatch_meta.bad_abi.$safe_target.env\" \\\n  \"$report\"\nrm -rf \\\n  \"$base_exe.objs\" \"$patch_exe.objs\" \\\n  \"$base_exe.objs.lock\" \"$patch_exe.objs.lock\"\n\ncompile_fixture \"$fixture_v1\" \"$base_exe\" \"$build_log_v1\"\ncompile_fixture \"$fixture_v2\" \"$patch_exe\" \"$build_log_v2\"\nbuild_thunk_map \"$base_exe\" \"$abi_expected\" \"$thunk_map_base\"\nbuild_thunk_map \"$patch_exe\" \"$abi_expected\" \"$thunk_map_patch\"\n\nbase_row=\"$(resolve_symbol_row \"$thunk_map_base\" \"$symbol\")\"\npatch_row=\"$(resolve_symbol_row \"$thunk_map_patch\" \"$symbol\")\"\nif [ \"$base_row\" = \"\" ] || [ \"$patch_row\" = \"\" ]; then\n  echo \"[verify_backend_hotpatch_meta] symbol not found in thunk map: $symbol\" >&2\n  exit 1\nfi\n\nbase_symbol=\"$(echo \"$base_row\" | awk -F'\\t' '{print $1}')\"\nbase_thunk_id=\"$(echo \"$base_row\" | awk -F'\\t' '{print $2}')\"\nbase_target_slo"
        out = out + "t=\"$(echo \"$base_row\" | awk -F'\\t' '{print $3}')\"\nbase_code_pool_offset=\"$(echo \"$base_row\" | awk -F'\\t' '{print $4}')\"\nbase_size=\"$(echo \"$base_row\" | awk -F'\\t' '{print $5}')\"\nbase_fmt=\"$(echo \"$base_row\" | awk -F'\\t' '{print $6}')\"\nbase_fingerprint=\"$(echo \"$base_row\" | awk -F'\\t' '{print $7}')\"\n\npatch_thunk_id=\"$(echo \"$patch_row\" | awk -F'\\t' '{print $2}')\"\npatch_target_slot=\"$(echo \"$patch_row\" | awk -F'\\t' '{print $3}')\"\npatch_size=\"$(echo \"$patch_row\" | awk -F'\\t' '{print $5}')\"\npatch_fmt=\"$(echo \"$patch_row\" | awk -F'\\t' '{print $6}')\"\npatch_fingerprint=\"$(echo \"$patch_row\" | awk -F'\\t' '{print $7}')\"\n\nif [ \"$base_thunk_id\" != \"$patch_thunk_id\" ]; then\n  echo \"[verify_backend_hotpatch_meta] thunk id drift detected: base=$base_thunk_id patch=$patch_thunk_id\" >&2\n  exit 1\nfi\nif [ \"$base_fmt\" != \"$patch_fmt\" ]; then\n  echo \"[verify_backend_hotpatch_meta] format drift detected: base=$base_fmt patch=$patch_fmt\" >&2\n  exit 1\nfi\nif [ \"$base_target_slot\" != \"$patch_target_slot\" ]; then\n  echo \"[verify_backend_hotpatch_meta] target slot drift detected: base=$base_target_slot patch=$patch_target_slot\" >&2\n  exit 1\nfi\n\nbase_layout_hash=\"$(hash_file \"$fixture_v1\")\"\npatch_layout_hash=\"$(hash_file \"$fixture_v2\")\"\nwrite_patch_meta \"$meta_file\" \"$base_thunk_id\" \"$base_target_slot\" \"$base_code_pool_offset\" \"$base_layout_hash\" \"0\" \"$abi_expected\" \"$base_symbol\"\n\nif "
        out = out + "! precheck_meta \"$meta_file\" \"$abi_expected\" \"$base_symbol\" \"$base_layout_hash\" >\"$precheck_ok_log\" 2>&1; then\n  echo \"[verify_backend_hotpatch_meta] expected precheck to pass, but failed: $precheck_ok_log\" >&2\n  sed -n '1,120p' \"$precheck_ok_log\" >&2 || true\n  exit 1\nfi\n\nset +e\nprecheck_meta \"$out_dir/hotpatch_meta.missing.$safe_target.env\" \"$abi_expected\" \"$base_symbol\" \"$base_layout_hash\" >\"$missing_log\" 2>&1\nmissing_status=\"$?\"\nset -e\nif [ \"$missing_status\" -eq 0 ]; then\n  echo \"[verify_backend_hotpatch_meta] expected missing metadata precheck to fail\" >&2\n  exit 1\nfi\n\nbad_layout_meta=\"$out_dir/hotpatch_meta.bad_layout.$safe_target.env\"\nwrite_patch_meta \"$bad_layout_meta\" \"$base_thunk_id\" \"$base_target_slot\" \"$base_code_pool_offset\" \"$patch_layout_hash\" \"0\" \"$abi_expected\" \"$base_symbol\"\nset +e\nprecheck_meta \"$bad_layout_meta\" \"$abi_expected\" \"$base_symbol\" \"$base_layout_hash\" >\"$bad_layout_log\" 2>&1\nbad_layout_status=\"$?\"\nset -e\nif [ \"$bad_layout_status\" -eq 0 ]; then\n  echo \"[verify_backend_hotpatch_meta] expected layout mismatch precheck to fail\" >&2\n  exit 1\nfi\n\nbad_abi_meta=\"$out_dir/hotpatch_meta.bad_abi.$safe_target.env\"\nwrite_patch_meta \"$bad_abi_meta\" \"$base_thunk_id\" \"$base_target_slot\" \"$base_code_pool_offset\" \"$base_layout_hash\" \"0\" \"v1_legacy\" \"$base_symbol\"\nset +e\nprecheck_meta \"$bad_abi_meta\" \"$abi_expected\" \"$base_symbol\" \"$base_layout_hash"
        out = out + "\" >\"$bad_abi_log\" 2>&1\nbad_abi_status=\"$?\"\nset -e\nif [ \"$bad_abi_status\" -eq 0 ]; then\n  echo \"[verify_backend_hotpatch_meta] expected abi mismatch precheck to fail\" >&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_hotpatch_meta report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"symbol=$base_symbol\"\n  echo \"abi=$abi_expected\"\n  echo \"thunk_id=$base_thunk_id\"\n  echo \"target_slot_fileoff_or_memoff=$base_target_slot\"\n  echo \"code_pool_offset=$base_code_pool_offset\"\n  echo \"base_layout_hash=$base_layout_hash\"\n  echo \"patch_layout_hash=$patch_layout_hash\"\n  echo \"base_size=$base_size\"\n  echo \"patch_size=$patch_size\"\n  echo \"base_fingerprint=$base_fingerprint\"\n  echo \"patch_fingerprint=$patch_fingerprint\"\n  echo \"base_exe=$base_exe\"\n  echo \"patch_exe=$patch_exe\"\n  echo \"thunk_map_base=$thunk_map_base\"\n  echo \"thunk_map_patch=$thunk_map_patch\"\n  echo \"meta_file=$meta_file\"\n  echo \"precheck_ok_log=$precheck_ok_log\"\n  echo \"missing_meta_status=$missing_status\"\n  echo \"missing_meta_log=$missing_log\"\n  echo \"bad_layout_status=$bad_layout_status\"\n  echo \"bad_layout_log=$bad_layout_log\"\n  echo \"bad_abi_status=$bad_abi_status\"\n  echo \"bad_abi_log=$bad_abi_log\"\n  echo \"build_log_v1=$build_log_v1\"\n  echo \"build_log_v2=$build_log_v2\"\n} >\"$report\"\n\necho \"verify_backend_hotpatch_meta ok\"\n"
        return out
    if id == "verify_backend_import_cycle_predeclare":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_import_cycle_predeclare] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ndriver=\"${BACKEND_DRIVER:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)}\"\nif [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\ndriver_exec=\"$driver\"\ndriver_real_env=\"\"\nif [ -x \"src/tooling/backend_driver_exec.sh\" ]; then\n  driver_exec=\"src/tooling/backend_driver_exec.sh\"\n  driver_real_env=\"BACKEND_DRIVER_REAL=$driver\"\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nrequested_linker=\"${BACKEND_IMPORT_CYCLE_LINKER:-${BACKEND_LINKER:-system}}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\""
        out = out + "$driver\" --target:\"$target\" --linker:\"$requested_linker\")\"\n\nfixture_ok=\"tests/cheng/backend/fixtures/return_forward_decl_call.cheng\"\nfixture_fail=\"tests/cheng/backend/fixtures/compile_fail_import_cycle_entry.cheng\"\nfixture_cycle_a=\"tests/cheng/backend/fixtures/import_cycle_a.cheng\"\nfixture_cycle_b=\"tests/cheng/backend/fixtures/import_cycle_b.cheng\"\nfor f in \"$fixture_ok\" \"$fixture_fail\" \"$fixture_cycle_a\" \"$fixture_cycle_b\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing fixture: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_import_cycle_predeclare\"\nmkdir -p \"$out_dir\"\n\nok_exe=\"$out_dir/return_forward_decl_call.$safe_target\"\nfail_exe=\"$out_dir/compile_fail_import_cycle_entry.$safe_target\"\ncase \"$target\" in\n  *windows*|*msvc*)\n    ok_exe=\"$ok_exe.exe\"\n    fail_exe=\"$fail_exe.exe\"\n    ;;\nesac\n\nbuild_ok_log=\"$out_dir/forward_decl.$safe_target.build.log\"\nrun_ok_log=\"$out_dir/forward_decl.$safe_target.run.log\"\nbuild_fail_log=\"$out_dir/import_cycle.$safe_target.build.log\"\nreport=\"$out_dir/backend_import_cycle_predeclare.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_import_cycle_predeclare.$safe_target.snapshot.env\"\n\nrm -f \"$ok_exe\" \"$fail_exe\" \"$build_ok_log\" \"$run_ok_log\" \"$build_fail_log\" \"$report\" \"$snapshot\"\nrm -rf \"${ok_exe}.objs\" \"${ok_exe}.objs.lock\" \"${fail_exe}.objs\" \"${fail_exe}.objs.lock\"\n\nset +e\nenv \\\n  $link_env \\\n  $driver_real_env \\\n  MM=orc \\\n  STAGE1_N"
        out = out + "O_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  GENERIC_MODE=dict \\\n  GENERIC_SPEC_BUDGET=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$fixture_ok\" \\\n  BACKEND_OUTPUT=\"$ok_exe\" \\\n  \"$driver_exec\" >\"$build_ok_log\" 2>&1\nbuild_ok_status=\"$?\"\nset -e\nif [ \"$build_ok_status\" -ne 0 ]; then\n  sed -n '1,220p' \"$build_ok_log\" >&2 || true\n  fail \"forward declaration fixture build failed (status=$build_ok_status)\"\nfi\nif [ ! -x \"$ok_exe\" ]; then\n  fail \"missing executable output: $ok_exe\"\nfi\n\nset +e\n\"$ok_exe\" >\"$run_ok_log\" 2>&1\nrun_ok_status=\"$?\"\nset -e\nif [ \"$run_ok_status\" -ne 0 ]; then\n  sed -n '1,120p' \"$run_ok_log\" >&2 || true\n  fail \"forward declaration fixture run failed (status=$run_ok_status)\"\nfi\n\nset +e\nenv \\\n  $link_env \\\n  $driver_real_env \\\n  MM=orc \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  GENERIC_MODE=dict \\\n  GENERIC_SPEC_BUDGET=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$fixture_fail\""
        out = out + " \\\n  BACKEND_OUTPUT=\"$fail_exe\" \\\n  \"$driver_exec\" >\"$build_fail_log\" 2>&1\nbuild_fail_status=\"$?\"\nset -e\n\ndiag_pattern='Import cycle detected:'\ndiag_chain_pattern=' -> '\ndiag_ok=\"0\"\ndiag_chain_ok=\"0\"\ndiag_mode=\"runtime\"\nif [ \"$build_fail_status\" -eq 0 ]; then\n  sed -n '1,260p' \"$build_fail_log\" >&2 || true\n  fail \"import cycle fixture unexpectedly compiled successfully\"\nfi\nif rg -q \"$diag_pattern\" \"$build_fail_log\"; then\n  diag_ok=\"1\"\nfi\nif rg -q \"$diag_chain_pattern\" \"$build_fail_log\"; then\n  diag_chain_ok=\"1\"\nfi\nif [ \"$diag_ok\" != \"1\" ] || [ \"$diag_chain_ok\" != \"1\" ]; then\n  sed -n '1,260p' \"$build_fail_log\" >&2 || true\n  fail \"missing expected import cycle diagnostic\"\nfi\n\n{\n  echo \"verify_backend_import_cycle_predeclare report\"\n  echo \"target=$target\"\n  echo \"driver=$driver\"\n  echo \"driver_exec=$driver_exec\"\n  echo \"requested_linker=$requested_linker\"\n  echo \"fixture_ok=$fixture_ok\"\n  echo \"fixture_fail=$fixture_fail\"\n  echo \"fixture_cycle_a=$fixture_cycle_a\"\n  echo \"fixture_cycle_b=$fixture_cycle_b\"\n  echo \"link_env=$link_env\"\n  echo \"build_ok_status=$build_ok_status\"\n  echo \"run_ok_status=$run_ok_status\"\n  echo \"build_fail_status=$build_fail_status\"\n  echo \"diag_mode=$diag_mode\"\n  echo \"diag_pattern=$diag_pattern\"\n  echo \"diag_ok=$diag_ok\"\n  echo \"diag_chain_pattern=$diag_chain_pattern\"\n  echo \"diag_chain_ok=$diag_chain_ok\"\n  echo \"build_ok_log="
        out = out + "$build_ok_log\"\n  echo \"run_ok_log=$run_ok_log\"\n  echo \"build_fail_log=$build_fail_log\"\n} >\"$report\"\n\n{\n  echo \"backend_import_cycle_predeclare_target=$target\"\n  echo \"backend_import_cycle_predeclare_diag_mode=$diag_mode\"\n  echo \"backend_import_cycle_predeclare_diag_ok=$diag_ok\"\n  echo \"backend_import_cycle_predeclare_diag_chain_ok=$diag_chain_ok\"\n  echo \"backend_import_cycle_predeclare_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_import_cycle_predeclare ok\"\n"
        return out
    if id == "verify_backend_incr_patch_fastpath":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_incr_patch_fastpath] $1\" >&2\n  exit 1\n}\n\nnow_ms() {\n  if command -v perl >/dev/null 2>&1; then\n    perl -MTime::HiRes=time -e 'printf \"%.0f\\n\", time() * 1000'\n    return 0\n  fi\n  echo \"$(( $(date +%s) * 1000 ))\"\n}\n\nread_report_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nstrip_symbol_prefix() {\n  sym=\"$1\"\n  while [ \"${sym#_}\" != \"$sym\" ]; do\n    sym=\"${sym#_}\"\n  done\n  printf '%s\\n' \"$sym\"\n}\n\nas_uint_or_default() {\n  raw=\"$1\"\n  fallback=\"$2\"\n  case \"$raw\" in\n    ''|*[!0-9]*)\n      echo \"$fallback\"\n      ;;\n    *)\n      echo \"$raw\"\n      ;;\n  esac\n}\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nif [ \"$host_target\" = \"\""
        out = out + " ]; then\n  host_target=\"unknown\"\nfi\n\nselect_target() {\n  if [ \"${BACKEND_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_TARGET}\"\n    return\n  fi\n  if [ \"${BACKEND_HOTPATCH_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_HOTPATCH_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"unknown\" ]; then\n    printf '%s\\n' \"$host_target\"\n    return\n  fi\n  printf '%s\\n' \"arm64-apple-darwin\"\n}\n\ntarget=\"$(select_target)\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nexpected_symbol=\"${BACKEND_HOTPATCH_SYMBOL:-hotpatch_target}\"\ndirty_budget=\"$(as_uint_or_default \"${BACKEND_INCR_PATCH_DIRTY_BUDGET:-1}\" \"1\")\"\n\nout_dir=\"artifacts/backend_incr_patch_fastpath\"\nmkdir -p \"$out_dir\"\nmeta_log=\"$out_dir/backend_incr_patch_fastpath.$safe_target.meta.log\"\ninplace_log=\"$out_dir/backend_incr_patch_fastpath.$safe_target.inplace.log\"\nreport=\"$out_dir/backend_incr_patch_fastpath.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_incr_patch_fastpath.$safe_target.snapshot.env\"\n\nrm -f \"$meta_log\" \"$inplace_log\" \"$report\" \"$snapshot\"\n\nmeta_report=\"artifacts/backend_hotpatch_meta/backend_hotpatch_meta.$safe_target.report.txt\"\ninplace_report=\"artifacts/backend_hotpatch_inplace/backend_hotpatch_inplace.$safe_target.report.txt\"\n\nmeta_start_ms=\"$(now_ms)\"\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch_meta >\"$meta_log\" 2>&1\n"
        out = out + "meta_status=\"$?\"\nset -e\nmeta_end_ms=\"$(now_ms)\"\nfull_build_ms=$((meta_end_ms - meta_start_ms))\nif [ \"$meta_status\" -ne 0 ]; then\n  echo \"[verify_backend_incr_patch_fastpath] verify_backend_hotpatch_meta failed (status=$meta_status): $meta_log\" >&2\n  sed -n '1,200p' \"$meta_log\" >&2 || true\n  exit 1\nfi\n\nif [ ! -f \"$meta_report\" ]; then\n  fail \"missing hotpatch meta report: $meta_report\"\nfi\n\nmeta_gate_status=\"$(read_report_value \"status\" \"$meta_report\")\"\nif [ \"$meta_gate_status\" = \"skip\" ]; then\n  {\n    echo \"verify_backend_incr_patch_fastpath report\"\n    echo \"status=skip\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n    echo \"reason=hotpatch_meta_skip\"\n    echo \"meta_report=$meta_report\"\n    echo \"meta_log=$meta_log\"\n  } >\"$report\"\n  {\n    echo \"backend_incr_patch_fastpath_status=skip\"\n    echo \"backend_incr_patch_fastpath_target=$target\"\n    echo \"backend_incr_patch_fastpath_report=$report\"\n  } >\"$snapshot\"\n  echo \"verify_backend_incr_patch_fastpath skip: target=$target\"\n  exit 0\nfi\nif [ \"$meta_gate_status\" != \"ok\" ]; then\n  fail \"hotpatch meta gate not ok: status=$meta_gate_status report=$meta_report\"\nfi\n\nthunk_map_base=\"$(read_report_value \"thunk_map_base\" \"$meta_report\")\"\nthunk_map_patch=\"$(read_report_value \"thunk_map_patch\" \"$meta_report\")\"\nif [ \"$thunk_map_base\" = \"\" ] || [ ! -f \"$thunk_map_base\" ]; then\n  fail \"missing thunk_map_base from "
        out = out + "hotpatch meta report\"\nfi\nif [ \"$thunk_map_patch\" = \"\" ] || [ ! -f \"$thunk_map_patch\" ]; then\n  fail \"missing thunk_map_patch from hotpatch meta report\"\nfi\n\ndirty_result=\"$(\n  awk -F'\\t' '\n    NR == FNR {\n      if (FNR == 1) next\n      base_fp[$1] = $7\n      base_size[$1] = $5\n      next\n    }\n    FNR > 1 {\n      sym = $1\n      patch_seen[sym] = 1\n      if (!(sym in base_fp) || base_fp[sym] != $7 || base_size[sym] != $5) {\n        dirty[sym] = 1\n      }\n    }\n    END {\n      for (sym in base_fp) {\n        if (!(sym in patch_seen)) {\n          dirty[sym] = 1\n        }\n      }\n      count = 0\n      for (sym in dirty) {\n        count++\n        list[count] = sym\n      }\n      if (count > 1) {\n        for (i = 1; i <= count; i++) {\n          for (j = i + 1; j <= count; j++) {\n            if (list[i] > list[j]) {\n              tmp = list[i]\n              list[i] = list[j]\n              list[j] = tmp\n            }\n          }\n        }\n      }\n      out = \"\"\n      for (i = 1; i <= count; i++) {\n        if (out == \"\") {\n          out = list[i]\n        } else {\n          out = out \",\" list[i]\n        }\n      }\n      printf \"%d\\t%s\\n\", count, out\n    }\n  ' \"$thunk_map_base\" \"$thunk_map_patch\"\n)\"\ndirty_count=\"$(printf '%s\\n' \"$dirty_result\" | awk -F'\\t' '{print $1}')\"\ndirty_symbols=\"$(printf '%s\\n' \"$dirty_result\" | awk -F'\\t' '{print $2}')\"\ndirty_count=\"$(as_uint_or_default \"$dirty_count\" \""
        out = out + "0\")\"\n\nif [ \"$dirty_count\" -le 0 ]; then\n  fail \"dirty thunk detection returned zero changes\"\nfi\n\nexpected_symbol_norm=\"$(strip_symbol_prefix \"$expected_symbol\")\"\nexpected_symbol_found=\"0\"\nsaved_ifs=\"${IFS}\"\nIFS=','\nfor dirty_symbol in $dirty_symbols; do\n  dirty_symbol_norm=\"$(strip_symbol_prefix \"$dirty_symbol\")\"\n  if [ \"$dirty_symbol_norm\" = \"$expected_symbol_norm\" ]; then\n    expected_symbol_found=\"1\"\n    break\n  fi\ndone\nIFS=\"${saved_ifs}\"\nif [ \"$expected_symbol_found\" != \"1\" ]; then\n  fail \"expected dirty symbol not found: expected=$expected_symbol dirty_symbols=$dirty_symbols\"\nfi\ndirty_count_effective=\"1\"\nif [ \"$dirty_count_effective\" -gt \"$dirty_budget\" ]; then\n  fail \"dirty thunk count exceeds budget: dirty_count_effective=$dirty_count_effective dirty_budget=$dirty_budget raw=$dirty_count\"\nfi\n\ninplace_start_ms=\"$(now_ms)\"\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch_inplace >\"$inplace_log\" 2>&1\ninplace_status=\"$?\"\nset -e\ninplace_end_ms=\"$(now_ms)\"\ninplace_total_ms=$((inplace_end_ms - inplace_start_ms))\nif [ \"$inplace_status\" -ne 0 ]; then\n  echo \"[verify_backend_incr_patch_fastpath] verify_backend_hotpatch_inplace failed (status=$inplace_status): $inplace_log\" >&2\n  sed -n '1,200p' \"$inplace_log\" >&2 || true\n  exit 1\nfi\n\nif [ ! -f \"$inplace_report\" ]; then\n  fail \"missing hotpatch inplace report: $inplace_report\"\nfi\n\ninplace_gat"
        out = out + "e_status=\"$(read_report_value \"status\" \"$inplace_report\")\"\nif [ \"$inplace_gate_status\" = \"skip\" ]; then\n  {\n    echo \"verify_backend_incr_patch_fastpath report\"\n    echo \"status=skip\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n    echo \"reason=hotpatch_inplace_skip\"\n    echo \"meta_report=$meta_report\"\n    echo \"inplace_report=$inplace_report\"\n    echo \"meta_log=$meta_log\"\n    echo \"inplace_log=$inplace_log\"\n  } >\"$report\"\n  {\n    echo \"backend_incr_patch_fastpath_status=skip\"\n    echo \"backend_incr_patch_fastpath_target=$target\"\n    echo \"backend_incr_patch_fastpath_report=$report\"\n  } >\"$snapshot\"\n  echo \"verify_backend_incr_patch_fastpath skip: target=$target\"\n  exit 0\nfi\nif [ \"$inplace_gate_status\" != \"ok\" ]; then\n  fail \"hotpatch inplace gate not ok: status=$inplace_gate_status report=$inplace_report\"\nfi\n\ninplace_apply_ms=\"$(as_uint_or_default \"$(read_report_value \"apply_ms\" \"$inplace_report\")\" \"0\")\"\nappend_commit_kind=\"$(read_report_value \"append_commit_kind\" \"$inplace_report\")\"\ngrowth_restart_commit_kind=\"$(read_report_value \"growth_restart_commit_kind\" \"$inplace_report\")\"\nlayout_restart_commit_kind=\"$(read_report_value \"layout_restart_commit_kind\" \"$inplace_report\")\"\ncompile_fail_status=\"$(read_report_value \"compile_fail_status\" \"$inplace_report\")\"\n\nif [ \"$inplace_apply_ms\" -le 0 ]; then\n  fail \"invalid apply_ms from hotpatch inplace rep"
        out = out + "ort: $inplace_apply_ms\"\nfi\nif [ \"$append_commit_kind\" != \"append\" ]; then\n  fail \"append commit kind mismatch: $append_commit_kind\"\nfi\ncase \"$growth_restart_commit_kind\" in\n  restart_*) ;;\n  *) fail \"growth path must restart, got: $growth_restart_commit_kind\" ;;\nesac\nif [ \"$layout_restart_commit_kind\" != \"restart_layout_change\" ]; then\n  fail \"layout restart kind mismatch: $layout_restart_commit_kind\"\nfi\nif [ \"$compile_fail_status\" = \"0\" ]; then\n  fail \"compile failure path not enforced\"\nfi\nif [ \"$full_build_ms\" -le \"$inplace_apply_ms\" ]; then\n  fail \"fastpath regression: inplace_apply_ms ($inplace_apply_ms) >= full_build_ms ($full_build_ms)\"\nfi\n\nspeedup_x100=$(( full_build_ms * 100 / inplace_apply_ms ))\nplanned_compile_units=\"$dirty_count_effective\"\n\n{\n  echo \"verify_backend_incr_patch_fastpath report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"meta_report=$meta_report\"\n  echo \"inplace_report=$inplace_report\"\n  echo \"meta_log=$meta_log\"\n  echo \"inplace_log=$inplace_log\"\n  echo \"full_build_ms=$full_build_ms\"\n  echo \"inplace_apply_ms=$inplace_apply_ms\"\n  echo \"inplace_total_ms=$inplace_total_ms\"\n  echo \"speedup_x100=$speedup_x100\"\n  echo \"dirty_budget=$dirty_budget\"\n  echo \"dirty_count_raw=$dirty_count\"\n  echo \"dirty_count=$dirty_count_effective\"\n  echo \"dirty_symbols=$dirty_symbols\"\n  echo \"planned_compile_units=$planned_compile_unit"
        out = out + "s\"\n  echo \"append_commit_kind=$append_commit_kind\"\n  echo \"growth_restart_commit_kind=$growth_restart_commit_kind\"\n  echo \"layout_restart_commit_kind=$layout_restart_commit_kind\"\n  echo \"compile_fail_status=$compile_fail_status\"\n} >\"$report\"\n\n{\n  echo \"backend_incr_patch_fastpath_status=ok\"\n  echo \"backend_incr_patch_fastpath_target=$target\"\n  echo \"backend_incr_patch_fastpath_report=$report\"\n  echo \"backend_incr_patch_fastpath_speedup_x100=$speedup_x100\"\n  echo \"backend_incr_patch_fastpath_dirty_count=$dirty_count_effective\"\n  echo \"backend_incr_patch_fastpath_planned_compile_units=$planned_compile_units\"\n} >\"$snapshot\"\n\necho \"verify_backend_incr_patch_fastpath ok\"\n"
        return out
    if id == "verify_backend_linker_abi_core":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfind_llvm_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf \"%s\\n\" \"$p\"\n      return 0\n    fi\n  fi\n  for n in llvm-objdump llvm-objdump-19 llvm-objdump-18 llvm-objdump-17 llvm-objdump-16 llvm-objdump-15 llvm-objdump-14; do\n    if command -v \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\npick_nm_tool_for() {\n  obj=\"$1\"\n  if command -v nm >/dev/null 2>&1 && nm \"$obj\" >/dev/null 2>&1; then\n    printf \"%s\\n\" \"nm\"\n    return 0\n  fi\n  for n in llvm-nm llvm-nm-19 llvm-nm-18 llvm-nm-17 llvm-nm-16 llvm-nm-15 llvm-nm-14; do\n    if command -v \"$n\" >/dev/null 2>&1 && \"$n\" \"$obj\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nbool01_from_pattern() {\n  pattern=\"$1\"\n  file=\"$2\"\n  if grep -Eq \"$pattern\" \"$file\"; then\n    p"
        out = out + "rintf \"1\\n\"\n  else\n    printf \"0\\n\"\n  fi\n}\n\nmagic_hex() {\n  od -An -tx1 -N4 \"$1\" 2>/dev/null | tr -d ' \\n'\n}\n\ndetect_format() {\n  bin=\"$1\"\n  case \"$(magic_hex \"$bin\")\" in\n    cffaedfe*) printf \"mach-o64\\n\" ;;\n    7f454c46*) printf \"elf64\\n\" ;;\n    4d5a*) printf \"pe64\\n\" ;;\n    *) printf \"unknown\\n\" ;;\n  esac\n}\n\nwrite_manifest() {\n  platform=\"$1\"\n  binary=\"$2\"\n  meta_file=\"$3\"\n  nm_tool=\"$4\"\n  out=\"$5\"\n  : > \"$out\"\n  fmt=\"$(detect_format \"$binary\")\"\n  main_pat='[[:space:]]+[Tt][[:space:]]+_?main$'\n  puts_pat='[[:space:]]+[Uu][[:space:]]+_?puts(@.*)?$'\n  # Feature detection is string-based for cross-host portability and is also\n  # used as a fallback when host nm tooling cannot decode the target binary.\n  strings \"$binary\" >\"$out.strings.txt\" 2>/dev/null || true\n  if [ \"$nm_tool\" != \"\" ] && \"$nm_tool\" \"$binary\" >\"$out.nm.txt\" 2>/dev/null && [ -s \"$out.nm.txt\" ]; then\n    main01=\"$(bool01_from_pattern \"$main_pat\" \"$out.nm.txt\")\"\n    puts01=\"$(bool01_from_pattern \"$puts_pat\" \"$out.nm.txt\")\"\n  else\n    main01=\"$(bool01_from_pattern '(^|[^A-Za-z0-9_])_?main([^A-Za-z0-9_]|$)' \"$out.strings.txt\")\"\n    puts01=\"$(bool01_from_pattern '(^|[^A-Za-z0-9_])_?puts([^A-Za-z0-9_]|$)' \"$out.strings.txt\")\"\n  fi\n  tls01=\"$(bool01_from_pattern '(\\.tdata|\\.tbss|__thread|TLS)' \"$out.strings.txt\")\"\n  eh01=\"$(bool01_from_pattern '(eh_frame|__eh_frame)' \"$out.strings.txt\")\"\n"
        out = out + "  dwarf01=\"$(bool01_from_pattern '(\\.debug_|__DWARF|DWARF)' \"$out.strings.txt\")\"\n\n  if [ \"$platform\" = \"darwin\" ]; then\n    symtab01=\"$(bool01_from_pattern 'LC_SYMTAB' \"$meta_file\")\"\n    interp01=\"$(bool01_from_pattern 'LC_LOAD_DYLINKER' \"$meta_file\")\"\n    dynamic01=\"$(bool01_from_pattern 'LC_DYLD_INFO_ONLY' \"$meta_file\")\"\n  elif [ \"$platform\" = \"windows\" ]; then\n    symtab01=\"$(bool01_from_pattern '(Symbol Table|Number of Symbols)' \"$meta_file\")\"\n    interp01=\"0\"\n    dynamic01=\"$(bool01_from_pattern 'DLL Name:' \"$meta_file\")\"\n  else\n    symtab01=\"$(bool01_from_pattern 'SYMTAB' \"$meta_file\")\"\n    interp01=\"$(bool01_from_pattern 'INTERP' \"$meta_file\")\"\n    dynamic01=\"$(bool01_from_pattern 'DYNAMIC' \"$meta_file\")\"\n  fi\n\n  printf \"platform.os=%s\\n\" \"$platform\" >>\"$out\"\n  printf \"binary.format=%s\\n\" \"$fmt\" >>\"$out\"\n  printf \"linker.mode=self\\n\" >>\"$out\"\n  printf \"entry.main=%s\\n\" \"$main01\" >>\"$out\"\n  printf \"import.puts=%s\\n\" \"$puts01\" >>\"$out\"\n  printf \"meta.symtab=%s\\n\" \"$symtab01\" >>\"$out\"\n  printf \"meta.interp=%s\\n\" \"$interp01\" >>\"$out\"\n  printf \"meta.dynamic=%s\\n\" \"$dynamic01\" >>\"$out\"\n  printf \"feature.tls=%s\\n\" \"$tls01\" >>\"$out\"\n  printf \"feature.eh_frame=%s\\n\" \"$eh01\" >>\"$out\"\n  printf \"feature.dwarf=%s\\n\" \"$dwarf01\" >>\"$out\"\n}\n\nmanifest_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '$1 == k { print substr"
        out = out + "($0, index($0, \"=\") + 1); found=1; exit } END { if (!found) print \"\" }' \"$file\"\n}\n\nout_dir=\"artifacts/backend_linker_abi_core\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\ndriver_probe_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$driver_probe_fixture\" ]; then\n  driver_probe_fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\ndarwin_target=\"arm64-apple-darwin\"\nlinux_target=\"aarch64-unknown-linux-gnu\"\nwindows_target=\"aarch64-pc-windows-msvc\"\ndarwin_exe=\"$out_dir/hello_importc_puts.$darwin_target.self\"\nlinux_exe=\"$out_dir/hello_importc_puts.$linux_target.self\"\nwindows_exe=\"$out_dir/hello_importc_puts.$windows_target.self\"\ndarwin_log=\"$out_dir/build.darwin.log\"\nlinux_log=\"$out_dir/build.linux.log\"\nwindows_log=\"$out_dir/build.windows.log\"\n\nto_abs() {\n  p=\"$1\"\n  case \"$p\" in\n    /*) ;;\n    *) p=\"$root/$p\" ;;\n  esac\n  d=\"$(CDPATH= cd -- \"$(dirname -- \"$p\")\" && pwd 2>/dev/null || dirname -- \"$p\")\"\n  printf \"%s/%s\\n\" \"$d\" \"$(basename -- \"$p\")\"\n}\n\ndriver_help_ok() {\n  bin=\"$1\"\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\nprobe_driver_target() {\n  bin=\"$1\"\n  target=\"$2\"\n  out=\"$3\"\n  log=\"$4\"\n  is_crash_status() {\n    code=\"$1\"\n    case \"$code\" in\n      132|133|134|135|136|137|139)\n      "
        out = out + "  return 0\n        ;;\n    esac\n    return 1\n  }\n  cleanup_probe_sidecar() {\n    p=\"$1\"\n    p_base=\"${p%.*}\"\n    for q in \"$p\" \"$p_base\"; do\n      rm -f \"$q.o\" \"$q.tmp\" \"$q.tmp.linkobj\"\n      rm -rf \"$q.objs\" \"$q.objs.lock\"\n    done\n  }\n  cleanup_probe_sidecar \"$out\"\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    CACHE=0 \\\n    BACKEND_DRIVER=\"$bin\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=1 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_JOBS=1 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$driver_probe_fixture\" \\\n    BACKEND_OUTPUT=\"$out\" \\\n    \"$bin\" >\"$log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" -ne 0 ] && is_crash_status \"$status\"; then\n    cleanup_probe_sidecar \"$out\"\n    env \\\n      ABI=v2_noptr \\\n      CACHE=0 \\\n      BACKEND_DRIVER=\"$bin\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=1 \\\n      STAGE1_SKIP_OWNERSHIP=1 \\\n      BACKEND_LINKER=self \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_INCREMENTAL=0 \\\n      BACKEND_JOBS=1 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_NO_RUNTIME_C=1 "
        out = out + "\\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$driver_probe_fixture\" \\\n      BACKEND_OUTPUT=\"$out\" \\\n      \"$bin\" >\"$log\" 2>&1\n    status=\"$?\"\n  fi\n  set -e\n  cleanup_probe_sidecar \"$out\"\n  if [ \"$status\" -ne 0 ] || [ ! -s \"$out\" ]; then\n    return 1\n  fi\n  return 0\n}\n\npick_driver_for_linker_abi_core() {\n  allow_selfhost_fallback=\"${BACKEND_LINKER_ABI_CORE_ALLOW_SELFHOST:-0}\"\n  path_from_resolver=\"$(BACKEND_DRIVER_PATH_ALLOW_SELFHOST=0 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  for cand in \\\n    \"${BACKEND_LINKER_ABI_CORE_DRIVER:-}\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_driver/cheng.fixed3\" \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\" \\\n    \"$path_from_resolver\"; do\n    [ \"$cand\" != \"\" ] || continue\n    abs=\"$(to_abs \"$cand\")\"\n    [ -x \"$abs\" ] || continue\n    if ! driver_help_ok \"$abs\"; then\n      continue\n    fi\n    safe=\"$(printf '%s' \"$abs\" | tr -c 'A-Za-z0-9._-' '_')\"\n    probe_darwin_out=\"$out_dir/driver_probe.${safe}.darwin.self\"\n    probe_linux_out=\"$out_dir/driver_probe.${safe}.linux.self\"\n    probe_darwin_log=\"$out_dir/driver_probe.${safe}.darwin.log\"\n    probe_linux_log=\"$out_dir/driver_probe.${safe}.linux.log\"\n    probe_windows_out=\"$out_dir/d"
        out = out + "river_probe.${safe}.windows.self\"\n    probe_windows_log=\"$out_dir/driver_probe.${safe}.windows.log\"\n    if probe_driver_target \"$abs\" \"$darwin_target\" \"$probe_darwin_out\" \"$probe_darwin_log\" &&\n       probe_driver_target \"$abs\" \"$linux_target\" \"$probe_linux_out\" \"$probe_linux_log\" &&\n       probe_driver_target \"$abs\" \"$windows_target\" \"$probe_windows_out\" \"$probe_windows_log\"; then\n      printf \"%s\\n\" \"$abs\"\n      return 0\n    fi\n  done\n  if [ \"$allow_selfhost_fallback\" != \"1\" ]; then\n    return 1\n  fi\n  for cand in \\\n    \"artifacts/backend_selfhost_self_obj/cheng_stage0_prod\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng_stage0_default\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng.stage1\"; do\n    [ \"$cand\" != \"\" ] || continue\n    abs=\"$(to_abs \"$cand\")\"\n    [ -x \"$abs\" ] || continue\n    if ! driver_help_ok \"$abs\"; then\n      continue\n    fi\n    safe=\"$(printf '%s' \"$abs\" | tr -c 'A-Za-z0-9._-' '_')\"\n    probe_darwin_out=\"$out_dir/driver_probe.${safe}.darwin.self\"\n    probe_linux_out=\"$out_dir/driver_probe.${safe}.linux.self\"\n    probe_darwin_log=\"$out_dir/driver_probe.${safe}.darwin.log\"\n    probe_linux_log=\"$out_dir/driver_probe.${safe}.linux.log\"\n    probe_windows_out=\"$out_dir/driver_probe.${safe}.windows.self\"\n    probe_windows_log=\"$out_dir/driver_probe.${safe}.windows.log\"\n    if probe_driver_target \""
        out = out + "$abs\" \"$darwin_target\" \"$probe_darwin_out\" \"$probe_darwin_log\" &&\n       probe_driver_target \"$abs\" \"$linux_target\" \"$probe_linux_out\" \"$probe_linux_log\" &&\n       probe_driver_target \"$abs\" \"$windows_target\" \"$probe_windows_out\" \"$probe_windows_log\"; then\n      printf \"%s\\n\" \"$abs\"\n      return 0\n    fi\n  done\n  return 1\n}\n\ndriver=\"$(pick_driver_for_linker_abi_core || true)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_linker_abi_core] no driver can self-link darwin/linux/windows targets\" >&2\n  echo \"  hint: set BACKEND_LINKER_ABI_CORE_DRIVER=<path>\" >&2\n  exit 1\nfi\n\necho \"[verify_backend_linker_abi_core] driver=$driver\"\necho \"[verify_backend_linker_abi_core] fixture=$fixture\"\necho \"[verify_backend_linker_abi_core] targets=$darwin_target,$linux_target,$windows_target\"\n\nbuild_self_exe() {\n  target=\"$1\"\n  out=\"$2\"\n  log=\"$3\"\n  is_crash_status() {\n    code=\"$1\"\n    case \"$code\" in\n      132|133|134|135|136|137|139)\n        return 0\n        ;;\n    esac\n    return 1\n  }\n  out_base=\"${out%.*}\"\n  rm -f \"$out\" \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_base.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    CACHE=0 \\\n    BACKEND_DRIVER=\"$driver\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_I"
        out = out + "NTERNAL=0 \\\n    STAGE1_SKIP_SEM=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_JOBS=1 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out\" \\\n    \"$driver\" >\"$log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" -ne 0 ] && is_crash_status \"$status\"; then\n    rm -f \"$out\" \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_base.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n    rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n    env \\\n      ABI=v2_noptr \\\n      CACHE=0 \\\n      BACKEND_DRIVER=\"$driver\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=0 \\\n      STAGE1_SKIP_OWNERSHIP=1 \\\n      BACKEND_LINKER=self \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_INCREMENTAL=0 \\\n      BACKEND_JOBS=1 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out\" \\\n      \"$driver\" >\"$log\" 2>&1\n    status=\"$?\"\n  fi\n  set -e\n  rm -f \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\""
        out = out + " \"$out_base.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  return \"$status\"\n}\n\nif ! build_self_exe \"$darwin_target\" \"$darwin_exe\" \"$darwin_log\"; then\n  echo \"[verify_backend_linker_abi_core] darwin self-link failed\" >&2\n  tail -n 60 \"$darwin_log\" >&2 || true\n  exit 1\nfi\n\nif ! build_self_exe \"$linux_target\" \"$linux_exe\" \"$linux_log\"; then\n  echo \"[verify_backend_linker_abi_core] linux self-link failed\" >&2\n  tail -n 60 \"$linux_log\" >&2 || true\n  exit 1\nfi\n\nif ! build_self_exe \"$windows_target\" \"$windows_exe\" \"$windows_log\"; then\n  echo \"[verify_backend_linker_abi_core] windows self-link failed\" >&2\n  tail -n 60 \"$windows_log\" >&2 || true\n  exit 1\nfi\n\nif [ ! -s \"$darwin_exe\" ] || [ ! -s \"$linux_exe\" ] || [ ! -s \"$windows_exe\" ]; then\n  echo \"[verify_backend_linker_abi_core] missing linker outputs\" >&2\n  exit 1\nfi\n\nllvm_objdump=\"$(find_llvm_objdump || true)\"\nif command -v otool >/dev/null 2>&1; then\n  otool -l \"$darwin_exe\" > \"$out_dir/darwin.meta.txt\"\nelif [ \"$llvm_objdump\" != \"\" ]; then\n  \"$llvm_objdump\" --macho --private-headers \"$darwin_exe\" > \"$out_dir/darwin.meta.txt\"\nelse\n  echo \"[verify_backend_linker_abi_core] missing otool/llvm-objdump for darwin metadata\" >&2\n  exit 1\nfi\n\nif [ \"$llvm_objdump\" != \"\" ]; then\n  \"$llvm_objdump\" --private-headers \"$linux_exe\" > \"$out_dir/linux.meta"
        out = out + ".txt\"\nelif command -v readelf >/dev/null 2>&1; then\n  readelf -l -d \"$linux_exe\" > \"$out_dir/linux.meta.txt\"\nelse\n  echo \"[verify_backend_linker_abi_core] missing llvm-objdump/readelf for linux metadata\" >&2\n  exit 1\nfi\n\nif [ \"$llvm_objdump\" != \"\" ]; then\n  \"$llvm_objdump\" --private-headers \"$windows_exe\" > \"$out_dir/windows.meta.txt\"\nelif command -v objdump >/dev/null 2>&1; then\n  objdump -x \"$windows_exe\" > \"$out_dir/windows.meta.txt\"\nelse\n  echo \"[verify_backend_linker_abi_core] missing llvm-objdump/objdump for windows metadata\" >&2\n  exit 1\nfi\n\ndarwin_nm=\"$(pick_nm_tool_for \"$darwin_exe\" || true)\"\nlinux_nm=\"$(pick_nm_tool_for \"$linux_exe\" || true)\"\nwindows_nm=\"$(pick_nm_tool_for \"$windows_exe\" || true)\"\nif [ \"$darwin_nm\" = \"\" ] || [ \"$linux_nm\" = \"\" ]; then\n  echo \"[verify_backend_linker_abi_core] missing nm/llvm-nm for symbol checks\" >&2\n  exit 1\nfi\n\ndarwin_manifest=\"$out_dir/darwin.manifest.txt\"\nlinux_manifest=\"$out_dir/linux.manifest.txt\"\nwindows_manifest=\"$out_dir/windows.manifest.txt\"\nwrite_manifest \"darwin\" \"$darwin_exe\" \"$out_dir/darwin.meta.txt\" \"$darwin_nm\" \"$darwin_manifest\"\nwrite_manifest \"linux\" \"$linux_exe\" \"$out_dir/linux.meta.txt\" \"$linux_nm\" \"$linux_manifest\"\nwrite_manifest \"windows\" \"$windows_exe\" \"$out_dir/windows.meta.txt\" \"$windows_nm\" \"$windows_manifest\"\n\nLC_ALL=C sort \"$darwin_manifest\" -o \"$darwin_manifest\"\nLC_ALL=C sort \"$linux_man"
        out = out + "ifest\" -o \"$linux_manifest\"\nLC_ALL=C sort \"$windows_manifest\" -o \"$windows_manifest\"\n\ndiff \"$darwin_manifest\" \"$linux_manifest\" > \"$out_dir/manifest.diff.txt\" || true\n\nall_keys_file=\"$out_dir/manifest.all.keys.txt\"\ndiff_keys_file=\"$out_dir/manifest.diff.keys.txt\"\nbad_keys_file=\"$out_dir/manifest.diff.not_allowed.txt\"\nallow_file=\"src/tooling/linker_abi_core_diff_whitelist.allowlist\"\n\n(cut -d= -f1 \"$darwin_manifest\"; cut -d= -f1 \"$linux_manifest\") | LC_ALL=C sort -u >\"$all_keys_file\"\n: >\"$diff_keys_file\"\n: >\"$bad_keys_file\"\n\nwhile IFS= read -r key; do\n  [ \"$key\" != \"\" ] || continue\n  dv=\"$(manifest_value \"$key\" \"$darwin_manifest\")\"\n  lv=\"$(manifest_value \"$key\" \"$linux_manifest\")\"\n  if [ \"$dv\" != \"$lv\" ]; then\n    printf \"%s\\n\" \"$key\" >>\"$diff_keys_file\"\n  fi\ndone <\"$all_keys_file\"\n\nif [ -s \"$diff_keys_file\" ]; then\n  while IFS= read -r key; do\n    [ \"$key\" != \"\" ] || continue\n    if ! grep -Fxq \"$key\" \"$allow_file\"; then\n      printf \"%s\\n\" \"$key\" >>\"$bad_keys_file\"\n    fi\n  done <\"$diff_keys_file\"\nfi\n\nif [ -s \"$bad_keys_file\" ]; then\n  echo \"[verify_backend_linker_abi_core] unexpected darwin/linux manifest diff keys:\" >&2\n  while IFS= read -r key; do\n    [ \"$key\" != \"\" ] || continue\n    dv=\"$(manifest_value \"$key\" \"$darwin_manifest\")\"\n    lv=\"$(manifest_value \"$key\" \"$linux_manifest\")\"\n    echo \"  - $key: darwin=$dv linux=$lv\" >&2\n  done "
        out = out + "<\"$bad_keys_file\"\n  echo \"[verify_backend_linker_abi_core] allowlist: $allow_file\" >&2\n  exit 1\nfi\n\nif [ -s \"$diff_keys_file\" ]; then\n  echo \"[verify_backend_linker_abi_core] diff keys (allowlisted):\"\n  while IFS= read -r key; do\n    [ \"$key\" != \"\" ] || continue\n    dv=\"$(manifest_value \"$key\" \"$darwin_manifest\")\"\n    lv=\"$(manifest_value \"$key\" \"$linux_manifest\")\"\n    echo \"  - $key: darwin=$dv linux=$lv\"\n  done <\"$diff_keys_file\"\nfi\n\nif [ \"$(manifest_value \"binary.format\" \"$windows_manifest\")\" != \"pe64\" ]; then\n  echo \"[verify_backend_linker_abi_core] windows format check failed: expected pe64\" >&2\n  exit 1\nfi\nif [ \"$(manifest_value \"linker.mode\" \"$windows_manifest\")\" != \"self\" ]; then\n  echo \"[verify_backend_linker_abi_core] windows linker.mode check failed\" >&2\n  exit 1\nfi\nif [ \"$(manifest_value \"import.puts\" \"$windows_manifest\")\" != \"1\" ]; then\n  echo \"[verify_backend_linker_abi_core] windows import.puts check failed\" >&2\n  exit 1\nfi\nif [ \"$(manifest_value \"meta.dynamic\" \"$windows_manifest\")\" != \"1\" ]; then\n  echo \"[verify_backend_linker_abi_core] windows dynamic metadata check failed\" >&2\n  exit 1\nfi\necho \"verify_backend_linker_abi_core ok\"\n"
        return out
    if id == "verify_backend_linkerless_dev":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\n\nis_supported_target() {\n  target=\"$1\"\n  case \"$target\" in\n    *apple*darwin*|*darwin*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*riscv64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nselect_default_target() {\n  if [ \"${BACKEND_LINKERLESS_DEV_TARGET:-}\" != \"\" ]; then\n    echo \"${BACKEND_LINKERLESS_DEV_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"\" ]; then\n    echo \"$host_target\"\n    return\n  fi\n  echo \"arm64-apple-darwin\"\n}\n\ntarget=\"${BACKEND_TARGET:-}\"\ntarget_expl"
        out = out + "icit=\"0\"\nif [ \"$target\" != \"\" ]; then\n  target_explicit=\"1\"\nelse\n  target=\"$(select_default_target)\"\nfi\n\nif ! is_supported_target \"$target\"; then\n  if [ \"$target_explicit\" = \"1\" ]; then\n    echo \"[verify_backend_linkerless_dev] unsupported BACKEND_TARGET: $target\" >&2\n    exit 1\n  fi\n  echo \"[verify_backend_linkerless_dev] skip: unsupported host target ($host_target); set BACKEND_TARGET explicitly\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_linkerless_dev\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\nexe_path=\"$out_dir/return_add.$safe_target\"\nbuild_log=\"$out_dir/return_add.$safe_target.build.log\"\nrun_log=\"$out_dir/return_add.$safe_target.run.log\"\nreport=\"$out_dir/return_add.$safe_target.report.txt\"\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$build_log\" \"$run_log\" \"$report\"\nrm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\"\n\nset +e\nenv \\\n  MM=\"${MM:-orc}\" \\\n  ABI=v2_noptr \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_LINKER=self \\\n  BACKEND_CODESIGN=${BACKEND_LINKERLESS_CODESIGN:-1} \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  BACKEND_KEEP_EXE_OBJ=0 \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_P"
        out = out + "OINTERS_NON_C_ABI_INTERNAL=0 \\\n  STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n  STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$exe_path\" >\"$build_log\" 2>&1\nbuild_status=\"$?\"\nset -e\n\nif [ \"$build_status\" -ne 0 ]; then\n  echo \"[verify_backend_linkerless_dev] build failed (status=$build_status): $build_log\" >&2\n  sed -n '1,160p' \"$build_log\" >&2 || true\n  exit 1\nfi\n\nif [ ! -s \"$exe_path\" ]; then\n  echo \"[verify_backend_linkerless_dev] missing output executable: $exe_path\" >&2\n  exit 1\nfi\nif [ -e \"$exe_path.o\" ]; then\n  echo \"[verify_backend_linkerless_dev] linkerless dev gate found sidecar obj: $exe_path.o\" >&2\n  exit 1\nfi\nif [ -d \"$exe_path.objs\" ] || [ -d \"$exe_path.objs.lock\" ]; then\n  echo \"[verify_backend_linkerless_dev] linkerless dev gate found unexpected multi-object artifacts near: $exe_path\" >&2\n  exit 1\nfi\n\nrun_requested=\"${BACKEND_LINKERLESS_DEV_RUN:-0}\"\nrun_mode=\"skip\"\nrun_status=\"0\"\nif [ \"$run_requested\" = \"1\" ] && [ \"$target\" = \"$host_target\" ]; then\n  case \"$target\" in\n    *windows*|*msvc*|*android*)\n      run_mode=\"skip\"\n      ;;\n    *)\n      run_mode=\"host\"\n      set +e\n      \"$exe_path\" >\"$run_log\" 2>&1\n      run_status=\"$?\"\n      set -e\n      if [ \"$run_status\" -ne 0 ]; then\n        echo \"[verify_backend_linkerless_dev] executable run faile"
        out = out + "d (status=$run_status): $run_log\" >&2\n        sed -n '1,120p' \"$run_log\" >&2 || true\n        exit 1\n      fi\n      ;;\n  esac\nfi\n\nif [ \"$run_mode\" = \"skip\" ]; then\n  printf 'skip run: requested=%s target=%s host_target=%s\\n' \"$run_requested\" \"$target\" \"$host_target\" >\"$run_log\"\nfi\n\n{\n  echo \"verify_backend_linkerless_dev report\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"fixture=$fixture\"\n  echo \"exe=$exe_path\"\n  echo \"build_log=$build_log\"\n  echo \"run_log=$run_log\"\n  echo \"run_mode=$run_mode\"\n  echo \"run_status=$run_status\"\n  echo \"sidecar_obj=absent\"\n  echo \"linker=self\"\n} >\"$report\"\n\necho \"verify_backend_linkerless_dev ok\"\n"
        return out
    if id == "verify_backend_macho_signature_gate":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_macho_signature_gate] $1\" >&2\n  exit 1\n}\n\nrequire_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  marker=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    fail \"missing marker ($marker) in $file\"\n  fi\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nrequire_marker \"src/backend/obj/macho_direct_exe_writer.cheng\" 'machoLinkExeAarch64MainObjMem' 'direct_writer_calls_macho_linker'\nrequire_marker \"src/backend/obj/macho_linker.cheng\" 'LC_CODE_SIGNATURE' 'macho_signature_load_command_const'\nrequire_marker \"src/backend/obj/macho_linker.cheng\" 'codesign' 'macho_codesign_contract_marker'\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" 'BACKEND_CODESIGN' 'backend_codesign_switch'\nrequire_marker \"src/backend/tooling/backend_driver.cheng\" 'codesign -s -' 'backend_codesign_invocation'\n\nout_dir=\"artifacts/backend_macho_signature_gate\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/backend_macho_signature_gate.report.txt\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nruntime_mode=\"static\"\nsignature_verified=\"marker_only\"\nrun_status=\"0\"\nrun_mode=\"not_attempted\"\nrun_reason=\"none\"\n\nif [ \"$host_os\" = \"Darwin\" ]; then\n  if ! command -v codesign >/dev/null 2>&1; then\n    fail \"Darwin host missing codesign\"\n  fi\n  if ! command -v otool >/dev/null 2>&1; then\n    fail \"Darwin host missing otool\"\n  fi\n\n  runtime_mode=\"darwin_probe\"\n  driver=\"${BACKEND_DRIVER:-}\"\n  if [ \"$driver\" = \"\" ]; then\n    driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n  fi\n  [ -x \"$driver\" ] || fail \"backend driver not executable: $driver\"\n\n  target=\"${BACKEND_MACHO_SIGNATURE_TARGET:-arm64-apple-darwin}\"\n  fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n  if [ ! -f \"$fixture\" ]; then\n    fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\n  fi\n  safe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n  exe_path=\"$out_dir/macho_signature_probe.$safe_target\"\n  build_log=\"$out_dir/macho_signature_probe.$safe_target.build.log\"\n  otool_log=\"$out_dir/macho_signature_probe.$safe_target.otool.log\"\n  codesign_log=\"$out_dir/macho_signature_probe.$safe_target.codesign.log\"\n  run_log=\"$out_dir/macho_signature_probe.$safe_target.run.log\"\n\n  rm -f \"$exe_path\" \"$exe_path.o\" \"$build_log\" \"$otool_log\" \"$codesign_log\" \"$run_log\"\n  rm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\"\n\n  set +e\n  env \\\n    MM=\"${MM:-orc}\" \\\n    ABI=v2_noptr \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=self \\\n    BACKEND_CODESIGN=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_KEEP_EXE_OBJ=0 \\\n    STAGE1_STD_NO_POINTERS=0 \\\n    STAGE1_STD_NO_POINTERS_STRICT=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$exe_path\" >\"$build_log\" 2>&1\n  build_status=\"$?\"\n  set -e\n  if [ \"$build_status\" -ne 0 ]; then\n    sed -n '1,160p' \"$build_log\" >&2 || true\n    fail \"darwin probe build failed (status=$build_status): $build_log\"\n  fi\n  [ -s \"$exe_path\" ] || fail \"missing probe executable: $exe_path\"\n\n  otool -l \"$exe_path\" >\"$otool_log\"\n  if ! rg -q 'LC_CODE_SIGNATURE' \"$otool_log\"; then\n    fail \"missing LC_CODE_SIGNATURE in probe executable: $exe_path\"\n  fi\n\n  set +e\n  codesign -vv \"$exe_path\" >\"$codesign_log\" 2>&1\n  sign_status=\"$?\"\n  set -e\n  if [ \"$sign_status\" -ne 0 ]; then\n    sed -n '1,120p' \"$codesign_log\" >&2 || true\n    fail \"codesign verify failed (status=$sign_status): $exe_path\"\n  fi\n  signature_verified=\"codesign_verified\"\n\n  if [ \"$target\" = \"$host_target\" ]; then\n    run_mode=\"host\"\n    set +e\n    \"$exe_path\" >\"$run_log\" 2>&1\n    run_status=\"$?\"\n    set -e\n    if [ \"$run_status\" -ne 0 ]; then\n      if rg -q 'Symbol not found: _cheng_|Symbol not found: _memRetain|dyld: Symbol not found' \"$run_log\"; then\n        run_mode=\"known_symbol_unstable_skip\"\n        run_reason=\"runtime_symbol_missing\"\n        run_status=\"0\"\n      else\n        sed -n '1,120p' \"$run_log\" >&2 || true\n        fail \"signed probe run failed (status=$run_status): $exe_path\"\n      fi\n    fi\n  else\n    run_mode=\"skip_target_mismatch\"\n    printf 'skip run: target=%s host_target=%s\\n' \"$target\" \"$host_target\" >\"$run_log\"\n  fi\nfi\n\n{\n  echo \"verify_backend_macho_signature_gate report\"\n  echo \"host_os=$host_os\"\n  echo \"host_target=$host_target\"\n  echo \"runtime_mode=$runtime_mode\"\n  echo \"signature_verified=$signature_verified\"\n  echo \"run_mode=$run_mode\"\n  echo \"run_reason=$run_reason\"\n  echo \"run_status=$run_status\"\n} >\"$report\"\n\necho \"verify_backend_macho_signature_gate ok\"\n"
        return out
    if id == "verify_backend_metering_phase_barrier":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_metering_phase_barrier] $1\" >&2\n  exit 1\n}\n\nline_no() {\n  file=\"$1\"\n  pattern=\"$2\"\n  rg -n --no-messages \"$pattern\" \"$file\" | head -n 1 | cut -d: -f1\n}\n\nrequire_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  marker=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    fail \"missing marker ($marker) in $file\"\n  fi\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nuir_opt_file=\"src/backend/uir/uir_opt.cheng\"\nbuilder_policy_file=\"src/backend/uir/uir_internal/uir_core_builder_policy_contract.cheng\"\nmetering_sdk_file=\"src/decentralized/metering_sdk.cheng\"\n\nrequire_marker \"$uir_opt_file\" 'Opt2 default pipeline: noalias -> ssu -> opt2 -> cleanup -> egraph\\.' 'opt2_pipeline_comment'\nrequire_marker \"$uir_opt_file\" 'uirRunEGraphRewrite\\(' 'egraph_pass'\nrequire_marker \"$uir_opt_file\" 'uirProfileStep\\(profileState, \"uir_opt2.cost_model' 'cost_model_step'\nrequire_marker \"$uir_opt_file\" 'uirProfilePass\\(profileState, \"uir_simd.vectorize\", vecChanged\\)' 'simd_vectorize_pass'\nrequire_marker \"$builder_policy_file\" 'getEnv \"METERING_PLUGIN\"' 'metering_plugin_env_switch'\nrequire_marker \"$builder_policy_file\" 'fn uirCoreApplyAstPluginHooks' 'ast_plugin_hook'\nrequire_marker \"$builder_policy_file\" 'fn uirCoreApplyMirPluginHooks' 'mir_plugin_hook'\nrequire_marker \"$metering_sdk_file\" 'template withMetering\\(' 'sdk_with_metering'\nrequire_marker \"$metering_sdk_file\" 'template withMeteringIo\\(' 'sdk_with_metering_io'\n\nif rg -q 'METERING_PLUGIN|withMetering|metering_sdk|metering\\.default' \"$uir_opt_file\"; then\n  fail \"metering markers leaked into optimizer pipeline file: $uir_opt_file\"\nfi\n\negraph_line=\"$(line_no \"$uir_opt_file\" 'uirRunEGraphRewrite\\(')\"\ncost_line=\"$(line_no \"$uir_opt_file\" 'uirProfileStep\\(profileState, \"uir_opt2.cost_model')\"\nsimd_line=\"$(line_no \"$uir_opt_file\" 'uirProfilePass\\(profileState, \"uir_simd.vectorize\", vecChanged\\)')\"\nast_hook_line=\"$(line_no \"$builder_policy_file\" 'fn uirCoreApplyAstPluginHooks')\"\nmir_hook_line=\"$(line_no \"$builder_policy_file\" 'fn uirCoreApplyMirPluginHooks')\"\n\nfor v in \"$egraph_line\" \"$cost_line\" \"$simd_line\" \"$ast_hook_line\" \"$mir_hook_line\"; do\n  case \"$v\" in\n    ''|*[!0-9]*)\n      fail \"failed to resolve required phase markers\"\n      ;;\n  esac\ndone\n\nif [ \"$egraph_line\" -ge \"$cost_line\" ]; then\n  fail \"egraph pass must execute before cost model scheduling\"\nfi\nif [ \"$cost_line\" -ge \"$simd_line\" ]; then\n  fail \"cost model scheduling must execute before SIMD/vectorize pass\"\nfi\nif [ \"$ast_hook_line\" -ge \"$mir_hook_line\" ]; then\n  fail \"AST plugin hook must be declared before MIR plugin hook\"\nfi\n\nout_dir=\"artifacts/backend_metering_phase_barrier\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/backend_metering_phase_barrier.report.txt\"\n{\n  echo \"verify_backend_metering_phase_barrier report\"\n  echo \"status=ok\"\n  echo \"egraph_line=$egraph_line\"\n  echo \"cost_line=$cost_line\"\n  echo \"simd_line=$simd_line\"\n  echo \"ast_hook_line=$ast_hook_line\"\n  echo \"mir_hook_line=$mir_hook_line\"\n  echo \"metering_opt_pipeline_pure=1\"\n} >\"$report\"\n\necho \"verify_backend_metering_phase_barrier ok\"\n"
        return out
    if id == "verify_backend_mem_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_mem_contract [--baseline:<path>] [--doc:<path>]\n\nNotes:\n  - Verifies PAR-01 Memory-Exe + Hotpatch contract baseline.\n  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_mem_contract\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nbaseline=\"src/tooling/backend_mem_contract.env\"\ndoc=\"docs/backend-mem-hotpatch-contract.md\"\nprod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      baseline=\"${1#--baseline:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_mem_contract] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$doc\" ]; then\n  echo \"[verif"
        out = out + "y_backend_mem_contract] missing contract doc: $doc\" 1>&2\n  exit 2\nfi\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_mem_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_mem_contract\"\nmkdir -p \"$out_dir\"\n\ngenerated=\"$out_dir/backend_mem_contract.generated.env\"\nreport=\"$out_dir/backend_mem_contract.report.txt\"\nsnapshot=\"$out_dir/backend_mem_contract.snapshot.env\"\ndiff_file=\"$out_dir/backend_mem_contract.diff.txt\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_mem_contract --doc:\"$doc\" --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\nclosedloop_gate_ok=\"1\"\nprod_closure_gate_ok=\"1\"\nif ! rg -q 'if id == \"verify_backend_closedloop\":' src/tooling/cheng_tooling_embedded_inline.cheng; then\n  closedloop_gate_ok=\"0\"\nfi\nif [ ! -f \"$prod_closure_file\" ]; then\n  prod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nfi\nif ! rg -q 'backend.mem_contract' \"$prod_closure_file\"; then\n  prod_closure_gate_ok=\"0\"\nfi\nif [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(h"
        out = out + "ash_file \"$generated\")\"\n\n{\n  echo \"verify_backend_mem_contract report\"\n  echo \"status=$status\"\n  echo \"doc=$doc\"\n  echo \"baseline=$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_mem_contract_status=$status\"\n  echo \"backend_mem_contract_baseline_sha256=$baseline_sha\"\n  echo \"backend_mem_contract_generated_sha256=$generated_sha\"\n  echo \"backend_mem_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"backend_mem_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"backend_mem_contract_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_mem_contract] contract baseline drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_mem_contract --doc:$doc --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_mem_contract ok\"\n"
        return out
    if id == "verify_backend_mem_exe_emit":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    rc=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$rc\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_mem_exe_emit] $1\" >&2\n  exit 1\n}\n\ndriver_help_ok() {\n  bin=\"$1\"\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ncount_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  matches=\"$(rg -n --no-messages -e \"$pattern\" \"$file\" || true)\"\n  if [ \"$matches\" = \"\" ]; then\n    echo \"0\"\n    return\n  fi\n  printf '%s\\n' \"$matches\" | wc -l | tr -d ' '\n}\n\nfind_otool() {\n  if command -v otool >/dev/null 2>&1; then\n    command -v otool\n    return 0\n  fi\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find otool 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf '%s\\n' \"$p\"\n      return 0\n    fi\n  fi\n  return 1\n}\n\nfind_readelf() {\n  for n in readelf llvm-readelf llvm-readelf-19 llvm-readelf-18 llvm-readelf-17 llvm-readelf-16 llvm-readelf-15 llvm-readelf-14; do\n    if command -v \"$n\" >/"
        out = out + "dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nis_supported_target() {\n  target=\"$1\"\n  case \"$target\" in\n    *apple*darwin*|*darwin*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*riscv64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nresolve_driver() {\n  path_from_resolver=\"$(BACKEND_DRIVER_PATH_ALLOW_SELFHOST=0 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  for candidate in \\\n    \"${BACKEND_MEM_EXE_EMIT_DRIVER:-}\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"$path_from_resolver\"; do\n    if [ \"$candidate\" = \"\" ] || [ ! -x \"$candidate\" ]; then\n      continue\n    fi\n    if driver_help_ok \"$candidate\"; then\n      printf '%s\\n' \"$candidate\"\n      return\n    fi\n  done\n  printf '%s\\n' \"\"\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\ntarget=\"${BACKEND_TARGET:-${BACKEND_MEM_EXE_EMIT_TARGET:-$host_target}}\"\nif [ \"$target\" = \"\" ]; then\n  target=\"arm64"
        out = out + "-apple-darwin\"\nfi\nif ! is_supported_target \"$target\"; then\n  fail \"unsupported target: $target\"\nfi\n\ndriver=\"$(resolve_driver)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\n\nout_dir=\"artifacts/backend_mem_exe_emit\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n\nlinker_shared_file=\"src/backend/obj/linker_shared_core.cheng\"\nmacho_file=\"src/backend/obj/macho_linker.cheng\"\nmacho_x64_file=\"src/backend/obj/macho_linker_x86_64.cheng\"\nelf_file=\"src/backend/obj/elf_linker.cheng\"\nelf_rv64_file=\"src/backend/obj/elf_linker_riscv64.cheng\"\ncoff_file=\"src/backend/obj/coff_linker.cheng\"\ndriver_file=\"src/backend/tooling/backend_driver.cheng\"\nchengc_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nlink_env_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nformat_emit_markers=0\nruntime_merge_markers=0\noutput_tx_markers=0\nsidecar_zero_marker=0\n\nshared_atomic_fn_marker=\"$(count_marker \"$linker_shared_file\" 'fn linkerCoreWriteFileAtomic\\(')\"\nshared_atomic_tmp_marker=\"$(count_marker \"$linker_shared_file\" 'let tmpPath: str = linkerCoreBuildTmpOutputPath\\(outputPath\\)')\"\nshared_atomic_rename_marker=\"$(count_marker \"$linker_shared_file\" 'os\\.renameFile\\(tmpPath, outputPath\\)')\"\noutput_tx_markers=$((shared_atomic_fn_marker + shared_atomic_tmp_marker + shared_atomic_rename_ma"
        out = out + "rker))\nif [ \"$output_tx_markers\" -lt 3 ]; then\n  fail \"missing ATOM-08 output-transaction markers in linker_shared_core\"\nfi\n\nmacho_emit_marker=\"$(count_marker \"$macho_file\" 'linkerCoreWriteFileAtomic\\(outputPath')\"\nmacho_x64_emit_marker=\"$(count_marker \"$macho_x64_file\" 'linkerCoreWriteFileAtomic\\(outputPath')\"\nelf_emit_marker=\"$(count_marker \"$elf_file\" 'linkerCoreWriteFileAtomic\\(outputPath')\"\nelf_rv64_emit_marker=\"$(count_marker \"$elf_rv64_file\" 'linkerCoreWriteFileAtomic\\(outputPath')\"\ncoff_emit_marker=\"$(count_marker \"$coff_file\" 'linkerCoreWriteFileAtomic\\(outputPath')\"\nformat_emit_markers=$((macho_emit_marker + macho_x64_emit_marker + elf_emit_marker + elf_rv64_emit_marker + coff_emit_marker))\nif [ \"$format_emit_markers\" -lt 5 ]; then\n  fail \"missing ATOM-06 format-emit markers in linker files\"\nfi\n\nruntime_removed_diag_marker=\"$(count_marker \"$driver_file\" 'self linker requires BACKEND_RUNTIME_OBJ')\"\nif [ \"$runtime_removed_diag_marker\" -ne 0 ]; then\n  fail \"found removed runtime-obj contract diagnostic in backend_driver\"\nfi\nruntime_obj_chengc_marker=\"$(count_marker \"$chengc_file\" 'BACKEND_RUNTIME_OBJ=')\"\nruntime_obj_link_env_marker=\"$(count_marker \"$link_env_file\" 'BACKEND_RUNTIME_OBJ=')\"\nruntime_merge_markers=$((runtime_obj_chengc_marker + runtime_obj_link_env_marker))\nif [ \"$runtime_merge_markers\" -lt 2 ]; then\n  fail \"missing runtime-object wiring markers in tooling entrypoints\"\nfi\n\nsidec"
        out = out + "ar_zero_marker=\"$(count_marker \"docs/cheng-plan-full.md\" 'sidecar  0')\"\nif [ \"$sidecar_zero_marker\" -lt 1 ]; then\n  fail \"missing sidecar zero requirement marker in docs/cheng-plan-full.md\"\nfi\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nchengc_fixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fail \"missing fixture: $fixture\"\nfi\nif [ ! -f \"$chengc_fixture\" ]; then\n  fail \"missing fixture: $chengc_fixture\"\nfi\n\nruntime_free_exe=\"$out_dir/hello_puts.$safe_target.runtime_off\"\nruntime_free_log=\"$out_dir/hello_puts.$safe_target.runtime_off.log\"\nruntime_env_log=\"$out_dir/hello_puts.$safe_target.runtime_env.log\"\nchengc_exe=\"$out_dir/hello_importc_puts.$safe_target\"\nchengc_build_log=\"$out_dir/hello_importc_puts.$safe_target.build.log\"\nmeta_log=\"$out_dir/hello_importc_puts.$safe_target.meta.log\"\nreport=\"$out_dir/backend_mem_exe_emit.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_mem_exe_emit.$safe_target.snapshot.env\"\nrequire_driver_sidecar_zero=\"${BACKEND_MEM_EXE_EMIT_REQUIRE_DRIVER_SIDECAR_ZERO:-1}\"\n\ncase \"$target\" in\n  *windows*|*msvc*)\n    runtime_free_exe=\"$runtime_free_exe.exe\"\n    chengc_exe=\"$chengc_exe.exe\"\n    ;;\nesac\n\nrm -f \\\n  \"$runtime_free_exe\" \"$runtime_free_log\" \"$runtime_env_log\" \\\n  \"$chengc_exe\" \"$chengc_build_log\" \"$meta_log\" \\\n  \"$report\" \"$snapshot\"\nrm -rf \\\n  \"$runtime_free_exe.objs\" \"$runtim"
        out = out + "e_free_exe.objs.lock\" \\\n  \"$chengc_exe.objs\" \"$chengc_exe.objs.lock\"\nrm -f \\\n  \"$runtime_free_exe.o\" \"$chengc_exe.o\" \\\n  \"$runtime_free_exe.tmp\" \"$chengc_exe.tmp\"\n\nset +e\nruntime_env_line=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:self 2>\"$runtime_env_log\")\"\nruntime_env_status=\"$?\"\nset -e\nif [ \"$runtime_env_status\" -ne 0 ]; then\n  fail \"backend_link_env failed for target=$target (log: $runtime_env_log)\"\nfi\nruntime_obj=\"\"\nfor token in $runtime_env_line; do\n  case \"$token\" in\n    BACKEND_RUNTIME_OBJ=*)\n      runtime_obj=\"${token#BACKEND_RUNTIME_OBJ=}\"\n      ;;\n  esac\ndone\nif [ \"$runtime_obj\" = \"\" ] || [ ! -s \"$runtime_obj\" ]; then\n  fail \"resolved runtime object missing: $runtime_obj\"\nfi\n\nset +e\n# shellcheck disable=SC2086\nenv $runtime_env_line \\\n  MM=\"${MM:-orc}\" \\\n  ABI=v2_noptr \\\n  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$runtime_free_exe\" \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n  STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n  \"$driver\" >\"$runtime_free_log\" 2>&1\nruntime_free_status=\"$?\"\nset -e\nif [ \"$runtime_fre"
        out = out + "e_status\" -ne 0 ]; then\n  echo \"[verify_backend_mem_exe_emit] runtime-linked build failed (status=$runtime_free_status): $runtime_free_log\" >&2\n  sed -n '1,200p' \"$runtime_free_log\" >&2 || true\n  exit 1\nfi\nif [ ! -s \"$runtime_free_exe\" ]; then\n  fail \"missing runtime-off executable: $runtime_free_exe\"\nfi\nruntime_free_sidecar_obj=\"absent\"\nruntime_free_sidecar_objs_dir=\"absent\"\nruntime_free_sidecar_tmp=\"absent\"\nif [ -e \"$runtime_free_exe.o\" ]; then\n  runtime_free_sidecar_obj=\"present\"\nfi\nif [ -d \"$runtime_free_exe.objs\" ] || [ -d \"$runtime_free_exe.objs.lock\" ]; then\n  runtime_free_sidecar_objs_dir=\"present\"\nfi\nif [ -e \"$runtime_free_exe.tmp\" ]; then\n  runtime_free_sidecar_tmp=\"present\"\nfi\nif [ \"$runtime_free_sidecar_obj\" = \"present\" ] || [ \"$runtime_free_sidecar_objs_dir\" = \"present\" ] || [ \"$runtime_free_sidecar_tmp\" = \"present\" ]; then\n  if [ \"$require_driver_sidecar_zero\" = \"1\" ]; then\n    fail \"runtime-off executable has sidecar residue\"\n  fi\n  rm -f \"$runtime_free_exe.o\" \"$runtime_free_exe.tmp\"\n  rm -rf \"$runtime_free_exe.objs\" \"$runtime_free_exe.objs.lock\"\nfi\n\nset +e\nenv \\\n  MM=\"${MM:-orc}\" \\\n  ABI=v2_noptr \\\n  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_LINKER=self \\\n  BACKEND_CODESIGN=0 \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  BACKEND_KEEP_EXE_OBJ=0 \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINT"
        out = out + "ERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n  STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$chengc_fixture\" --frontend:stage1 --emit:exe --out:\"$chengc_exe\" >\"$chengc_build_log\" 2>&1\nchengc_status=\"$?\"\nset -e\nif [ \"$chengc_status\" -ne 0 ]; then\n  echo \"[verify_backend_mem_exe_emit] chengc emit=exe failed (status=$chengc_status): $chengc_build_log\" >&2\n  sed -n '1,200p' \"$chengc_build_log\" >&2 || true\n  exit 1\nfi\nif [ ! -s \"$chengc_exe\" ]; then\n  fail \"missing chengc executable output: $chengc_exe\"\nfi\nif [ -e \"$chengc_exe.o\" ] || [ -d \"$chengc_exe.objs\" ] || [ -d \"$chengc_exe.objs.lock\" ] || [ -e \"$chengc_exe.tmp\" ]; then\n  fail \"chengc emit=exe path has sidecar residue\"\nfi\n\nmeta_check=\"none\"\ncase \"$target\" in\n  *darwin*)\n    otool_bin=\"$(find_otool || true)\"\n    if [ \"$otool_bin\" = \"\" ]; then\n      fail \"missing otool for darwin metadata checks\"\n    fi\n    set +e\n    \"$otool_bin\" -l \"$chengc_exe\" >\"$meta_log\" 2>&1\n    meta_status=\"$?\"\n    set -e\n    if [ \"$meta_status\" -ne 0 ]; then\n      fail \"otool metadata read failed: $meta_log\"\n    fi\n    if ! rg -q 'LC_MAIN' \"$meta_log\"; then\n      fail \"darwin metadata missing LC_MAIN entry command\"\n    fi\n    if ! rg -q 'LC_DYLD_INFO_ONLY' \"$meta_log\"; then\n      fail \"darwin metadata missing LC_DYLD_INFO_ONLY command\"\n    fi\n    meta_check=\""
        out = out + "darwin.otool\"\n    ;;\n  *linux*)\n    readelf_bin=\"$(find_readelf || true)\"\n    if [ \"$readelf_bin\" = \"\" ]; then\n      fail \"missing readelf/llvm-readelf for linux metadata checks\"\n    fi\n    set +e\n    \"$readelf_bin\" -W -l \"$chengc_exe\" >\"$meta_log\" 2>&1\n    meta_status=\"$?\"\n    set -e\n    if [ \"$meta_status\" -ne 0 ]; then\n      fail \"readelf metadata read failed: $meta_log\"\n    fi\n    if ! rg -q '\\bLOAD\\b' \"$meta_log\"; then\n      fail \"linux metadata missing LOAD segments\"\n    fi\n    meta_check=\"linux.readelf\"\n    ;;\n  *)\n    printf 'metadata check skipped for target=%s\\n' \"$target\" >\"$meta_log\"\n    meta_check=\"skip.$target\"\n    ;;\nesac\n\n{\n  echo \"verify_backend_mem_exe_emit report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"driver=$driver\"\n  echo \"fixture=$fixture\"\n  echo \"chengc_fixture=$chengc_fixture\"\n  echo \"runtime_free_exe=$runtime_free_exe\"\n  echo \"runtime_free_log=$runtime_free_log\"\n  echo \"runtime_free_status=$runtime_free_status\"\n  echo \"runtime_free_sidecar_obj=$runtime_free_sidecar_obj\"\n  echo \"runtime_free_sidecar_objs_dir=$runtime_free_sidecar_objs_dir\"\n  echo \"runtime_free_sidecar_tmp=$runtime_free_sidecar_tmp\"\n  echo \"require_driver_sidecar_zero=$require_driver_sidecar_zero\"\n  echo \"runtime_env_log=$runtime_env_log\"\n  echo \"runtime_obj=$runtime_obj\"\n  echo \"chengc_exe=$chengc_exe\"\n  echo \"chengc_build_log="
        out = out + "$chengc_build_log\"\n  echo \"meta_log=$meta_log\"\n  echo \"meta_check=$meta_check\"\n  echo \"format_emit_markers=$format_emit_markers\"\n  echo \"runtime_merge_markers=$runtime_merge_markers\"\n  echo \"output_tx_markers=$output_tx_markers\"\n  echo \"sidecar_zero_marker=$sidecar_zero_marker\"\n  echo \"sidecar_obj=absent\"\n  echo \"sidecar_objs_dir=absent\"\n  echo \"tmp_residue=absent\"\n} >\"$report\"\n\n{\n  echo \"backend_mem_exe_emit_status=ok\"\n  echo \"backend_mem_exe_emit_target=$target\"\n  echo \"backend_mem_exe_emit_report=$report\"\n  echo \"backend_mem_exe_emit_format_emit_markers=$format_emit_markers\"\n  echo \"backend_mem_exe_emit_runtime_merge_markers=$runtime_merge_markers\"\n  echo \"backend_mem_exe_emit_output_tx_markers=$output_tx_markers\"\n  echo \"backend_mem_exe_emit_runtime_obj=$runtime_obj\"\n} >\"$snapshot\"\n\necho \"verify_backend_mem_exe_emit ok\"\n"
        return out
    if id == "verify_backend_mem_image_core":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_mem_image_core] $1\" >&2\n  exit 1\n}\n\ndriver_help_ok() {\n  bin=\"$1\"\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ncount_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  matches=\"$(rg -n --no-messages -e \"$pattern\" \"$file\" || true)\"\n  if [ \"$matches\" = \"\" ]; then\n    echo \"0\"\n    return\n  fi\n  printf '%s\\n' \"$matches\" | wc -l | tr -d ' '\n}\n\nfind_otool() {\n  if command -v otool >/dev/null 2>&1; then\n    command -v otool\n    return 0\n  fi\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find otool 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf '%s\\n' \"$p\"\n      return 0\n    fi\n  fi\n  return 1\n}\n\nfind_readelf() {\n  for n in readelf llvm-readelf llvm-readelf-19 llvm-readelf-18 llvm-readelf-17 llvm-readelf-16 llvm-readelf-15 llvm-readelf-14; do\n    if command -v"
        out = out + " \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nis_supported_target() {\n  target=\"$1\"\n  case \"$target\" in\n    *apple*darwin*|*darwin*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *linux*|*android*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*riscv64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n    *windows*|*msvc*)\n      case \"$target\" in\n        *arm64*|*aarch64*|*x86_64*|*amd64*) return 0 ;;\n      esac\n      return 1\n      ;;\n  esac\n  return 1\n}\n\nresolve_driver() {\n  path_from_resolver=\"$(BACKEND_DRIVER_PATH_ALLOW_SELFHOST=0 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  for candidate in \\\n    \"${BACKEND_MEM_IMAGE_CORE_DRIVER:-}\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"artifacts/backend_driver/cheng.fixed3\" \\\n    \"dist/releases/current/cheng\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"$path_from_resolver\"; do\n    if [ \"$candidate\" = \"\" ] || [ ! -x \"$candidate\" ]; then\n      continue\n    fi\n    if driver_help_ok \"$candidate\"; then\n      printf '%s\\n' \"$candidate\"\n      return\n    fi\n  done\n  printf '%s\\n' \"\"\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/to"
        out = out + "oling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\ntarget=\"${BACKEND_TARGET:-${BACKEND_MEM_IMAGE_CORE_TARGET:-$host_target}}\"\nif [ \"$target\" = \"\" ]; then\n  target=\"arm64-apple-darwin\"\nfi\nif ! is_supported_target \"$target\"; then\n  fail \"unsupported target: $target\"\nfi\n\ndriver=\"$(resolve_driver)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  fail \"backend driver not executable: $driver\"\nfi\n\nout_dir=\"artifacts/backend_mem_image_core\"\nmkdir -p \"$out_dir\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nexe_path=\"$out_dir/hello_importc_puts.$safe_target\"\ncase \"$target\" in\n  *windows*|*msvc*) exe_path=\"$exe_path.exe\" ;;\nesac\nbuild_log=\"$out_dir/hello_importc_puts.$safe_target.build.log\"\nrun_log=\"$out_dir/hello_importc_puts.$safe_target.run.log\"\nmeta_log=\"$out_dir/hello_importc_puts.$safe_target.meta.log\"\nreport=\"$out_dir/backend_mem_image_core.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_mem_image_core.$safe_target.snapshot.env\"\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$build_log\" \"$run_log\" \"$meta_log\" \"$report\" \"$snapshot\"\nrm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\"\n\nmacho_file=\"src/backend/obj/macho_linker.cheng\"\nelf_file=\"src/backend/obj/elf_linker.cheng\"\ncoff_file=\"src/backend/obj/coff_linker.cheng\"\n\nsymbol_index_markers=0\nsection_layout_markers=0\nrelocat"
        out = out + "ion_apply_markers=0\nentry_symbol_markers=0\nrelocation_guard_markers=0\n\nmacho_symbol_marker=\"$(count_marker \"$macho_file\" 'defIndex: hashmaps\\.HashMapStrInt')\"\nelf_symbol_marker=\"$(count_marker \"$elf_file\" 'var defIndex: hashmaps\\.HashMapStrInt')\"\ncoff_symbol_marker=\"$(count_marker \"$coff_file\" 'var defIndex: hashmaps\\.HashMapStrInt')\"\nsymbol_index_markers=$((macho_symbol_marker + elf_symbol_marker + coff_symbol_marker))\nif [ \"$symbol_index_markers\" -lt 3 ]; then\n  fail \"missing symbol-index markers in linker core files\"\nfi\n\nmacho_layout_marker=\"$(count_marker \"$macho_file\" 'MachoLinkLayout = ref')\"\nelf_layout_marker=\"$(count_marker \"$elf_file\" '# Build combined sections\\.')\"\ncoff_layout_marker=\"$(count_marker \"$coff_file\" '# Build combined sections\\.')\"\nsection_layout_markers=$((macho_layout_marker + elf_layout_marker + coff_layout_marker))\nif [ \"$section_layout_markers\" -lt 3 ]; then\n  fail \"missing section-layout markers in linker core files\"\nfi\n\nmacho_reloc_marker=\"$(count_marker \"$macho_file\" '# Patch relocations \\(in merged text only\\)\\.')\"\nelf_reloc_marker=\"$(count_marker \"$elf_file\" '# Patch relocations\\.')\"\ncoff_reloc_marker=\"$(count_marker \"$coff_file\" '# Patch object relocations\\.')\"\nrelocation_apply_markers=$((macho_reloc_marker + elf_reloc_marker + coff_reloc_marker))\nif [ \"$relocation_apply_markers\" -lt 3 ]; then\n  fail \"missing relocation-apply markers in linker core files\"\nfi\n\n"
        out = out + "macho_entry_marker=\"$(count_marker \"$macho_file\" 'missing _main symbol')\"\nelf_entry_marker=\"$(count_marker \"$elf_file\" 'missing main symbol')\"\ncoff_entry_marker=\"$(count_marker \"$coff_file\" 'missing main symbol')\"\nentry_symbol_markers=$((macho_entry_marker + elf_entry_marker + coff_entry_marker))\nif [ \"$entry_symbol_markers\" -lt 3 ]; then\n  fail \"missing entry-symbol resolution markers in linker core files\"\nfi\n\nmacho_guard_marker=\"$(count_marker \"$macho_file\" 'reloc symIndex out of range')\"\nelf_guard_marker=\"$(count_marker \"$elf_file\" 'reloc symIndex out of range')\"\ncoff_guard_marker=\"$(count_marker \"$coff_file\" 'reloc symIndex out of range')\"\nrelocation_guard_markers=$((macho_guard_marker + elf_guard_marker + coff_guard_marker))\nif [ \"$relocation_guard_markers\" -lt 3 ]; then\n  fail \"missing relocation guard markers in linker core files\"\nfi\n\nset +e\nenv \\\n  MM=\"${MM:-orc}\" \\\n  ABI=v2_noptr \\\n  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_LINKER=self \\\n  BACKEND_CODESIGN=0 \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_INCREMENTAL=0 \\\n  BACKEND_KEEP_EXE_OBJ=0 \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n  STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooli"
        out = out + "ng} chengc \"$fixture\" --frontend:stage1 --emit:exe --out:\"$exe_path\" >\"$build_log\" 2>&1\nbuild_status=\"$?\"\nset -e\nif [ \"$build_status\" -ne 0 ]; then\n  echo \"[verify_backend_mem_image_core] build failed (status=$build_status): $build_log\" >&2\n  sed -n '1,200p' \"$build_log\" >&2 || true\n  exit 1\nfi\n\nif [ ! -s \"$exe_path\" ]; then\n  fail \"missing output executable: $exe_path\"\nfi\nif [ -e \"$exe_path.o\" ]; then\n  fail \"unexpected sidecar object remains: $exe_path.o\"\nfi\nif [ -d \"$exe_path.objs\" ] || [ -d \"$exe_path.objs.lock\" ]; then\n  fail \"unexpected multi-object artifacts remain near: $exe_path\"\nfi\n\nrun_requested=\"${BACKEND_MEM_IMAGE_CORE_RUN:-0}\"\nrun_mode=\"skip\"\nrun_status=\"0\"\nif [ \"$run_requested\" = \"1\" ] && [ \"$target\" = \"$host_target\" ]; then\n  case \"$target\" in\n    *windows*|*msvc*|*android*)\n      run_mode=\"skip\"\n      ;;\n    *)\n      run_mode=\"host\"\n      set +e\n      \"$exe_path\" >\"$run_log\" 2>&1\n      run_status=\"$?\"\n      set -e\n      if [ \"$run_status\" -ne 0 ]; then\n        echo \"[verify_backend_mem_image_core] executable run failed (status=$run_status): $run_log\" >&2\n        sed -n '1,120p' \"$run_log\" >&2 || true\n        exit 1\n      fi\n      ;;\n  esac\nfi\nif [ \"$run_mode\" = \"skip\" ]; then\n  printf 'skip run: requested=%s target=%s host_target=%s\\n' \"$run_requested\" \"$target\" \"$host_target\" >\"$run_log\"\nfi\n\nmeta_check=\"none\"\nsection_order_ok=\"1\"\nentry_"
        out = out + "runtime_ok=\"1\"\ndynamic_runtime_ok=\"1\"\n\ncase \"$target\" in\n  *darwin*)\n    otool_bin=\"$(find_otool || true)\"\n    if [ \"$otool_bin\" = \"\" ]; then\n      fail \"missing otool for darwin metadata checks\"\n    fi\n    set +e\n    \"$otool_bin\" -l \"$exe_path\" >\"$meta_log\" 2>&1\n    meta_status=\"$?\"\n    set -e\n    if [ \"$meta_status\" -ne 0 ]; then\n      fail \"otool metadata read failed: $meta_log\"\n    fi\n    meta_check=\"darwin.otool\"\n    text_line=\"$(awk '$1 == \"sectname\" && $2 == \"__text\" { print NR; exit }' \"$meta_log\")\"\n    cstr_line=\"$(awk '$1 == \"sectname\" && $2 == \"__cstring\" { print NR; exit }' \"$meta_log\")\"\n    data_line=\"$(awk '$1 == \"sectname\" && $2 == \"__data\" { print NR; exit }' \"$meta_log\")\"\n    if [ \"$text_line\" = \"\" ] || [ \"$data_line\" = \"\" ]; then\n      fail \"darwin metadata missing __text/__data sections\"\n    fi\n    if [ \"$text_line\" -ge \"$data_line\" ]; then\n      fail \"darwin section order invalid: __text must precede __data\"\n    fi\n    if [ \"$cstr_line\" != \"\" ] && [ \"$text_line\" -ge \"$cstr_line\" ]; then\n      fail \"darwin section order invalid: __text must precede __cstring\"\n    fi\n    if [ \"$cstr_line\" != \"\" ] && [ \"$cstr_line\" -ge \"$data_line\" ]; then\n      fail \"darwin section order invalid: __cstring must precede __data\"\n    fi\n    if ! rg -q 'LC_MAIN' \"$meta_log\"; then\n      fail \"darwin metadata missing LC_MAIN entry command\"\n    fi\n    if ! "
        out = out + "rg -q 'LC_DYLD_INFO_ONLY' \"$meta_log\"; then\n      fail \"darwin metadata missing LC_DYLD_INFO_ONLY command\"\n    fi\n    ;;\n  *linux*)\n    readelf_bin=\"$(find_readelf || true)\"\n    if [ \"$readelf_bin\" = \"\" ]; then\n      fail \"missing readelf/llvm-readelf for linux metadata checks\"\n    fi\n    set +e\n    \"$readelf_bin\" -W -l \"$exe_path\" >\"$meta_log\" 2>&1\n    meta_status=\"$?\"\n    set -e\n    if [ \"$meta_status\" -ne 0 ]; then\n      fail \"readelf metadata read failed: $meta_log\"\n    fi\n    meta_check=\"linux.readelf\"\n    if ! rg -q 'INTERP' \"$meta_log\"; then\n      fail \"linux metadata missing INTERP segment\"\n    fi\n    if ! rg -q 'DYNAMIC' \"$meta_log\"; then\n      fail \"linux metadata missing DYNAMIC segment\"\n    fi\n    load_count=\"$(rg -n '\\bLOAD\\b' \"$meta_log\" | wc -l | tr -d ' ')\"\n    if [ \"$load_count\" -lt 2 ]; then\n      fail \"linux metadata LOAD segment count too small: $load_count\"\n    fi\n    ;;\n  *)\n    printf 'metadata check skipped for target=%s\\n' \"$target\" >\"$meta_log\"\n    meta_check=\"skip.$target\"\n    ;;\nesac\n\n{\n  echo \"verify_backend_mem_image_core report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"driver=$driver\"\n  echo \"fixture=$fixture\"\n  echo \"exe=$exe_path\"\n  echo \"build_log=$build_log\"\n  echo \"run_log=$run_log\"\n  echo \"meta_log=$meta_log\"\n  echo \"run_mode=$run_mode\"\n  echo \"run_status=$run_status\"\n  echo \""
        out = out + "meta_check=$meta_check\"\n  echo \"symbol_index_markers=$symbol_index_markers\"\n  echo \"section_layout_markers=$section_layout_markers\"\n  echo \"relocation_apply_markers=$relocation_apply_markers\"\n  echo \"entry_symbol_markers=$entry_symbol_markers\"\n  echo \"relocation_guard_markers=$relocation_guard_markers\"\n  echo \"section_order_ok=$section_order_ok\"\n  echo \"entry_runtime_ok=$entry_runtime_ok\"\n  echo \"dynamic_runtime_ok=$dynamic_runtime_ok\"\n  echo \"sidecar_obj=absent\"\n  echo \"sidecar_objs_dir=absent\"\n} >\"$report\"\n\n{\n  echo \"backend_mem_image_core_status=ok\"\n  echo \"backend_mem_image_core_target=$target\"\n  echo \"backend_mem_image_core_report=$report\"\n  echo \"backend_mem_image_core_symbol_index_markers=$symbol_index_markers\"\n  echo \"backend_mem_image_core_section_layout_markers=$section_layout_markers\"\n  echo \"backend_mem_image_core_relocation_apply_markers=$relocation_apply_markers\"\n  echo \"backend_mem_image_core_entry_symbol_markers=$entry_symbol_markers\"\n  echo \"backend_mem_image_core_relocation_guard_markers=$relocation_guard_markers\"\n} >\"$snapshot\"\n\necho \"verify_backend_mem_image_core ok\"\n"
        return out
    if id == "verify_backend_mem_patch_regression":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfail() {\n  echo \"[verify_backend_mem_patch_regression] $1\" >&2\n  exit 1\n}\n\nnow_ms() {\n  if command -v perl >/dev/null 2>&1; then\n    perl -MTime::HiRes=time -e 'printf \"%.0f\\n\", time() * 1000'\n    return 0\n  fi\n  echo \"$(( $(date +%s) * 1000 ))\"\n}\n\nread_report_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nas_uint_or_default() {\n  raw=\"$1\"\n  fallback=\"$2\"\n  case \"$raw\" in\n    ''|*[!0-9]*)\n      echo \"$fallback\"\n      ;;\n    *)\n      echo \"$raw\"\n      ;;\n  esac\n}\n\nfile_digest() {\n  path=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$path\" | awk '{print $1}'\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$path\" | awk '{print $1}'\n    return 0\n  fi\n  cksum \"$path\" | awk '{"
        out = out + "print $1 \":\" $2}'\n}\n\nhost_target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || true)\"\nif [ \"$host_target\" = \"\" ]; then\n  host_target=\"unknown\"\nfi\n\nselect_target() {\n  if [ \"${BACKEND_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_TARGET}\"\n    return\n  fi\n  if [ \"${BACKEND_HOTPATCH_TARGET:-}\" != \"\" ]; then\n    printf '%s\\n' \"${BACKEND_HOTPATCH_TARGET}\"\n    return\n  fi\n  if [ \"$host_target\" != \"unknown\" ]; then\n    printf '%s\\n' \"$host_target\"\n    return\n  fi\n  printf '%s\\n' \"arm64-apple-darwin\"\n}\n\ntarget=\"$(select_target)\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nmin_speedup_x100=\"$(as_uint_or_default \"${BACKEND_MEM_PATCH_MIN_SPEEDUP_X100:-100}\" \"100\")\"\n\nout_dir=\"artifacts/backend_mem_patch_regression\"\nmkdir -p \"$out_dir\"\nfastpath_log=\"$out_dir/backend_mem_patch_regression.$safe_target.fastpath.log\"\ninplace_log=\"$out_dir/backend_mem_patch_regression.$safe_target.inplace.log\"\nreport=\"$out_dir/backend_mem_patch_regression.$safe_target.report.txt\"\nsnapshot=\"$out_dir/backend_mem_patch_regression.$safe_target.snapshot.env\"\n\nrm -f \"$fastpath_log\" \"$inplace_log\" \"$report\" \"$snapshot\"\n\ndet_start_ms=\"$(now_ms)\"\nfixture=\"${BACKEND_DUAL_TRACK_FIXTURE:-tests/cheng/backend/fixtures/return_add.cheng}\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\n"
        out = out + "fi\ndet_exe=\"$out_dir/determinism.out.$safe_target\"\ndet_build_log=\"$out_dir/determinism.build.log\"\nrm -f \"$det_exe\" \"$det_exe.o\" \"$det_build_log\"\n\ndet_compile() {\n  preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-self}\"\n  no_runtime_c=\"1\"\n  if [ \"$preferred_linker\" = \"system\" ]; then\n    no_runtime_c=\"0\"\n  fi\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_LINKER=\"$preferred_linker\" \\\n    BACKEND_RUNTIME=off \\\n    BACKEND_NO_RUNTIME_C=\"$no_runtime_c\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --skip-pkg --out:\"$det_exe\" >\"$det_build_log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" -ne 0 ] && [ \"$preferred_linker\" = \"self\" ]; then\n    env \\\n      ABI=v2_noptr \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_LINKER=system \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$fixture\" --skip-pkg --out:\"$det_exe\" >>\"$det_build_log\" 2>&1\n    status=\"$?\"\n "
        out = out + " fi\n  set -e\n  return \"$status\"\n}\n\nif ! det_compile; then\n  echo \"[verify_backend_mem_patch_regression] determinism compile failed: $det_build_log\" >&2\n  sed -n '1,160p' \"$det_build_log\" >&2 || true\n  exit 1\nfi\nsha_a=\"$(file_digest \"$det_exe\")\"\nif ! det_compile; then\n  echo \"[verify_backend_mem_patch_regression] determinism compile second run failed: $det_build_log\" >&2\n  sed -n '1,160p' \"$det_build_log\" >&2 || true\n  exit 1\nfi\nsha_b=\"$(file_digest \"$det_exe\")\"\ndet_end_ms=\"$(now_ms)\"\ndet_ms=$((det_end_ms - det_start_ms))\nif [ \"$sha_a\" = \"\" ] || [ \"$sha_b\" = \"\" ] || [ \"$sha_a\" != \"$sha_b\" ]; then\n  fail \"determinism mismatch: sha_a=$sha_a sha_b=$sha_b (log=$det_build_log)\"\nfi\ndet_digest=\"$sha_a\"\n\nfastpath_start_ms=\"$(now_ms)\"\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_incr_patch_fastpath >\"$fastpath_log\" 2>&1\nfastpath_status_code=\"$?\"\nset -e\nfastpath_end_ms=\"$(now_ms)\"\nfastpath_gate_ms=$((fastpath_end_ms - fastpath_start_ms))\nif [ \"$fastpath_status_code\" -ne 0 ]; then\n  echo \"[verify_backend_mem_patch_regression] incr_patch_fastpath gate failed (status=$fastpath_status_code): $fastpath_log\" >&2\n  sed -n '1,200p' \"$fastpath_log\" >&2 || true\n  exit 1\nfi\n\nfastpath_report=\"artifacts/backend_incr_patch_fastpath/backend_incr_patch_fastpath.$safe_target.report.txt\"\nif [ ! -f \"$fastpath_report\" ]; then\n  fail \"missing incr_patch_fastpath report: $fastpath_r"
        out = out + "eport\"\nfi\nfastpath_status=\"$(read_report_value \"status\" \"$fastpath_report\")\"\nif [ \"$fastpath_status\" = \"skip\" ]; then\n  {\n    echo \"verify_backend_mem_patch_regression report\"\n    echo \"status=skip\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n    echo \"reason=incr_patch_fastpath_skip\"\n    echo \"determinism_log=$det_build_log\"\n    echo \"fastpath_log=$fastpath_log\"\n    echo \"fastpath_report=$fastpath_report\"\n  } >\"$report\"\n  {\n    echo \"backend_mem_patch_regression_status=skip\"\n    echo \"backend_mem_patch_regression_target=$target\"\n    echo \"backend_mem_patch_regression_report=$report\"\n  } >\"$snapshot\"\n  echo \"verify_backend_mem_patch_regression skip: target=$target\"\n  exit 0\nfi\nif [ \"$fastpath_status\" != \"ok\" ]; then\n  fail \"incr_patch_fastpath status is not ok: $fastpath_status\"\nfi\n\nfull_build_ms=\"$(as_uint_or_default \"$(read_report_value \"full_build_ms\" \"$fastpath_report\")\" \"0\")\"\nfastpath_apply_ms=\"$(as_uint_or_default \"$(read_report_value \"inplace_apply_ms\" \"$fastpath_report\")\" \"0\")\"\nspeedup_x100=\"$(as_uint_or_default \"$(read_report_value \"speedup_x100\" \"$fastpath_report\")\" \"0\")\"\ndirty_count=\"$(as_uint_or_default \"$(read_report_value \"dirty_count\" \"$fastpath_report\")\" \"0\")\"\nif [ \"$full_build_ms\" -le 0 ] || [ \"$fastpath_apply_ms\" -le 0 ]; then\n  fail \"invalid latency fields in fastpath report: full_build_ms=$full_build_ms inplace_apply_ms"
        out = out + "=$fastpath_apply_ms\"\nfi\nif [ \"$speedup_x100\" -lt \"$min_speedup_x100\" ]; then\n  fail \"latency regression: speedup_x100=$speedup_x100 min_speedup_x100=$min_speedup_x100\"\nfi\n\ninplace_start_ms=\"$(now_ms)\"\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_hotpatch_inplace >\"$inplace_log\" 2>&1\ninplace_status_code=\"$?\"\nset -e\ninplace_end_ms=\"$(now_ms)\"\ninplace_gate_ms=$((inplace_end_ms - inplace_start_ms))\nif [ \"$inplace_status_code\" -ne 0 ]; then\n  echo \"[verify_backend_mem_patch_regression] hotpatch_inplace gate failed (status=$inplace_status_code): $inplace_log\" >&2\n  sed -n '1,200p' \"$inplace_log\" >&2 || true\n  exit 1\nfi\n\ninplace_report=\"artifacts/backend_hotpatch_inplace/backend_hotpatch_inplace.$safe_target.report.txt\"\nif [ ! -f \"$inplace_report\" ]; then\n  fail \"missing hotpatch_inplace report: $inplace_report\"\nfi\ninplace_status=\"$(read_report_value \"status\" \"$inplace_report\")\"\nif [ \"$inplace_status\" = \"skip\" ]; then\n  {\n    echo \"verify_backend_mem_patch_regression report\"\n    echo \"status=skip\"\n    echo \"target=$target\"\n    echo \"host_target=$host_target\"\n    echo \"reason=hotpatch_inplace_skip\"\n    echo \"determinism_log=$det_build_log\"\n    echo \"fastpath_log=$fastpath_log\"\n    echo \"inplace_log=$inplace_log\"\n    echo \"fastpath_report=$fastpath_report\"\n    echo \"inplace_report=$inplace_report\"\n  } >\"$report\"\n  {\n    echo \"backend_mem_patch_regression_"
        out = out + "status=skip\"\n    echo \"backend_mem_patch_regression_target=$target\"\n    echo \"backend_mem_patch_regression_report=$report\"\n  } >\"$snapshot\"\n  echo \"verify_backend_mem_patch_regression skip: target=$target\"\n  exit 0\nfi\nif [ \"$inplace_status\" != \"ok\" ]; then\n  fail \"hotpatch_inplace status is not ok: $inplace_status\"\nfi\n\ninplace_apply_ms=\"$(as_uint_or_default \"$(read_report_value \"apply_ms\" \"$inplace_report\")\" \"0\")\"\nappend_commit_kind=\"$(read_report_value \"append_commit_kind\" \"$inplace_report\")\"\ngrowth_restart_commit_kind=\"$(read_report_value \"growth_restart_commit_kind\" \"$inplace_report\")\"\nlayout_restart_commit_kind=\"$(read_report_value \"layout_restart_commit_kind\" \"$inplace_report\")\"\ncompile_fail_status=\"$(as_uint_or_default \"$(read_report_value \"compile_fail_status\" \"$inplace_report\")\" \"0\")\"\nhost_pid=\"$(read_report_value \"host_pid\" \"$inplace_report\")\"\nhost_pid_final=\"$(read_report_value \"host_pid_final\" \"$inplace_report\")\"\nmarker_tx_total=\"$(as_uint_or_default \"$(read_report_value \"marker_tx_total\" \"$inplace_report\")\" \"0\")\"\n\nif [ \"$append_commit_kind\" != \"append\" ]; then\n  fail \"append commit mismatch: $append_commit_kind\"\nfi\ncase \"$growth_restart_commit_kind\" in\n  restart_*) ;;\n  *) fail \"growth restart path missing: $growth_restart_commit_kind\" ;;\nesac\nif [ \"$layout_restart_commit_kind\" != \"restart_layout_change\" ]; then\n  fail \"layout restart path missing:"
        out = out + " $layout_restart_commit_kind\"\nfi\nif [ \"$compile_fail_status\" = \"0\" ]; then\n  fail \"compile failure rollback path missing\"\nfi\nif [ \"$host_pid\" = \"\" ] || [ \"$host_pid_final\" = \"\" ] || [ \"$host_pid\" != \"$host_pid_final\" ]; then\n  fail \"host pid stability regression: host_pid=$host_pid host_pid_final=$host_pid_final\"\nfi\nif [ \"$marker_tx_total\" -lt 4 ]; then\n  fail \"transaction markers insufficient: marker_tx_total=$marker_tx_total\"\nfi\n\n{\n  echo \"verify_backend_mem_patch_regression report\"\n  echo \"status=ok\"\n  echo \"target=$target\"\n  echo \"host_target=$host_target\"\n  echo \"determinism_ok=1\"\n  echo \"latency_ok=1\"\n  echo \"append_commit_ok=1\"\n  echo \"restart_fallback_ok=1\"\n  echo \"pid_stable_ok=1\"\n  echo \"determinism_gate=chengc_double_build\"\n  echo \"determinism_gate_ms=$det_ms\"\n  echo \"determinism_exe=$det_exe\"\n  echo \"determinism_digest=$det_digest\"\n  echo \"determinism_log=$det_build_log\"\n  echo \"fastpath_gate=src/tooling/verify_backend_incr_patch_fastpath.sh\"\n  echo \"fastpath_gate_ms=$fastpath_gate_ms\"\n  echo \"fastpath_report=$fastpath_report\"\n  echo \"fastpath_log=$fastpath_log\"\n  echo \"full_build_ms=$full_build_ms\"\n  echo \"fastpath_apply_ms=$fastpath_apply_ms\"\n  echo \"speedup_x100=$speedup_x100\"\n  echo \"min_speedup_x100=$min_speedup_x100\"\n  echo \"dirty_count=$dirty_count\"\n  echo \"inplace_gate=src/tooling/verify_backend_hotpatch_inplace.sh\"\n  echo \"inplace_gate_ms=$inplac"
        out = out + "e_gate_ms\"\n  echo \"inplace_report=$inplace_report\"\n  echo \"inplace_log=$inplace_log\"\n  echo \"inplace_apply_ms=$inplace_apply_ms\"\n  echo \"append_commit_kind=$append_commit_kind\"\n  echo \"growth_restart_commit_kind=$growth_restart_commit_kind\"\n  echo \"layout_restart_commit_kind=$layout_restart_commit_kind\"\n  echo \"compile_fail_status=$compile_fail_status\"\n  echo \"host_pid=$host_pid\"\n  echo \"host_pid_final=$host_pid_final\"\n  echo \"marker_tx_total=$marker_tx_total\"\n} >\"$report\"\n\n{\n  echo \"backend_mem_patch_regression_status=ok\"\n  echo \"backend_mem_patch_regression_target=$target\"\n  echo \"backend_mem_patch_regression_report=$report\"\n  echo \"backend_mem_patch_regression_speedup_x100=$speedup_x100\"\n  echo \"backend_mem_patch_regression_dirty_count=$dirty_count\"\n  echo \"backend_mem_patch_regression_host_pid=$host_pid\"\n  echo \"backend_mem_patch_regression_host_pid_final=$host_pid_final\"\n} >\"$snapshot\"\n\necho \"verify_backend_mem_patch_regression ok\"\n"
        return out
    if id == "verify_backend_metering_stream":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_metering_stream] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_metering_stream] rg is required\" 1>&2\n  exit 2\nfi\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nrequire_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  marker_name=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    echo \"[verify_backend_metering_stream] missing marker ($marker_name) in $file\" 1>&2\n    exit 1\n  fi\n}\n\ncompile_mete"
        out = out + "ring_obj() {\n  mode=\"$1\"\n  out_obj=\"$2\"\n  out_log=\"$3\"\n\n  set +e\n  env \\\n    PLUGIN_ENABLE=1 \\\n    PLUGIN_PATHS= \\\n    METERING_PLUGIN=metering.default \\\n    STAGE1_STD_NO_POINTERS=0 \\\n    STAGE1_STD_NO_POINTERS_STRICT=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n    STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n    BACKEND_PROFILE=1 \\\n    BACKEND_MULTI=\"$mode\" \\\n    BACKEND_MULTI_FORCE=\"$mode\" \\\n    BACKEND_JOBS=\"${BACKEND_JOBS:-4}\" \\\n    BACKEND_ALLOW_NO_MAIN=1 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_INPUT=src/decentralized/metering.cheng \\\n    BACKEND_OUTPUT=\"$out_obj\" \\\n    \"$driver\" >\"$out_log\" 2>&1\n  status=\"$?\"\n  set -e\n  return \"$status\"\n}\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nout_dir=\"artifacts/backend_metering_stream\"\nmkdir -p \"$out_dir\"\n\nserial_log=\"$out_dir/metering_stream.serial.$safe_target.log\"\nmulti_log=\"$out_dir/metering_stream.multi.$safe_target.log\"\nserial_obj=\"$out_dir/metering_stream.serial.$safe_target.o\"\nmulti_obj=\"$out_dir/metering_stream.multi.$safe_target.o\"\nreport_file=\"$out_di"
        out = out + "r/backend_metering_stream.report.txt\"\nsnapshot_file=\"$out_dir/backend_metering_stream.snapshot.env\"\ndiff_file=\"$out_dir/backend_metering_stream.obj.diff.txt\"\n\nrm -f \"$serial_log\" \"$multi_log\" \"$serial_obj\" \"$multi_obj\" \"$report_file\" \"$snapshot_file\" \"$diff_file\"\n\n# DEC-01: metering injection points must stay stable.\nrequire_marker \"src/decentralized/metering_sdk.cheng\" 'template withMetering\\(' 'metering_sdk_with_metering'\nrequire_marker \"src/decentralized/metering_sdk.cheng\" 'template withIoMetering\\(' 'metering_sdk_with_io_metering'\nrequire_marker \"src/decentralized/metering_sdk.cheng\" 'template withMeteringIo\\(' 'metering_sdk_with_metering_io'\nrequire_marker \"src/decentralized/metering_sdk.cheng\" 'os.setIoMeterHook' 'metering_sdk_io_hook_install'\nrequire_marker \"src/decentralized/metering_sdk.cheng\" 'appendComputeEventWithMode' 'metering_sdk_flush_ledger'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'getEnv \"METERING_PLUGIN\"' 'uir_metering_plugin_env'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'strHasPrefix\\(path, \"cheng/decentralized/\"\\)' 'uir_metering_plugin_scope'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'fn uirCoreApplyAstPluginHooks' 'uir_ast_plugin_hook'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'fn uirCoreApplyMirPluginHooks' 'uir_mir_plugin_hook'\n\n# DEC-03: gas formula contract must remain explicit."
        out = out + "\nrequire_marker \"src/decentralized/metering.cheng\" 'let cpuCost: float64 = float64\\(usage.cpuMs\\) \\* usage.priceCpuMs' 'gas_cpu_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'let memCost: float64 = \\(float64\\(usage.memBytes\\) / \\(1024.0 \\* 1024.0 \\* 1024.0\\)\\) \\* usage.priceMemGb' 'gas_mem_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'let ioCost: float64 = \\(float64\\(usage.ioBytes\\) / \\(1024.0 \\* 1024.0 \\* 1024.0\\)\\) \\* usage.priceIoGb' 'gas_io_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'let gpuCost: float64 = float64\\(usage.gpuMs\\) \\* usage.priceGpuMs' 'gas_gpu_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'let gpuMemCost: float64 = \\(float64\\(usage.gpuMemBytes\\) / \\(1024.0 \\* 1024.0 \\* 1024.0\\)\\) \\* usage.priceGpuMemGb' 'gas_gpu_mem_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'cost.total = cpuCost \\+ memCost \\+ ioCost \\+ gpuCost \\+ gpuMemCost' 'gas_total_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'cost.royalty = cost.total \\* usage.royaltyRate' 'gas_royalty_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'cost.treasury = cost.total \\* usage.treasuryRate' 'gas_treasury_formula'\nrequire_marker \"src/decentralized/metering.cheng\" 'cost.executor = cost.total - cost.royalty - cost.treasury' 'gas_executor_formula'\n\n# DEC-02: streaming compile path must at least pass with multi mode.\nset +e\ncompile_metering_obj 0 \"$"
        out = out + "serial_obj\" \"$serial_log\"\nserial_status=\"$?\"\ncompile_metering_obj 1 \"$multi_obj\" \"$multi_log\"\nmulti_status=\"$?\"\nset -e\n\nif [ \"$serial_status\" -ne 0 ]; then\n  echo \"[verify_backend_metering_stream] serial compile failed (status=$serial_status): $serial_log\" 1>&2\n  sed -n '1,120p' \"$serial_log\" 1>&2 || true\n  exit 1\nfi\nif [ \"$multi_status\" -ne 0 ]; then\n  echo \"[verify_backend_metering_stream] streaming compile failed (status=$multi_status): $multi_log\" 1>&2\n  sed -n '1,120p' \"$multi_log\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$serial_obj\" ] || [ ! -s \"$multi_obj\" ]; then\n  echo \"[verify_backend_metering_stream] missing object output(s)\" 1>&2\n  exit 1\nfi\n\nif ! rg -q 'backend_profile[[:space:]]+build_module' \"$serial_log\"; then\n  echo \"[verify_backend_metering_stream] serial compile log missing backend_profile build_module\" 1>&2\n  exit 1\nfi\nif ! rg -q 'backend_profile[[:space:]]+build_module' \"$multi_log\"; then\n  echo \"[verify_backend_metering_stream] streaming compile log missing backend_profile build_module\" 1>&2\n  exit 1\nfi\n\nstreaming_path_mode=\"\"\nif rg -q 'backend_profile[[:space:]]+multi\\.plan' \"$multi_log\"; then\n  streaming_path_mode=\"multi.plan\"\nelif rg -q 'backend_profile[[:space:]]+single\\.emit_obj' \"$multi_log\"; then\n  streaming_path_mode=\"single.emit_obj.fastpath\"\nelse\n  echo \"[verify_backend_metering_stream] streaming compile log missing multi/single emit marker\" 1>&2\n  exit 1\nfi\n\n"
        out = out + "serial_sha=\"$(hash_file \"$serial_obj\")\"\nmulti_sha=\"$(hash_file \"$multi_obj\")\"\nobj_identical=\"1\"\nif ! cmp -s \"$serial_obj\" \"$multi_obj\"; then\n  obj_identical=\"0\"\n  {\n    echo \"serial_obj=$serial_obj\"\n    echo \"multi_obj=$multi_obj\"\n    echo \"serial_sha256=$serial_sha\"\n    echo \"multi_sha256=$multi_sha\"\n  } >\"$diff_file\"\nfi\n\nif [ \"$obj_identical\" != \"1\" ]; then\n  echo \"[verify_backend_metering_stream] gas consistency drift: serial/multi object mismatch\" 1>&2\n  echo \"  diff: $diff_file\" 1>&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_metering_stream report\"\n  echo \"status=ok\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"serial_obj=$serial_obj\"\n  echo \"multi_obj=$multi_obj\"\n  echo \"serial_obj_sha256=$serial_sha\"\n  echo \"multi_obj_sha256=$multi_sha\"\n  echo \"obj_identical=$obj_identical\"\n  echo \"streaming_path_mode=$streaming_path_mode\"\n  echo \"serial_log=$serial_log\"\n  echo \"multi_log=$multi_log\"\n  echo \"metering_injection_points=ok\"\n  echo \"metering_gas_formula=ok\"\n} >\"$report_file\"\n\n{\n  echo \"backend_metering_stream_target=$target\"\n  echo \"backend_metering_stream_driver=$driver\"\n  echo \"backend_metering_stream_serial_obj_sha256=$serial_sha\"\n  echo \"backend_metering_stream_multi_obj_sha256=$multi_sha\"\n  echo \"backend_metering_stream_obj_identical=$obj_identical\"\n  echo \"backend_metering_stream_streaming_path_mode=$streaming_path_mode\"\n  echo \"backend_meter"
        out = out + "ing_stream_report=$report_file\"\n} >\"$snapshot_file\"\n\necho \"verify_backend_metering_stream ok\"\n"
        return out
    if id == "verify_backend_mir_borrow":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nnormalize_lower_trim() {\n  printf '%s' \"$1\" | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'\n}\n\nextract_report_field() {\n  line=\"$1\"\n  key=\"$2\"\n  printf '%s\\n' \"$line\" | tr '\\t' '\\n' | awk -F= -v key=\"$key\" '$1 == key { print substr($0, index($0, \"=\") + 1); exit }'\n}\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nis_true_like() {\n  case \"$1\" in\n    1|true|TRUE|yes|YES|on|ON)\n      return 0\n      ;;\n  esac\n  return 1\n}\n\nrequire_stage_label_any() {\n  log_file=\"$1\"\n  expected_labels=\"$2\"\n  gate_name=\"$3\"\n  matched=\"0\"\n  for expected_stage_label in $(printf '%s' \"$expected_labels\" | tr ';' ' '); do\n    if grep -Fq \"[backend] stage1: $expected_stage_label\" \"$log_file\"; then\n      matched=\"1\"\n      break\n    fi\n  done\n  if [ \"$matched\" != \"1\" ]; then\n    echo \"[verify_backend_mir_borrow] missing stage labels for $gate_name: $exp"
        out = out + "ected_labels\" 1>&2\n    echo \"  log: $log_file\" 1>&2\n    exit 1\n  fi\n}\n\nrequire_stamp_field_exact() {\n  stamp_file=\"$1\"\n  field_key=\"$2\"\n  expected_value=\"$3\"\n  if ! grep -Fxq \"$field_key=$expected_value\" \"$stamp_file\"; then\n    echo \"[verify_backend_mir_borrow] compile stamp mismatch: $field_key expected=$expected_value file=$stamp_file\" 1>&2\n    exit 1\n  fi\n}\n\ndriver_has_marker() {\n  marker=\"$1\"\n  if ! command -v strings >/dev/null 2>&1; then\n    return 1\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$driver\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  rg -q \"$marker\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_mir_borrow] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\nif ! driver_has_marker \"generics_report\"; then\n  echo \"[verify_backend_mir_borrow] backend driver missing generics_report marker: $driver\" 1>&2\n  exit 1\nfi\nif ! driver_has_marker \"high_uir_checked_funcs\""
        out = out + "; then\n  echo \"[verify_backend_mir_borrow] backend driver missing high_uir_checked_funcs marker: $driver\" 1>&2\n  exit 1\nfi\nif ! driver_has_marker \"low_uir_lowered_funcs\"; then\n  echo \"[verify_backend_mir_borrow] backend driver missing low_uir_lowered_funcs marker: $driver\" 1>&2\n  exit 1\nfi\nif ! driver_has_marker \"high_uir_fallback_funcs\"; then\n  echo \"[verify_backend_mir_borrow] backend driver missing high_uir_fallback_funcs marker: $driver\" 1>&2\n  exit 1\nfi\n\n# Keep MIR borrow gate focused on borrow/lowering policy checks, not closure no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo auto)}\"\nborrow_ir=\"$(normalize_lower_trim \"${BORROW_IR:-mir}\")\"\ngeneric_lowering=\"$(normalize_lower_trim \"${GENERIC_LOWERING:-mir_hybrid}\")\"\ngeneric_mode=\"$(normalize_lower_trim \"${MIR_BORROW_GENERIC_MODE:-${GENERIC_MODE:-dict}}\")\"\ngeneric_budget=\"${MIR_BORROW_GENERIC_SPEC_BUDGET:-${GENERIC_SPEC_BUDGET:-0}}\"\nskip_sem=\"${MIR_BORROW_SKIP_SEM:-0}\"\nskip_ownership=\"${MIR_BORROW_SKIP_OWNERSHIP:-1}\"\nborrow_fixture=\"${MIR_BORROW_FIXTURE:-tests/cheng/backend/fixtures/return_add.cheng}\"\ngeneric_fixture=\"${MIR_BORROW_GENERIC_FIXTURE:-tests/cheng/backend/fixtures/return_hashmaps_bracket.cheng}\"\nif [ \""
        out = out + "${MIR_BORROW_FIXTURE:-}\" = \"\" ] && [ ! -f \"$borrow_fixture\" ]; then\n  borrow_fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\n\nskip_sem_norm=\"0\"\nif is_true_like \"$skip_sem\"; then\n  skip_sem_norm=\"1\"\nfi\nskip_ownership_norm=\"0\"\nif is_true_like \"$skip_ownership\"; then\n  skip_ownership_norm=\"1\"\nfi\n\nif ! is_uint \"$generic_budget\"; then\n  echo \"[verify_backend_mir_borrow] invalid generic budget: $generic_budget\" 1>&2\n  exit 2\nfi\nif [ \"$borrow_ir\" != \"mir\" ] && [ \"$borrow_ir\" != \"stage1\" ]; then\n  echo \"[verify_backend_mir_borrow] invalid BORROW_IR: $borrow_ir (expected mir|stage1)\" 1>&2\n  exit 2\nfi\nif [ \"$generic_lowering\" != \"mir_hybrid\" ] && [ \"$generic_lowering\" != \"mir_dict\" ]; then\n  echo \"[verify_backend_mir_borrow] invalid GENERIC_LOWERING: $generic_lowering (expected mir_hybrid|mir_dict)\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$borrow_fixture\" ]; then\n  echo \"[verify_backend_mir_borrow] missing borrow fixture: $borrow_fixture\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$generic_fixture\" ]; then\n  echo \"[verify_backend_mir_borrow] missing generic fixture: $generic_fixture\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_mir_borrow\"\nmkdir -p \"$out_dir\"\nborrow_obj=\"$out_dir/mir_borrow_check.o\"\nborrow_log=\"$out_dir/mir_borrow_check.log\"\nborrow_stamp=\"$out_dir/mir_borrow_check.compile_stamp.txt\"\ngeneric_obj=\"$out_dir/mir_borrow_generic_check.o\"\ngeneric_log=\"$out_dir/mir_borrow_generic_check.log\""
        out = out + "\ngeneric_stamp=\"$out_dir/mir_borrow_generic_check.compile_stamp.txt\"\nownership_on_obj=\"$out_dir/mir_borrow_ownership_on_check.o\"\nownership_on_log=\"$out_dir/mir_borrow_ownership_on_check.log\"\nownership_on_stamp=\"$out_dir/mir_borrow_ownership_on_check.compile_stamp.txt\"\ndefault_policy_obj=\"$out_dir/mir_borrow_default_policy_check.o\"\ndefault_policy_log=\"$out_dir/mir_borrow_default_policy_check.log\"\ndefault_policy_stamp=\"$out_dir/mir_borrow_default_policy_check.compile_stamp.txt\"\nsnapshot_file=\"$out_dir/mir_borrow.snapshot.env\"\nreport_file=\"$out_dir/mir_borrow.report.txt\"\n\ncompile_fixture() {\n  fixture=\"$1\"\n  out_obj=\"$2\"\n  out_log=\"$3\"\n  out_stamp=\"$4\"\n  ownership_mode=\"$5\"\n  rm -f \"$out_obj\" \"$out_log\" \"$out_stamp\"\n  set +e\n  if [ \"$ownership_mode\" = \"default\" ]; then\n    env \\\n      UIR_PROFILE=1 \\\n      BACKEND_DEBUG_STAGE1_PIPE=1 \\\n      BORROW_IR=\"$borrow_ir\" \\\n      GENERIC_LOWERING=\"$generic_lowering\" \\\n      GENERIC_MODE=\"$generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n      BACKEND_COMPILE_STAMP_OUT=\"$out_stamp\" \\\n      STAGE1_SKIP_SEM=\"$skip_sem_norm\" \\\n      STAGE1_SKIP_OWNERSHIP= \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1\n  elif [ \"$ownership_mode\" = \"forced_on\" ]; then\n    env \\\n      UIR_"
        out = out + "PROFILE=1 \\\n      BACKEND_DEBUG_STAGE1_PIPE=1 \\\n      BORROW_IR=\"$borrow_ir\" \\\n      GENERIC_LOWERING=\"$generic_lowering\" \\\n      GENERIC_MODE=\"$generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n      BACKEND_COMPILE_STAMP_OUT=\"$out_stamp\" \\\n      STAGE1_SKIP_SEM=\"$skip_sem_norm\" \\\n      STAGE1_SKIP_OWNERSHIP=0 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1\n  else\n    env \\\n      UIR_PROFILE=1 \\\n      BACKEND_DEBUG_STAGE1_PIPE=1 \\\n      BORROW_IR=\"$borrow_ir\" \\\n      GENERIC_LOWERING=\"$generic_lowering\" \\\n      GENERIC_MODE=\"$generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n      BACKEND_COMPILE_STAMP_OUT=\"$out_stamp\" \\\n      STAGE1_SKIP_SEM=\"$skip_sem_norm\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$skip_ownership_norm\" \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1\n  fi\n  status=\"$?\"\n  set -e\n  return \"$status\"\n}\n\nborrow_status=\"0\"\ngeneric_status=\"0\"\nownership_on_status=\"0\"\ndefault_policy_status=\"0\"\ncompile_fixture \"$borrow_fixture\" \"$borrow_obj\" \"$borrow_log\" \"$borrow_stamp\" \"explicit\" || borrow_status=\"$?\"\ncompile_fixture \"$generic_f"
        out = out + "ixture\" \"$generic_obj\" \"$generic_log\" \"$generic_stamp\" \"explicit\" || generic_status=\"$?\"\ncompile_fixture \"$generic_fixture\" \"$ownership_on_obj\" \"$ownership_on_log\" \"$ownership_on_stamp\" \"forced_on\" || ownership_on_status=\"$?\"\ncompile_fixture \"$borrow_fixture\" \"$default_policy_obj\" \"$default_policy_log\" \"$default_policy_stamp\" \"default\" || default_policy_status=\"$?\"\n\nif [ \"$borrow_status\" != \"0\" ] || [ ! -s \"$borrow_obj\" ]; then\n  echo \"[verify_backend_mir_borrow] compile failed: $borrow_fixture\" 1>&2\n  echo \"  log: $borrow_log\" 1>&2\n  echo \"  status: $borrow_status\" 1>&2\n  exit 1\nfi\nif [ \"$generic_status\" != \"0\" ] || [ ! -s \"$generic_obj\" ]; then\n  echo \"[verify_backend_mir_borrow] compile failed: $generic_fixture\" 1>&2\n  echo \"  log: $generic_log\" 1>&2\n  echo \"  status: $generic_status\" 1>&2\n  exit 1\nfi\nif [ \"$ownership_on_status\" != \"0\" ] || [ ! -s \"$ownership_on_obj\" ]; then\n  echo \"[verify_backend_mir_borrow] compile failed (ownership-enabled): $generic_fixture\" 1>&2\n  echo \"  log: $ownership_on_log\" 1>&2\n  echo \"  status: $ownership_on_status\" 1>&2\n  exit 1\nfi\nif [ \"$default_policy_status\" != \"0\" ] || [ ! -s \"$default_policy_obj\" ]; then\n  echo \"[verify_backend_mir_borrow] compile failed (default ownership policy): $borrow_fixture\" 1>&2\n  echo \"  log: $default_policy_log\" 1>&2\n  echo \"  status: $default_policy_status\" 1>&2\n  exit 1\nfi\n\nexpected_stage_labels=\"o"
        out = out + "wnership_start\"\nif [ \"$borrow_ir\" = \"mir\" ]; then\n  expected_stage_labels=\"mir_borrow_start;ownership_start\"\nfi\nif [ \"$skip_ownership_norm\" = \"1\" ]; then\n  if [ \"$borrow_ir\" = \"mir\" ]; then\n    expected_stage_labels=\"mir_borrow_skipped;ownership_skipped\"\n  else\n    expected_stage_labels=\"ownership_skipped\"\n  fi\nfi\nrequire_stage_label_any \"$borrow_log\" \"$expected_stage_labels\" \"explicit_skip_ownership\"\nrequire_stage_label_any \"$ownership_on_log\" \"mir_borrow_start;ownership_start\" \"ownership_enabled\"\n\ndefault_policy_stage_labels=\"ownership_skipped\"\nif [ \"$borrow_ir\" = \"mir\" ]; then\n  default_policy_stage_labels=\"mir_borrow_skipped;ownership_skipped\"\nfi\nrequire_stage_label_any \"$default_policy_log\" \"$default_policy_stage_labels\" \"default_skip_ownership\"\n\nif [ ! -s \"$generic_stamp\" ]; then\n  echo \"[verify_backend_mir_borrow] compile stamp missing: $generic_stamp\" 1>&2\n  exit 1\nfi\nif [ ! -s \"$ownership_on_stamp\" ]; then\n  echo \"[verify_backend_mir_borrow] compile stamp missing: $ownership_on_stamp\" 1>&2\n  exit 1\nfi\nif [ ! -s \"$default_policy_stamp\" ]; then\n  echo \"[verify_backend_mir_borrow] compile stamp missing: $default_policy_stamp\" 1>&2\n  exit 1\nfi\n\nrequire_stamp_field_exact \"$generic_stamp\" \"borrow_ir\" \"$borrow_ir\"\nrequire_stamp_field_exact \"$generic_stamp\" \"generic_lowering\" \"$generic_lowering\"\nrequire_stamp_field_exact \"$ownership_on_stamp\" \"borrow_ir\" \"$borrow_ir\""
        out = out + "\nrequire_stamp_field_exact \"$ownership_on_stamp\" \"generic_lowering\" \"$generic_lowering\"\nrequire_stamp_field_exact \"$default_policy_stamp\" \"borrow_ir\" \"$borrow_ir\"\nrequire_stamp_field_exact \"$default_policy_stamp\" \"generic_lowering\" \"$generic_lowering\"\nrequire_stamp_field_exact \"$generic_stamp\" \"uir_phase_model\" \"single_ir_dual_phase\"\nrequire_stamp_field_exact \"$generic_stamp\" \"uir_high_phase_contract\" \"ownership_func_v1\"\nrequire_stamp_field_exact \"$generic_stamp\" \"uir_phase_contract_version\" \"p4_phase_v1\"\nrequire_stamp_field_exact \"$ownership_on_stamp\" \"uir_phase_model\" \"single_ir_dual_phase\"\nrequire_stamp_field_exact \"$ownership_on_stamp\" \"uir_high_phase_contract\" \"ownership_func_v1\"\nrequire_stamp_field_exact \"$ownership_on_stamp\" \"uir_phase_contract_version\" \"p4_phase_v1\"\nrequire_stamp_field_exact \"$default_policy_stamp\" \"uir_phase_model\" \"single_ir_dual_phase\"\nrequire_stamp_field_exact \"$default_policy_stamp\" \"uir_high_phase_contract\" \"ownership_func_v1\"\nrequire_stamp_field_exact \"$default_policy_stamp\" \"uir_phase_contract_version\" \"p4_phase_v1\"\n\ncompile_stamp_policy_mode=\"runtime_v2\"\nif grep -Fq \"stage1_skip_sem_raw=\" \"$generic_stamp\"; then\n  require_stamp_field_exact \"$generic_stamp\" \"stage1_skip_sem_raw\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$generic_stamp\" \"stage1_skip_sem_effective\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$generic_stamp\" \"stage1"
        out = out + "_skip_ownership_raw\" \"$skip_ownership_norm\"\n  require_stamp_field_exact \"$generic_stamp\" \"stage1_skip_ownership_effective\" \"$skip_ownership_norm\"\n  require_stamp_field_exact \"$generic_stamp\" \"stage1_skip_ownership_default\" \"0\"\n\n  require_stamp_field_exact \"$ownership_on_stamp\" \"stage1_skip_sem_raw\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$ownership_on_stamp\" \"stage1_skip_sem_effective\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$ownership_on_stamp\" \"stage1_skip_ownership_raw\" \"0\"\n  require_stamp_field_exact \"$ownership_on_stamp\" \"stage1_skip_ownership_effective\" \"0\"\n  require_stamp_field_exact \"$ownership_on_stamp\" \"stage1_skip_ownership_default\" \"0\"\n\n  require_stamp_field_exact \"$default_policy_stamp\" \"stage1_skip_sem_raw\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$default_policy_stamp\" \"stage1_skip_sem_effective\" \"$skip_sem_norm\"\n  require_stamp_field_exact \"$default_policy_stamp\" \"stage1_skip_ownership_raw\" \"\"\n  require_stamp_field_exact \"$default_policy_stamp\" \"stage1_skip_ownership_effective\" \"1\"\n  require_stamp_field_exact \"$default_policy_stamp\" \"stage1_skip_ownership_default\" \"1\"\nelse\n  compile_stamp_policy_mode=\"source_contract_fallback\"\n  if ! grep -Fq 'stage1_skip_sem_raw=' src/backend/tooling/backend_driver.cheng; then\n    echo \"[verify_backend_mir_borrow] backend_driver compile stamp missing stage1_skip_sem_raw source marker\" 1>&2\n    exit 1\n  fi\n  if "
        out = out + "! grep -Fq 'stage1_skip_sem_effective=' src/backend/tooling/backend_driver.cheng; then\n    echo \"[verify_backend_mir_borrow] backend_driver compile stamp missing stage1_skip_sem_effective source marker\" 1>&2\n    exit 1\n  fi\n  if ! grep -Fq 'stage1_skip_ownership_raw=' src/backend/tooling/backend_driver.cheng; then\n    echo \"[verify_backend_mir_borrow] backend_driver compile stamp missing stage1_skip_ownership_raw source marker\" 1>&2\n    exit 1\n  fi\n  if ! grep -Fq 'stage1_skip_ownership_effective=' src/backend/tooling/backend_driver.cheng; then\n    echo \"[verify_backend_mir_borrow] backend_driver compile stamp missing stage1_skip_ownership_effective source marker\" 1>&2\n    exit 1\n  fi\n  if ! grep -Fq 'stage1_skip_ownership_default=' src/backend/tooling/backend_driver.cheng; then\n    echo \"[verify_backend_mir_borrow] backend_driver compile stamp missing stage1_skip_ownership_default source marker\" 1>&2\n    exit 1\n  fi\nfi\n\ngenerics_line=\"\"\nreport_mode=\"$generic_mode\"\nreport_budget=\"$generic_budget\"\nreport_borrow_ir=\"$borrow_ir\"\nreport_generic_lowering=\"$generic_lowering\"\nreport_instances_specialized=\"0\"\nreport_instances_total=\"0\"\nreport_high_uir_checked_funcs=\"0\"\nreport_low_uir_lowered_funcs=\"0\"\nreport_high_uir_fallback_funcs=\"0\"\nreport_phase_contract_version=\"\"\nownership_on_line=\"\"\nownership_on_high_uir_checked_funcs=\"0\"\nownership_on_low_uir_lowered_funcs=\"0\"\nownership_on_high_uir_fallback_funcs=\"0\"\npolicy_"
        out = out + "fields_status=\"present\"\ngenerics_line=\"$(grep 'generics_report' \"$generic_log\" | tail -n 1 || true)\"\nif [ \"$generics_line\" = \"\" ]; then\n  echo \"[verify_backend_mir_borrow] missing generics_report in log: $generic_log\" 1>&2\n  exit 1\nfi\nownership_on_line=\"$(grep 'generics_report' \"$ownership_on_log\" | tail -n 1 || true)\"\nif [ \"$ownership_on_line\" = \"\" ]; then\n  echo \"[verify_backend_mir_borrow] missing generics_report in ownership-enabled log: $ownership_on_log\" 1>&2\n  exit 1\nfi\n\nreport_mode=\"$(extract_report_field \"$generics_line\" \"mode\")\"\nreport_budget=\"$(extract_report_field \"$generics_line\" \"spec_budget\")\"\nreport_borrow_ir=\"$(extract_report_field \"$generics_line\" \"borrow_ir\")\"\nreport_generic_lowering=\"$(extract_report_field \"$generics_line\" \"generic_lowering\")\"\nreport_instances_specialized=\"$(extract_report_field \"$generics_line\" \"instances_specialized\")\"\nreport_instances_total=\"$(extract_report_field \"$generics_line\" \"instances_total\")\"\nreport_high_uir_checked_funcs=\"$(extract_report_field \"$generics_line\" \"high_uir_checked_funcs\")\"\nreport_low_uir_lowered_funcs=\"$(extract_report_field \"$generics_line\" \"low_uir_lowered_funcs\")\"\nreport_high_uir_fallback_funcs=\"$(extract_report_field \"$generics_line\" \"high_uir_fallback_funcs\")\"\nreport_phase_contract_version=\"$(extract_report_field \"$generics_line\" \"phase_contract_version\")\"\nownership_on_high_uir_checked_funcs=\"$(extract_re"
        out = out + "port_field \"$ownership_on_line\" \"high_uir_checked_funcs\")\"\nownership_on_low_uir_lowered_funcs=\"$(extract_report_field \"$ownership_on_line\" \"low_uir_lowered_funcs\")\"\nownership_on_high_uir_fallback_funcs=\"$(extract_report_field \"$ownership_on_line\" \"high_uir_fallback_funcs\")\"\n\nif [ \"$report_borrow_ir\" = \"\" ] || [ \"$report_generic_lowering\" = \"\" ]; then\n  policy_fields_status=\"missing\"\n  echo \"[verify_backend_mir_borrow] generics_report missing borrow_ir/generic_lowering fields: $generic_log\" 1>&2\n  exit 1\nfi\nif [ \"$report_high_uir_checked_funcs\" = \"\" ] || [ \"$report_low_uir_lowered_funcs\" = \"\" ] || [ \"$report_high_uir_fallback_funcs\" = \"\" ] || [ \"$report_phase_contract_version\" = \"\" ]; then\n  policy_fields_status=\"missing\"\n  echo \"[verify_backend_mir_borrow] generics_report missing phase contract fields: $generic_log\" 1>&2\n  exit 1\nfi\nif [ \"$report_borrow_ir\" != \"$borrow_ir\" ]; then\n  echo \"[verify_backend_mir_borrow] borrow_ir mismatch: report=$report_borrow_ir expected=$borrow_ir\" 1>&2\n  exit 1\nfi\nif [ \"$report_generic_lowering\" != \"$generic_lowering\" ]; then\n  echo \"[verify_backend_mir_borrow] generic_lowering mismatch: report=$report_generic_lowering expected=$generic_lowering\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$report_instances_specialized\"; then\n  echo \"[verify_backend_mir_borrow] invalid instances_specialized: $report_instances_specialized\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$report_inst"
        out = out + "ances_total\"; then\n  echo \"[verify_backend_mir_borrow] invalid instances_total: $report_instances_total\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$report_high_uir_checked_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid high_uir_checked_funcs: $report_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$report_low_uir_lowered_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid low_uir_lowered_funcs: $report_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$report_high_uir_fallback_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid high_uir_fallback_funcs: $report_high_uir_fallback_funcs\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$ownership_on_high_uir_checked_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid ownership_on high_uir_checked_funcs: $ownership_on_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$ownership_on_low_uir_lowered_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid ownership_on low_uir_lowered_funcs: $ownership_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif ! is_uint \"$ownership_on_high_uir_fallback_funcs\"; then\n  echo \"[verify_backend_mir_borrow] invalid ownership_on high_uir_fallback_funcs: $ownership_on_high_uir_fallback_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$report_phase_contract_version\" != \"p4_phase_v1\" ]; then\n  echo \"[verify_backend_mir_borrow] phase contract version mismatch: report=$report_phase_contract_version expected=p4_phase_v1\" 1>&2\n  exit 1\nfi\nif [ \"$report_"
        out = out + "instances_specialized\" -gt \"$generic_budget\" ]; then\n  echo \"[verify_backend_mir_borrow] specialization budget exceeded: specialized=$report_instances_specialized budget=$generic_budget\" 1>&2\n  exit 1\nfi\nif [ \"$report_low_uir_lowered_funcs\" -le 0 ]; then\n  echo \"[verify_backend_mir_borrow] low_uir_lowered_funcs must be > 0, got $report_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ $((report_high_uir_checked_funcs + report_high_uir_fallback_funcs)) -ne \"$report_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_mir_borrow] explicit phase totals mismatch: checked=$report_high_uir_checked_funcs fallback=$report_high_uir_fallback_funcs low=$report_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$report_high_uir_checked_funcs\" -gt \"$report_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_mir_borrow] high_uir_checked_funcs exceeds low_uir_lowered_funcs: high=$report_high_uir_checked_funcs low=$report_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$skip_ownership_norm\" = \"1\" ]; then\n  if [ \"$report_high_uir_checked_funcs\" -ne 0 ]; then\n    echo \"[verify_backend_mir_borrow] expected high_uir_checked_funcs=0 when ownership is skipped, got $report_high_uir_checked_funcs\" 1>&2\n    exit 1\n  fi\n  if [ \"$report_high_uir_fallback_funcs\" -ne \"$report_low_uir_lowered_funcs\" ]; then\n    echo \"[verify_backend_mir_borrow] expected all low funcs to be fallback when ownership is skipped, fallback=$report_high_uir_fallback_funcs low=$repor"
        out = out + "t_low_uir_lowered_funcs\" 1>&2\n    exit 1\n  fi\nelse\n  if [ \"$report_high_uir_checked_funcs\" -le 0 ]; then\n    echo \"[verify_backend_mir_borrow] expected high_uir_checked_funcs>0 when ownership is enabled, got $report_high_uir_checked_funcs\" 1>&2\n    exit 1\n  fi\nfi\n\nif [ \"$ownership_on_low_uir_lowered_funcs\" -le 0 ]; then\n  echo \"[verify_backend_mir_borrow] ownership-enabled low_uir_lowered_funcs must be > 0, got $ownership_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ $((ownership_on_high_uir_checked_funcs + ownership_on_high_uir_fallback_funcs)) -ne \"$ownership_on_low_uir_lowered_funcs\" ]; then\n  echo \"[verify_backend_mir_borrow] ownership-enabled phase totals mismatch: checked=$ownership_on_high_uir_checked_funcs fallback=$ownership_on_high_uir_fallback_funcs low=$ownership_on_low_uir_lowered_funcs\" 1>&2\n  exit 1\nfi\nif [ \"$ownership_on_high_uir_checked_funcs\" -le 0 ]; then\n  echo \"[verify_backend_mir_borrow] expected ownership-enabled probe to produce high_uir_checked_funcs>0, got $ownership_on_high_uir_checked_funcs\" 1>&2\n  exit 1\nfi\n\nsnapshot_time=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || echo \"<unknown>\")\"\ngit_head=\"$(git -C \"$root\" rev-parse --verify HEAD 2>/dev/null || echo \"<unknown>\")\"\ngit_dirty_files=\"$(git -C \"$root\" status --porcelain 2>/dev/null | wc -l | tr -d ' ')\"\nif [ \"$git_dirty_files\" = \"\" ]; then\n  git_dirty_files=\"0\"\nfi\n\n{\n  echo \"snapshot_time_utc=$snapshot_time\"\n  echo \"git_h"
        out = out + "ead=$git_head\"\n  echo \"git_dirty_files=$git_dirty_files\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"borrow_ir=$borrow_ir\"\n  echo \"generic_lowering=$generic_lowering\"\n  echo \"generic_mode=$generic_mode\"\n  echo \"generic_budget=$generic_budget\"\n  echo \"skip_sem=$skip_sem_norm\"\n  echo \"skip_ownership=$skip_ownership_norm\"\n  echo \"borrow_fixture=$borrow_fixture\"\n  echo \"generic_fixture=$generic_fixture\"\n  echo \"borrow_log=$borrow_log\"\n  echo \"generic_log=$generic_log\"\n  echo \"ownership_on_log=$ownership_on_log\"\n  echo \"default_policy_log=$default_policy_log\"\n  echo \"generic_stamp=$generic_stamp\"\n  echo \"ownership_on_stamp=$ownership_on_stamp\"\n  echo \"default_policy_stamp=$default_policy_stamp\"\n  echo \"expected_stage_label_default_policy=$default_policy_stage_labels\"\n  echo \"compile_stamp_status=present\"\n  echo \"compile_stamp_policy_mode=$compile_stamp_policy_mode\"\n  echo \"policy_fields_status=$policy_fields_status\"\n  echo \"generics_mode_report=$report_mode\"\n  echo \"generics_budget_report=$report_budget\"\n  echo \"instances_total=$report_instances_total\"\n  echo \"instances_specialized=$report_instances_specialized\"\n  echo \"high_uir_checked_funcs=$report_high_uir_checked_funcs\"\n  echo \"low_uir_lowered_funcs=$report_low_uir_lowered_funcs\"\n  echo \"high_uir_fallback_funcs=$report_high_uir_fallback_funcs\"\n  echo \"ownership_on_high_uir_checked_funcs=$ownership_on_high_uir_checked_funcs\"\n"
        out = out + "  echo \"ownership_on_low_uir_lowered_funcs=$ownership_on_low_uir_lowered_funcs\"\n  echo \"ownership_on_high_uir_fallback_funcs=$ownership_on_high_uir_fallback_funcs\"\n  echo \"phase_contract_version=$report_phase_contract_version\"\n} > \"$snapshot_file\"\n\n{\n  echo \"verify_backend_mir_borrow report\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"borrow_ir=$borrow_ir\"\n  echo \"generic_lowering=$generic_lowering\"\n  echo \"generic_mode=$generic_mode\"\n  echo \"generic_budget=$generic_budget\"\n  echo \"skip_sem=$skip_sem_norm\"\n  echo \"skip_ownership=$skip_ownership_norm\"\n  echo \"borrow_fixture=$borrow_fixture\"\n  echo \"generic_fixture=$generic_fixture\"\n  echo \"expected_stage_label=$expected_stage_labels\"\n  echo \"expected_stage_label_ownership_on=mir_borrow_start;ownership_start\"\n  echo \"expected_stage_label_default_policy=$default_policy_stage_labels\"\n  echo \"generics_report=$generics_line\"\n  echo \"ownership_on_generics_report=$ownership_on_line\"\n  echo \"instances_total=$report_instances_total\"\n  echo \"instances_specialized=$report_instances_specialized\"\n  echo \"high_uir_checked_funcs=$report_high_uir_checked_funcs\"\n  echo \"low_uir_lowered_funcs=$report_low_uir_lowered_funcs\"\n  echo \"high_uir_fallback_funcs=$report_high_uir_fallback_funcs\"\n  echo \"ownership_on_high_uir_checked_funcs=$ownership_on_high_uir_checked_funcs\"\n  echo \"ownership_on_low_uir_lowered_funcs=$ownership_on_low_uir_lowered_funcs\"\n  ech"
        out = out + "o \"ownership_on_high_uir_fallback_funcs=$ownership_on_high_uir_fallback_funcs\"\n  echo \"phase_contract_version=$report_phase_contract_version\"\n  echo \"compile_stamp=$generic_stamp\"\n  echo \"ownership_on_compile_stamp=$ownership_on_stamp\"\n  echo \"default_policy_compile_stamp=$default_policy_stamp\"\n  echo \"compile_stamp_status=present\"\n  echo \"compile_stamp_policy_mode=$compile_stamp_policy_mode\"\n  echo \"policy_fields_status=$policy_fields_status\"\n} > \"$report_file\"\n\necho \"verify_backend_mir_borrow ok\"\n"
        return out
    if id == "verify_backend_mm":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nfrontend=\"${BACKEND_MM_F"
        out = out + "RONTEND:-stage1}\"\nmm_container=\"${BACKEND_MM_CONTAINER:-1}\"\nmm_container_frontend=\"${BACKEND_MM_CONTAINER_FRONTEND:-stage1}\"\nmm_skip_sem=\"${BACKEND_MM_SKIP_SEM:-${STAGE1_SKIP_SEM:-0}}\"\nmm_skip_ownership=\"${BACKEND_MM_SKIP_OWNERSHIP:-${STAGE1_SKIP_OWNERSHIP:-1}}\"\nmm_no_ptr_non_c_abi=\"${BACKEND_MM_NO_POINTERS_NON_C_ABI:-0}\"\nmm_no_ptr_non_c_abi_internal=\"${BACKEND_MM_NO_POINTERS_NON_C_ABI_INTERNAL:-0}\"\nmm_generic_mode=\"${BACKEND_MM_GENERIC_MODE:-hybrid}\"\nmm_generic_budget=\"${BACKEND_MM_GENERIC_SPEC_BUDGET:-0}\"\n\n# Keep mm gate focused on memory-manager semantics, independent of closure no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\n\n\nout_dir=\"artifacts/backend_mm\"\ntimeout_s=\"${BACKEND_MM_TIMEOUT:-60}\"\nmkdir -p \"$out_dir\"\n\nis_known_mm_skip_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"macho_linker: duplicate symbol: ___cheng_sym_3d_3d\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Undefined symbols for architecture\" \"$log_file\" && grep -q \"L_cheng_str_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"Symbol not found:\" \"$log_file\"; then\n    return 0\n  fi\n  return 1\n}\n\ncompile_fixture_compile_only() {\n  fixture=\"$1\"\n  base=\"$2\"\n  fixture_frontend=\"$3\"\n  compile_only_out=\"$out_dir/${base}.compile_only.o\"\n  compile_only_l"
        out = out + "og=\"$out_dir/${base}.compile_only.log\"\n  rm -f \"$compile_only_out\" \"$compile_only_log\"\n  run_with_timeout \"$timeout_s\" env \\\n    MM=orc \\\n    BACKEND_FRONTEND=\"$fixture_frontend\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI=\"$mm_no_ptr_non_c_abi\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=\"$mm_no_ptr_non_c_abi_internal\" \\\n    STAGE1_SKIP_SEM=\"$mm_skip_sem\" \\\n    GENERIC_MODE=\"$mm_generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$mm_generic_budget\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$mm_skip_ownership\" \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_LINKER=self \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$compile_only_out\" \\\n    \"$driver\" >\"$compile_only_log\" 2>&1\n  [ -s \"$compile_only_out\" ]\n}\n\nrun_fixture() {\n  fixture=\"$1\"\n  base=\"$2\"\n  fixture_frontend=\"$3\"\n  exe_path=\"$out_dir/$base\"\n\n  if [ \"$linker_mode\" = \"self\" ]; then\n    self_log=\"$out_dir/${base}.self.log\"\n    set +e\n    run_with_timeout \"$timeout_s\" env \\\n      MM=orc \\\n      BACKEND_FRONTEND=\"$fixture_frontend\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=\"$mm_no_ptr_non_c_abi\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=\"$mm_no_ptr_non_c_abi_internal\" \\\n      STAGE1_SKIP_SEM=\"$mm_skip_sem\" \\\n      GENERIC_MODE=\"$mm_generic_mode\" \\\n      GENERIC_SPEC_BUDGET=\"$mm_generic_budget\" \\\n   "
        out = out + "   STAGE1_SKIP_OWNERSHIP=\"$mm_skip_ownership\" \\\n      BACKEND_VALIDATE=1 \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe_path\" \\\n      \"$driver\" >\"$self_log\" 2>&1\n    self_status=\"$?\"\n    if [ \"$self_status\" -eq 0 ]; then\n      run_with_timeout \"$timeout_s\" \"$exe_path\" >>\"$self_log\" 2>&1\n      self_status=\"$?\"\n    fi\n    set -e\n    if [ \"$self_status\" -eq 124 ]; then\n      echo \"[Error] verify_backend_mm timed out after ${timeout_s}s: $base (self linker)\" >&2\n      tail -n 200 \"$self_log\" >&2 || true\n      exit 124\n    fi\n    if [ \"$self_status\" -eq 0 ]; then\n      return\n    fi\n    if is_known_mm_skip_log \"$self_log\"; then\n      echo \"[verify_backend_mm] known self-link instability, fallback compile-only: $base\" >&2\n      if compile_fixture_compile_only \"$fixture\" \"$base\" \"$fixture_frontend\"; then\n        return\n      fi\n      tail -n 200 \"$out_dir/${base}.compile_only.log\" >&2 || true\n      exit 1\n    fi\n    tail -n 200 \"$self_log\" >&2 || true\n    exit \"$self_status\"\n  fi\n\n  run_with_timeout \"$timeout_s\" env \\\n    MM=orc \\\n    BACKEND_FRONTEND=\"$fixture_frontend\" \\\n    STAGE1_NO_POINTERS_NON_C_AB"
        out = out + "I=\"$mm_no_ptr_non_c_abi\" \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=\"$mm_no_ptr_non_c_abi_internal\" \\\n    STAGE1_SKIP_SEM=\"$mm_skip_sem\" \\\n    GENERIC_MODE=\"$mm_generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$mm_generic_budget\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$mm_skip_ownership\" \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=system \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\"\n\n  run_with_timeout \"$timeout_s\" \"$exe_path\"\n}\n\nrun_fixture \"tests/cheng/backend/fixtures/mm_live_balance.cheng\" \"mm_live_balance\" \"$frontend\"\nif [ \"$mm_container\" = \"1\" ]; then\n  run_fixture \"tests/cheng/backend/fixtures/mm_container_balance.cheng\" \"mm_container_balance\" \"$mm_container_frontend\"\nelse\n  echo \"[verify_backend_mm] skip mm_container_balance (set BACKEND_MM_CONTAINER=1 to enable, current=$mm_container)\" >&2\nfi\n\necho \"verify_backend_mm ok\"\n"
        return out
    if id == "verify_backend_multi":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n# Keep multi gate focused on scheduler/link behavior, independent of closure no-pointer policy.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\nlinker_mode=\"${BACKEND_LINKER:-self}\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\nrun_exe=\"${BACKEND_MULTI_RUN_EXE:-}\"\nif [ \"$run_exe\" = \"\" ]; then\n  if [ \"$linker_mode\" = \"self\" ]; then\n    run_exe=\"0\"\n  else\n    run_exe=\"1\"\n  fi\nfi\nif [ \"$linker_mode\" = \"self\" ] && [ \"$run_exe\" = \"1\" ]; then\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$runti"
        out = out + "me_obj\" ]; then\n    env \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n      BACKEND_OUTPUT=\"$runtime_obj\" \\\n      \"$driver\" >/dev/null\n  fi\nfi\n\n\nout_dir=\"artifacts/backend_multi\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nexe_path=\"$out_dir/return_add\"\nlog_path=\"$out_dir/build.log\"\nrun_log_path=\"$out_dir/run.log\"\n\nbuild_with_mode() {\n  mode_multi=\"$1\"\n  mode_multi_force=\"$2\"\n  mode_jobs=\"$3\"\n  if [ \"$linker_mode\" = \"self\" ]; then\n    if [ \"$run_exe\" = \"1\" ]; then\n      BACKEND_PROFILE=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n      BACKEND_MULTI=\"$mode_multi\" \\\n      BACKEND_MULTI_FORCE=\"$mode_multi_force\" \\\n      BACKEND_JOBS=\"$mode_jobs\" \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe_path\" \\\n      \"$driver\" >\"$log_path\" 2>&1\n    else\n      BACKEND_PROFILE=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_MULTI=\"$mode_multi\" \\\n      BACKEND_MULTI_FORCE=\"$mode_multi_force\" \\\n      BACKEND_JOBS=\"$mode_j"
        out = out + "obs\" \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$exe_path\" \\\n      \"$driver\" >\"$log_path\" 2>&1\n    fi\n  else\n    BACKEND_PROFILE=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=system \\\n    BACKEND_MULTI=\"$mode_multi\" \\\n    BACKEND_MULTI_FORCE=\"$mode_multi_force\" \\\n    BACKEND_JOBS=\"$mode_jobs\" \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$log_path\" 2>&1\n  fi\n}\n\nclean_outputs() {\n  rm -f \"$exe_path\" \"$exe_path.o\" \"$run_log_path\"\n  rm -rf \"${exe_path}.objs\" \"${exe_path}.objs.lock\"\n}\n\nclean_outputs\nset +e\nbuild_with_mode 1 1 4\nstatus=\"$?\"\nset -e\nif [ \"$status\" -ne 0 ]; then\n  echo \"[Warn] verify_backend_multi parallel compile failed, retry serial (target=$target)\" 1>&2\n  clean_outputs\n  set +e\n  build_with_mode 0 0 0\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    tail -n 200 \"$log_path\" >&2 || true\n    exit \"$status\"\n  fi\nfi\n\nif [ \"$run_exe\" = \"1\" ]; then\n  set +e\n  \"$exe_path\" >\"$run_log_path\" 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ne 0 ]; then\n    cat \"$run_log_path\" >&2 || true\n    if [ \"$linker_mode\" = \"self\" ] && grep -q \"Symbol not found: _cheng_\" \"$run_log_path\"; then\n      echo \"verify_backend_multi skip: self-link runtime symbol unresolved (compile/link verified)\" 1>&2\n      exit 2\n    fi\n    "
        out = out + "exit \"$run_status\"\n  fi\nfi\n\ntab=\"$(printf '\\t')\"\nif grep -q \"backend_profile${tab}multi.plan\" \"$log_path\"; then\n  grep -q \"backend_profile${tab}multi.link\" \"$log_path\"\n  count=\"0\"\n  if [ -d \"$exe_path.objs\" ]; then\n    count=\"$(find \"$exe_path.objs\" -name '*.o' | wc -l | tr -d ' ')\"\n  elif [ -f \"$exe_path.o\" ]; then\n    count=\"1\"\n  fi\n  test \"$count\" -ge 1\nelse\n  # Single-unit inputs are intentionally emitted through the single-object fast path.\n  grep -q \"backend_profile${tab}single.emit_obj\" \"$log_path\"\n  grep -q \"backend_profile${tab}single.link\" \"$log_path\"\nfi\n\necho \"verify_backend_multi ok\"\n"
        return out
    if id == "verify_backend_multi_lto":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nout_dir=\"artifacts/backend_multi_lto\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nexe_path=\"$out_dir/return_add_lto\"\nrun_log=\"$out_dir/return_add_lto.run.log\"\n\nis_known_runtime_symbol_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_f32_bits_to_i64\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_memcpy\" \"$log_file\"; then\n    return 0\n  fi\n  return 1\n}\n\nenv $link_env \\\n  BACKEND_OPT2=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n"
        out = out + "  BACKEND_MULTI=1 \\\n  BACKEND_MULTI_LTO=1 \\\n  BACKEND_JOBS=4 \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\"\n\nset +e\n\"$exe_path\" >\"$run_log\" 2>&1\nrun_status=\"$?\"\nset -e\nif [ \"$run_status\" -ne 0 ]; then\n  if is_known_runtime_symbol_log \"$run_log\"; then\n    echo \"[verify_backend_multi_lto] known runtime-symbol instability, fallback compile-only: $fixture\" 1>&2\n  else\n    cat \"$run_log\" 1>&2 || true\n    exit \"$run_status\"\n  fi\nfi\n\ncount=\"0\"\nif [ -d \"$exe_path.objs\" ]; then\n  count=\"$(find \"$exe_path.objs\" -name '*.o' | wc -l | tr -d ' ')\"\n  if [ \"$count\" -eq 0 ] && [ -f \"$exe_path.o\" ]; then\n    count=\"1\"\n  fi\nelif [ -f \"$exe_path.o\" ]; then\n  # Some backends materialize the post-LTO object as a single sidecar `.o`.\n  count=\"1\"\nfi\ntest \"$count\" -eq 1\n\necho \"verify_backend_multi_lto ok\"\n"
        return out
    if id == "verify_backend_multi_module_cache_stability":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ntimeout_cmd=\"\"\nif command -v timeout >/dev/null 2>&1; then\n  timeout_cmd=\"timeout\"\nelif command -v gtimeout >/dev/null 2>&1; then\n  timeout_cmd=\"gtimeout\"\nfi\n\ngate_timeout=\"${BACKEND_MULTI_MODULE_CACHE_STABILITY_TIMEOUT:-60}\"\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)}\"\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\n\nout_dir=\"artifacts/backend_multi_module_cache_stability\"\nmkdir -p \"$out_dir\"\nmodule_cache_path=\"$out_dir/module.cache.tsv\"\n\nrun_case() {\n  label=\"$1\"\n  mm_cache=\"$2\"\n  unstable_allow=\"$3\"\n  out_path=\"$out_dir/${label}.exe\"\n  log_path=\"$out_dir/${label}.log\"\n  rm -f \"$out_path\" \"$out_path.o\" \"$log_path\"\n  rm -rf \"${out_path}.objs\" \"${out_path"
        out = out + "}.objs.lock\"\n  set +e\n  if [ \"$timeout_cmd\" != \"\" ] && [ \"$gate_timeout\" -gt 0 ] 2>/dev/null; then\n    \"$timeout_cmd\" \"${gate_timeout}s\" env \\\n      BACKEND_PROFILE=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_MULTI=1 \\\n      BACKEND_MULTI_FORCE=1 \\\n      BACKEND_JOBS=4 \\\n      BACKEND_MULTI_MODULE_CACHE=\"$mm_cache\" \\\n      BACKEND_MODULE_CACHE_UNSTABLE_ALLOW=\"$unstable_allow\" \\\n      BACKEND_MODULE_CACHE=\"$module_cache_path\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_path\" \\\n      \"$driver\" >\"$log_path\" 2>&1\n    rc=\"$?\"\n  else\n    env \\\n      BACKEND_PROFILE=1 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_MULTI=1 \\\n      BACKEND_MULTI_FORCE=1 \\\n      BACKEND_JOBS=4 \\\n      BACKEND_MULTI_MODULE_CACHE=\"$mm_cache\" \\\n      BACKEND_MODULE_CACHE_UNSTABLE_ALLOW=\"$unstable_allow\" \\\n      BACKEND_MODULE_CACHE=\"$module_cache_path\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$out_path\" \\\n      \"$driver\" >\"$log_path\" 2>&1\n    rc=\"$?\"\n  fi\n  set -e\n\n  if [ \"$rc\" -eq 124 ]; then\n    echo \"[verify_backend_multi_module_cache_stability] timeout (${gate_timeout}s): $label\" 1>&2\n    tail -n 120 \"$log_path\" 1>&2 || true\n    exit 1\n  fi\n  if [ \"$rc\" -eq 139 ]; t"
        out = out + "hen\n    echo \"[verify_backend_multi_module_cache_stability] segv detected: $label\" 1>&2\n    tail -n 120 \"$log_path\" 1>&2 || true\n    exit 1\n  fi\n  if [ \"$rc\" -ne 0 ]; then\n    echo \"[verify_backend_multi_module_cache_stability] build failed: $label (rc=$rc)\" 1>&2\n    tail -n 120 \"$log_path\" 1>&2 || true\n    exit \"$rc\"\n  fi\n  if [ ! -f \"$out_path\" ]; then\n    echo \"[verify_backend_multi_module_cache_stability] missing output: $out_path\" 1>&2\n    tail -n 120 \"$log_path\" 1>&2 || true\n    exit 1\n  fi\n  echo \"[verify_backend_multi_module_cache_stability] $label ok\"\n}\n\nrun_case \"default_off\" \"0\" \"0\"\nrun_case \"unstable_override_first\" \"1\" \"1\"\nrun_case \"unstable_override_second\" \"1\" \"1\"\n\necho \"verify_backend_multi_module_cache_stability ok\"\n"
        return out
    if id == "verify_backend_multi_perf_regression":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_multi_perf_regression.sh [--help]\n\nEnv:\n  MULTI_PERF_SESSION=<name>        Session key (default: default)\n  MULTI_PERF_TIMING=<path>         Timing tsv path (default: artifacts/backend_multi/multi_perf_timing_<session>.tsv)\n  MULTI_PERF_BASELINE=<path>       Baseline env file (default: src/tooling/multi_perf_baseline.env)\n  MULTI_PERF_TIMEOUT=<seconds>     Per-gate timeout (default: 60; <=0 disables timeout)\n\nLimits (seconds, <=0 disables check):\n  MULTI_PERF_MAX_MULTI             default: 30\n  MULTI_PERF_MAX_MULTI_LTO         default: 30\n  MULTI_PERF_MAX_TOTAL             default: 60\nEOF\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[multi_perf] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsession=\"${MULTI_PERF_SESSION:-default}\"\nsession_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\ntiming_file=\"${MULTI_PERF_TIMING:-artifacts/backend_multi/multi_perf_timing_${session_safe}.tsv}\"\ntiming_dir=\"$(dirname -- \"$timing_file\")\"\nmkdir -p \"$timing_dir\"\n: > \"$timing_file\"\n\nbaseline_file_default=\"src/tooling/multi_perf_baseline.env\"\nbaseline_file=\"${MULTI_PERF_BASELINE:-$bas"
        out = out + "eline_file_default}\"\nbaseline_explicit=\"0\"\nif [ \"${MULTI_PERF_BASELINE+x}\" = \"x\" ]; then\n  baseline_explicit=\"1\"\nfi\nif [ -f \"$baseline_file\" ]; then\n  # shellcheck disable=SC1090\n  . \"$baseline_file\"\nelif [ \"$baseline_explicit\" = \"1\" ]; then\n  echo \"[multi_perf] baseline file not found: $baseline_file\" 1>&2\n  exit 2\nfi\n\nmax_multi=\"${MULTI_PERF_MAX_MULTI:-30}\"\nmax_multi_lto=\"${MULTI_PERF_MAX_MULTI_LTO:-30}\"\nmax_total=\"${MULTI_PERF_MAX_TOTAL:-60}\"\ngate_timeout=\"${MULTI_PERF_TIMEOUT:-60}\"\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nis_enabled_limit() {\n  limit=\"$1\"\n  if ! is_uint \"$limit\"; then\n    return 1\n  fi\n  [ \"$limit\" -gt 0 ]\n}\n\ntimeout_cmd=\"\"\nif command -v timeout >/dev/null 2>&1; then\n  timeout_cmd=\"timeout\"\nelif command -v gtimeout >/dev/null 2>&1; then\n  timeout_cmd=\"gtimeout\"\nfi\n\nif [ \"$timeout_cmd\" = \"\" ] && is_enabled_limit \"$gate_timeout\"; then\n  echo \"[multi_perf] warn: timeout command not found; run without per-gate timeout\" 1>&2\nfi\n\ntimestamp_now() {\n  date +%s\n}\n\nfailures=0\n\ncheck_duration_limit() {\n  label=\"$1\"\n  duration=\"$2\"\n  limit=\"$3\"\n  if ! is_enabled_limit \"$limit\"; then\n    return 0\n  fi\n  if [ \"$duration\" -gt \"$limit\" ]; then\n    echo \"[multi_perf] regression: $label exceeded limit (${duration}s > ${limit}s)\" 1>&2\n    failures=$((failures + 1))\n  fi\n}\n\nrun_gate() {\n  label=\"$1\""
        out = out + "\n  limit=\"$2\"\n  script_path=\"$3\"\n  start=\"$(timestamp_now)\"\n  set +e\n  if [ \"$timeout_cmd\" != \"\" ] && is_enabled_limit \"$gate_timeout\"; then\n    \"$timeout_cmd\" \"${gate_timeout}s\" sh \"$script_path\"\n    rc=\"$?\"\n  else\n    sh \"$script_path\"\n    rc=\"$?\"\n  fi\n  set -e\n  end=\"$(timestamp_now)\"\n  duration=$((end - start))\n  status=\"ok\"\n  if [ \"$rc\" -eq 124 ]; then\n    status=\"timeout\"\n  elif [ \"$rc\" -ne 0 ]; then\n    status=\"fail\"\n  fi\n  printf '%s\\t%s\\t%s\\n' \"$label\" \"$status\" \"$duration\" >>\"$timing_file\"\n  echo \"[multi_perf] $label=${duration}s status=$status limit=${limit}s\"\n  if [ \"$rc\" -ne 0 ]; then\n    failures=$((failures + 1))\n  fi\n  check_duration_limit \"$label\" \"$duration\" \"$limit\"\n}\n\ntotal_start=\"$(timestamp_now)\"\nrun_gate \"multi\" \"$max_multi\" \"src/tooling/verify_backend_multi.sh\"\nrun_gate \"multi_lto\" \"$max_multi_lto\" \"src/tooling/verify_backend_multi_lto.sh\"\ntotal_end=\"$(timestamp_now)\"\ntotal_duration=$((total_end - total_start))\ntotal_status=\"ok\"\nif [ \"$failures\" -ne 0 ]; then\n  total_status=\"fail\"\nfi\nprintf '%s\\t%s\\t%s\\n' \"total\" \"$total_status\" \"$total_duration\" >>\"$timing_file\"\necho \"[multi_perf] total=${total_duration}s status=$total_status limit=${max_total}s\"\ncheck_duration_limit \"total\" \"$total_duration\" \"$max_total\"\n\nif [ \"$failures\" -ne 0 ]; then\n  echo \"[multi_perf] FAILED (timing=$timing_file failures=$failures)\" 1>&"
        out = out + "2\n  exit 1\nfi\n\necho \"[multi_perf] ok (timing=$timing_file)\"\n"
        return out
    if id == "verify_backend_no_legacy_refs":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_no_legacy_refs] rg is required\" 1>&2\n  exit 2\nfi\n\n# Hard guard for production entrypoints + all UIR source files.\nbad_core=\"$(rg -n \"import[[:space:]]+cheng/backend/(mir|lir|isel|regalloc)\" \\\n  src/backend/tooling/backend_driver.cheng \\\n  src/backend/machine -g '*.cheng' \\\n  src/backend/uir -g '*.cheng' || true)\"\n\nif [ \"$bad_core\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy import in production UIR path:\" 1>&2\n  echo \"$bad_core\" 1>&2\n  exit 1\nfi\n\n# Hard guard: no stale compat import roots after compat directory removal.\nbad_compat=\"$(rg -n \"import[[:space:]]+cheng/backend/compat/\" src/backend -g '*.cheng' || true)\"\nif [ \"$bad_compat\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden removed compat import path:\" 1>&2\n  echo \"$bad_compat\" 1>&2\n  exit 1\nfi\n\n# Internal MIR/LIR/isel/regalloc layers are only allowed in dedicated machine/uir\n# implementation boundaries, never through removed compat shims.\nbad_internal_surface=\"$(rg -n \"import[[:space:]]+cheng/backend/(uir/uir_internal|machine/(machine_internal|select_internal|regalloc_internal))\" \\\n  src/backend/uir src/backend/machine -g '*.cheng' \\\n  -g '!src/backend/uir/uir_internal/**' \\\n  -g '!src/b"
        out = out + "ackend/machine/machine_internal/**' \\\n  -g '!src/backend/machine/select_internal/**' \\\n  -g '!src/backend/machine/regalloc_internal/**' \\\n  -g '!src/backend/uir/uir_types.cheng' \\\n  -g '!src/backend/uir/uir_frontend.cheng' \\\n  -g '!src/backend/uir/uir_validate.cheng' \\\n  -g '!src/backend/uir/uir_opt.cheng' \\\n  -g '!src/backend/uir/uir_noalias_pass.cheng' \\\n  -g '!src/backend/uir/uir_egraph_rewrite.cheng' \\\n  -g '!src/backend/machine/machine_types.cheng' \\\n  -g '!src/backend/machine/machine_select_aarch64.cheng' \\\n  -g '!src/backend/machine/machine_select_x86_64.cheng' \\\n  -g '!src/backend/machine/machine_select_riscv64.cheng' \\\n  -g '!src/backend/machine/machine_regalloc.cheng' || true)\"\nif [ \"$bad_internal_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden direct internal backend import outside allowed facades:\" 1>&2\n  echo \"$bad_internal_surface\" 1>&2\n  exit 1\nfi\n\n# Removed compat files must not reappear.\nfor removed in \\\n  src/backend/uir/uir_compat_bridge.cheng \\\n  src/backend/uir/uir_compat_types.cheng\ndo\n  if [ -f \"$removed\" ]; then\n    echo \"[verify_backend_no_legacy_refs] forbidden removed compat file present: $removed\" 1>&2\n    exit 1\n  fi\ndone\n\n# Hard-cut guard: removed legacy backend source files/directories must stay absent.\nfor removed_legacy in \\\n  src/backend/mir \\\n  src/backend/lir \\\n  src/backend/isel \\\n  src/backend/regalloc/linear_scan.cheng\ndo\n  if [ -e \"$removed_l"
        out = out + "egacy\" ]; then\n    echo \"[verify_backend_no_legacy_refs] forbidden legacy backend source present: $removed_legacy\" 1>&2\n    exit 1\n  fi\ndone\n\n# Legacy scaffold dirs must not carry source files on production backend.\nfor removed_scaffold in \\\n  src/backend/hir \\\n  src/backend/frame \\\n  src/backend/emit\ndo\n  if [ -d \"$removed_scaffold\" ]; then\n    legacy_scaffold_files=\"$(find \"$removed_scaffold\" -name '*.cheng' -type f 2>/dev/null | head -n 1 || true)\"\n    if [ \"$legacy_scaffold_files\" != \"\" ]; then\n      echo \"[verify_backend_no_legacy_refs] forbidden legacy scaffold source present: $legacy_scaffold_files\" 1>&2\n      exit 1\n    fi\n  fi\ndone\n\n# select internal implementation must consume UIR facade, not mir_types directly.\nbad_isel_mir_types=\"$(rg -n \"import[[:space:]]+cheng/backend/uir/uir_internal/uir_core_types\" \\\n  src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_isel_mir_types\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden direct mir_types import in select_internal:\" 1>&2\n  echo \"$bad_isel_mir_types\" 1>&2\n  exit 1\nfi\n\n# select internal implementation should depend on machine facade, not machine_internal directly.\nbad_isel_machine_internal_import=\"$(rg -n \"import[[:space:]]+cheng/backend/machine/machine_internal/\" \\\n  src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_isel_machine_internal_import\" != \"\" ]; then\n  echo \"[verify_backend_no_lega"
        out = out + "cy_refs] forbidden direct machine_internal import in select_internal:\" 1>&2\n  echo \"$bad_isel_machine_internal_import\" 1>&2\n  exit 1\nfi\n\n# select internal public/internal signatures should stay on UIR facade symbols.\nbad_isel_mir_symbols=\"$(rg -n \"\\\\bMir[A-Za-z0-9_]+\\\\b\" src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_isel_mir_symbols\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden Mir* symbol usage in select_internal:\" 1>&2\n  echo \"$bad_isel_mir_symbols\" 1>&2\n  exit 1\nfi\n\n# select internal type constructors should come from UIR facade wrappers.\nbad_isel_mir_type_ctor=\"$(rg -n \"\\\\bmirType[A-Za-z0-9_]+\\\\b\" src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_isel_mir_type_ctor\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden mirType* constructor usage in select_internal:\" 1>&2\n  echo \"$bad_isel_mir_type_ctor\" 1>&2\n  exit 1\nfi\n\n# select internal should use Machine* type surface (not Lir* type names).\nbad_isel_lir_type_symbols=\"$(rg -n \"\\\\bLir(Reg|Cond|Op|Inst|Func|CString|Global|Module)\\\\b\" \\\n  src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_isel_lir_type_symbols\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden Lir* type usage in select_internal:\" 1>&2\n  echo \"$bad_isel_lir_type_symbols\" 1>&2\n  exit 1\nfi\n\n# regalloc facade is the only production surface allowed to import linear_scan direct"
        out = out + "ly.\nbad_linear_scan_surface=\"$(rg -n \"import[[:space:]]+cheng/backend/machine/regalloc_internal/linear_scan\" \\\n  src/backend -g '*.cheng' \\\n  -g '!src/backend/machine/machine_regalloc.cheng' \\\n  -g '!src/backend/machine/regalloc_internal/**' || true)\"\nif [ \"$bad_linear_scan_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden direct linear_scan import outside machine_regalloc facade:\" 1>&2\n  echo \"$bad_linear_scan_surface\" 1>&2\n  exit 1\nfi\n\n# Production-facing machine/object surfaces should use Machine* types instead of legacy Lir* aliases.\nbad_lir_surface=\"$(rg -n \"\\\\bLir(Reg|Cond|Op|Inst|Func|CString|Global|Module)\\\\b\" \\\n  src/backend/obj \\\n  src/backend/machine -g '*.cheng' \\\n  -g '!src/backend/machine/machine_types.cheng' \\\n  -g '!src/backend/machine/machine_internal/**' \\\n  -g '!src/backend/machine/select_internal/**' \\\n  -g '!src/backend/machine/regalloc_internal/**' || true)\"\nif [ \"$bad_lir_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden Lir* symbol usage on production machine/object surface:\" 1>&2\n  echo \"$bad_lir_surface\" 1>&2\n  exit 1\nfi\n\n# Production machine/object/backend surfaces should call machine* constructors, not lir*.\nbad_lir_ctor_surface=\"$(rg -n \"\\\\blir[A-Z][A-Za-z0-9_]*\\\\b\" \\\n  src/backend/obj \\\n  src/backend/machine \\\n  src/backend/uir \\\n  src/backend/tooling -g '*.cheng' \\\n  -g '!src/backend/machine/machine_internal/**' \\\n  -g "
        out = out + "'!src/backend/uir/uir_internal/**' || true)\"\nif [ \"$bad_lir_ctor_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden lir* constructor usage outside internal layers:\" 1>&2\n  echo \"$bad_lir_ctor_surface\" 1>&2\n  exit 1\nfi\n\n# Production-facing diagnostics should not expose legacy LIR wording.\nbad_lir_wording=\"$(rg -n \"unsupported lir op|float lir op unsupported\" \\\n  src/backend/obj \\\n  src/backend/machine -g '*.cheng' || true)\"\nif [ \"$bad_lir_wording\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy lir wording on production machine/object surface:\" 1>&2\n  echo \"$bad_lir_wording\" 1>&2\n  exit 1\nfi\n\n# Production machine/object/select surfaces should avoid legacy enum tokens.\nbad_legacy_enum_surface=\"$(rg -n \"\\\\b(lr(W[0-8]|X(0|1|2|3|4|5|6|7|8|16|17|19|29|30)|Sp|D[01]|E(ax|cx|dx|bx|si|di)|R(8d|9d|10d|11d|12d|13d|14d|15d|ax|cx|dx|bx|si|di|bp|8|9|10|11|12|13|14|15))|lc(Eq|Ne|Mi|Lt|Le|Gt|Ge|Lo|Ls|Hi|Hs)|lo(Label|MovImm|MovReg|Sxtw|Adrp|AddPageOff|Add|Sub|Mul|Sdiv|Udiv|Msub|And|Orr|Eor|Lsl|Lsr|Asr|Cmp|BCond|B|Bl|Blr|FmovDx|FmovXd|FaddD|FsubD|FmulD|FdivD|FnegD|FcmpD|ScvtfDx|Svc|Ret|Str|Ldr|Strb|Ldrb|Ldrsb|Strh|Ldrh|Ldrsh|SubSp|AddSp))\\\\b\" \\\n  src/backend/obj \\\n  src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_legacy_enum_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy enum token usage on production machine/object/select surface:\" 1>&"
        out = out + "2\n  echo \"$bad_legacy_enum_surface\" 1>&2\n  exit 1\nfi\n\n# Non-internal production surface must not leak Mir/Lir symbol names.\nbad_legacy_symbol_surface=\"$(rg -n \"\\\\b(Mir[A-Za-z0-9_]+|Lir[A-Za-z0-9_]+|mir[A-Z][A-Za-z0-9_]*|lir[A-Z][A-Za-z0-9_]*)\\\\b\" \\\n  src/backend -g '*.cheng' \\\n  -g '!src/backend/uir/uir_internal/**' \\\n  -g '!src/backend/machine/machine_internal/**' \\\n  -g '!src/backend/machine/select_internal/**' || true)\"\nif [ \"$bad_legacy_symbol_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden Mir/Lir symbol leakage on non-internal backend surface:\" 1>&2\n  echo \"$bad_legacy_symbol_surface\" 1>&2\n  exit 1\nfi\n\n# Internal implementation naming is also converged: no Mir/Lir symbols remain.\nbad_legacy_symbol_internal=\"$(rg -n \"\\\\b(Mir[A-Za-z0-9_]+|Lir[A-Za-z0-9_]+|mir[A-Z][A-Za-z0-9_]*|lir[A-Z][A-Za-z0-9_]*)\\\\b\" \\\n  src/backend/uir/uir_internal \\\n  src/backend/machine/machine_internal \\\n  src/backend/machine/select_internal -g '*.cheng' || true)\"\nif [ \"$bad_legacy_symbol_internal\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden Mir/Lir symbol usage in internal backend implementation:\" 1>&2\n  echo \"$bad_legacy_symbol_internal\" 1>&2\n  exit 1\nfi\n\n# Machine internal enum tokens are converged to machineCore* namespace.\nbad_legacy_machine_enum_internal=\"$(rg -n \"\\\\b(lr[A-Z][A-Za-z0-9_]*|lc[A-Z][A-Za-z0-9_]*|lo[A-Z][A-Za-z0-9_]*)\\\\b\" \\\n  src/backend/machine/machine_inte"
        out = out + "rnal -g '*.cheng' || true)\"\nif [ \"$bad_legacy_machine_enum_internal\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy lr/lc/lo enum token in machine_internal:\" 1>&2\n  echo \"$bad_legacy_machine_enum_internal\" 1>&2\n  exit 1\nfi\n\n# Transitional compat aliases are fully removed; any usage is forbidden.\nbad_uir_compat_surface=\"$(rg -n \"\\\\bUirCompat(Type|TypeKind|Block)\\\\b\" \\\n  src/backend -g '*.cheng' || true)\"\nif [ \"$bad_uir_compat_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden UirCompat* alias usage:\" 1>&2\n  echo \"$bad_uir_compat_surface\" 1>&2\n  exit 1\nfi\n\n# Object writers must go through machine facade instead of internal MIR/LIR/isel/regalloc layers.\nbad_obj=\"$(rg -n \"import[[:space:]]+cheng/backend/(uir/uir_internal|machine/(machine_internal|select_internal|regalloc_internal))\" \\\n  src/backend/obj -g '*.cheng' || true)\"\nif [ \"$bad_obj\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy import in object writers:\" 1>&2\n  echo \"$bad_obj\" 1>&2\n  exit 1\nfi\n\n# Tooling scripts should not force legacy knobs.\nbad_tooling=\"$(rg -n \"MIR_PROFILE|BACKEND_SSA|STAGE1_SKIP_MONO|BACKEND_SKIP_MONO|C_SYSTEM\" src/tooling -g '*.sh' -g '!verify_backend_no_legacy_refs.sh' || true)\"\nif [ \"$bad_tooling\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden legacy env usage in tooling scripts:\" 1>&2\n  echo \"$bad_tooling\" 1>&2\n  exit 1\nfi\n\n# St"
        out = out + "age0 compat overlay has been removed from production tooling.\nbad_stage0_compat_generator=\"$(rg -n \"gen_stage0_compat_src\\\\.py\" src/tooling -g '*.sh' -g '!verify_backend_no_legacy_refs.sh' || true)\"\nif [ \"$bad_stage0_compat_generator\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden stage0 compat overlay generator usage in tooling scripts:\" 1>&2\n  echo \"$bad_stage0_compat_generator\" 1>&2\n  exit 1\nfi\n\nbad_stage0_compat_default=\"$(rg -n \"CHENG_(SELF_OBJ_BOOTSTRAP|BACKEND_BUILD_DRIVER)_STAGE0_COMPAT:-1\" src/tooling -g '*.sh' -g '!verify_backend_no_legacy_refs.sh' || true)\"\nif [ \"$bad_stage0_compat_default\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden stage0 compat default=1 in tooling scripts:\" 1>&2\n  echo \"$bad_stage0_compat_default\" 1>&2\n  exit 1\nfi\n\n# Backend source files must not read removed legacy env knobs directly.\nbad_backend_removed_env_reads=\"$(rg -n \"MIR_PROFILE|BACKEND_SSA|STAGE1_SKIP_MONO|BACKEND_SKIP_MONO|C_SYSTEM\" \\\n  src/backend -g '*.cheng' \\\n  -g '!src/backend/tooling/backend_driver.cheng' || true)\"\nif [ \"$bad_backend_removed_env_reads\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden removed legacy env reads in backend source:\" 1>&2\n  e"
        out = out + "cho \"$bad_backend_removed_env_reads\" 1>&2\n  exit 1\nfi\n\n# Stage1 source files must not read removed legacy frontend env knobs.\nbad_stage1_removed_env_reads=\"$(rg -n \"C_SYSTEM\" src/stage1 -g '*.cheng' || true)\"\nif [ \"$bad_stage1_removed_env_reads\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden removed frontend env reads in stage1 source:\" 1>&2\n  echo \"$bad_stage1_removed_env_reads\" 1>&2\n  exit 1\nfi\n\n# ABI v1 is removed from production tooling/backend surfaces.\nbad_abi_v1_surface=\"$(rg -n \"ABI[^\\\\n]*v1|--abi:v1\" \\\n  src/backend src/tooling scripts verify.sh \\\n  -g '*.cheng' -g '*.sh' -g '!src/tooling/cheng_tooling_embedded_inline.cheng' || true)\"\nif [ \"$bad_abi_v1_surface\" != \"\" ]; then\n  echo \"[verify_backend_no_legacy_refs] forbidden ABI v1 usage in production surfaces:\" 1>&2\n  echo \"$bad_abi_v1_surface\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_no_legacy_refs ok\"\n"
        return out
    if id == "verify_backend_no_obj_artifacts":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nscan_paths_csv=\"${BACKEND_NO_OBJ_SCAN_PATHS:-artifacts/backend_closedloop:artifacts/backend_profile_smoke:artifacts/backend_profile_schema:artifacts/backend_mem_contract:artifacts/backend_dod_contract:artifacts/backend_mem_image_core:artifacts/backend_mem_exe_emit:artifacts/backend_profile_baseline:artifacts/backend_linkerless_dev:artifacts/backend_hotpatch_meta:artifacts/backend_hotpatch_inplace:artifacts/backend_incr_patch_fastpath:artifacts/backend_mem_patch_regression:artifacts/backend_hotpatch:artifacts/backend_plugin_isolation:artifacts/backend_linker_abi_core:artifacts/backend_self_linker_elf:artifacts/backend_self_linker_coff:artifacts/backend_prod:dist/releases/current}\"\n\nout_dir=\"artifacts/backend_no_obj_artifacts\"\nreport=\"$out_dir/backend_no_obj_artifacts.report.txt\"\nmkdir -p \"$out_dir\"\n\nmatches_file=\"$out_dir/backend_no_obj_artifacts.matches.txt\"\n: >\"$matches_file\"\n\nold_ifs=\"$IFS\"\nIFS=':'\nfor p in $scan_paths_csv; do\n  IFS=\"$old_ifs\"\n  [ \"$p\" != \"\" ] || continue\n  if [ ! -e \"$p\" ]; then\n    continue\n  fi\n  find \"$p\" \\( -type f -o -type d \\) \\\n    \\( -name '*.o' -o -name '*.obj' -o -name '*.objs' -o -name '*.objs.lock' -o -name '*.tmp.linkobj' \\) \\\n    -print >>\"$matches_file\"\ndone\nIFS=\"$old_ifs\"\n\nif [ -s \"$matches_file\" ]; then\n  LC_ALL=C sort "
        out = out + "-u \"$matches_file\" -o \"$matches_file\"\nfi\n\ncount=\"0\"\nif [ -s \"$matches_file\" ]; then\n  count=\"$(wc -l < \"$matches_file\" | tr -d ' ')\"\nfi\n\n{\n  echo \"scan_paths=$scan_paths_csv\"\n  echo \"obj_like_count=$count\"\n  if [ \"$count\" != \"0\" ]; then\n    echo \"obj_like_paths_file=$matches_file\"\n  fi\n} >\"$report\"\n\nif [ \"$count\" != \"0\" ]; then\n  echo \"[verify_backend_no_obj_artifacts] found obj-like artifacts in closure outputs:\" >&2\n  sed 's/^/  - /' \"$matches_file\" >&2\n  echo \"[verify_backend_no_obj_artifacts] report=$report\" >&2\n  exit 1\nfi\n\necho \"verify_backend_no_obj_artifacts ok\"\n"
        return out
    if id == "verify_backend_noalias_opt":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_noalias_opt] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_has_marker() {\n  cand=\"$1\"\n  marker=\"$2\"\n  if [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 0\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  rg -F -q \"$marker\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    BACKEND_DRIVER_A"
        out = out + "LLOW_FALLBACK=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_noalias_opt] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\nrefresh_missing_marker=\"${PAR05_DRIVER_REFRESH:-0}\"\ncase \"$refresh_missing_marker\" in\n  0|1) ;;\n  *) refresh_missing_marker=\"0\" ;;\nesac\nif ! driver_has_marker \"$driver\" \"uir_opt2.noalias\"; then\n  if [ \"$refresh_missing_marker\" = \"1\" ]; then\n    refreshed_driver=\"$(env \\\n      BACKEND_DRIVER_PATH_PREFER_REBUILD=1 \\\n      BACKEND_DRIVER_ALLOW_FALLBACK=0 \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n    if [ -x \"$refreshed_driver\" ] && driver_has_marker \"$refreshed_driver\" \"uir_opt2.noalias\"; then\n      echo \"[verify_backend_noalias_opt] use refreshed backend driver: $refreshed_driver\" 1>&2\n      driver=\"$refreshed_driver\"\n    fi\n  fi\nfi\nif ! driver_has_marker \"$driver\" \"uir_opt2.noalias\"; then\n  echo \"[verify_backend_noalias_opt] backend driver missing noalias marker: $driver\" 1>&2\n  exit 1\nfi\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\nbenefit_fixture=\"${BACKEND_NOALIAS_BENEFIT_FIXTURE:-tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng}\"\nmem2reg_fixture=\"${BACKEND_NOALIAS_M"
        out = out + "EM2REG_FIXTURE:-tests/cheng/backend/fixtures/return_opt2_noalias_mem2reg_load.cheng}\"\nguard_fixture=\"${BACKEND_NOALIAS_GUARD_FIXTURE:-tests/cheng/backend/fixtures/return_store_deref.cheng}\"\nfor fixture_path in \"$benefit_fixture\" \"$mem2reg_fixture\" \"$guard_fixture\"; do\n  if [ ! -f \"$fixture_path\" ]; then\n    echo \"[verify_backend_noalias_opt] missing fixture: $fixture_path\" 1>&2\n    exit 2\n  fi\ndone\n\nfor required in \\\n  \"src/backend/uir/uir_noalias_pass.cheng\" \\\n  \"src/backend/uir/uir_opt.cheng\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[verify_backend_noalias_opt] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\nrequire_marker() {\n  file=\"$1\"\n  pat=\"$2\"\n  label=\"$3\"\n  if ! rg -q \"$pat\" \"$file\"; then\n    echo \"[verify_backend_noalias_opt] missing marker ($label) in $file\" 1>&2\n    exit 1\n  fi\n}\n\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"fn uirRunNoAliasPrep\\\\(\" \"noalias_pass_entry\"\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"fn uirNoAliasResolveAddrBaseSlot\\\\(\" \"noalias_resolve_addr\"\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"st\\\\.kind = msAssign\" \"noalias_mem2reg_store\"\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"noalias_report\" \"noalias_report_surface\"\nrequire_marker \"src/backend/uir/uir_noalias_pass.cheng\" \"proof_backed_changes=\" \"noalias_proof_backed_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \""
        out = out + "uir_opt2\\\\.noalias\" \"noalias_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.noalias\\\\.proof_required\" \"noalias_proof_required_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt2\\\\.noalias\\\\.proof_backed_funcs=\" \"noalias_proof_backed_profile_surface\"\nrequire_marker \"src/backend/uir/uir_opt.cheng\" \"uir_opt3\\\\.ssa\\\\.lower\" \"mem2reg_profile_surface\"\n\nout_dir=\"artifacts/backend_noalias_opt\"\nmkdir -p \"$out_dir\"\nobj=\"$out_dir/noalias_opt.o\"\nlog=\"$out_dir/noalias_opt.log\"\n\nbenefit_obj_off=\"$out_dir/noalias_opt.benefit.off.o\"\nbenefit_obj_on=\"$out_dir/noalias_opt.benefit.on.o\"\nbenefit_log_off=\"$out_dir/noalias_opt.benefit.off.log\"\nbenefit_log_on=\"$out_dir/noalias_opt.benefit.on.log\"\n\nmem2reg_obj_off=\"$out_dir/noalias_opt.mem2reg.off.o\"\nmem2reg_obj_on=\"$out_dir/noalias_opt.mem2reg.on.o\"\nmem2reg_log_off=\"$out_dir/noalias_opt.mem2reg.off.log\"\nmem2reg_log_on=\"$out_dir/noalias_opt.mem2reg.on.log\"\n\nguard_obj_off=\"$out_dir/noalias_opt.guard.off.o\"\nguard_obj_on=\"$out_dir/noalias_opt.guard.on.o\"\nguard_log_off=\"$out_dir/noalias_opt.guard.off.log\"\nguard_log_on=\"$out_dir/noalias_opt.guard.on.log\"\n\nreport=\"$out_dir/noalias_opt.report.txt\"\nsnapshot=\"$out_dir/noalias_opt.snapshot.env\"\nrm -f \\\n  \"$obj\" \"$log\" \\\n  \"$benefit_obj_off\" \"$benefit_obj_on\" \"$benefit_log_off\" \"$benefit_log_on\" \\\n  \"$mem2reg_obj_off\" \"$mem2reg_obj_on\" \"$mem2"
        out = out + "reg_log_off\" \"$mem2reg_log_on\" \\\n  \"$guard_obj_off\" \"$guard_obj_on\" \"$guard_log_off\" \"$guard_log_on\"\n\nbuild_one() {\n  fixture=\"$1\"\n  noalias=\"$2\"\n  out_obj=\"$3\"\n  out_log=\"$4\"\n  cache_dir=\"$out_obj.objs\"\n  rm -rf \"$cache_dir\"\n  set +e\n  env \\\n    ABI=v2_noptr \\\n    STAGE1_STD_NO_POINTERS=0 \\\n    STAGE1_STD_NO_POINTERS_STRICT=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_OWNERSHIP=0 \\\n    BACKEND_MODULE_CACHE= \\\n    BACKEND_MULTI_MODULE_CACHE= \\\n    UIR_PROFILE=1 \\\n    UIR_NOALIAS=\"$noalias\" \\\n    UIR_NOALIAS_REQUIRE_PROOF=1 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_OPT_LEVEL=2 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out_obj\" \\\n    \"$driver\" >\"$out_log\" 2>&1\n  status=\"$?\"\n  set -e\n  return \"$status\"\n}\n\nprofile_metric() {\n  file=\"$1\"\n  event=\"$2\"\n  field=\"$3\"\n  awk -v target_event=\"$event\" -v target_field=\"$field\" '\n    $1 == \"uir_profile\" && $2 == target_event {\n      for (i = 3; i <= NF; i++) {\n        split($i, kv, \"=\")\n        if (kv[1] == target_field) {\n          print kv[2]\n          found = 1\n          exit\n        }\n      }\n    }\n"
        out = out + "    END {\n      if (!found) {\n        print \"\"\n      }\n    }\n  ' \"$file\"\n}\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nrequire_profile_events() {\n  label=\"$1\"\n  off_log=\"$2\"\n  on_log=\"$3\"\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.disabled([[:space:]]+|$)' \"$off_log\"; then\n    echo \"[verify_backend_noalias_opt] missing noalias disabled profile event (${label}): $off_log\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias([[:space:]]+|$)' \"$on_log\"; then\n    echo \"[verify_backend_noalias_opt] missing noalias profile event (${label}): $on_log\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.safe\\.copy_prop([[:space:]]+|$)' \"$on_log\"; then\n    echo \"[verify_backend_noalias_opt] missing opt2 copy_prop event (${label}): $on_log\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.proof_required([[:space:]]+|$)' \"$on_log\"; then\n    echo \"[verify_backend_noalias_opt] missing noalias proof-required profile event (${label}): $on_log\" 1>&2\n    exit 1\n  fi\n  if ! rg -q '^uir_profile[[:space:]]+uir_opt2\\.noalias\\.proof_backed_funcs=' \"$on_log\"; then\n    echo \"[verify_backend_noalias_opt] missing noalias proof-backed funcs profile event (${label}): $on_log\" 1>&2\n    exit 1\n  fi\n}\n\nextract_report_metric() {\n  line=\"$1\"\n  key=\"$2\"\n  printf '%s\\n' \"$line\" | tr '\\t' '\\"
        out = out + "n' | awk -F= -v target_key=\"$key\" '$1==target_key{print $2; exit}'\n}\n\nparse_noalias_report() {\n  log_file=\"$1\"\n  report_label=\"$2\"\n  line=\"$(rg '^noalias_report[[:space:]]+' \"$log_file\" | tail -n 1 || true)\"\n  if [ \"$line\" = \"\" ]; then\n    echo \"source_contract_fallback||0|0|0|0|0|0|0|0|0|0\"\n    return 0\n  fi\n\n  forwarded=\"$(extract_report_metric \"$line\" \"forward_loads\")\"\n  mem2reg_loads=\"$(extract_report_metric \"$line\" \"mem2reg_loads\")\"\n  mem2reg_stores=\"$(extract_report_metric \"$line\" \"mem2reg_stores\")\"\n  changed_funcs=\"$(extract_report_metric \"$line\" \"changed_funcs\")\"\n  proof_backed_changes=\"$(extract_report_metric \"$line\" \"proof_backed_changes\")\"\n  proof_checked_funcs=\"$(extract_report_metric \"$line\" \"proof_checked_funcs\")\"\n  proof_skipped_funcs=\"$(extract_report_metric \"$line\" \"proof_skipped_funcs\")\"\n  proof_required=\"$(extract_report_metric \"$line\" \"proof_required\")\"\n  for metric_pair in \\\n    \"forward_loads:$forwarded\" \\\n    \"mem2reg_loads:$mem2reg_loads\" \\\n    \"mem2reg_stores:$mem2reg_stores\" \\\n    \"changed_funcs:$changed_funcs\" \\\n    \"proof_backed_changes:$proof_backed_changes\" \\\n    \"proof_checked_funcs:$proof_checked_funcs\" \\\n    \"proof_skipped_funcs:$proof_skipped_funcs\" \\\n    \"proof_required:$proof_required\"; do\n    metric_name=\"${metric_pair%%:*}\"\n    metric_value=\"${metric_pair#*:}\"\n    if ! is_uint \"$metric_value\"; then\n      echo \"[ve"
        out = out + "rify_backend_noalias_opt] invalid noalias_report metric (${report_label}/${metric_name}): ${metric_value}\" 1>&2\n      exit 1\n    fi\n  done\n  total_changes=$((forwarded + mem2reg_loads + mem2reg_stores))\n  echo \"runtime_v2|$line|$forwarded|$mem2reg_loads|$mem2reg_stores|$changed_funcs|$proof_backed_changes|$proof_checked_funcs|$proof_skipped_funcs|$proof_required|$total_changes\"\n}\n\nif ! build_one \"$benefit_fixture\" 0 \"$benefit_obj_off\" \"$benefit_log_off\"; then\n  echo \"[verify_backend_noalias_opt] compile failed (benefit/noalias=0): $benefit_fixture\" 1>&2\n  tail -n 200 \"$benefit_log_off\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$benefit_fixture\" 1 \"$benefit_obj_on\" \"$benefit_log_on\"; then\n  echo \"[verify_backend_noalias_opt] compile failed (benefit/noalias=1): $benefit_fixture\" 1>&2\n  tail -n 200 \"$benefit_log_on\" 1>&2 || true\n  exit 1\nfi\n\nif ! build_one \"$mem2reg_fixture\" 0 \"$mem2reg_obj_off\" \"$mem2reg_log_off\"; then\n  echo \"[verify_backend_noalias_opt] compile failed (mem2reg/noalias=0): $mem2reg_fixture\" 1>&2\n  tail -n 200 \"$mem2reg_log_off\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$mem2reg_fixture\" 1 \"$mem2reg_obj_on\" \"$mem2reg_log_on\"; then\n  echo \"[verify_backend_noalias_opt] compile failed (mem2reg/noalias=1): $mem2reg_fixture\" 1>&2\n  tail -n 200 \"$mem2reg_log_on\" 1>&2 || true\n  exit 1\nfi\n\nif ! build_one \"$guard_fixture\" 0 \"$guard_obj_off\" \"$guard_log_off\"; then\n  echo \"[verify_backend_noali"
        out = out + "as_opt] compile failed (guard/noalias=0): $guard_fixture\" 1>&2\n  tail -n 200 \"$guard_log_off\" 1>&2 || true\n  exit 1\nfi\nif ! build_one \"$guard_fixture\" 1 \"$guard_obj_on\" \"$guard_log_on\"; then\n  echo \"[verify_backend_noalias_opt] compile failed (guard/noalias=1): $guard_fixture\" 1>&2\n  tail -n 200 \"$guard_log_on\" 1>&2 || true\n  exit 1\nfi\n\nfor out_obj in \\\n  \"$benefit_obj_off\" \"$benefit_obj_on\" \\\n  \"$mem2reg_obj_off\" \"$mem2reg_obj_on\" \\\n  \"$guard_obj_off\" \"$guard_obj_on\"; do\n  if [ ! -s \"$out_obj\" ]; then\n    echo \"[verify_backend_noalias_opt] missing object output: $out_obj\" 1>&2\n    exit 1\n  fi\ndone\n\nrequire_profile_events \"benefit\" \"$benefit_log_off\" \"$benefit_log_on\"\nrequire_profile_events \"mem2reg\" \"$mem2reg_log_off\" \"$mem2reg_log_on\"\nrequire_profile_events \"guard\" \"$guard_log_off\" \"$guard_log_on\"\n\nbenefit_report=\"$(parse_noalias_report \"$benefit_log_on\" \"benefit\")\"\nIFS='|' read -r benefit_mode benefit_report_line benefit_forwarded benefit_mem2reg_loads benefit_mem2reg_stores benefit_changed_funcs benefit_proof_backed_changes benefit_proof_checked_funcs benefit_proof_skipped_funcs benefit_proof_required benefit_total_changes <<EOF\n$benefit_report\nEOF\nmem2reg_report=\"$(parse_noalias_report \"$mem2reg_log_on\" \"mem2reg\")\"\nIFS='|' read -r mem2reg_mode mem2reg_report_line mem2reg_forwarded mem2reg_mem2reg_loads mem2reg_mem2reg_stores mem2reg_changed_funcs mem2reg_proof_backed_changes mem2re"
        out = out + "g_proof_checked_funcs mem2reg_proof_skipped_funcs mem2reg_proof_required mem2reg_total_changes <<EOF\n$mem2reg_report\nEOF\nguard_report=\"$(parse_noalias_report \"$guard_log_on\" \"guard\")\"\nIFS='|' read -r guard_mode guard_report_line guard_forwarded guard_mem2reg_loads guard_mem2reg_stores guard_changed_funcs guard_proof_backed_changes guard_proof_checked_funcs guard_proof_skipped_funcs guard_proof_required guard_total_changes <<EOF\n$guard_report\nEOF\n\nif [ \"$benefit_mode\" = \"runtime_v2\" ]; then\n  if [ \"$benefit_forwarded\" -le 0 ] || [ \"$benefit_mem2reg_stores\" -le 0 ] || [ \"$benefit_changed_funcs\" -le 0 ]; then\n    echo \"[verify_backend_noalias_opt] benefit fixture missing forward/mem2reg_store signal: $benefit_report_line\" 1>&2\n    exit 1\n  fi\n  if [ \"$benefit_proof_backed_changes\" -le 0 ] || [ \"$benefit_proof_checked_funcs\" -le 0 ] || [ \"$benefit_proof_required\" -ne 1 ]; then\n    echo \"[verify_backend_noalias_opt] benefit fixture missing proof-backed noalias signal: $benefit_report_line\" 1>&2\n    exit 1\n  fi\nfi\nif [ \"$mem2reg_mode\" = \"runtime_v2\" ]; then\n  if [ \"$mem2reg_mem2reg_loads\" -le 0 ] || [ \"$mem2reg_changed_funcs\" -le 0 ]; then\n    echo \"[verify_backend_noalias_opt] mem2reg fixture missing mem2reg_load signal: $mem2reg_report_line\" 1>&2\n    exit 1\n  fi\n  if [ \"$mem2reg_proof_backed_changes\" -le 0 ] || [ \"$mem2reg_proof_checked_funcs\" -le 0 ] || [ \"$mem2reg_proof_required\" -ne 1 ]; then\n    echo \"[verify_"
        out = out + "backend_noalias_opt] mem2reg fixture missing proof-backed noalias signal: $mem2reg_report_line\" 1>&2\n    exit 1\n  fi\nfi\nif ! cmp -s \"$guard_obj_off\" \"$guard_obj_on\"; then\n  echo \"[verify_backend_noalias_opt] guard object mismatch (expected fallback-stable): $guard_obj_off vs $guard_obj_on\" 1>&2\n  exit 1\nfi\nif [ \"$guard_mode\" = \"runtime_v2\" ]; then\n  if [ \"$guard_total_changes\" -ne 0 ] || [ \"$guard_changed_funcs\" -ne 0 ]; then\n    echo \"[verify_backend_noalias_opt] guard fixture expected zero noalias changes: $guard_report_line\" 1>&2\n    exit 1\n  fi\n  if [ \"$guard_proof_required\" -ne 1 ]; then\n    echo \"[verify_backend_noalias_opt] guard fixture missing proof-required noalias mode: $guard_report_line\" 1>&2\n    exit 1\n  fi\nfi\n\nnoalias_report_mode=\"runtime_v2\"\nfor mode in \"$benefit_mode\" \"$mem2reg_mode\" \"$guard_mode\"; do\n  if [ \"$mode\" != \"runtime_v2\" ]; then\n    noalias_report_mode=\"source_contract_fallback\"\n    break\n  fi\ndone\n\ncp \"$benefit_obj_on\" \"$obj\"\ncp \"$benefit_log_on\" \"$log\"\n\nsize_off=\"$(wc -c < \"$benefit_obj_off\" | tr -d ' ')\"\nsize_on=\"$(wc -c < \"$benefit_obj_on\" | tr -d ' ')\"\nsize_delta=\"$((size_off - size_on))\"\n\nmem2reg_size_off=\"$(wc -c < \"$mem2reg_obj_off\" | tr -d ' ')\"\nmem2reg_size_on=\"$(wc -c < \"$mem2reg_obj_on\" | tr -d ' ')\"\nmem2reg_size_delta=\"$((mem2reg_size_off - mem2reg_size_on))\"\n\nguard_size_off=\"$(wc -c < \"$guard_obj_off\" | tr -d ' ')\"\nguard_size_on=\""
        out = out + "$(wc -c < \"$guard_obj_on\" | tr -d ' ')\"\nguard_size_delta=\"$((guard_size_off - guard_size_on))\"\n\nemit_total_ms_off=\"$(profile_metric \"$benefit_log_off\" \"single.emit_obj\" \"total_ms\")\"\nemit_total_ms_on=\"$(profile_metric \"$benefit_log_on\" \"single.emit_obj\" \"total_ms\")\"\nnoalias_step_ms_on=\"$(profile_metric \"$benefit_log_on\" \"uir_opt2.noalias\" \"step_ms\")\"\ncopy_prop_step_ms_on=\"$(profile_metric \"$benefit_log_on\" \"uir_opt2.safe.copy_prop\" \"step_ms\")\"\n\nbenefit_hint=\"pass_activated_codegen_stable\"\nif [ \"$size_delta\" -gt 0 ]; then\n  benefit_hint=\"obj_size_reduced\"\nelif [ \"$size_delta\" -lt 0 ]; then\n  benefit_hint=\"obj_size_increased\"\nfi\nmem2reg_hint=\"mem2reg_load_triggered\"\nif [ \"$mem2reg_mem2reg_loads\" -le 0 ]; then\n  mem2reg_hint=\"mem2reg_load_missing\"\nfi\nguard_hint=\"fallback_stable_guard\"\nif [ \"$guard_size_delta\" -ne 0 ]; then\n  guard_hint=\"guard_size_changed\"\nfi\n\n{\n  echo \"verify_backend_noalias_opt report\"\n  echo \"driver=$driver\"\n  echo \"target=$target\"\n  echo \"fixture=$benefit_fixture\"\n  echo \"object=$obj\"\n  echo \"log=$log\"\n  echo \"object_off=$benefit_obj_off\"\n  echo \"object_on=$benefit_obj_on\"\n  echo \"log_off=$benefit_log_off\"\n  echo \"log_on=$benefit_log_on\"\n  echo \"emit_total_ms_off=${emit_total_ms_off:-na}\"\n  echo \"emit_total_ms_on=${emit_total_ms_on:-na}\"\n  echo \"noalias_step_ms_on=${noalias_step_ms_on:-na}\"\n  echo \"copy_prop_step_ms_on=${copy_prop_step_ms"
        out = out + "_on:-na}\"\n  echo \"noalias_report_mode=$noalias_report_mode\"\n  echo \"noalias_report=$benefit_report_line\"\n  echo \"noalias_forwarded_loads=$benefit_forwarded\"\n  echo \"noalias_mem2reg_loads=$benefit_mem2reg_loads\"\n  echo \"noalias_mem2reg_stores=$benefit_mem2reg_stores\"\n  echo \"noalias_changed_funcs=$benefit_changed_funcs\"\n  echo \"noalias_proof_backed_changes=$benefit_proof_backed_changes\"\n  echo \"noalias_proof_checked_funcs=$benefit_proof_checked_funcs\"\n  echo \"noalias_proof_skipped_funcs=$benefit_proof_skipped_funcs\"\n  echo \"noalias_proof_required=$benefit_proof_required\"\n  echo \"obj_size_off=$size_off\"\n  echo \"obj_size_on=$size_on\"\n  echo \"obj_size_delta=$size_delta\"\n  echo \"benefit_hint=$benefit_hint\"\n  echo \"benefit_fixture=$benefit_fixture\"\n  echo \"benefit_report_mode=$benefit_mode\"\n  echo \"benefit_report=$benefit_report_line\"\n  echo \"benefit_total_changes=$benefit_total_changes\"\n  echo \"mem2reg_fixture=$mem2reg_fixture\"\n  echo \"mem2reg_object_off=$mem2reg_obj_off\"\n  echo \"mem2reg_object_on=$mem2reg_obj_on\"\n  echo \"mem2reg_log_off=$mem2reg_log_off\"\n  echo \"mem2reg_log_on=$mem2reg_log_on\"\n  echo \"mem2reg_report_mode=$mem2reg_mode\"\n  echo \"mem2reg_report=$mem2reg_report_line\"\n  echo \"mem2reg_forwarded_loads=$mem2reg_forwarded\"\n  echo \"mem2reg_mem2reg_loads=$mem2reg_mem2reg_loads\"\n  echo \"mem2reg_mem2reg_stores=$mem2reg_mem2reg_stores\"\n  echo \"mem2reg_changed_funcs=$mem2reg_changed_funcs\"\n"
        out = out + "  echo \"mem2reg_proof_backed_changes=$mem2reg_proof_backed_changes\"\n  echo \"mem2reg_proof_checked_funcs=$mem2reg_proof_checked_funcs\"\n  echo \"mem2reg_proof_skipped_funcs=$mem2reg_proof_skipped_funcs\"\n  echo \"mem2reg_proof_required=$mem2reg_proof_required\"\n  echo \"mem2reg_total_changes=$mem2reg_total_changes\"\n  echo \"mem2reg_obj_size_off=$mem2reg_size_off\"\n  echo \"mem2reg_obj_size_on=$mem2reg_size_on\"\n  echo \"mem2reg_obj_size_delta=$mem2reg_size_delta\"\n  echo \"mem2reg_hint=$mem2reg_hint\"\n  echo \"guard_fixture=$guard_fixture\"\n  echo \"guard_object_off=$guard_obj_off\"\n  echo \"guard_object_on=$guard_obj_on\"\n  echo \"guard_log_off=$guard_log_off\"\n  echo \"guard_log_on=$guard_log_on\"\n  echo \"guard_report_mode=$guard_mode\"\n  echo \"guard_report=$guard_report_line\"\n  echo \"guard_forwarded_loads=$guard_forwarded\"\n  echo \"guard_mem2reg_loads=$guard_mem2reg_loads\"\n  echo \"guard_mem2reg_stores=$guard_mem2reg_stores\"\n  echo \"guard_changed_funcs=$guard_changed_funcs\"\n  echo \"guard_proof_backed_changes=$guard_proof_backed_changes\"\n  echo \"guard_proof_checked_funcs=$guard_proof_checked_funcs\"\n  echo \"guard_proof_skipped_funcs=$guard_proof_skipped_funcs\"\n  echo \"guard_proof_required=$guard_proof_required\"\n  echo \"guard_total_changes=$guard_total_changes\"\n  echo \"guard_obj_size_off=$guard_size_off\"\n  echo \"guard_obj_size_on=$guard_size_on\"\n  echo \"guard_obj_size_delta=$guard_size_delta\"\n  echo \"guard_hint=$guard_h"
        out = out + "int\"\n} >\"$report\"\n\n{\n  echo \"backend_noalias_opt_driver=$driver\"\n  echo \"backend_noalias_opt_target=$target\"\n  echo \"backend_noalias_opt_fixture=$benefit_fixture\"\n  echo \"backend_noalias_opt_report=$report\"\n  echo \"backend_noalias_opt_emit_total_ms_off=${emit_total_ms_off:-}\"\n  echo \"backend_noalias_opt_emit_total_ms_on=${emit_total_ms_on:-}\"\n  echo \"backend_noalias_opt_noalias_step_ms_on=${noalias_step_ms_on:-}\"\n  echo \"backend_noalias_opt_copy_prop_step_ms_on=${copy_prop_step_ms_on:-}\"\n  echo \"backend_noalias_opt_report_mode=$noalias_report_mode\"\n  echo \"backend_noalias_opt_forwarded_loads=$benefit_forwarded\"\n  echo \"backend_noalias_opt_mem2reg_loads=$benefit_mem2reg_loads\"\n  echo \"backend_noalias_opt_mem2reg_stores=$benefit_mem2reg_stores\"\n  echo \"backend_noalias_opt_changed_funcs=$benefit_changed_funcs\"\n  echo \"backend_noalias_opt_proof_backed_changes=$benefit_proof_backed_changes\"\n  echo \"backend_noalias_opt_proof_checked_funcs=$benefit_proof_checked_funcs\"\n  echo \"backend_noalias_opt_proof_skipped_funcs=$benefit_proof_skipped_funcs\"\n  echo \"backend_noalias_opt_proof_required=$benefit_proof_required\"\n  echo \"backend_noalias_opt_obj_size_off=$size_off\"\n  echo \"backend_noalias_opt_obj_size_on=$size_on\"\n  echo \"backend_noalias_opt_obj_size_delta=$size_delta\"\n  echo \"backend_noalias_opt_benefit_hint=$benefit_hint\"\n  echo \"backend_noalias_opt_benefit_total_changes=$benefit_total_changes\"\n  echo \"backend"
        out = out + "_noalias_opt_mem2reg_fixture=$mem2reg_fixture\"\n  echo \"backend_noalias_opt_mem2reg_report_mode=$mem2reg_mode\"\n  echo \"backend_noalias_opt_mem2reg_forwarded_loads=$mem2reg_forwarded\"\n  echo \"backend_noalias_opt_mem2reg_mem2reg_loads=$mem2reg_mem2reg_loads\"\n  echo \"backend_noalias_opt_mem2reg_mem2reg_stores=$mem2reg_mem2reg_stores\"\n  echo \"backend_noalias_opt_mem2reg_changed_funcs=$mem2reg_changed_funcs\"\n  echo \"backend_noalias_opt_mem2reg_proof_backed_changes=$mem2reg_proof_backed_changes\"\n  echo \"backend_noalias_opt_mem2reg_proof_checked_funcs=$mem2reg_proof_checked_funcs\"\n  echo \"backend_noalias_opt_mem2reg_proof_skipped_funcs=$mem2reg_proof_skipped_funcs\"\n  echo \"backend_noalias_opt_mem2reg_proof_required=$mem2reg_proof_required\"\n  echo \"backend_noalias_opt_mem2reg_total_changes=$mem2reg_total_changes\"\n  echo \"backend_noalias_opt_mem2reg_obj_size_off=$mem2reg_size_off\"\n  echo \"backend_noalias_opt_mem2reg_obj_size_on=$mem2reg_size_on\"\n  echo \"backend_noalias_opt_mem2reg_obj_size_delta=$mem2reg_size_delta\"\n  echo \"backend_noalias_opt_mem2reg_hint=$mem2reg_hint\"\n  echo \"backend_noalias_opt_guard_fixture=$guard_fixture\"\n  echo \"backend_noalias_opt_guard_report_mode=$guard_mode\"\n  echo \"backend_noalias_opt_guard_forwarded_loads=$guard_forwarded\"\n  echo \"backend_noalias_opt_guard_mem2reg_loads=$guard_mem2reg_loads\"\n  echo \"backend_noalias_opt_guard_mem2reg_stores=$guard_mem2reg_stores\"\n  echo \"backend_noalias_opt_guard_c"
        out = out + "hanged_funcs=$guard_changed_funcs\"\n  echo \"backend_noalias_opt_guard_total_changes=$guard_total_changes\"\n  echo \"backend_noalias_opt_guard_proof_backed_changes=$guard_proof_backed_changes\"\n  echo \"backend_noalias_opt_guard_proof_checked_funcs=$guard_proof_checked_funcs\"\n  echo \"backend_noalias_opt_guard_proof_skipped_funcs=$guard_proof_skipped_funcs\"\n  echo \"backend_noalias_opt_guard_proof_required=$guard_proof_required\"\n  echo \"backend_noalias_opt_guard_obj_size_off=$guard_size_off\"\n  echo \"backend_noalias_opt_guard_obj_size_on=$guard_size_on\"\n  echo \"backend_noalias_opt_guard_obj_size_delta=$guard_size_delta\"\n  echo \"backend_noalias_opt_guard_hint=$guard_hint\"\n} >\"$snapshot\"\n\necho \"verify_backend_noalias_opt ok\"\n"
        return out
    if id == "verify_backend_nolibc_linux_aarch64":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_NOLIBC_TARGET:-aarch64-unknown-linux-gnu}\"\nout_dir=\"artifacts/backend_nolibc_linux_aarch64\"\nmkdir -p \"$out_dir\"\n\nruntime_src=\"src/std/system_helpers_backend_nolibc_linux_aarch64.cheng\"\nruntime_obj=\"$out_dir/system_helpers_backend_nolibc_linux_aarch64.$target.o\"\n\nif [ ! -f \"$runtime_src\" ]; then\n  echo \"[verify_backend_nolibc_linux_aarch64] missing runtime source: $runtime_src\" >&2\n  exit 1\nfi\n\nif [ ! -f \"$runtime_obj\" ] || [ \"$runtime_src\" -nt \"$runtime_obj\" ]; then\n  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$runtime_src\" \\\n  BACKEND_OUTPUT=\"$runtime_obj\" \\\n    \"$driver\" >/dev/null\nfi\n\nif [ ! -s \"$runtime_obj\" ]; then\n  echo \"[verify_backend_nolibc_linux_aarch64] missing runtime object: $runt"
        out = out + "ime_obj\" >&2\n  exit 1\nfi\n\nfind_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf \"%s\\n\" \"$p\"\n      return 0\n    fi\n  fi\n  for n in llvm-objdump llvm-objdump-19 llvm-objdump-18 llvm-objdump-17 llvm-objdump-16 llvm-objdump-15 llvm-objdump-14; do\n    if command -v \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nfind_nm() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-nm 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf \"%s\\n\" \"$p\"\n      return 0\n    fi\n  fi\n  for n in llvm-nm llvm-nm-19 llvm-nm-18 llvm-nm-17 llvm-nm-16 llvm-nm-15 llvm-nm-14 nm; do\n    if command -v \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nobjdump=\"$(find_objdump || true)\"\nnm_tool=\"$(find_nm || true)\"\nif [ \"$objdump\" = \"\" ] || [ \"$nm_tool\" = \"\" ]; then\n  echo \"[verify_backend_nolibc_linux_aarch64] missing llvm-objdump/llvm-nm\" >&2\n  exit 2\nfi\n\nbuild_exe() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  BACKEND_ELF_PROFILE=nolibc \\\n  BACKEND_LINKER=self \\\n  BACKEND_NO_RUNTIME_C=1 \\\n  BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >"
        out = out + "/dev/null\n  if [ ! -s \"$exe_path\" ]; then\n    echo \"[verify_backend_nolibc_linux_aarch64] missing output: $exe_path\" >&2\n    exit 1\n  fi\n}\n\nvalidate_static() {\n  exe_path=\"$1\"\n  base=\"$2\"\n\n  \"$objdump\" --private-headers \"$exe_path\" > \"$out_dir/$base.objdump.private.txt\"\n\n  grep -q \"file format elf64-littleaarch64\" \"$out_dir/$base.objdump.private.txt\"\n  if grep -q \"INTERP\" \"$out_dir/$base.objdump.private.txt\"; then\n    echo \"[verify_backend_nolibc_linux_aarch64] unexpected PT_INTERP: $exe_path\" >&2\n    exit 1\n  fi\n  if grep -q \"DYNAMIC\" \"$out_dir/$base.objdump.private.txt\"; then\n    echo \"[verify_backend_nolibc_linux_aarch64] unexpected PT_DYNAMIC: $exe_path\" >&2\n    exit 1\n  fi\n\n  undef_out=\"$($nm_tool -u \"$exe_path\" 2>/dev/null || true)\"\n  if [ \"$(printf '%s' \"$undef_out\" | tr -d '[:space:]')\" != \"\" ]; then\n    echo \"[verify_backend_nolibc_linux_aarch64] unexpected undefined symbols in: $exe_path\" >&2\n    printf \"%s\\n\" \"$undef_out\" >&2\n    exit 1\n  fi\n\n  if strings \"$exe_path\" | grep -Eq \"libc\\.so|ld-linux-aarch64\"; then\n    echo \"[verify_backend_nolibc_linux_aarch64] dynamic libc loader strings found: $exe_path\" >&2\n    exit 1\n  fi\n}\n\nhello_fixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nadd_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nmm_fixture=\"tests/cheng/backend/fixtures/mm_live_balance.cheng\"\n\nhello_exe=\"$out_dir/hello_puts.$target.nolibc\"\nadd_exe="
        out = out + "\"$out_dir/return_add.$target.nolibc\"\nmm_exe=\"$out_dir/mm_live_balance.$target.nolibc\"\n\nbuild_exe \"$hello_fixture\" \"$hello_exe\"\nbuild_exe \"$add_fixture\" \"$add_exe\"\nbuild_exe \"$mm_fixture\" \"$mm_exe\"\n\nvalidate_static \"$hello_exe\" \"hello_puts.$target.nolibc\"\nvalidate_static \"$add_exe\" \"return_add.$target.nolibc\"\nvalidate_static \"$mm_exe\" \"mm_live_balance.$target.nolibc\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\ncase \"$host_os/$host_arch\" in\n  Linux/aarch64|Linux/arm64)\n    \"$hello_exe\" > \"$out_dir/run.hello_puts.txt\"\n    grep -Fq \"hello from cheng backend\" \"$out_dir/run.hello_puts.txt\"\n\n    \"$add_exe\"\n    \"$mm_exe\"\n    ;;\n  *)\n    echo \"[verify_backend_nolibc_linux_aarch64] run phase skipped: linux/aarch64 only (host=$host_os/$host_arch)\" >&2\n    ;;\nesac\n\necho \"verify_backend_nolibc_linux_aarch64 ok\"\n"
        return out
    if id == "verify_backend_noptr_default_cli":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ndriver_has_non_c_abi_diag() {\n  cand=\"$1\"\n  if [ \"$cand\" = \"\" ] || [ ! -x \"$cand\" ]; then\n    return 1\n  fi\n  if ! command -v strings >/dev/null 2>&1; then\n    return 1\n  fi\n  tmp_strings=\"$(mktemp \"${TMPDIR:-/tmp}/cheng_driver_strings.XXXXXX\" 2>/dev/null || true)\"\n  if [ \"$tmp_strings\" = \"\" ]; then\n    return 1\n  fi\n  set +e\n  strings \"$cand\" 2>/dev/null >\"$tmp_strings\"\n  strings_status=\"$?\"\n  grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$tmp_strings\"\n  status=\"$?\"\n  set -e\n  rm -f \"$tmp_strings\" 2>/dev/null || true\n  if [ \"$strings_status\" -ne 0 ] && [ \"$status\" -ne 0 ]; then\n    return 1\n  fi\n  [ \"$status\" -eq 0 ]\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  case \"$seconds\" in\n    ''|*[!0-9]*)\n      \"$@\"\n      return $?\n      ;;\n  esac\n  if command -v timeout >/dev/null 2>&1; then\n    timeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  if command -v gtimeout >/dev/null 2>&1; then\n    gtimeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n "
        out = out + "     my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nout_dir=\"artifacts/backend_noptr_default_cli\"\nprobe_non_c_abi=\"tests/cheng/backend/fixtures/noptr_default_cli_probe_tmp.cheng\"\nobj_non_c_abi=\"$out_dir/noptr_default_cli_probe.o\"\nlog_non_c_abi=\"$out_dir/noptr_default_cli_probe.log\"\npositive_src=\"tests/cheng/backend/fixtures/return_add.cheng\"\nobj_positive=\"$out_dir/noptr_default_cli_positive.o\"\nlog_positive=\"$out_dir/noptr_default_cli_positive.log\"\nbridge_src=\"src/std/c.cheng\"\nobj_bridge=\"$out_dir/noptr_default_cli_c_bridge.o\"\nlog_bridge=\"$out_dir/noptr_default_cli_c_bridge.log\"\nchengc_tool=\"src/tooling/chengc.sh\"\ntimeout_s=\"${BACKEND_NOPTR_DEFAULT_CLI_TIMEOUT:-60}\"\n\nmkdir -p \"$out_dir\"\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\nfi\n\nif ! driver_has_non_c_abi_diag \"$driver\"; then\n  echo \"[Error] backend driver missing non-C-ABI no-pointer diagnostic marker: ${driver:-<unset>}\" 1>&2\n  exit 1\nfi\n\n"
        out = out + "cleanup_probe() {\n  rm -f \"$probe_non_c_abi\"\n}\ntrap cleanup_probe EXIT INT TERM\n\ncat >\"$probe_non_c_abi\" <<'EOF'\nfn main(): int32 =\n    var p: int32* = nil\n    return 0\nEOF\n\necho \"== backend.noptr_default_cli.non_c_abi_default ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  -u STAGE1_NO_POINTERS_NON_C_ABI \\\n  -u STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" \"$probe_non_c_abi\" --backend:obj --emit-obj --obj-out:\"$obj_non_c_abi\" >\"$log_non_c_abi\" 2>&1\nstatus_non_c_abi=\"$?\"\nset -e\nif [ \"$status_non_c_abi\" -eq 124 ]; then\n  echo \"[Error] default chengc non-C-ABI pointer probe timed out after ${timeout_s}s\" 1>&2\n  exit 1\nfi\nif [ \"$status_non_c_abi\" -eq 0 ]; then\n  echo \"[Error] expected default chengc path to reject non-C-ABI pointer usage: $probe_non_c_abi\" 1>&2\n  exit 1\nfi\nif ! grep -Fq \"no-pointer policy: pointer types are forbidden outside C ABI modules\" \"$log_non_c_abi\"; then\n  echo \"[Error] missing default chengc non-C-ABI pointer diagnostic in: $log_non_c_abi\" 1>&2\n  exit 1\nfi\n\necho \"== backend.noptr_default_cli.positive ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POI"
        out = out + "NTERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" \"$positive_src\" --backend:obj --emit-obj --obj-out:\"$obj_positive\" >\"$log_positive\" 2>&1\nstatus_positive=\"$?\"\nset -e\nif [ \"$status_positive\" -ne 0 ]; then\n  echo \"[Error] expected non-pointer positive sample to compile with non-C-ABI opt-out: $positive_src\" 1>&2\n  if [ \"$status_positive\" -eq 124 ]; then\n    echo \"[Error] positive sample timed out after ${timeout_s}s\" 1>&2\n  fi\n  tail -n 120 \"$log_positive\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$obj_positive\" ]; then\n  echo \"[Error] missing positive object output: $obj_positive\" 1>&2\n  exit 1\nfi\n\necho \"== backend.noptr_default_cli.c_abi_bridge ==\"\nset +e\nrun_with_timeout \"$timeout_s\" env \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=1 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_SKIP_SEM=0 \\\n  STAGE1_SKIP_OWNERSHIP=1 \\\n  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_WHOLE_PROGRAM=0 \\\n  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" \"$bridge_src\" --backend:obj --emit-obj --obj-out:\"$obj_bridge\" >\"$log_bridge\" 2>&1\nstatus_bridge=\"$?\"\nset -e\nif [ \"$status_bridge\" -ne 0 ]; then\n  echo \"[Error] expected C ABI bridge sample to compile: $bridge_src\" 1>&2\n  if [ \"$status_bridge\" -eq 124 ]; then\n    echo \"[Error] C ABI bridge sample timed out after ${timeout_s}"
        out = out + "s\" 1>&2\n  fi\n  tail -n 120 \"$log_bridge\" 1>&2 || true\n  exit 1\nfi\nif [ ! -s \"$obj_bridge\" ]; then\n  echo \"[Error] missing C ABI bridge object output: $obj_bridge\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_noptr_default_cli ok\"\n"
        return out
    if id == "verify_backend_noptr_exemption_scope":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nout_dir=\"artifacts/backend_noptr_exemption_scope\"\nhits_file=\"$out_dir/noptr_exemption_scope.hits.txt\"\nbad_file=\"$out_dir/noptr_exemption_scope.bad.txt\"\nmkdir -p \"$out_dir\"\n: >\"$hits_file\"\n: >\"$bad_file\"\n\nallowlist='\nsrc/tooling/backend_driver_path.${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure\nsrc/tooling/build_backend_driver.${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_tooling\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\nsrc/tooling/cheng_tooling_embedded_inline.cheng\n'\n\nis_allowed_file() {\n  cand=\"$1\"\n  while IFS= read -r allowed; do\n    if [ \"$allowed\" = \"\" ]; then\n      continue\n    fi\n    if [ \"$cand\" = \"$allowed\" ]; then\n      return 0\n    fi\n  done <<EOF\n$allowlist\nEOF\n  return 1\n}\n\nset +e\nrg -n \"STAGE1_NO_POINTERS_NON_C_ABI=[0]|STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=[0]\" \\\n  --glob '*.sh' \\\n  --glob 'cheng_tooling_embedded_inline.cheng' \\\n  src/tooling >\"$hits_file\"\nrg_status=\"$?\"\nset -e\ncase \"$rg_status\" in\n  0|1) ;;\n  *)\n    echo \"[Error] failed to scan tooling scripts for no-pointer exemptions\" 1>&2\n    exit 1\n    ;;\nesac\n\nif [ \"$rg_status\" -eq 0 ]; then\n  while IFS= read -r hit; do\n    if [ \"$hit\" = \"\" ]; then\n      continue\n    fi\n    hit_file=\"${hit%%:*"
        out = out + "}\"\n    if ! is_allowed_file \"$hit_file\"; then\n      printf '%s\\n' \"$hit\" >>\"$bad_file\"\n    fi\n  done <\"$hits_file\"\nfi\n\nif [ -s \"$bad_file\" ]; then\n  echo \"[Error] no-pointer exemption found outside allowlist:\" 1>&2\n  sed 's/^/  - /' \"$bad_file\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_noptr_exemption_scope ok\"\n"
        return out
    if id == "verify_backend_obj":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\n\ntarget=\"\"\nnm_main=\"main\"\nnm_puts=\"puts\"\n\ncase \"$host_os\" in\n  Darwin)\n    target=\"arm64-apple-darwin\"\n    nm_main=\"_main\"\n    nm_puts=\"_puts\"\n    ;;\n  Linux)\n    target=\"aarch64-unknown-linux-gnu\"\n    ;;\n  *)\n    echo \"verify_backend_obj skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\n\nout_dir=\"artifacts/backend_obj\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_TARGET=\"$target\" \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_path\" \\\n\"$driver\"\n\nif ! command -v nm >/dev/null 2>&1; then\n  echo \"verify_backend_obj skip: missing nm\" 1>&2\n  exit 2\nfi\n\nset +e\nnm \"$obj_path\" > \"$out_dir/hello_importc_puts.nm.txt\" 2>&1\nst"
        out = out + "atus_nm=\"$?\"\nset -e\nif [ \"$status_nm\" -ne 0 ]; then\n  echo \"verify_backend_obj skip: nm cannot read object ($host_os): $obj_path\" 1>&2\n  cat \"$out_dir/hello_importc_puts.nm.txt\" 1>&2 || true\n  exit 2\nfi\n\ngrep -q \" T $nm_main\" \"$out_dir/hello_importc_puts.nm.txt\"\ngrep -q \" U $nm_puts\" \"$out_dir/hello_importc_puts.nm.txt\"\n\necho \"verify_backend_obj ok\"\n"
        return out
    if id == "verify_backend_obj_determinism":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\ncase \"$host_os\" in\n  Darwin)\n    ;;\n  *)\n    echo \"verify_backend_obj_determinism skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nout_dir=\"artifacts/backend_obj_determinism\"\nmkdir -p \"$out_dir\"\n\nobj_a=\"$out_dir/a.o\"\nobj_b=\"$out_dir/b.o\"\n\nrun_obj() {\n  out=\"$1\"\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=arm64-apple-darwin \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$out\" \\\n  \"$driver\"\n}\n\nrun_obj \"$obj_a\"\nsha_a=\"$(sha256_file \"$obj_a\")\"\n"
        out = out + "\nrun_obj \"$obj_b\"\nsha_b=\"$(sha256_file \"$obj_b\")\"\n\nif [ \"$sha_a\" = \"\" ] || [ \"$sha_b\" = \"\" ]; then\n  echo \"verify_backend_obj_determinism skip: missing sha256 tool\" 1>&2\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ]; then\n  echo \"[verify_backend_obj_determinism] mismatch: $sha_a vs $sha_b\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_obj_determinism ok\"\n"
        return out
    if id == "verify_backend_obj_determinism_strict":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\ncase \"$host_os\" in\n  Darwin)\n    ;;\n  *)\n    echo \"verify_backend_obj_determinism_strict skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nout_dir=\"artifacts/backend_obj_determinism_strict\"\nmkdir -p \"$out_dir\"\nmkdir -p \"$out_dir/tmp_a\" \"$out_dir/tmp_b\" \"$out_dir/tmp_c\"\n\nobj_a=\"$out_dir/a.o\"\nobj_b=\"$out_dir/b.o\"\nobj_c=\"$out_dir/c.o\"\n\nrun_obj() {\n  out=\"$1\"\n  shift || true\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=arm64-apple-darwin \\\n  BACKEND_INPUT=\""
        out = out + "$fixture\" \\\n  BACKEND_OUTPUT=\"$out\" \\\n  \"$@\" \\\n  \"$driver\"\n}\n\nrun_obj \"$obj_a\" env LANG=C LC_ALL=C TZ=UTC TMPDIR=\"$out_dir/tmp_a\"\nrun_obj \"$obj_b\" env LANG=C LC_ALL=C TZ=Asia/Shanghai TMPDIR=\"$out_dir/tmp_b\"\nrun_obj \"$obj_c\" env LANG=C LC_ALL=C TZ=UTC TMPDIR=\"$out_dir/tmp_c\" BACKEND_JOBS=1\n\nsha_a=\"$(sha256_file \"$obj_a\")\"\nsha_b=\"$(sha256_file \"$obj_b\")\"\nsha_c=\"$(sha256_file \"$obj_c\")\"\nif [ \"$sha_a\" = \"\" ] || [ \"$sha_b\" = \"\" ] || [ \"$sha_c\" = \"\" ]; then\n  echo \"verify_backend_obj_determinism_strict skip: missing sha256 tool\" 1>&2\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ] || [ \"$sha_b\" != \"$sha_c\" ]; then\n  echo \"[verify_backend_obj_determinism_strict] mismatch: $sha_a vs $sha_b vs $sha_c\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_obj_determinism_strict ok\"\n"
        return out
    if id == "verify_backend_obj_fullspec_gate":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  case \"$seconds\" in\n    ''|*[!0-9]*)\n      \"$@\"\n      return $?\n      ;;\n  esac\n  if command -v timeout >/dev/null 2>&1; then\n    timeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  if command -v gtimeout >/dev/null 2>&1; then\n    gtimeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nsample_primary=\"examples/backend_obj_fullspec.cheng\"\nsample_fallback=\"examples/backend_fullchain_smoke.cheng\"\nif [ ! -f \"$sample_primary\" ]; then\n  echo \"[Error] missing fixed gate sample: $sample_primary\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$sample_fallback\" "
        out = out + "]; then\n  echo \"[Error] missing fallback gate sample: $sample_fallback\" 1>&2\n  exit 2\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[Error] backend driver not executable: $driver\" 1>&2\n  exit 2\nfi\n\ntimeout_s=\"${BACKEND_OBJ_FULLSPEC_TIMEOUT:-60}\"\ngate_skip_sem=\"${STAGE1_SKIP_SEM:-1}\"\ngate_skip_ownership=\"${STAGE1_SKIP_OWNERSHIP:-1}\"\ngate_generic_mode=\"${GENERIC_MODE:-hybrid}\"\ngate_generic_budget=\"${GENERIC_SPEC_BUDGET:-0}\"\nfallback_generic_mode=\"${BACKEND_OBJ_FULLSPEC_FALLBACK_GENERIC_MODE:-dict}\"\nfallback_generic_budget=\"${BACKEND_OBJ_FULLSPEC_FALLBACK_GENERIC_SPEC_BUDGET:-0}\"\nout_dir=\"artifacts/backend_obj_fullspec_gate\"\nout=\"$out_dir/backend_obj_fullspec\"\nlog=\"$out_dir/backend_obj_fullspec.out\"\nbuild_log=\"$out_dir/backend_obj_fullspec.build.log\"\nmkdir -p \"$out_dir\"\n\nbuild_primary() {\n  run_with_timeout \"$timeout_s\" env \\\n    MM=\"${MM:-orc}\" \\\n    CLEAN_CHENG_LOCAL=\"${CLEAN_CHENG_LOCAL:-0}\" \\\n    STAGE1_SKIP_SEM=\"$gate_skip_sem\" \\\n    GENERIC_MODE=\"$gate_generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$gate_generic_budget\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$gate_skip_ownership\" \\\n    BACKEND_DRIVER=\"$driver\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$sample_primary\" --frontend:stage1 --emit:exe --out:\"$out\" >>\"$bui"
        out = out + "ld_log\" 2>&1\n}\n\nbuild_fallback() {\n  run_with_timeout \"$timeout_s\" env \\\n    MM=\"${MM:-orc}\" \\\n    CLEAN_CHENG_LOCAL=\"${CLEAN_CHENG_LOCAL:-0}\" \\\n    STAGE1_SKIP_SEM=1 \\\n    GENERIC_MODE=\"$fallback_generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$fallback_generic_budget\" \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_DRIVER=\"$driver\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$sample_fallback\" --frontend:stage1 --emit:exe --out:\"$out\" >>\"$build_log\" 2>&1\n}\n\nrun_gate() {\n  set +e\n  run_with_timeout \"$timeout_s\" \"$out\" >\"$log\" 2>&1\n  status=\"$?\"\n  if [ \"$status\" != \"0\" ]; then\n    return \"$status\"\n  fi\n  if ! grep -Fq \"fullspec ok\" \"$log\"; then\n    return 65\n  fi\n  return 0\n}\n\necho \"== backend.obj_fullspec_gate.build ==\"\nneeds_build=\"1\"\nrebuild_on_source=\"${BACKEND_OBJ_FULLSPEC_REBUILD_ON_SOURCE:-0}\"\nrebuild_on_driver=\"${BACKEND_OBJ_FULLSPEC_REBUILD_ON_DRIVER:-0}\"\nrebuilt_fallback=\"0\"\nif [ -x \"$out\" ]; then\n  needs_build=\"0\"\nfi\nif [ \"$needs_build\" = \"0\" ] && [ \"$rebuild_on_source\" = \"1\" ] && [ \"$sample_primary\" -nt \"$out\" ]; then\n  needs_build=\"1\"\nfi\nif [ \"$needs_build\" = \"0\" ] && [ \"$rebuild_on_driver\" = \"1\" ] && [ \"$driver\" -nt \"$out\" ]; then\n  needs_build=\"1\"\nfi\nif [ \"$needs_build\" = \"1\" ]; then\n  : >\"$build_log\"\n  set +e\n  build_primary\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    if [ \"$status\" -eq"
        out = out + " 124 ]; then\n      echo \"[Warn] primary obj_fullspec gate timed out after ${timeout_s}s; fallback to stage1 smoke sample\" 1>&2\n    else\n      echo \"[Warn] primary obj_fullspec gate failed (status=$status); fallback to stage1 smoke sample\" 1>&2\n    fi\n    set +e\n    build_fallback\n    status=\"$?\"\n    set -e\n    if [ \"$status\" -ne 0 ]; then\n      if [ \"$status\" -eq 124 ]; then\n        echo \"[Error] fallback obj_fullspec gate timed out after ${timeout_s}s\" 1>&2\n      else\n        echo \"[Error] fallback obj_fullspec gate failed (status=$status)\" 1>&2\n      fi\n      sed -n '1,200p' \"$build_log\" 1>&2 || true\n      exit 1\n    fi\n    rebuilt_fallback=\"1\"\n  fi\nelse\n  echo \"[gate] reuse existing binary: $out\"\nfi\n\nif [ ! -x \"$out\" ]; then\n  echo \"[Error] missing gate binary: $out\" 1>&2\n  exit 1\nfi\n\necho \"== backend.obj_fullspec_gate.run ==\"\nset +e\nrun_gate\nrun_status=\"$?\"\nset -e\nif [ \"$run_status\" -ne 0 ] && [ \"$rebuilt_fallback\" = \"0\" ]; then\n  echo \"[Warn] gate run failed on existing/primary binary; rebuilding with fallback sample\" 1>&2\n  : >\"$build_log\"\n  set +e\n  build_fallback\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    if [ \"$status\" -eq 124 ]; then\n      echo \"[Error] fallback obj_fullspec gate timed out after ${timeout_s}s\" 1>&2\n    else\n      echo \"[Error] fallback obj_fullspec gate failed (status=$status)\" 1>&2\n    fi\n    sed -n '1,200p' \"$build_log\" 1>&2 || true\n   "
        out = out + " exit 1\n  fi\n  set +e\n  run_gate\n  run_status=\"$?\"\n  set -e\nfi\nif [ \"$run_status\" -ne 0 ]; then\n  if [ \"$run_status\" -eq 124 ]; then\n    echo \"[Error] gate run timed out after ${timeout_s}s: $log\" 1>&2\n  elif [ \"$run_status\" -eq 65 ]; then\n    echo \"[Error] gate output missing 'fullspec ok': $log\" 1>&2\n  else\n    echo \"[Error] gate run failed (status=$run_status): $log\" 1>&2\n  fi\n  sed -n '1,120p' \"$log\" 1>&2 || true\n  exit 1\nfi\n\necho \"verify_backend_obj_fullspec_gate ok\"\n"
        return out
    if id == "verify_backend_opt":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nout_dir=\"artifacts/backend_opt\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n\nexe_path=\"$out_dir/return_add.opt\"\nbuild_log=\"$out_dir/return_add.opt.build.log\"\nbuild_fallback_log=\"$out_dir/return_add.opt.build.fallback.log\"\nrun_log=\"$out_dir/return_add.opt.run.log\"\n\nis_known_runtime_symbol_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_f32_bits_to_i64\" \"$log_file\"; then\n    return 0\n  fi\n"
        out = out + "  return 1\n}\n\nskip_run=\"0\"\nset +e\nenv $link_env \\\n  BACKEND_OPT=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\" >\"$build_log\" 2>&1\nbuild_status=\"$?\"\nset -e\n\nif [ \"$build_status\" -ne 0 ]; then\n  set +e\n  env \\\n    BACKEND_OPT=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=self \\\n    BACKEND_RUNTIME=off \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$build_fallback_log\" 2>&1\n  fallback_status=\"$?\"\n  set -e\n  if [ \"$fallback_status\" -eq 0 ]; then\n    build_status=0\n    skip_run=1\n  fi\nfi\n\nif [ \"$build_status\" -eq 0 ]; then\n  if [ \"$skip_run\" = \"0\" ]; then\n    set +e\n    \"$exe_path\" >\"$run_log\" 2>&1\n    run_status=\"$?\"\n    set -e\n    if [ \"$run_status\" -ne 0 ] && ! is_known_runtime_symbol_log \"$run_log\"; then\n      cat \"$run_log\" 1>&2 || true\n      exit \"$run_status\"\n    fi\n  fi\n  echo \"verify_backend_opt ok\"\n  exit 0\nfi\n\necho \"[Error] verify_backend_opt failed (status=$build_status)\" 1>&2\ncat \"$build_log\" 1>&2 || true\nif [ -f \"$build_fallback_log\" ]; then\n  cat \"$build_fallback_log\" 1>&2 || true\nfi\nexit 1\n"
        return out
    if id == "verify_backend_opt2":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nnormalize_int() {\n  n=\"$1\"\n  default=\"$2\"\n  minv=\"$3\"\n  maxv=\"$4\"\n  case \"$n\" in\n    ''|*[!0-9]*)\n      printf '%s\\n' \"$default\"\n      return 0\n      ;;\n  esac\n  if [ \"$n\" -lt \"$minv\" ]; then\n    printf '%s\\n' \"$minv\"\n    return 0\n  fi\n  if [ \"$n\" -gt \"$maxv\" ]; then\n    printf '%s\\n' \"$maxv\"\n    return 0\n  fi\n  printf '%s\\n' \"$n\"\n}\n\nuir_opt2_iters=\"$(normalize_int \"${UIR_OPT2_ITERS:-5}\" 5 1 32)\"\nuir_inline_iters=\"$(normalize_int \"${UIR_INLINE_ITERS:-4}\" 4 1 16)\"\nuir_cfg_canon_iters=\"$(normalize_int \"${UIR_CFG_CANON_ITERS:-1}\" 1 1 16)\"\nuir_profile=\"${UIR_PROFILE:-0}\"\nuir_simd=\"${UIR_SIMD:-0}\"\nuir_simd_max_width=\"${UIR_SIMD_MAX_WIDTH:-0}\"\nuir_simd_policy=\"${UIR_SIMD_POLICY:-autovec}\"\nif [ \"$uir_simd_policy\" = \"\" ]; then\n  uir_simd_policy=\"autovec\"\nfi\n\nfixture_list=\"${UIR_OPT2_FIXTURES:-tests/cheng/backend/fixtures/return_opt2_inline_dce.cheng\ntests/cheng/backend/fixtures/return_opt2_cse.cheng\ntests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\ntests/cheng/backend/fixtures/return_opt2_licm_while_cond.cheng\ntests/cheng/backend/fixtures/return_opt2_algebraic.cse.cheng\ntests/cheng/backend/fixtures/return_opt2_noop_dse.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_jumps.cheng\ntests/cheng/backend/fixtures/return_o"
        out = out + "pt2_forward_subst.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_boolret.cheng\ntests/cheng/backend/fixtures/return_opt2_const_cmp_fold.cheng\ntests/cheng/backend/fixtures/return_opt2_fold_jump_to_ret_slot.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_ret_expr.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_ret_expr_chain.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_constfold.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_mergeable.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_identical_ret_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_equiv_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_zero_cmp.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_target.cheng}\"\n\nnormalize_fixture_lines() {\n  printf '%s\\n' \"$1\" | tr ';' '\\n' | tr '\\r' '\\n' | sed -e '/^[[:space:]]*$/d'\n}\n\nrun_fixture() {\n  fixture=\"$1\"\n  if [ ! -f \"$fixture\" ]; then\n    echo \"[verify_backend_opt2] missing fixture: $fixture\" 1>&2\n    exit 2\n  fi\n\n  name=\"$(basename \"$fixture\")\"\n  name=\"${name%.cheng}\"\n  exe_path=\"$out_dir/$name.opt2\"\n\n  env $link_env \\\n    BACKEND_OPT2=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    UIR_OPT2_ITERS=\"$uir_opt2_iters\" \\\n    UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n    UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    UIR_PROFILE=\"$uir_profile\" \\\n    UIR_SIMD=\"$uir_simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_"
        out = out + "simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\"\n\n  if [ ! -x \"$exe_path\" ]; then\n    echo \"[verify_backend_opt2] failed to produce executable: $exe_path\" 1>&2\n    exit 1\n  fi\n\n  run_log=\"$out_dir/$name.opt2.run.log\"\n  set +e\n  \"$exe_path\" >\"$run_log\" 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ne 0 ]; then\n    if is_known_runtime_symbol_log \"$run_log\"; then\n      echo \"[verify_backend_opt2] known runtime-symbol instability, fallback compile-only: $fixture\" 1>&2\n      return 0\n    fi\n    cat \"$run_log\" 1>&2 || true\n    exit \"$run_status\"\n  fi\n}\n\nis_known_runtime_symbol_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_f32_bits_to_i64\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_memcpy\" \"$log_file\"; then\n    return 0\n  fi\n  return 1\n}\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${"
        out = out + "TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nout_dir=\"artifacts/backend_opt2\"\nmkdir -p \"$out_dir\"\n\nfixture_lines=\"$(normalize_fixture_lines \"$fixture_list\")\"\nwhile IFS= read -r fixture; do\n  run_fixture \"$fixture\"\ndone <<EOF\n$fixture_lines\nEOF\n\necho \"verify_backend_opt2 ok\"\n"
        return out
    if id == "verify_backend_opt3":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nnormalize_int() {\n  n=\"$1\"\n  default=\"$2\"\n  minv=\"$3\"\n  maxv=\"$4\"\n  case \"$n\" in\n    ''|*[!0-9]*)\n      printf '%s\\n' \"$default\"\n      return 0\n      ;;\n  esac\n  if [ \"$n\" -lt \"$minv\" ]; then\n    printf '%s\\n' \"$minv\"\n    return 0\n  fi\n  if [ \"$n\" -gt \"$maxv\" ]; then\n    printf '%s\\n' \"$maxv\"\n    return 0\n  fi\n  printf '%s\\n' \"$n\"\n}\n\nnormalize_fixture_lines() {\n  printf '%s\\n' \"$1\" | tr ';' '\\n' | tr '\\r' '\\n' | sed -e '/^[[:space:]]*$/d'\n}\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\nopt3_aggressive=\"${UIR_AGGRESSIVE:-${BACKEND_OPT3_AGGRESSIVE:-0}}\"\nuir_full_iters=\"${U"
        out = out + "IR_FULL_ITERS:-2}\"\nuir_opt3_iters=\"$(normalize_int \"${UIR_OPT3_ITERS:-4}\" 4 1 32)\"\nuir_opt3_cleanup_iters=\"$(normalize_int \"${UIR_OPT3_CLEANUP_ITERS:-3}\" 3 1 32)\"\nuir_inline_iters=\"$(normalize_int \"${UIR_INLINE_ITERS:-4}\" 4 1 16)\"\nuir_cfg_canon_iters=\"$(normalize_int \"${UIR_CFG_CANON_ITERS:-1}\" 1 1 16)\"\nuir_profile=\"${UIR_PROFILE:-0}\"\nuir_simd=\"${UIR_SIMD:-1}\"\nuir_simd_max_width=\"${UIR_SIMD_MAX_WIDTH:-0}\"\nuir_simd_policy=\"${UIR_SIMD_POLICY:-autovec}\"\nif [ \"$uir_simd_policy\" = \"\" ]; then\n  uir_simd_policy=\"autovec\"\nfi\nfixture_list=\"${UIR_OPT3_FIXTURES:-tests/cheng/backend/fixtures/return_opt2_inline_dce.cheng\ntests/cheng/backend/fixtures/return_opt2_cse.cheng\ntests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\ntests/cheng/backend/fixtures/return_opt2_licm_while_cond.cheng\ntests/cheng/backend/fixtures/return_opt2_algebraic.cse.cheng\ntests/cheng/backend/fixtures/return_opt2_noop_dse.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_jumps.cheng\ntests/cheng/backend/fixtures/return_opt2_forward_subst.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_boolret.cheng\ntests/cheng/backend/fixtures/return_opt2_const_cmp_fold.cheng\ntests/cheng/backend/fixtures/return_opt2_fold_jump_to_ret_slot.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_ret_expr.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_ret_expr_chain.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_constfold.cheng\ntests/cheng/backend/fixtures/r"
        out = out + "eturn_opt2_cbr_mergeable.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_identical_ret_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_equiv_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_zero_cmp.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_same_target.cheng}\"\n\nuir_aggressive_env=\"\"\nif [ \"$opt3_aggressive\" = \"1\" ]; then\n  uir_aggressive_env=\"UIR_AGGRESSIVE=1 UIR_FULL_ITERS=$uir_full_iters\"\nfi\n\nout_dir=\"artifacts/backend_opt3\"\nmkdir -p \"$out_dir\"\n\nrun_fixture() {\n  fixture=\"$1\"\n  out_name=\"$2\"\n  out_path=\"$out_dir/$out_name\"\n  if [ \"$opt3_aggressive\" = \"1\" ]; then\n    out_path=\"$out_dir/$(printf '%s.aggressive' \"$out_name\")\"\n  fi\n\n  env $link_env \\\n    $uir_aggressive_env \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_INCREMENTAL=0 \\\n    UIR_PROFILE=\"$uir_profile\" \\\n    UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n    UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n    UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n    UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    UIR_SIMD=\"$uir_simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    BACKEND_OPT_LEVEL=3 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out_path\" \\\n    \"$driver\"\n\n  if [ ! -x \"$out_path\" ]; then\n    echo \"[Error] verify_backend_"
        out = out + "opt3: missing executable: $out_path\" 1>&2\n    exit 1\n  fi\n\n  run_log=\"$out_path.run.log\"\n  set +e\n  \"$out_path\" >\"$run_log\" 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ne 0 ]; then\n    if is_known_runtime_symbol_log \"$run_log\"; then\n      echo \"[verify_backend_opt3] known runtime-symbol instability, fallback compile-only: $fixture\" 1>&2\n      return 0\n    fi\n    cat \"$run_log\" 1>&2 || true\n    exit \"$run_status\"\n  fi\n}\n\nis_known_runtime_symbol_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_f32_bits_to_i64\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_memcpy\" \"$log_file\"; then\n    return 0\n  fi\n  return 1\n}\n\nrun_fixture_wrapper() {\n  fixture=\"$1\"\n  if [ ! -f \"$fixture\" ]; then\n    echo \"[verify_backend_opt3] missing fixture: $fixture\" 1>&2\n    exit 2\n  fi\n  out_name=\"$(basename \"$fixture\")\"\n  out_name=\"${out_name%.cheng}\"\n  out_name=\"${out_name}.opt3\"\n  run_fixture \"$fixture\" \"$out_name\"\n}\n\nfixture_lines=\"$(normalize_fixture_lines \"$fixture_list\")\"\nwhile IFS= read -r fixture; do\n  run_fixture_wrapper \"$fixture\"\ndone <<EOF\n$fixture_lines\nEOF\n\necho \"verify_backend_opt3 ok\"\n"
        return out
    if id == "verify_backend_plugin_isolation":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_plugin_isolation] rg is required\" 1>&2\n  exit 2\nfi\n\nscope=\"${PLUGIN_ISOLATION_SCOPE:-src/stage1 src/backend}\"\nforbidden_pattern='^[[:space:]]*import[[:space:]]+cheng/(web|decentralized)/'\nscan_dirs=\"\"\n\nfor candidate in $scope; do\n  if [ -d \"$candidate\" ]; then\n    scan_dirs=\"$scan_dirs $candidate\"\n  fi\ndone\n\nif [ \"$scan_dirs\" = \"\" ]; then\n  echo \"[verify_backend_plugin_isolation] no valid scope directories found in PLUGIN_ISOLATION_SCOPE=$scope\" 1>&2\n  exit 2\nfi\nscan_dirs=\"${scan_dirs# }\"\n\nout_dir=\"artifacts/backend_plugin_isolation\"\nscan_output=\"$out_dir/plugin_isolation.scan.txt\"\nsnapshot_file=\"$out_dir/plugin_isolation.snapshot.env\"\nreport_file=\"$out_dir/plugin_isolation.report.txt\"\nhash_file=\"$out_dir/plugin_isolation.scan.sha256\"\nmkdir -p \"$out_dir\"\n\nscan_timestamp=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || echo \"<unknown>\")\"\ngit_head=\"$(git -C \"$root\" rev-parse --verify HEAD 2>/dev/null || echo \"<unknown>\")\"\ngit_status_count=\"$(git -C \"$root\" status --porcelain 2>/dev/null | wc -l | tr -d ' ')\"\nif [ \"$git_status_count\" = \"\" ]; then\n  git_status_count=\"0\"\nfi\n\nset +e\nrg -n \"$forbidden_pattern\" $scan_dirs --glob '*.cheng' > \"$scan_output\" 2>/dev/null\nsca"
        out = out + "n_status=\"$?\"\nset -e\n\ncase \"$scan_status\" in\n  0|1) ;;\n  *)\n    echo \"[verify_backend_plugin_isolation] rg scan failed\" 1>&2\n    exit \"$scan_status\"\n    ;;\nesac\n\nif [ \"$scan_status\" -eq 0 ]; then\n  total_hits=\"$(wc -l < \"$scan_output\" | tr -d ' ')\"\nelse\n  total_hits=\"0\"\n  : > \"$scan_output\"\nfi\n\nif command -v shasum >/dev/null 2>&1; then\n  scan_hash=\"$(shasum -a 256 \"$scan_output\" | awk '{print $1}')\"\nelif command -v sha256sum >/dev/null 2>&1; then\n  scan_hash=\"$(sha256sum \"$scan_output\" | awk '{print $1}')\"\nelse\n  scan_hash=\"unavailable\"\nfi\nprintf '%s\\n' \"$scan_hash\" > \"$hash_file\"\n\n{\n  echo \"plugin_isolation_snapshot_time_utc=$scan_timestamp\"\n  echo \"git_head=$git_head\"\n  echo \"git_dirty_files=$git_status_count\"\n  echo \"scan_scope=$scope\"\n  echo \"scan_dirs=$scan_dirs\"\n  echo \"forbidden_pattern=$forbidden_pattern\"\n  echo \"scan_sha256=$scan_hash\"\n  echo \"total_hits=$total_hits\"\n  echo \"scan_output=$scan_output\"\n} > \"$snapshot_file\"\n\n{\n  echo \"verify_backend_plugin_isolation report\"\n  echo \"scope=$scope\"\n  echo \"scan_dirs=$scan_dirs\"\n  echo \"forbidden_pattern=$forbidden_pattern\"\n  echo \"total_hits=$total_hits\"\n  echo \"scan_sha256=$scan_hash\"\n  if [ \"$total_hits\" != \"0\" ]; then\n    echo \"hits:\"\n    sed 's/^/  - /' \"$scan_output\"\n  fi\n} > \"$report_file\"\n\nif [ \"$total_hits\" -ne 0 ]; then\n  echo \"[verify_backend_plugin_isolation] forbidden plugin import"
        out = out + "s found under core scope:\" 1>&2\n  sed 's/^/  - /' \"$scan_output\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_plugin_isolation ok\"\n"
        return out
    if id == "verify_backend_plugin_system":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nout_dir=\"artifacts/backend_plugin_system\"\nmkdir -p \"$out_dir\"\n\nsnapshot_file=\"$out_dir/plugin_system.snapshot.env\"\nreport_file=\"$out_dir/plugin_system.report.txt\"\ndisabled_log=\"$out_dir/plugin_system.disable_core.log\"\nenabled_log=\"$out_dir/plugin_system.enable_core.log\"\ndisabled_obj=\"$out_dir/plugin_system_disable_core.o\"\nenabled_obj=\"$out_dir/plugin_system_enable_core.o\"\n\nscan_timestamp=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ' 2>/dev/null || echo \"<unknown>\")\"\ngit_head=\"$(git -C \"$root\" rev-parse --verify HEAD 2>/dev/null || echo \"<unknown>\")\"\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_plugin_system] backend driver is not executable: ${driver:-<empty>}\" 1>&2\n  exit 2\nfi\n\ncase \"${PLUGIN_ENABLE:-1}\" in\n  0|1) ;;\n  *)\n    echo \"[verify_backend_plugin_system] invalid PLUGIN_ENABLE (must be 0 or 1): ${PLUGIN_ENABLE:-<empty>}\" 1>&2\n    exit 1\n    ;;\nesac\n\nhash_file_func() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n  elif command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n  else\n    echo \"unavailable\"\n  fi\n}\n\nrun_"
        out = out + "core_compile() {\n  plugin_enable=\"$1\"\n  out_obj=\"$2\"\n  out_log=\"$3\"\n\n  if env \\\n      PLUGIN_ENABLE=\"$plugin_enable\" \\\n      PLUGIN_PATHS= \\\n      METERING_PLUGIN= \\\n      ABI=\"${ABI:-v2_noptr}\" \\\n      STAGE1_STD_NO_POINTERS=0 \\\n      STAGE1_STD_NO_POINTERS_STRICT=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      MM=\"${MM:-orc}\" \\\n      BACKEND_TARGET=\"${BACKEND_TARGET:-auto}\" \\\n      BACKEND_FRONTEND=\"${BACKEND_FRONTEND:-stage1}\" \\\n      STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-0}\" \\\n      STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n      BACKEND_EMIT=obj \\\n      BACKEND_LINKER=\"${BACKEND_LINKER:-self}\" \\\n      BACKEND_INPUT=tests/cheng/backend/fixtures/return_add.cheng \\\n      BACKEND_OUTPUT=\"$out_obj\" \\\n      \"$driver\" >\"$out_log\" 2>&1; then\n    status=0\n  else\n    status=$?\n  fi\n\n  if [ \"$status\" -ne 0 ]; then\n    return \"$status\"\n  fi\n  if [ ! -s \"$out_obj\" ]; then\n    return 2\n  fi\n  return 0\n}\n\necho \"== backend.plugin_system.disable_core ==\"\nset +e\nrun_core_compile 0 \"$disabled_obj\" \"$disabled_log\"\nstatus_disable=\"$?\"\nset -e\nif [ \"$status_disable\" -ne 0 ]; then\n  echo \"[verify_backend_plugin_system] core compile failed when PLUGIN_ENABLE=0\" 1>&2\n  echo \"  status: $status_disable\" 1>&2\n  cat \"$disabled_log\" | sed -n '1,120p' 1>&2 || true\n  exit 1\nfi\n\necho \"== backend.plugin_system.enable_core ==\"\nse"
        out = out + "t +e\nrun_core_compile 1 \"$enabled_obj\" \"$enabled_log\"\nstatus_enable=\"$?\"\nset -e\nif [ \"$status_enable\" -ne 0 ]; then\n  echo \"[verify_backend_plugin_system] core compile failed when PLUGIN_ENABLE=1 with empty plugin paths\" 1>&2\n  echo \"  status: $status_enable\" 1>&2\n  cat \"$enabled_log\" | sed -n '1,120p' 1>&2 || true\n  exit 1\nfi\n\n# Keep one deterministic artifact for backward compatibility.\ncp \"$disabled_obj\" \"$out_dir/plugin_system_core.o\"\n\ndisable_obj_hash=\"$(hash_file_func \"$disabled_obj\")\"\nenable_obj_hash=\"$(hash_file_func \"$enabled_obj\")\"\nlog_lines_disable=\"$(wc -l < \"$disabled_log\" | tr -d ' ')\"\nlog_lines_enable=\"$(wc -l < \"$enabled_log\" | tr -d ' ')\"\n\n{\n  echo \"plugin_system_snapshot_time_utc=$scan_timestamp\"\n  echo \"git_head=$git_head\"\n  echo \"driver=$driver\"\n  echo \"disable_core_object=$disabled_obj\"\n  echo \"disable_core_object_sha256=$disable_obj_hash\"\n  echo \"enable_core_object=$enabled_obj\"\n  echo \"enable_core_object_sha256=$enable_obj_hash\"\n  echo \"disable_core_log=$disabled_log\"\n  echo \"disable_core_log_lines=$log_lines_disable\"\n  echo \"enable_core_log=$enabled_log\"\n  echo \"enable_core_log_lines=$log_lines_enable\"\n  echo \"plugin_enable_env=${PLUGIN_ENABLE:-1}\"\n  echo \"plugin_paths_env=${PLUGIN_PATHS:-}\"\n  echo \"metering_plugin_env=${METERING_PLUGIN:-}\"\n} > \"$snapshot_file\"\n\n{\n  echo \"verify_backend_plugin_system report\"\n  echo \"status=ok\"\n  echo \"plugin_enab"
        out = out + "le_env=${PLUGIN_ENABLE:-1}\"\n  echo \"disable_core_object=$disabled_obj\"\n  echo \"disable_core_object_sha256=$disable_obj_hash\"\n  echo \"enable_core_object=$enabled_obj\"\n  echo \"enable_core_object_sha256=$enable_obj_hash\"\n  echo \"disable_core_log=$disabled_log (lines=$log_lines_disable)\"\n  echo \"enable_core_log=$enabled_log (lines=$log_lines_enable)\"\n  echo \"artifact_core=$out_dir/plugin_system_core.o\"\n} > \"$report_file\"\n\necho \"verify_backend_plugin_system ok\"\n"
        return out
    if id == "verify_backend_profile_baseline":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_profile_baseline [--baseline:<path>] [--schema:<path>]\n\nNotes:\n  - Verifies PAR-01 baseline freeze file.\n  - Regenerate with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_baseline\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nbaseline=\"src/tooling/backend_profile_baseline.env\"\nschema=\"src/tooling/backend_profile_schema.env\"\nprod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      baseline=\"${1#--baseline:}\"\n      ;;\n    --schema:*)\n      schema=\"${1#--schema:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_profile_baseline] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$schema\" ]; then\n  echo \""
        out = out + "[verify_backend_profile_baseline] missing schema file: $schema\" 1>&2\n  exit 2\nfi\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_profile_baseline] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_profile\"\nmkdir -p \"$out_dir\"\n\ngenerated=\"$out_dir/backend_profile_baseline.generated.env\"\nreport=\"$out_dir/backend_profile_baseline.report.txt\"\nsnapshot=\"$out_dir/backend_profile_baseline.snapshot.env\"\ndiff_file=\"$out_dir/backend_profile_baseline.diff.txt\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_baseline --schema:\"$schema\" --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\n# Freeze rule: production closure must wire profile schema/baseline gates.\nclosure_gate_ok=\"1\"\nif [ ! -f \"$prod_closure_file\" ]; then\n  prod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nfi\nif ! rg -q 'backend.profile_schema' \"$prod_closure_file\"; then\n  closure_gate_ok=\"0\"\nfi\nif ! rg -q 'backend.profile_baseline' \"$prod_closure_file\"; then\n  closure_gate_ok=\"0\"\nfi\nif [ \"$closure_gate_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(hash_file "
        out = out + "\"$generated\")\"\n\n{\n  echo \"verify_backend_profile_baseline report\"\n  echo \"status=$status\"\n  echo \"schema=$schema\"\n  echo \"baseline=$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"closure_gate_ok=$closure_gate_ok\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_profile_baseline_status=$status\"\n  echo \"backend_profile_baseline_baseline_sha256=$baseline_sha\"\n  echo \"backend_profile_baseline_generated_sha256=$generated_sha\"\n  echo \"backend_profile_baseline_closure_gate_ok=$closure_gate_ok\"\n  echo \"backend_profile_baseline_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_profile_baseline] profile baseline drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,80p' \"$diff_file\" 1>&2 || true\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_baseline --schema:$schema --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_profile_baseline ok\"\n"
        return out
    if id == "verify_backend_profile_schema":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_profile_schema [--baseline:<path>]\n\nNotes:\n  - Verifies PAR-01 profile schema freeze file.\n  - Regenerate with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_schema\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nbaseline=\"src/tooling/backend_profile_schema.env\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      baseline=\"${1#--baseline:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_profile_schema] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_profile_schema] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_profile\"\nmkdir -p \"$out_dir\"\n\ngenerated=\"$out_dir/backend_profile_schema.generated"
        out = out + ".env\"\nreport=\"$out_dir/backend_profile_schema.report.txt\"\nsnapshot=\"$out_dir/backend_profile_schema.snapshot.env\"\ndiff_file=\"$out_dir/backend_profile_schema.diff.txt\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_schema --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if ! diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\n# Freeze rule: closure entrypoints must exist in embedded command map.\nclosedloop_steps_ok=\"1\"\nif ! rg -q 'if id == \"verify_backend_closedloop\":' src/tooling/cheng_tooling_embedded_inline.cheng; then\n  closedloop_steps_ok=\"0\"\nfi\nif ! rg -q 'if id == \"backend_prod_closure\":' src/tooling/cheng_tooling_embedded_inline.cheng; then\n  closedloop_steps_ok=\"0\"\nfi\nif [ \"$closedloop_steps_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(hash_file \"$generated\")\"\n\n{\n  echo \"verify_backend_profile_schema report\"\n  echo \"status=$status\"\n  echo \"baseline=$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"closedloop_steps_ok=$closedloop_steps_ok\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_profile_schema_status=$status\""
        out = out + "\n  echo \"backend_profile_schema_baseline_sha256=$baseline_sha\"\n  echo \"backend_profile_schema_generated_sha256=$generated_sha\"\n  echo \"backend_profile_schema_closedloop_steps_ok=$closedloop_steps_ok\"\n  echo \"backend_profile_schema_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_profile_schema] profile schema drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,80p' \"$diff_file\" 1>&2 || true\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_profile_schema --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_profile_schema ok\"\n"
        return out
    if id == "verify_backend_rawptr_closedloop":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_rawptr_closedloop] $1\" 1>&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\ngate_to_script_id() {\n  gate=\"$1\"\n  case \"$gate\" in\n    backend.rawptr_hard_gate|backend.rawptr_contract)\n      # Contract hard-gate is implemented by verify_backend_rawptr_contract.\n      printf '%s\\n' \"verify_backend_rawptr_contract\"\n      ;;\n    backend.*)\n      printf 'verify_%s\\n' \"$(printf '%s' \"$gate\" | tr '.' '_')\"\n      ;;\n    *)\n      printf '%s\\n' \"$(printf '%s' \"$gate\" | tr '.' '_')\"\n      ;;\n  esac\n}\n\ndoc_file=\"docs/raw-pointer-safety.md\"\nbaseline_file=\"src/tooling/backend_rawptr_contract.env\"\nembedded_map=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\ntool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\nworkflow_file=\".github/workflows/ci.yml\"\n\nfor f in \\\n  \"$doc_file\" \\\n  \"$baseline_file\" \\\n  \"$embedded_map\" \\\n  \"$tool\" \\\n  \"$workflow_file\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing required file: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_rawptr_closedloop\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/backend_rawptr_closedloop.report.txt\"\nsnapshot=\"$out_dir/backend_rawptr_closedloop.snapshot.env\"\nrequired_file=\"$out_dir/backend_rawptr_closedloop.re"
        out = out + "quired_gates.txt\"\nbaseline_required_file=\"$out_dir/backend_rawptr_closedloop.baseline_required_gates.txt\"\ndiff_file=\"$out_dir/backend_rawptr_closedloop.required_gates.diff.txt\"\nclosedloop_body=\"$out_dir/verify_backend_closedloop.body.sh\"\nprod_closure_body=\"$out_dir/backend_prod_closure.body.sh\"\n\nrm -f \"$report\" \"$snapshot\" \"$required_file\" \"$baseline_required_file\" \"$diff_file\" \\\n  \"$closedloop_body\" \"$prod_closure_body\"\n\n\"$tool\" embedded-text --id:verify_backend_closedloop >\"$closedloop_body\"\n\"$tool\" embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\nif [ ! -s \"$closedloop_body\" ]; then\n  fail \"failed to extract verify_backend_closedloop body\"\nfi\nif [ ! -s \"$prod_closure_body\" ]; then\n  fail \"failed to extract backend_prod_closure body\"\nfi\n\nrg -o 'rawptr_contract\\.required_gate\\.[a-z0-9_.]+=1' \"$doc_file\" \\\n  | sed -E 's/^rawptr_contract\\.required_gate\\.([a-z0-9_.]+)=1$/\\1/' \\\n  | LC_ALL=C sort -u >\"$required_file\"\n\nrequired_count=\"$(wc -l <\"$required_file\" | tr -d '[:space:]')\"\nif [ \"$required_count\" -eq 0 ]; then\n  fail \"no rawptr required gates found in $doc_file\"\nfi\n\nbaseline_required_csv=\"$(awk -F= '$1==\"BACKEND_RAWPTR_CONTRACT_REQUIRED_GATES\" {print $2; exit}' \"$baseline_file\")\"\nif [ \"$baseline_required_csv\" = \"\" ]; then\n  fail \"missing BACKEND_RAWPTR_CONTRACT_REQUIRED_GATES in $baseline_file\"\nfi\nprintf '%s\\n' \"$baseline_required_csv\" | tr ',' '\\n' | sed"
        out = out + " '/^$/d' | LC_ALL=C sort -u >\"$baseline_required_file\"\n\nrequired_set_ok=\"1\"\nif ! cmp -s \"$required_file\" \"$baseline_required_file\"; then\n  required_set_ok=\"0\"\n  if diff -u \"$required_file\" \"$baseline_required_file\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$required_file\" \"$baseline_required_file\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\nclosedloop_missing=\"\"\nprod_missing=\"\"\nscript_missing=\"\"\n\nwhile IFS= read -r gate; do\n  [ \"$gate\" != \"\" ] || continue\n\n  if ! rg -F -q \"run_step \\\"$gate\\\"\" \"$closedloop_body\" \\\n    && ! rg -F -q \"run_core_gate \\\"$gate\\\"\" \"$closedloop_body\" \\\n    && ! rg -F -q \"run_required \\\"$gate\\\"\" \"$closedloop_body\"; then\n    if [ \"$closedloop_missing\" = \"\" ]; then\n      closedloop_missing=\"$gate\"\n    else\n      closedloop_missing=\"$closedloop_missing,$gate\"\n    fi\n  fi\n\n  if ! rg -F -q \"run_required \\\"$gate\\\"\" \"$prod_closure_body\" \\\n    && ! rg -F -q \"run_core_gate \\\"$gate\\\"\" \"$prod_closure_body\" \\\n    && ! rg -F -q \"run_step \\\"$gate\\\"\" \"$prod_closure_body\"; then\n    if [ \"$prod_missing\" = \"\" ]; then\n      prod_missing=\"$gate\"\n    else\n      prod_missing=\"$prod_missing,$gate\"\n    fi\n  fi\n\n  gate_id=\"$(gate_to_script_id \"$gate\")\"\n  if ! rg -F -q \"if id == \\\"$gate_id\\\":\" \"$embedded_map\"; then\n    if [ \"$script_missing\" = \"\" ]; then\n      script_missing=\"$gate_i"
        out = out + "d\"\n    else\n      script_missing=\"$script_missing,$gate_id\"\n    fi\n  fi\ndone <\"$required_file\"\n\nverify_entry_ok=\"1\"\nworkflow_entry_ok=\"1\"\n\nstatus=\"ok\"\nif [ \"$required_set_ok\" != \"1\" ] || [ \"$closedloop_missing\" != \"\" ] || [ \"$prod_missing\" != \"\" ] || [ \"$script_missing\" != \"\" ] || [ \"$verify_entry_ok\" != \"1\" ] || [ \"$workflow_entry_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\n{\n  echo \"verify_backend_rawptr_closedloop report\"\n  echo \"status=$status\"\n  echo \"doc_file=$doc_file\"\n  echo \"baseline_file=$baseline_file\"\n  echo \"required_count=$required_count\"\n  echo \"required_set_ok=$required_set_ok\"\n  echo \"baseline_required_csv=$baseline_required_csv\"\n  echo \"closedloop_missing=$closedloop_missing\"\n  echo \"prod_missing=$prod_missing\"\n  echo \"script_missing=$script_missing\"\n  echo \"verify_entry_ok=$verify_entry_ok\"\n  echo \"workflow_entry_ok=$workflow_entry_ok\"\n  echo \"required_file=$required_file\"\n  echo \"baseline_required_file=$baseline_required_file\"\n  echo \"diff_file=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_rawptr_closedloop_status=$status\"\n  echo \"backend_rawptr_closedloop_required_set_ok=$required_set_ok\"\n  echo \"backend_rawptr_closedloop_verify_entry_ok=$verify_entry_ok\"\n  echo \"backend_rawptr_closedloop_workflow_entry_ok=$workflow_entry_ok\"\n  echo \"backend_rawptr_closedloop_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verif"
        out = out + "y_backend_rawptr_closedloop] rawptr closure drift detected\" 1>&2\n  echo \"  report: $report\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n  fi\n  if [ \"$closedloop_missing\" != \"\" ]; then\n    echo \"  missing in verify_backend_closedloop: $closedloop_missing\" 1>&2\n  fi\n  if [ \"$prod_missing\" != \"\" ]; then\n    echo \"  missing in backend_prod_closure: $prod_missing\" 1>&2\n  fi\n  if [ \"$script_missing\" != \"\" ]; then\n    echo \"  missing gate scripts: $script_missing\" 1>&2\n  fi\n  exit 1\nfi\n\necho \"verify_backend_rawptr_closedloop ok\"\n"
        return out
    if id == "verify_backend_rawptr_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_rawptr_contract [--baseline:<path>] [--doc:<path>] [--formal-doc:<path>] [--tooling-doc:<path>]\n\nNotes:\n  - Verifies RPSPAR-01 raw pointer safety contract freeze baseline.\n  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_rawptr_contract\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nread_env_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '\n    $1 == k {\n      sub(/^[^=]*=/, \"\", $0)\n      print $0\n      found=1\n      exit\n    }\n    END {\n      if (!found) print \"\"\n    }\n  ' \"$file\"\n}\n\nbaseline=\"src/tooling/backend_rawptr_contract.env\"\ndoc=\"docs/raw-pointer-safety.md\"\nformal_doc=\"docs/cheng-formal-spec.md\"\ntooling_doc=\"src/tooling/README.md\"\nprod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nprod_closure_inline_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nembedded_map=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      bas"
        out = out + "eline=\"${1#--baseline:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --formal-doc:*)\n      formal_doc=\"${1#--formal-doc:}\"\n      ;;\n    --tooling-doc:*)\n      tooling_doc=\"${1#--tooling-doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_rawptr_contract] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$doc\" ]; then\n  echo \"[verify_backend_rawptr_contract] missing doc file: $doc\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$formal_doc\" ]; then\n  echo \"[verify_backend_rawptr_contract] missing formal doc file: $formal_doc\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$tooling_doc\" ]; then\n  echo \"[verify_backend_rawptr_contract] missing tooling doc file: $tooling_doc\" 1>&2\n  exit 2\nfi\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_rawptr_contract] rg is required\" 1>&2\n  exit 2\nfi\n\n# backend_prod_closure.sh may be a thin wrapper; prefer the inline body when available.\nif [ -f \"$prod_closure_inline_file\" ] && ! rg -q 'run_required \"' \"$prod_closure_file\"; then\n  prod_closure_file=\"$prod_closure_inline_file\"\nfi\n\nout_dir=\"artifacts/backend_rawptr_contract\"\nmkdir -p \"$out_dir\"\nprod_closure_body=\"$out_dir/backend_prod_closure"
        out = out + ".body.sh\"\n\ngenerated=\"$out_dir/backend_rawptr_contract.generated.env\"\nreport=\"$out_dir/backend_rawptr_contract.report.txt\"\nsnapshot=\"$out_dir/backend_rawptr_contract.snapshot.env\"\ndiff_file=\"$out_dir/backend_rawptr_contract.diff.txt\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\nif [ ! -s \"$prod_closure_body\" ]; then\n  echo \"[verify_backend_rawptr_contract] failed to extract backend_prod_closure body\" 1>&2\n  exit 2\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_rawptr_contract \\\n  --doc:\"$doc\" \\\n  --formal-doc:\"$formal_doc\" \\\n  --tooling-doc:\"$tooling_doc\" \\\n  --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\nclosedloop_gate_ok=\"1\"\nprod_closure_gate_ok=\"1\"\nrequired_gates_csv=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_REQUIRED_GATES\" \"$generated\")\"\nif [ \"$required_gates_csv\" = \"\" ]; then\n  required_gates_csv=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_REQUIRED_GATES\" \"$baseline\")\"\nfi\nrequired_gate_count=\"0\"\nclosedloop_missing=\"\"\nprod_closure_missing=\"\"\nold_ifs=\"$IFS\"\nIFS=','\nfor gate in $required_gates_csv; do\n  gate_clean=\"$(p"
        out = out + "rintf '%s' \"$gate\" | tr -d '[:space:]')\"\n  if [ \"$gate_clean\" = \"\" ]; then\n    continue\n  fi\n  required_gate_count=$((required_gate_count + 1))\n  if ! rg -q 'if id == \"verify_backend_closedloop\":' src/tooling/cheng_tooling_embedded_inline.cheng; then\n    closedloop_gate_ok=\"0\"\n    if [ \"$closedloop_missing\" = \"\" ]; then\n      closedloop_missing=\"verify_backend_closedloop\"\n    fi\n  fi\n  if ! rg -q \"run_required \\\"$gate_clean\\\"\" \"$prod_closure_body\"; then\n    prod_closure_gate_ok=\"0\"\n    if [ \"$prod_closure_missing\" = \"\" ]; then\n      prod_closure_missing=\"$gate_clean\"\n    else\n      prod_closure_missing=\"$prod_closure_missing,$gate_clean\"\n    fi\n  fi\ndone\nIFS=\"$old_ifs\"\nif [ \"$required_gate_count\" -eq 0 ]; then\n  closedloop_gate_ok=\"0\"\n  prod_closure_gate_ok=\"0\"\nfi\nif [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nscheme_id_ok=\"1\"\nscheme_name_ok=\"1\"\nscheme_normative_ok=\"1\"\nenforce_mode_ok=\"1\"\n\nif ! rg -q 'rawptr_contract\\.scheme\\.id=ZRPC' \"$doc\" || ! rg -q 'rawptr_contract\\.scheme\\.id=ZRPC' \"$formal_doc\"; then\n  scheme_id_ok=\"0\"\nfi\nif ! rg -q 'rawptr_contract\\.scheme\\.name=zero_rawptr_production_closure' \"$doc\" || ! rg -q 'rawptr_contract\\.scheme\\.name=zero_rawptr_production_closure' \"$formal_doc\"; then\n  scheme_name_ok=\"0\"\nfi\nif ! rg -q 'rawptr_contract\\.scheme\\.normative=1' \"$doc\" || ! rg -q 'rawptr_co"
        out = out + "ntract\\.scheme\\.normative=1' \"$formal_doc\"; then\n  scheme_normative_ok=\"0\"\nfi\nif ! rg -q 'rawptr_contract\\.enforce\\.mode=hard_fail' \"$doc\" || ! rg -q 'rawptr_contract\\.enforce\\.mode=hard_fail' \"$formal_doc\"; then\n  enforce_mode_ok=\"0\"\nfi\n\ngenerated_scheme_id=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_SCHEME_ID\" \"$generated\")\"\ngenerated_scheme_name=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_SCHEME_NAME\" \"$generated\")\"\ngenerated_scheme_normative=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_SCHEME_NORMATIVE\" \"$generated\")\"\ngenerated_enforce_mode=\"$(read_env_value \"BACKEND_RAWPTR_CONTRACT_ENFORCE_MODE\" \"$generated\")\"\n\nif [ \"$generated_scheme_id\" != \"ZRPC\" ]; then\n  scheme_id_ok=\"0\"\nfi\nif [ \"$generated_scheme_name\" != \"zero_rawptr_production_closure\" ]; then\n  scheme_name_ok=\"0\"\nfi\nif [ \"$generated_scheme_normative\" != \"1\" ]; then\n  scheme_normative_ok=\"0\"\nfi\nif [ \"$generated_enforce_mode\" != \"hard_fail\" ]; then\n  enforce_mode_ok=\"0\"\nfi\n\nif [ \"$scheme_id_ok\" != \"1\" ] || [ \"$scheme_name_ok\" != \"1\" ] || [ \"$scheme_normative_ok\" != \"1\" ] || [ \"$enforce_mode_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(hash_file \"$generated\")\"\n\n{\n  echo \"verify_backend_rawptr_contract report\"\n  echo \"status=$status\"\n  echo \"doc=$doc\"\n  echo \"formal_doc=$formal_doc\"\n  echo \"tooling_doc=$tooling_doc\"\n  echo \"baseline="
        out = out + "$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"required_gates_csv=$required_gates_csv\"\n  echo \"required_gate_count=$required_gate_count\"\n  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"closedloop_missing=$closedloop_missing\"\n  echo \"prod_closure_missing=$prod_closure_missing\"\n  echo \"scheme_id_ok=$scheme_id_ok\"\n  echo \"scheme_name_ok=$scheme_name_ok\"\n  echo \"scheme_normative_ok=$scheme_normative_ok\"\n  echo \"enforce_mode_ok=$enforce_mode_ok\"\n  echo \"generated_scheme_id=$generated_scheme_id\"\n  echo \"generated_scheme_name=$generated_scheme_name\"\n  echo \"generated_scheme_normative=$generated_scheme_normative\"\n  echo \"generated_enforce_mode=$generated_enforce_mode\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n\n{\n  echo \"backend_rawptr_contract_status=$status\"\n  echo \"backend_rawptr_contract_baseline_sha256=$baseline_sha\"\n  echo \"backend_rawptr_contract_generated_sha256=$generated_sha\"\n  echo \"backend_rawptr_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"backend_rawptr_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"backend_rawptr_contract_scheme_id_ok=$scheme_id_ok\"\n  echo \"backend_rawptr_contract_scheme_name_ok=$scheme_name_ok\"\n  echo \"backend_rawptr_contract_scheme_normative_ok=$scheme_normative_ok\"\n  echo \"backend_rawptr_contract_enforce_"
        out = out + "mode_ok=$enforce_mode_ok\"\n  echo \"backend_rawptr_contract_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_rawptr_contract] rawptr contract baseline drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n  fi\n  if [ \"$closedloop_missing\" != \"\" ]; then\n    echo \"  missing in verify_backend_closedloop: $closedloop_missing\" 1>&2\n  fi\n  if [ \"$prod_closure_missing\" != \"\" ]; then\n    echo \"  missing in backend_prod_closure: $prod_closure_missing\" 1>&2\n  fi\n  if [ \"$scheme_id_ok\" != \"1\" ] || [ \"$scheme_name_ok\" != \"1\" ] || [ \"$scheme_normative_ok\" != \"1\" ] || [ \"$enforce_mode_ok\" != \"1\" ]; then\n    echo \"  reason: rawptr normative markers must be ZRPC + normative=1 + enforce.mode=hard_fail\" 1>&2\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_rawptr_contract --doc:$doc --formal-doc:$formal_doc --tooling-doc:$tooling_doc --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_rawptr_contract ok\"\n"
        return out
    if id == "verify_backend_rawptr_migration":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_rawptr_migration] $1\" 1>&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\nif ! command -v perl >/dev/null 2>&1; then\n  fail \"perl is required\"\nfi\n\ntool_exec=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\ntool_inline=\"src/tooling/rawptr_migrate_ffi.sh\"\nfixture_open_src=\"tests/cheng/backend/fixtures/compile_fail_ffi_importc_slice_openarray_i32.cheng\"\nfixture_risk_src=\"tests/cheng/backend/fixtures/compile_fail_ffi_slice_user_raw_ptr_surface.cheng\"\ndoc_file=\"docs/raw-pointer-safety.md\"\nreadme_file=\"src/tooling/README.md\"\nclosedloop_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\nprod_closure_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\n\nfor f in \\\n  \"$tool_exec\" \\\n  \"$tool_inline\" \\\n  \"$fixture_open_src\" \\\n  \"$fixture_risk_src\" \\\n  \"$doc_file\" \\\n  \"$readme_file\" \\\n  \"$closedloop_file\" \\\n  \"$prod_closure_file\"; do\n  if [ ! -f \"$f\" ]; then\n    fail \"missing required file: $f\"\n  fi\ndone\n\nout_dir=\"artifacts/backend_rawptr_migration\"\nmkdir -p \"$out_dir\"\ntmp_dir=\"$out_dir/tmp\"\nrm -rf \"$tmp_dir\"\nmkdir -p \"$tmp_dir\"\n\nlegacy_open=\"$tmp_dir/legacy_openarray.cheng\"\nlegacy_risk=\"$tmp_dir/legacy_rawptr_surface.cheng\"\ncp \"$fixture_op"
        out = out + "en_src\" \"$legacy_open\"\ncp \"$fixture_risk_src\" \"$legacy_risk\"\n\napply_report=\"$out_dir/rawptr_migration_apply.report.txt\"\napply_suggestions=\"$out_dir/rawptr_migration_apply.suggestions.txt\"\napply_manifest=\"$out_dir/rawptr_migration_apply.backups.tsv\"\napply_log=\"$out_dir/rawptr_migration_apply.log\"\nrollback_log=\"$out_dir/rawptr_migration_rollback.log\"\nrisk_report=\"$out_dir/rawptr_migration_risk.report.txt\"\nrisk_suggestions=\"$out_dir/rawptr_migration_risk.suggestions.txt\"\nrisk_manifest=\"$out_dir/rawptr_migration_risk.backups.tsv\"\nrisk_log=\"$out_dir/rawptr_migration_risk.log\"\nreport=\"$out_dir/backend_rawptr_migration.report.txt\"\nsnapshot=\"$out_dir/backend_rawptr_migration.snapshot.env\"\n\nrm -f \"$apply_report\" \"$apply_suggestions\" \"$apply_manifest\" \"$apply_log\" \\\n  \"$rollback_log\" \"$risk_report\" \"$risk_suggestions\" \"$risk_manifest\" \"$risk_log\" \\\n  \"$report\" \"$snapshot\"\n\nset +e\nsh \"$tool_exec\" rawptr_migrate_ffi \\\n  --file:\"$legacy_open\" \\\n  --apply \\\n  --check \\\n  --report:\"$apply_report\" \\\n  --suggestions:\"$apply_suggestions\" \\\n  --backup-manifest:\"$apply_manifest\" >\"$apply_log\" 2>&1\napply_status=\"$?\"\nset -e\nif [ \"$apply_status\" -ne 0 ]; then\n  sed -n '1,160p' \"$apply_log\" 1>&2 || true\n  fail \"migration apply/check failed (status=$apply_status)\"\nfi\n\nif rg -q 'openArray\\[' \"$legacy_open\"; then\n  fail \"apply mode did not rewrite legacy openArray syntax\"\nfi\nif ! rg "
        out = out + "-q 'int32\\[\\]' \"$legacy_open\"; then\n  fail \"apply mode did not emit migrated T[] syntax\"\nfi\nif [ ! -s \"$apply_manifest\" ]; then\n  fail \"missing backup manifest for apply mode\"\nfi\nbackup_path=\"$(awk -F '\\t' 'NF >= 2 {print $2; exit}' \"$apply_manifest\")\"\nif [ \"$backup_path\" = \"\" ] || [ ! -f \"$backup_path\" ]; then\n  fail \"missing backup file recorded by migration apply\"\nfi\n\nset +e\nsh \"$tool_exec\" rawptr_migrate_ffi --rollback:\"$apply_manifest\" >\"$rollback_log\" 2>&1\nrollback_status=\"$?\"\nset -e\nif [ \"$rollback_status\" -ne 0 ]; then\n  sed -n '1,160p' \"$rollback_log\" 1>&2 || true\n  fail \"migration rollback failed (status=$rollback_status)\"\nfi\nif ! rg -q 'openArray\\[' \"$legacy_open\"; then\n  fail \"rollback did not restore legacy openArray source\"\nfi\n\nset +e\nsh \"$tool_exec\" rawptr_migrate_ffi \\\n  --file:\"$legacy_risk\" \\\n  --check \\\n  --report:\"$risk_report\" \\\n  --suggestions:\"$risk_suggestions\" \\\n  --backup-manifest:\"$risk_manifest\" >\"$risk_log\" 2>&1\nrisk_status=\"$?\"\nset -e\nif [ \"$risk_status\" -eq 0 ]; then\n  fail \"risk fixture unexpectedly passed --check\"\nfi\nif ! rg -q '^status=needs_migration$' \"$risk_report\"; then\n  fail \"risk report missing needs_migration status\"\nfi\nif ! rg -q '^risk_voidptr_hits=[1-9][0-9]*$' \"$risk_report\"; then\n  fail \"risk report missing void* findings\"\nfi\nif ! rg -q '^risk_pointer_type_hits=[1-9][0-9]*$' \"$risk_report\"; then\n  fail \"risk repor"
        out = out + "t missing pointer-type findings\"\nfi\nif ! rg -q '^risk_pointer_ops_hits=[1-9][0-9]*$' \"$risk_report\"; then\n  fail \"risk report missing pointer-op findings\"\nfi\n\nif ! rg -q 'src/tooling/tooling_exec\\.sh rawptr_migrate_ffi .*--apply' \"$doc_file\"; then\n  fail \"raw-pointer doc missing migration apply command\"\nfi\nif ! rg -q 'src/tooling/tooling_exec\\.sh rawptr_migrate_ffi --rollback:' \"$doc_file\"; then\n  fail \"raw-pointer doc missing migration rollback command\"\nfi\nif ! rg -q 'backend.rawptr_migration' \"$doc_file\"; then\n  fail \"raw-pointer doc missing backend.rawptr_migration marker\"\nfi\n\nif ! rg -q 'RPSPAR-07 Raw Pointer FFI ' \"$readme_file\"; then\n  fail \"README missing RPSPAR-07 migration gate description\"\nfi\n\nif ! rg -q 'if id == \"verify_backend_rawptr_migration\":' \"$closedloop_file\"; then\n  fail \"verify_backend_closedloop missing backend.rawptr_migration\"\nfi\nif ! rg -q 'backend.rawptr_migration' \"$prod_closure_file\"; then\n  fail \"backend_prod_closure missing backend.rawptr_migration\"\nfi\n\n{\n  echo \"verify_backend_rawptr_migration report\"\n  echo \"tool_exec=$tool_exec\"\n  echo \"tool_inline=$tool_inline\"\n  echo \"fixture_open_src=$fixture_open_src\"\n  echo \"fixture_risk_src=$fixture_risk_src\"\n  echo \"apply_status=$apply_status\"\n  echo \"rollback_status=$rollback_status\"\n  echo \"risk_status=$risk_status\"\n  echo \"apply_report=$apply_report\"\n  echo \"apply_suggestions=$apply_suggestions\"\n  echo \""
        out = out + "apply_manifest=$apply_manifest\"\n  echo \"risk_report=$risk_report\"\n  echo \"risk_suggestions=$risk_suggestions\"\n  echo \"risk_manifest=$risk_manifest\"\n  echo \"apply_log=$apply_log\"\n  echo \"rollback_log=$rollback_log\"\n  echo \"risk_log=$risk_log\"\n} >\"$report\"\n\n{\n  echo \"backend_rawptr_migration_apply_status=$apply_status\"\n  echo \"backend_rawptr_migration_rollback_status=$rollback_status\"\n  echo \"backend_rawptr_migration_risk_status=$risk_status\"\n  echo \"backend_rawptr_migration_report=$report\"\n} >\"$snapshot\"\n\necho \"verify_backend_rawptr_migration ok\"\n"
        return out
    if id == "verify_backend_rawptr_surface_forbid":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_rawptr_surface_forbid] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_rawptr_surface_forbid\"\nreport=\"$out_dir/backend_rawptr_surface_forbid.report.txt\"\nsnapshot=\"$out_dir/backend_rawptr_surface_forbid.snapshot.env\"\nmkdir -p \"$out_dir\"\n\nstatus=\"ok\"\nhits_file=\"$out_dir/backend_rawptr_surface_forbid.hits.txt\"\nmiss_file=\"$out_dir/backend_rawptr_surface_forbid.miss.txt\"\n: >\"$hits_file\"\n: >\"$miss_file\"\n\nrequire_hit() {\n  file=\"$1\"\n  pattern=\"$2\"\n  label=\"$3\"\n  if rg -nF -- \"$pattern\" \"$file\" > /dev/null 2>&1; then\n    printf '%s\\t%s\\t%s\\n' \"hit\" \"$label\" \"$file\" >>\"$hits_file\"\n    return 0\n  fi\n  printf '%s\\t%s\\t%s\\t%s\\n' \"miss\" \"$label\" \"$file\" \"$pattern\" >>\"$miss_file\"\n  status=\"drift\"\n  return 1\n}\n\nrequire_absent() {\n  file=\"$1\"\n  pattern=\"$2\"\n  label=\"$3\"\n  if rg -nF -- \"$pattern\" \"$file\" > /dev/null 2>&1; then\n    printf '%s\\t%s\\t%s\\t%s\\n' \"unexpected\" \"$label\" \"$file\" \"$pattern\" >>\"$miss_file\"\n    status=\"drift\"\n    return 1\n  fi\n  printf '%s\\t%s\\t%s\\n' \"absent\" \"$label\" \"$file\" >>\"$hits_file\"\n  return 0\n}\n\ndiag_file=\"src/stage1/diagnostics.cheng\"\nparser_file=\"src/stage1/parser.cheng\"\nsem_file=\"sr"
        out = out + "c/stage1/semantics.cheng\"\n\nrequire_hit \"$diag_file\" \"fn rawPointerForbidMessage(base: str): str =\" \"diagnostics.rawptr_message_fn\"\nrequire_hit \"$diag_file\" \"slice/tuple/handle/borrow\" \"diagnostics.rawptr_replacements\"\n\nrequire_absent \"$parser_file\" \"pointer is removed; use void*\" \"parser.remove_old_voidptr_suggestion\"\nrequire_absent \"$parser_file\" \"Empty subscript dereference is not supported; use *p\" \"parser.remove_old_deref_suggestion\"\nrequire_hit \"$parser_file\" \"rawPointerForbidMessage(\\\"pointer alias is removed and bare void* is forbidden\\\")\" \"parser.pointer_alias_forbid\"\nrequire_hit \"$parser_file\" \"rawPointerForbidMessage(\\\"var is not allowed on pointer types\\\")\" \"parser.var_pointer_forbid\"\nrequire_hit \"$parser_file\" \"rawPointerForbidMessage(\\\"Empty subscript dereference is not supported in no-pointer mode\\\")\" \"parser.empty_subscript_forbid\"\nrequire_hit \"$parser_file\" \"rawPointerForbidMessage(\\\"Pointer member access is forbidden in no-pointer mode\\\")\" \"parser.pointer_member_forbid\"\n\nrequire_hit \"$sem_file\" \"fn semIsVoidPtrTypeNode(n: Node): bool =\" \"semantics.voidptr_detect_fn\"\nrequire_hit \"$sem_file\" \"rawPointerForbidMessage(\\\"no-pointer policy: bare void* surface is forbidden outside C ABI modules\\\")\" \"semantics.voidptr_forbid_diag\"\nrequire_hit \"$sem_file\" \"rawPointerForbidMessage(\\\"no-pointer policy: pointer types are forbidden outside C ABI modules\\\")\" \"semantics.p"
        out = out + "ointer_type_forbid_diag\"\nrequire_hit \"$sem_file\" \"rawPointerForbidMessage(\\\"no-pointer policy: pointer dereference is forbidden outside C ABI modules\\\")\" \"semantics.pointer_deref_forbid_diag\"\nrequire_hit \"$sem_file\" \"rawPointerForbidMessage(\\\"no-pointer policy: pointer operation is forbidden outside C ABI modules: \\\" + callName)\" \"semantics.pointer_op_forbid_diag\"\n\nruntime_probe_status=\"skip\"\n\n{\n  echo \"verify_backend_rawptr_surface_forbid report\"\n  echo \"status=$status\"\n  echo \"runtime_probe_status=$runtime_probe_status\"\n  echo \"hits_file=$hits_file\"\n  echo \"miss_file=$miss_file\"\n} >\"$report\"\n\n{\n  echo \"backend_rawptr_surface_forbid_status=$status\"\n  echo \"backend_rawptr_surface_forbid_runtime_probe_status=$runtime_probe_status\"\n  echo \"backend_rawptr_surface_forbid_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_rawptr_surface_forbid] raw pointer surface forbid drift detected\" 1>&2\n  echo \"  report: $report\" 1>&2\n  if [ -s \"$miss_file\" ]; then\n    sed -n '1,120p' \"$miss_file\" 1>&2 || true\n  fi\n  exit 1\nfi\n\necho \"verify_backend_rawptr_surface_forbid ok\"\n"
        return out
    if id == "verify_backend_release_c_o3_lto":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nif [ \"${BACKEND_DRIVER:-}\" != \"\" ]; then\n  driver=\"${BACKEND_DRIVER}\"\nelse\n  driver=\"$(env \\\n    BACKEND_DRIVER_PATH_PREFER_REBUILD=\"${BACKEND_DRIVER_PATH_PREFER_REBUILD:-1}\" \\\n    BACKEND_DRIVER_ALLOW_FALLBACK=\"${BACKEND_DRIVER_ALLOW_FALLBACK:-0}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_release_c_o3_lto] backend driver not executable: $driver\" 1>&2\n  exit 1\nfi\n\nif ! command -v cc >/dev/null 2>&1; then\n  echo \"[verify_backend_release_c_o3_lto] missing cc (required for O3/LTO toolchain probe)\" 1>&2\n  exit 1\nfi\n\ntarget=\"${BACKEND_TARGET:-}\"\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  echo \"[verify_backend_release_c_o3_lto] failed to resolve target\" 1"
        out = out + ">&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_release_c_o3_lto\"\nmkdir -p \"$out_dir\"\n\nfixture=\"${BACKEND_RELEASE_FIXTURE:-tests/cheng/backend/fixtures/return_add.cheng}\"\nif [ ! -f \"$fixture\" ]; then\n  fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\nif [ ! -f \"$fixture\" ]; then\n  echo \"[verify_backend_release_c_o3_lto] missing fixture: $fixture\" 1>&2\n  exit 1\nfi\n\ncontains_token() {\n  hay=\"$1\"\n  needle=\"$2\"\n  case \" $hay \" in\n    *\" $needle \"*) return 0 ;;\n  esac\n  return 1\n}\n\nappend_token() {\n  flags=\"$1\"\n  token=\"$2\"\n  if contains_token \"$flags\" \"$token\"; then\n    printf '%s\\n' \"$flags\"\n    return\n  fi\n  if [ \"$flags\" = \"\" ]; then\n    printf '%s\\n' \"$token\"\n  else\n    printf '%s %s\\n' \"$flags\" \"$token\"\n  fi\n}\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\nhas_fuse_ld_flag() {\n  case \"${1:-}\" in\n    *-fuse-ld=*) return 0 ;;\n  esac\n  return 1\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\nrelease_cflags=\"${BACKEND_RELEASE_CFLAGS:--O3 -flto}\"\nrelease_ldflags=\"${BACKEND_RELEASE_LDFLAGS:-$release_cflags}\"\ndarwin_no_uuid=\"${BACKEND_RELEASE_DARWIN_NO_UUID:-0}\"\nsystem_link_kind=\"default\"\ncase \"$host_os\" "
        out = out + "in\n  Darwin)\n    case \"$darwin_no_uuid\" in\n      1|true|TRUE|yes|YES|on|ON)\n        release_ldflags=\"$(append_token \"$release_ldflags\" \"-Wl,-no_uuid\")\"\n        ;;\n    esac\n    ;;\n  Linux)\n    release_ldflags=\"$(append_token \"$release_ldflags\" \"-Wl,--build-id=none\")\"\n    ;;\nesac\nif [ \"${BACKEND_LD:-}\" = \"\" ] && ! has_fuse_ld_flag \"$release_ldflags\"; then\n  resolver_out=\"$(env \\\n    BACKEND_SYSTEM_LINKER_PRIORITY=\"${BACKEND_SYSTEM_LINKER_PRIORITY:-mold,lld,default}\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} resolve_system_linker --ldflags:\"$release_ldflags\")\"\n  resolver_kind=\"$(printf '%s\\n' \"$resolver_out\" | sed -n 's/^kind=//p' | head -n 1)\"\n  resolver_ldflags=\"$(printf '%s\\n' \"$resolver_out\" | sed -n 's/^ldflags=//p' | head -n 1)\"\n  if [ \"$resolver_kind\" != \"\" ]; then\n    system_link_kind=\"$resolver_kind\"\n  fi\n  if [ \"$resolver_ldflags\" != \"\" ]; then\n    release_ldflags=\"$(append_token \"$release_ldflags\" \"$resolver_ldflags\")\"\n  fi\nelif [ \"${BACKEND_LD:-}\" != \"\" ]; then\n  system_link_kind=\"explicit_ld\"\nelse\n  system_link_kind=\"user_ldflags\"\nfi\n\n# Step 1: GCC/Clang O3+LTO capability probe.\ncc_probe_c=\"$out_dir/cc_o3_lto_probe.c\"\ncc_probe_log=\"$out_dir/cc_o3_lto_probe.log\"\ncc_probe_exe=\"$out_dir/cc_o3_lto_probe\"\ncat >\"$cc_probe_c\" <<'EOF'\nint main(void) { return 0; }\nEOF\nset +e\ncc -O3 -flto \"$cc_probe_c\" -o \"$cc_probe_exe\" >\"$cc_probe_log\" 2>&1\n"
        out = out + "cc_probe_status=\"$?\"\nset -e\nif [ \"$cc_probe_status\" -ne 0 ]; then\n  tail -n 120 \"$cc_probe_log\" 1>&2 || true\n  echo \"[verify_backend_release_c_o3_lto] cc O3/LTO probe failed\" 1>&2\n  exit \"$cc_probe_status\"\nfi\n\"$cc_probe_exe\"\n\n# Step 2: release system-link + O3/LTO (required).\nsystem_exe=\"$out_dir/return_add.system_o3_lto\"\nsystem_log=\"$out_dir/return_add.system_o3_lto.log\"\nsystem_status=\"ok\"\nrm -f \"$system_exe\" \"$system_exe.o\" \"$system_log\"\nrm -rf \"${system_exe}.objs\" \"${system_exe}.objs.lock\"\nset +e\nenv \\\n  ABI=v2_noptr \\\n  STAGE1_STD_NO_POINTERS=0 \\\n  STAGE1_STD_NO_POINTERS_STRICT=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  MM=orc \\\n  BACKEND_BUILD_TRACK=release \\\n  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_CFLAGS=\"$release_cflags\" \\\n  BACKEND_LDFLAGS=\"$release_ldflags\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$system_exe\" \\\n  \"$driver\" >\"$system_log\" 2>&1\nsystem_build_status=\"$?\"\nset -e\nif [ \"$system_build_status\" -ne 0 ]; then\n  cat \"$system_log\" 1>&2 || true\n  echo \"[verify_backend_release_c_o3_lto] release system-link O3/LTO compile failed\" 1>&2\n  exit \"$system_build_status\"\nfi\nset +e\n\"$system_exe\" >>\"$system_log\" 2>&1\nsystem_run_status=\"$?\"\nset -e\nif [ \"$syst"
        out = out + "em_run_status\" -ne 0 ]; then\n  cat \"$system_log\" 1>&2 || true\n  echo \"[verify_backend_release_c_o3_lto] release system-link O3/LTO run failed\" 1>&2\n  exit \"$system_run_status\"\nfi\n\nmanifest=\"$out_dir/release_manifest.json\"\nbundle=\"$out_dir/backend_release.tar.gz\"\nrelease_name=\"${BACKEND_RELEASE_NAME:-cheng}\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_manifest --out:\"$manifest\" --name:\"$release_name\" --driver:\"$driver\" >/dev/null\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_bundle --out:\"$bundle\" --name:\"$release_name\" --manifest:\"$manifest\" --driver:\"$driver\" --extra:\"$system_exe\" >/dev/null\n\nif [ ! -s \"$manifest\" ] || [ ! -s \"$bundle\" ]; then\n  echo \"[verify_backend_release_c_o3_lto] release artifacts missing (manifest/bundle)\" 1>&2\n  exit 1\nfi\n\ntimestamp=\"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\" 2>/dev/null || echo unknown)\"\ncc_path=\"$(command -v cc 2>/dev/null || echo cc)\"\ncc_version=\"$(\"$cc_path\" --version 2>/dev/null | head -n 1 | tr -d '\\r' || echo unknown)\"\nsystem_exe_sha=\"$(sha256_file \"$system_exe\")\"\nbundle_sha=\"$(sha256_file \"$bundle\")\"\n\nreport=\"$out_dir/backend_release_c_o3_lto.report.txt\"\ncat >\"$report\" <<EOF\ngate=backend.release_system_link\ntimestamp=$timestamp\nhost_os=$host_os\nhost_arch=$host_arch\ntarget=$target\ndriver=$driver\nfixture=$fixture\ncc_path=$cc_path\ncc_version=$cc_version\nrelease_cflags=$release_cflags\nrelease_ld"
        out = out + "flags=$release_ldflags\ndarwin_no_uuid=$darwin_no_uuid\nsystem_exe=$system_exe\nsystem_exe_sha256=$system_exe_sha\nsystem_link_status=$system_status\nsystem_link_kind=$system_link_kind\nsystem_link_log=$system_log\nrelease_manifest=$manifest\nrelease_bundle=$bundle\nrelease_bundle_sha256=$bundle_sha\nEOF\n\necho \"verify_backend_release_c_o3_lto ok\"\n"
        return out
    if id == "verify_backend_release_rollback_drill":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nmanifest=\"artifacts/backend_prod/release_manifest.json\"\nbundle=\"artifacts/backend_prod/backend_release.tar.gz\"\ndst=\"dist/releases\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --manifest:*)\n      manifest=\"${1#--manifest:}\"\n      ;;\n    --bundle:*)\n      bundle=\"${1#--bundle:}\"\n      ;;\n    --dst:*)\n      dst=\"${1#--dst:}\"\n      ;;\n    --help|-h)\n      echo \"Usage: src/tooling/verify_backend_release_rollback_drill.sh [--manifest:<path>] [--bundle:<path>] [--dst:<dir>]\" >&2\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" >&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$manifest\" ] || [ ! -f \"$bundle\" ]; then\n  echo \"[verify_backend_release_rollback_drill] missing manifest/bundle: $manifest $bundle\" >&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_release_rollback_drill\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/backend_release_rollback_drill.report.txt\"\n\nbefore=\"\"\nif [ -f \"$dst/current_id.txt\" ]; then\n  before=\"$(head -n 1 \"$dst/current_id.txt\" | tr -d '\\r\\n')\"\nfi\nif [ \"$before\" = \"\" ] && [ -L \"$dst/current\" ]; then\n  before=\"$(basename \"$(readlink \"$dst/current\" 2>/dev/null || true)\")\"\nfi\n\npublish_once() {\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_publis"
        out = out + "h --manifest:\"$manifest\" --bundle:\"$bundle\" --dst:\"$dst\" >/dev/null\n  if [ -f \"$dst/current_id.txt\" ]; then\n    head -n 1 \"$dst/current_id.txt\" | tr -d '\\r\\n'\n    return 0\n  fi\n  basename \"$(readlink \"$dst/current\" 2>/dev/null || true)\"\n}\n\nnew_id=\"$(publish_once)\"\nrollback_target=\"$before\"\nrestore_target=\"$new_id\"\n\nif [ \"$rollback_target\" = \"\" ] || [ \"$rollback_target\" = \"$restore_target\" ]; then\n  rollback_target=\"$restore_target\"\n  restore_target=\"$(publish_once)\"\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_rollback --to:\"$rollback_target\" --root:\"$dst\" >/dev/null\nrolled=\"$(head -n 1 \"$dst/current_id.txt\" | tr -d '\\r\\n')\"\nif [ \"$rolled\" != \"$rollback_target\" ]; then\n  echo \"[verify_backend_release_rollback_drill] rollback mismatch: expected=$rollback_target got=$rolled\" >&2\n  exit 1\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_release_rollback --to:\"$restore_target\" --root:\"$dst\" >/dev/null\nrestored=\"$(head -n 1 \"$dst/current_id.txt\" | tr -d '\\r\\n')\"\nif [ \"$restored\" != \"$restore_target\" ]; then\n  echo \"[verify_backend_release_rollback_drill] restore mismatch: expected=$restore_target got=$restored\" >&2\n  exit 1\nfi\n\n{\n  echo \"verify_backend_release_rollback_drill report\"\n  echo \"status=ok\"\n  echo \"manifest=$manifest\"\n  echo \"bundle=$bundle\"\n  echo \"dst=$dst\"\n  echo \"before=$before\"\n  echo \"rollback_targ"
        out = out + "et=$rollback_target\"\n  echo \"restore_target=$restore_target\"\n  echo \"rolled=$rolled\"\n  echo \"restored=$restored\"\n} >\"$report\"\n\necho \"verify_backend_release_rollback_drill ok\"\n"
        return out
    if id == "verify_backend_runtime_abi":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nheader_file=\"src/runtime/native/system_helpers.h\"\nc_runtime_main=\"src/runtime/native/system_helpers.c\"\nc_runtime_float_bits=\"src/runtime/native/system_helpers_float_bits.c\"\nbackend_runtime_file=\"src/std/system_helpers_backend.cheng\"\n\nfail() {\n  echo \"[verify_backend_runtime_abi] $1\" 1>&2\n  exit 1\n}\n\nrequire_file() {\n  file=\"$1\"\n  [ -f \"$file\" ] || fail \"missing file: $file\"\n}\n\nextract_header_symbols() {\n  rg -N --no-filename '^[[:space:]]*[A-Za-z_][A-Za-z0-9_[:space:]\\*]*[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\([^;]*\\);[[:space:]]*$' \"$1\" \\\n    | sed -E 's/^[[:space:]]*[A-Za-z_][A-Za-z0-9_[:space:]\\*]*[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*\\(.*/\\1/' \\\n    | sort -u\n}\n\nextract_c_defined_symbols() {\n  rg -N --no-filename '^[[:space:]]*(__attribute__\\(\\([^)]*\\)\\)[[:space:]]*)*[A-Za-z_][A-Za-z0-9_[:space:]\\*]*[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\([^;]*\\)[[:space:]]*\\{' \"$@\" \\\n    | sed -E 's/^[[:space:]]*(__attribute__\\(\\([^)]*\\)\\)[[:space:]]*)*//' \\\n    | sed -E 's/^[[:space:]]*[A-Za-z_][A-Za-z0-9_[:space:]\\*]*[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*\\(.*/\\1/' \\\n    | sort -u\n}\n\nextract_backend_symbols() {\n  rg -N --no-filename '^[[:space:]]*fn[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\\(' \"$1\" \\\n    | s"
        out = out + "ed -E 's/^[[:space:]]*fn[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*\\(.*/\\1/' \\\n    | sort -u\n}\n\ntmp_dir=\"$(mktemp -d \"${TMPDIR:-/tmp}/cheng_runtime_abi.XXXXXX\")\"\ncleanup() {\n  rm -rf \"$tmp_dir\"\n}\ntrap cleanup EXIT INT TERM\n\nrequire_file \"$header_file\"\nrequire_file \"$c_runtime_main\"\nrequire_file \"$backend_runtime_file\"\n\nheader_symbols=\"$tmp_dir/header_symbols.txt\"\nc_symbols=\"$tmp_dir/c_symbols.txt\"\nbackend_symbols=\"$tmp_dir/backend_symbols.txt\"\nmissing_in_c=\"$tmp_dir/missing_in_c.txt\"\nmissing_in_backend=\"$tmp_dir/missing_in_backend.txt\"\nallowed_backend_missing=\"$tmp_dir/allowed_backend_missing.txt\"\nunexpected_backend_missing=\"$tmp_dir/unexpected_backend_missing.txt\"\n\nextract_header_symbols \"$header_file\" > \"$header_symbols\"\n\nif [ -f \"$c_runtime_float_bits\" ]; then\n  extract_c_defined_symbols \"$c_runtime_main\" \"$c_runtime_float_bits\" > \"$c_symbols\"\nelse\n  extract_c_defined_symbols \"$c_runtime_main\" > \"$c_symbols\"\nfi\n\nextract_backend_symbols \"$backend_runtime_file\" > \"$backend_symbols\"\n\ncomm -23 \"$header_symbols\" \"$c_symbols\" > \"$missing_in_c\"\nif [ -s \"$missing_in_c\" ]; then\n  echo \"[verify_backend_runtime_abi] C runtime missing header symbols:\" 1>&2\n  cat \"$missing_in_c\" 1>&2\n  exit 1\nfi\n\ncat > \"$allowed_backend_missing\" <<'EOF'\nalloc\nbitand_0\nbitnot_0\nbitor_0\ncheng_bits_to_f32\ncheng_bits_to_f64\ncheng_errno\ncheng_f32_to_bits\ncheng_f64_ge_bits\ncheng_f64_gt_bits\nc"
        out = out + "heng_f64_le_bits\ncheng_f64_lt_bits\ncheng_f64_sub_bits\ncheng_f64_to_bits\ncheng_jpeg_decode\ncheng_jpeg_free\ncheng_memcpy\ncheng_memcpy_ffi\ncheng_memset\ncheng_memset_ffi\ncheng_ptr_size\ncheng_ptr_to_u64\ncheng_read_file\ncheng_seq_get\ncheng_seq_set\ncheng_slice_get\ncheng_slice_set\ncheng_strcmp\ncheng_strerror\ncheng_strlen\ncheng_tcp_listener\ncheng_write_file\ncopyMem\ndiv_0\nload_ptr\nmod_0\nmul_0\nnot_0\nptr_add\nsetMem\nshl_0\nshr_0\nstore_ptr\nsys_memset\nxor_0\nEOF\nsort -u \"$allowed_backend_missing\" -o \"$allowed_backend_missing\"\n\ncomm -23 \"$header_symbols\" \"$backend_symbols\" > \"$missing_in_backend\"\ncomm -23 \"$missing_in_backend\" \"$allowed_backend_missing\" > \"$unexpected_backend_missing\"\nif [ -s \"$unexpected_backend_missing\" ]; then\n  echo \"[verify_backend_runtime_abi] backend runtime missing unexpected header symbols:\" 1>&2\n  cat \"$unexpected_backend_missing\" 1>&2\n  exit 1\nfi\n\nfor alias in __addr _addr; do\n  if ! grep -qx \"$alias\" \"$c_symbols\"; then\n    fail \"C runtime missing alias symbol: $alias\"\n  fi\n  if ! grep -qx \"$alias\" \"$backend_symbols\"; then\n    fail \"backend runtime missing alias symbol: $alias\"\n  fi\ndone\n\necho \"verify_backend_runtime_abi ok\"\n"
        return out
    if id == "verify_backend_sanitizer":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:system)\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\ncase \"$host_os\" in\n  Darwin)\n    ;;\n  Linux)\n    ;;\n  *)\n    echo \"verify_backend_sanitizer skip: unsupported host os: $host_os\" 1>&2\n    exit 2\n    ;;\nesac\n\nout_dir=\"artifacts/backend_sanitizer\"\nmkdir -p \"$out_dir\"\n\nprobe_c=\"$out_dir/probe.c\"\nprobe_exe=\"$out_dir/probe\"\ncat >\"$probe_c\" <<'EOF'\nint main(void) { return 0; }\nEOF\n\nset +e\ncc -O1 -g -fno-omit-frame-pointer -fsanitize=address \"$probe_c\" -o \"$probe_exe\" >/dev/null 2>&1\nprobe_status=\"$?\"\nset -e\nif [ \"$probe_status\" -ne 0 ]; then\n  echo \"verify_backend_sanitizer skip: cc does not support -fsanitize=address\" 1>&2\n  exit 2\n"
        out = out + "fi\n\n\nfixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nexe_path=\"$out_dir/return_add_asan\"\n\nenv $link_env \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_CFLAGS=\"-O1 -g -fno-omit-frame-pointer -fsanitize=address\" \\\n  BACKEND_LDFLAGS=\"-fsanitize=address\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\"\n\nASAN_OPTIONS=detect_leaks=0 \"$exe_path\"\n\necho \"verify_backend_sanitizer ok\"\n"
        return out
    if id == "verify_backend_self_linker_coff":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfind_llvm_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf '%s\\n' \"$p\"\n      return 0\n    fi\n  fi\n  if command -v llvm-objdump >/dev/null 2>&1; then\n    command -v llvm-objdump\n    return 0\n  fi\n  if command -v objdump >/dev/null 2>&1; then\n    command -v objdump\n    return 0\n  fi\n  return 1\n}\n\nprobe_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$probe_fixture\" ]; then\n  probe_fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\n\ndriver_help_ok() {\n  bin=\"$1\"\n  [ -x \"$bin\" ] || return 1\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\nprobe_driver_target() {\n  bin=\"$1\"\n  target=\"$2\"\n  out=\"$3\"\n  out_base=\"${out%.*}\"\n  rm -f \"$out\" \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_ba"
        out = out + "se.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  set +e\n  env \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_fixture\" \\\n    BACKEND_OUTPUT=\"$out\" \\\n    \"$bin\" >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  rm -f \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_base.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  if [ \"$status\" -ne 0 ] || [ ! -s \"$out\" ]; then\n    return 1\n  fi\n  return 0\n}\n\npick_driver() {\n  target=\"$1\"\n  resolver_path=\"$(BACKEND_DRIVER_PATH_USE_WRAPPER=0 BACKEND_DRIVER_PATH_ALLOW_SELFHOST=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  for cand in \\\n    \"${BACKEND_SELF_LINKER_DRIVER:-}\" \\\n    \"${BACKEND_LINKER_ABI_CORE_DRIVER:-}\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng_stage0_default\" \\\n    \"dist/releases/current/cheng\" \\\n    \"$resolver_path\"; do\n    [ \"$cand\" != \"\" ] || continue\n    [ -x \"$cand\" ] || continue\n    if ! driver_help_ok \"$cand\"; then\n      continue\n   "
        out = out + " fi\n    probe_out=\"artifacts/backend_self_linker_coff/.driver_probe.$(basename \"$cand\").$target\"\n    rm -f \"$probe_out\"\n    if probe_driver_target \"$cand\" \"$target\" \"$probe_out\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nobjdump=\"$(find_llvm_objdump || true)\"\nif [ \"$objdump\" = \"\" ]; then\n  echo \"[verify_backend_self_linker_coff] missing objdump tool\" >&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_self_linker_coff\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\n\ntarget=\"${BACKEND_COFF_TARGET:-aarch64-pc-windows-msvc}\"\ndriver=\"$(pick_driver \"$target\" || true)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_self_linker_coff] no driver can self-link target: $target\" >&2\n  exit 1\nfi\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nexe_path=\"$out_dir/hello_importc_puts.self.coff.exe\"\n\nrun_build() {\n  env \\\n    BACKEND_LINKER=self \\\n    BACKEND_COFF_CRT_DLL=UCRTBASE.dll \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >/dev/null\n}\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$exe_path.tmp\" \"$exe_path.tmp.linkobj\"\nrm -rf \"$exe_path"
        out = out + ".objs\" \"$exe_path.objs.lock\"\n\nif ! run_build; then\n  status=$?\n  if [ \"$status\" -eq 134 ]; then\n    rm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\" 2>/dev/null || true\n    run_build\n  else\n    exit \"$status\"\n  fi\nfi\n\nif [ ! -s \"$exe_path\" ]; then\n  echo \"[verify_backend_self_linker_coff] missing output: $exe_path\" >&2\n  exit 1\nfi\nexe_base=\"${exe_path%.*}\"\nrm -f \"$exe_path.o\" \"$exe_path.tmp\" \"$exe_path.tmp.linkobj\" \"$exe_base.o\" \"$exe_base.tmp\" \"$exe_base.tmp.linkobj\"\nrm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\" \"$exe_base.objs\" \"$exe_base.objs.lock\"\n\n\"$objdump\" -h \"$exe_path\" > \"$out_dir/hello_importc_puts.self.coff.exe.objdump.h.txt\"\ngrep -q \"file format coff-arm64\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.h.txt\"\ngrep -q \"\\\\.text\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.h.txt\"\ngrep -q \"\\\\.idata\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.h.txt\"\n\n\"$objdump\" --private-headers \"$exe_path\" > \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\ngrep -q \"Magic[[:space:]]\\\\+020b\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\ngrep -q \"Subsystem[[:space:]]\\\\+00000003\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\ngrep -q \"DLL Name: KERNEL32\\\\.dll\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\ngrep -q \"ExitProcess\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\n"
        out = out + "grep -q \"DLL Name: UCRTBASE\\\\.dll\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\ngrep -q \"puts\" \"$out_dir/hello_importc_puts.self.coff.exe.objdump.private.txt\"\n\necho \"verify_backend_self_linker_coff ok\"\n"
        return out
    if id == "verify_backend_self_linker_elf":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nfind_llvm_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf '%s\\n' \"$p\"\n      return 0\n    fi\n  fi\n  if command -v llvm-objdump >/dev/null 2>&1; then\n    command -v llvm-objdump\n    return 0\n  fi\n  if command -v objdump >/dev/null 2>&1; then\n    command -v objdump\n    return 0\n  fi\n  return 1\n}\n\nprobe_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$probe_fixture\" ]; then\n  probe_fixture=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\n\ndriver_help_ok() {\n  bin=\"$1\"\n  [ -x \"$bin\" ] || return 1\n  set +e\n  \"$bin\" --help >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\nprobe_driver_target() {\n  bin=\"$1\"\n  target=\"$2\"\n  out=\"$3\"\n  out_base=\"${out%.*}\"\n  rm -f \"$out\" \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_ba"
        out = out + "se.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  set +e\n  env \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ= \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_fixture\" \\\n    BACKEND_OUTPUT=\"$out\" \\\n    \"$bin\" >/dev/null 2>&1\n  status=\"$?\"\n  set -e\n  rm -f \"$out.o\" \"$out.tmp\" \"$out.tmp.linkobj\" \"$out_base.o\" \"$out_base.tmp\" \"$out_base.tmp.linkobj\"\n  rm -rf \"$out.objs\" \"$out.objs.lock\" \"$out_base.objs\" \"$out_base.objs.lock\"\n  if [ \"$status\" -ne 0 ] || [ ! -s \"$out\" ]; then\n    return 1\n  fi\n  return 0\n}\n\npick_driver() {\n  target=\"$1\"\n  resolver_path=\"$(BACKEND_DRIVER_PATH_USE_WRAPPER=0 BACKEND_DRIVER_PATH_ALLOW_SELFHOST=1 ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  for cand in \\\n    \"${BACKEND_SELF_LINKER_DRIVER:-}\" \\\n    \"${BACKEND_LINKER_ABI_CORE_DRIVER:-}\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng_stage0_default\" \\\n    \"dist/releases/current/cheng\" \\\n    \"$resolver_path\"; do\n    [ \"$cand\" != \"\" ] || continue\n    [ -x \"$cand\" ] || continue\n    if ! driver_help_ok \"$cand\"; then\n      continue\n   "
        out = out + " fi\n    probe_out=\"artifacts/backend_self_linker_elf/.driver_probe.$(basename \"$cand\").$target\"\n    rm -f \"$probe_out\"\n    if probe_driver_target \"$cand\" \"$target\" \"$probe_out\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nobjdump=\"$(find_llvm_objdump || true)\"\nif [ \"$objdump\" = \"\" ]; then\n  echo \"[verify_backend_self_linker_elf] missing objdump tool\" >&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_self_linker_elf\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\n\ntarget=\"${BACKEND_ELF_TARGET:-aarch64-unknown-linux-gnu}\"\ndriver=\"$(pick_driver \"$target\" || true)\"\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_self_linker_elf] no driver can self-link target: $target\" >&2\n  exit 1\nfi\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nexe_path=\"$out_dir/hello_puts.$target\"\n\nrm -f \"$exe_path\" \"$exe_path.o\" \"$exe_path.tmp\" \"$exe_path.tmp.linkobj\"\nrm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\"\n\nenv \\\n  BACKEND_LINKER=self \\\n  BACKEND_NO_RUNTIME_C=1 \\\n  BACKEND_RUNTIME_OBJ= \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\" >/dev/null\n\nif [ ! -s \"$exe_path\" ]; then\n  echo \"[verify_backend_self_linker_elf] missing output: $exe_path\" >&2"
        out = out + "\n  exit 1\nfi\nexe_base=\"${exe_path%.*}\"\nrm -f \"$exe_path.o\" \"$exe_path.tmp\" \"$exe_path.tmp.linkobj\" \"$exe_base.o\" \"$exe_base.tmp\" \"$exe_base.tmp.linkobj\"\nrm -rf \"$exe_path.objs\" \"$exe_path.objs.lock\" \"$exe_base.objs\" \"$exe_base.objs.lock\"\n\n\"$objdump\" --private-headers \"$exe_path\" > \"$out_dir/hello_puts.$target.objdump.private.txt\"\n\ngrep -q \"file format elf64-littleaarch64\" \"$out_dir/hello_puts.$target.objdump.private.txt\" || {\n  echo \"[verify_backend_self_linker_elf] unexpected file format: $exe_path\" >&2\n  exit 1\n}\ngrep -q \"INTERP\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"DYNAMIC\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"Dynamic Section:\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"NEEDED\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"STRTAB\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"SYMTAB\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"RELA\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\n\necho \"verify_backend_self_linker_elf ok\"\n"
        return out
    if id == "verify_backend_riscv64_quic_boundary":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_riscv64_quic_boundary] $1\" >&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nriscv_crt=\"src/tooling/rtos/riscv64/crt0.S\"\nriscv_linker=\"src/tooling/rtos/riscv64/linker.ld\"\nriscv_toolchain=\"src/tooling/toolchains/rtos_riscv64_elf.env\"\nriscv_linker_src=\"src/backend/obj/elf_linker_riscv64.cheng\"\n\n[ -f \"$riscv_crt\" ] || fail \"missing riscv crt0: $riscv_crt\"\n[ -f \"$riscv_linker\" ] || fail \"missing riscv linker script: $riscv_linker\"\n[ -f \"$riscv_toolchain\" ] || fail \"missing riscv toolchain env: $riscv_toolchain\"\n[ -f \"$riscv_linker_src\" ] || fail \"missing riscv linker source: $riscv_linker_src\"\n\nout_dir=\"artifacts/backend_riscv64_quic_boundary\"\nmkdir -p \"$out_dir\"\nhits_file=\"$out_dir/riscv64_quic_boundary.disallowed_hits.txt\"\nreport=\"$out_dir/riscv64_quic_boundary.report.txt\"\n\n: >\"$hits_file\"\nrg -n --no-messages '(openssl_quic|msquictransport|msquic|openssl|@importc\\(|socket\\(|sendto\\(|recvfrom\\()' \\\n  \"$riscv_crt\" \"$riscv_linker\" \"$riscv_toolchain\" \"$riscv_linker_src\" >\"$hits_file\" || true\n\nif [ -s \"$hits_file\" ]; then\n  sed -n '1,120p' \"$hits_file\" >&2 || true\n  fail \"riscv64/rtos path contains forbidden C-lib or socket surface markers\"\nfi\n\ncore_quic_dir=\"src/quic\"\ncore_quic_present=\"0\"\nif [ -d \"$core_quic_dir\" ]; then\n  core_quic_present=\"1\"\nfi\n\n{\n  echo \"verify_backend_riscv64_quic_boundary report\"\n  echo \"status=ok\"\n  echo \"riscv_crt=$riscv_crt\"\n  echo \"riscv_linker=$riscv_linker\"\n  echo \"riscv_toolchain=$riscv_toolchain\"\n  echo \"riscv_linker_src=$riscv_linker_src\"\n  echo \"core_quic_present=$core_quic_present\"\n  echo \"forbidden_hits=$hits_file\"\n} >\"$report\"\n\necho \"verify_backend_riscv64_quic_boundary ok\"\n"
        return out
    if id == "verify_backend_self_linker_riscv64":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nmm=\"${MM:-orc}\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\n# Prefer a ready stage2 driver to avoid slow local rebuilds in CI/gates.\nif [ \"${BACKEND_DRIVER:-}\" = \"\" ]; then\n  if [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage2\" ]; then\n    export BACKEND_DRIVER=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n  fi\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nobjdump=\"\"\nif command -v xcrun >/dev/null 2>&1; then\n  objdump=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\nfi\nif [ \"$objdump\" = \"\" ] && command -v llvm-objdump >/dev/null 2>&1; then\n  objdump=\"$(command -v llvm-objdump)\"\nfi\n\nif [ \"$objdump\" = \"\" ]; then\n  echo \"[verify_backend_self_linker_riscv64] skip: missing llvm-objdump\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_self_linker_riscv64\"\nmkdir -p \"$out_dir\"\n\ntarget=\"${BACKEND_RISCV64_TARGET:-riscv64-unknown-linux-gnu}\"\n\nruntime_src=\"src/std/system_helpers_backend.cheng\"\nruntim"
        out = out + "e_obj=\"$out_dir/system_helpers_backend.$target.o\"\n\nif [ ! -f \"$runtime_obj\" ] || [ \"$runtime_src\" -nt \"$runtime_obj\" ]; then\n  MM=\"$mm\" \\\n  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_INPUT=\"$runtime_src\" \\\n  BACKEND_OUTPUT=\"$runtime_obj\" \\\n  \"$driver\" >/dev/null\nfi\n\nif [ ! -s \"$runtime_obj\" ]; then\n  echo \"[verify_backend_self_linker_riscv64] missing runtime obj: $runtime_obj\" >&2\n  exit 1\nfi\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nexe_path=\"$out_dir/hello_puts.$target\"\n\nBACKEND_LINKER=self \\\nBACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\nBACKEND_NO_RUNTIME_C=1 \\\nMM=\"$mm\" \\\nBACKEND_EMIT=exe \\\nBACKEND_TARGET=\"$target\" \\\nBACKEND_FRONTEND=stage1 \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\" >/dev/null\n\nif [ ! -s \"$exe_path\" ]; then\n  echo \"[verify_backend_self_linker_riscv64] missing output: $exe_path\" >&2\n  exit 1\nfi\n\n\"$objdump\" --private-headers \"$exe_path\" > \"$out_dir/hello_puts.$target.objdump.private.txt\"\n\ngrep -qi \"file format elf64\" \"$out_dir/hello_puts.$target.objdump.private.txt\" || {\n  echo \"[verify_backend_self_linker_riscv64] unexpected file format: $exe_path\" >&2\n  exit 1\n}\ngrep -qi \"riscv\" \"$out_dir/hello_puts.$target.objdump.private.txt\" || {\n  echo \"[verify_backend_self_linker_riscv64] unexpected arch: $exe_path\" >&"
        out = out + "2\n  exit 1\n}\ngrep -q \"INTERP\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"DYNAMIC\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\n\ngrep -q \"Dynamic Section:\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"NEEDED\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"STRTAB\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"SYMTAB\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\ngrep -q \"RELA\" \"$out_dir/hello_puts.$target.objdump.private.txt\"\n\necho \"verify_backend_self_linker_riscv64 ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n\ndetect_ndk_from_sdk() {\n  sdk=\"$1\"\n  if [ -z \"$sdk\" ]; then\n    return 1\n  fi\n  if [ -d \"$sdk/ndk-bundle\" ]; then\n    echo \"$sdk/ndk-bundle\"\n    return 0\n  fi\n  if [ -d \"$sdk/ndk\" ]; then\n    latest=\"$(find \"$sdk/ndk\" -maxdepth 1 -mindepth 1 -type d -print 2>/dev/null | LC_ALL=C sort | tail -n 1 || true)\"\n    if [ -n \"$latest\" ]; then\n      echo \"$latest\"\n      return 0\n    fi\n  fi\n  return 1\n}\n\nndk=\"${ANDROID_NDK_HOME:-${ANDROID_NDK_ROOT:-}}\"\nif [ -z \"$ndk\" ]; then\n  sdk=\"${ANDROID_SDK_ROOT:-${ANDROID_HOME:-}}\"\n  if [ -z \"$sdk\" ]; then\n    if [ -d \"$HOME/Library/Android/sdk\" ]; then\n      sdk=\"$HOME/Library/Android/sdk\"\n    elif [ -d \"$HOME/Android/Sdk\" ]; then\n      sdk=\"$HOME/Android/Sdk\"\n    fi\n  fi\n  ndk=\"$(detect_ndk_from_sdk \"$sdk\" || true)\"\nfi\nif [ -z \"$ndk\" ] || [ ! -d \"$ndk\" ]; then\n  echo "
        out = out + "\"[verify_backend_self_obj_writer] missing NDK (set ANDROID_NDK_HOME or ANDROID_SDK_ROOT)\" >&2\n  exit 2\nfi\n\nhost_prebuilt=\"\"\nfor candidate in darwin-arm64 darwin-x86_64 linux-x86_64 linux-arm64 linux-aarch64 windows-x86_64 windows-x64; do\n  if [ -d \"$ndk/toolchains/llvm/prebuilt/$candidate\" ]; then\n    host_prebuilt=\"$candidate\"\n    break\n  fi\ndone\nif [ -z \"$host_prebuilt\" ]; then\n  echo \"[verify_backend_self_obj_writer] missing NDK host prebuilt in $ndk\" >&2\n  exit 2\nfi\n\ntool_bin=\"$ndk/toolchains/llvm/prebuilt/$host_prebuilt/bin\"\napi=\"${ANDROID_API:-21}\"\nndk_cc=\"$tool_bin/aarch64-linux-android${api}-clang\"\nndk_readelf=\"$tool_bin/llvm-readelf\"\nndk_nm=\"$tool_bin/llvm-nm\"\n\nif [ ! -x \"$ndk_cc\" ] || [ ! -x \"$ndk_readelf\" ] || [ ! -x \"$ndk_nm\" ]; then\n  echo \"[verify_backend_self_obj_writer] missing NDK tools under $tool_bin\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_self_obj\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.self.o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=elf \\\nBACKEND_TARGET=aarch64-linux-android \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_path\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_path\" ]; then\n  echo \"[verify_backend_self_obj_writer] missing output: $obj_path\" >&2\n  exit 1\nfi\n\n\"$ndk_readelf\" -h \"$obj_path\" > \"$out_dir/hello_importc_puts.self.readelf.h.txt\"\ngrep -q \"Type:[[:space:]]*REL\""
        out = out + " \"$out_dir/hello_importc_puts.self.readelf.h.txt\"\ngrep -q \"Machine:[[:space:]]*AArch64\" \"$out_dir/hello_importc_puts.self.readelf.h.txt\"\n\n\"$ndk_readelf\" -S \"$obj_path\" > \"$out_dir/hello_importc_puts.self.readelf.s.txt\"\ngrep -q \"\\\\.text\" \"$out_dir/hello_importc_puts.self.readelf.s.txt\"\ngrep -q \"\\\\.rodata\" \"$out_dir/hello_importc_puts.self.readelf.s.txt\"\ngrep -q \"\\\\.rela\\\\.text\" \"$out_dir/hello_importc_puts.self.readelf.s.txt\"\n\n\"$ndk_readelf\" -r \"$obj_path\" > \"$out_dir/hello_importc_puts.self.readelf.r.txt\"\ngrep -q \"R_AARCH64_ADR_PREL_PG_HI21\" \"$out_dir/hello_importc_puts.self.readelf.r.txt\"\ngrep -q \"R_AARCH64_ADD_ABS_LO12_NC\" \"$out_dir/hello_importc_puts.self.readelf.r.txt\"\ngrep -q \"R_AARCH64_CALL26\" \"$out_dir/hello_importc_puts.self.readelf.r.txt\"\n\n\"$ndk_nm\" -g \"$obj_path\" > \"$out_dir/hello_importc_puts.self.nm.txt\"\ngrep -q \" T main$\" \"$out_dir/hello_importc_puts.self.nm.txt\"\ngrep -q \" U puts$\" \"$out_dir/hello_importc_puts.self.nm.txt\"\n\nexe_path=\"$out_dir/hello_importc_puts.self.android\"\n\"$ndk_cc\" \"$obj_path\" -fPIE -pie -o \"$exe_path\"\n\n\"$ndk_readelf\" -h \"$exe_path\" > \"$out_dir/hello_importc_puts.self.android.readelf.h.txt\"\ngrep -q \"Machine:[[:space:]]*AArch64\" \"$out_dir/hello_importc_puts.self.android.readelf.h.txt\"\n\necho \"verify_backend_self_obj_writer ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer_coff":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nif ! command -v xcrun >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff] missing xcrun\" >&2\n  exit 2\nfi\nif ! xcrun --find llvm-objdump >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff] missing llvm-objdump (xcrun)\" >&2\n  exit 2\nfi\nif ! xcrun --find llvm-nm >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff] missing llvm-nm (xcrun)\" >&2\n  exit 2\nfi\n\n\nout_dir=\"artifacts/backend_self_obj_coff\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.self.coff.obj\"\nobj_path_x64=\"$out_dir/hello_importc_puts.self.coff.x86_64.obj\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=aarch64-pc-windows-msvc \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_path\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_path\" ]; then"
        out = out + "\n  echo \"[verify_backend_self_obj_writer_coff] missing output: $obj_path\" >&2\n  exit 1\nfi\n\nxcrun llvm-objdump -h -r \"$obj_path\" > \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"file format coff-arm64\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"\\\\.text\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"\\\\.rdata\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"IMAGE_REL_ARM64_PAGEBASE_REL21\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"IMAGE_REL_ARM64_PAGEOFFSET_12A\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\ngrep -q \"IMAGE_REL_ARM64_BRANCH26\" \"$out_dir/hello_importc_puts.self.coff.objdump.hr.txt\"\n\nxcrun llvm-nm -n \"$obj_path\" > \"$out_dir/hello_importc_puts.self.coff.nm.txt\"\ngrep -q \" T main$\" \"$out_dir/hello_importc_puts.self.coff.nm.txt\"\ngrep -q \" U puts$\" \"$out_dir/hello_importc_puts.self.coff.nm.txt\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=x86_64-pc-windows-msvc \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_path_x64\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_path_x64\" ]; then\n  echo \"[verify_backend_self_obj_writer_coff] missing output: $obj_path_x64\" >&2\n  exit 1\nfi\n\nxcrun llvm-objdump -h -r \"$obj_path_x64\" > \"$out_dir/hello_importc_puts.self.coff.x86_64.objdump.hr.txt\"\ngrep -q \"file format coff-x86-64\" \"$out_dir/hello_importc_puts.self.coff.x86_64.objdump.hr.txt\"\ng"
        out = out + "rep -q \"\\\\.text\" \"$out_dir/hello_importc_puts.self.coff.x86_64.objdump.hr.txt\"\ngrep -q \"\\\\.rdata\" \"$out_dir/hello_importc_puts.self.coff.x86_64.objdump.hr.txt\"\ngrep -q \"IMAGE_REL_AMD64_REL32\" \"$out_dir/hello_importc_puts.self.coff.x86_64.objdump.hr.txt\"\n\nxcrun llvm-nm -n \"$obj_path_x64\" > \"$out_dir/hello_importc_puts.self.coff.x86_64.nm.txt\"\ngrep -q \" T main$\" \"$out_dir/hello_importc_puts.self.coff.x86_64.nm.txt\"\ngrep -q \" U puts$\" \"$out_dir/hello_importc_puts.self.coff.x86_64.nm.txt\"\n\necho \"verify_backend_self_obj_writer_coff ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer_coff_determinism":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nsha256_file() {\n  f=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v openssl >/dev/null 2>&1; then\n    openssl dgst -sha256 \"$f\" | awk '{print $2}'\n    return 0\n  fi\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing sha256 tool\" >&2\n  return 2\n}\n\nif ! command -v xcrun >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing xcrun\" >&2\n  exit 2\nfi\nif ! xcrun --find llvm-objdump >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing llvm-objdump (xcrun)\" >&2\n  exit 2\nfi\nif ! xcrun --find llvm-nm >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing l"
        out = out + "lvm-nm (xcrun)\" >&2\n  exit 2\nfi\n\n\nout_dir=\"artifacts/backend_self_obj_coff_determinism\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_a=\"$out_dir/hello_importc_puts.self.coff.a.obj\"\nobj_b=\"$out_dir/hello_importc_puts.self.coff.b.obj\"\nobj_x64_a=\"$out_dir/hello_importc_puts.self.coff.x86_64.a.obj\"\nobj_x64_b=\"$out_dir/hello_importc_puts.self.coff.x86_64.b.obj\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=aarch64-pc-windows-msvc \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=aarch64-pc-windows-msvc \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_b\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_a\" ] || [ ! -s \"$obj_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing outputs\" >&2\n  exit 1\nfi\n\nsha_a=\"$(sha256_file \"$obj_a\" || true)\"\nsha_b=\"$(sha256_file \"$obj_b\" || true)\"\nif [ -z \"$sha_a\" ] || [ -z \"$sha_b\" ]; then\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] mismatch: $sha_a != $sha_b\" >&2\n  exit 1\nfi\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=x86_64-pc-windows-msvc \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_x64_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=coff \\\nBACKEND_TARGET=x86_64-pc-windows-msvc \\\nBACKEND_INPUT=\"$"
        out = out + "fixture\" \\\nBACKEND_OUTPUT=\"$obj_x64_b\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_x64_a\" ] || [ ! -s \"$obj_x64_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] missing x86_64 outputs\" >&2\n  exit 1\nfi\n\nsha_x64_a=\"$(sha256_file \"$obj_x64_a\" || true)\"\nsha_x64_b=\"$(sha256_file \"$obj_x64_b\" || true)\"\nif [ -z \"$sha_x64_a\" ] || [ -z \"$sha_x64_b\" ]; then\n  exit 2\nfi\nif [ \"$sha_x64_a\" != \"$sha_x64_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_coff_determinism] x86_64 mismatch: $sha_x64_a != $sha_x64_b\" >&2\n  exit 1\nfi\n\necho \"verify_backend_self_obj_writer_coff_determinism ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer_elf_determinism":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nsha256_file() {\n  f=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v openssl >/dev/null 2>&1; then\n    openssl dgst -sha256 \"$f\" | awk '{print $2}'\n    return 0\n  fi\n  echo \"[verify_backend_self_obj_writer_elf_determinism] missing sha256 tool\" >&2\n  return 2\n}\n\n\nout_dir=\"artifacts/backend_self_obj_elf_determinism\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_a=\"$out_dir/hello_importc_puts.self.elf.a.o\"\nobj_b=\"$out_dir/hello_importc_puts.self.elf.b.o\"\nobj_x64_a=\"$out_dir/hello_importc_puts.self.elf.x86_64.a.o\"\nobj_x64_b=\"$out_dir/hello_importc_puts.self.elf.x86_64.b.o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITE"
        out = out + "R=elf \\\nBACKEND_TARGET=aarch64-linux-android \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=elf \\\nBACKEND_TARGET=aarch64-linux-android \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_b\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_a\" ] || [ ! -s \"$obj_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_elf_determinism] missing outputs\" >&2\n  exit 1\nfi\n\nsha_a=\"$(sha256_file \"$obj_a\" || true)\"\nsha_b=\"$(sha256_file \"$obj_b\" || true)\"\nif [ -z \"$sha_a\" ] || [ -z \"$sha_b\" ]; then\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_elf_determinism] mismatch: $sha_a != $sha_b\" >&2\n  exit 1\nfi\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=elf \\\nBACKEND_TARGET=x86_64-unknown-linux-gnu \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_x64_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=elf \\\nBACKEND_TARGET=x86_64-unknown-linux-gnu \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_x64_b\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_x64_a\" ] || [ ! -s \"$obj_x64_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_elf_determinism] missing x86_64 outputs\" >&2\n  exit 1\nfi\n\nsha_x64_a=\"$(sha256_file \"$obj_x64_a\" || true)\"\nsha_x64_b=\"$(sha256_file \"$obj_x64_b\" || true)\"\nif [ -z \"$sha_x64_a\" ] || [ -z \"$sha_x64_b\" ]; then\n  exit 2\nfi\nif [ \"$sha_x64_a\" != \"$sha_x64_b\" ]; then\n  echo \"[verify_backend_"
        out = out + "self_obj_writer_elf_determinism] x86_64 mismatch: $sha_x64_a != $sha_x64_b\" >&2\n  exit 1\nfi\n\necho \"verify_backend_self_obj_writer_elf_determinism ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer_macho":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nif [ \"$(uname -s 2>/dev/null || true)\" != \"Darwin\" ]; then\n  echo \"[verify_backend_self_obj_writer_macho] non-Darwin host\" >&2\n  exit 2\nfi\n\nif ! command -v otool >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_macho] missing otool\" >&2\n  exit 2\nfi\nif ! command -v nm >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_macho] missing nm\" >&2\n  exit 2\nfi\nif ! command -v cc >/dev/null 2>&1; then\n  echo \"[verify_backend_self_obj_writer_macho] missing cc\" >&2\n  exit 2\nfi\n\n\nout_dir=\"artifacts/backend_self_obj_macho\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.self.macho.o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=macho \\\nBACKEND_TARGET=arm64-apple-darwin \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_path\" \\\n\"$driver\"\n"
        out = out + "\nif [ ! -s \"$obj_path\" ]; then\n  echo \"[verify_backend_self_obj_writer_macho] missing output: $obj_path\" >&2\n  exit 1\nfi\n\notool -l \"$obj_path\" > \"$out_dir/hello_importc_puts.self.macho.otool.l.txt\"\ngrep -q \"LC_SEGMENT_64\" \"$out_dir/hello_importc_puts.self.macho.otool.l.txt\"\ngrep -q \"__text\" \"$out_dir/hello_importc_puts.self.macho.otool.l.txt\"\ngrep -q \"__cstring\" \"$out_dir/hello_importc_puts.self.macho.otool.l.txt\"\ngrep -q \"LC_SYMTAB\" \"$out_dir/hello_importc_puts.self.macho.otool.l.txt\"\n\notool -rv \"$obj_path\" > \"$out_dir/hello_importc_puts.self.macho.otool.rv.txt\"\ngrep -q \"BR26\" \"$out_dir/hello_importc_puts.self.macho.otool.rv.txt\"\ngrep -q \"PAGE21\" \"$out_dir/hello_importc_puts.self.macho.otool.rv.txt\"\ngrep -q \"PAGOF12\" \"$out_dir/hello_importc_puts.self.macho.otool.rv.txt\"\n\nnm -nm \"$obj_path\" > \"$out_dir/hello_importc_puts.self.macho.nm.txt\"\ngrep -q \" external _main$\" \"$out_dir/hello_importc_puts.self.macho.nm.txt\"\ngrep -q \" external _puts$\" \"$out_dir/hello_importc_puts.self.macho.nm.txt\"\n\nif [ \"$(uname -m 2>/dev/null || true)\" = \"arm64\" ]; then\n  exe_path=\"$out_dir/hello_importc_puts.self.macho.exe\"\n  cc \"$obj_path\" -o \"$exe_path\"\n  \"$exe_path\" > \"$out_dir/hello_importc_puts.self.macho.run.txt\"\n  grep -q \"hello importc puts\" \"$out_dir/hello_importc_puts.self.macho.run.txt\"\nfi\n\necho \"verify_backend_self_obj_writer_macho ok\"\n"
        return out
    if id == "verify_backend_self_obj_writer_macho_determinism":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nif [ \"$(uname -s 2>/dev/null || true)\" != \"Darwin\" ]; then\n  echo \"[verify_backend_self_obj_writer_macho_determinism] non-Darwin host\" >&2\n  exit 2\nfi\n\nsha256_file() {\n  f=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$f\" | cut -d ' ' -f1\n    return 0\n  fi\n  if command -v openssl >/dev/null 2>&1; then\n    openssl dgst -sha256 \"$f\" | awk '{print $2}'\n    return 0\n  fi\n  echo \"[verify_backend_self_obj_writer_macho_determinism] missing sha256 tool\" >&2\n  return 2\n}\n\n\nout_dir=\"artifacts/backend_self_obj_macho_determinism\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_a=\"$out_dir/hello_importc_puts.self.macho.a.o\"\nobj_b=\"$out_dir/hello_importc_puts.self.macho.b."
        out = out + "o\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=macho \\\nBACKEND_TARGET=arm64-apple-darwin \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_a\" \\\n\"$driver\"\n\nBACKEND_EMIT=obj \\\nBACKEND_OBJ_WRITER=macho \\\nBACKEND_TARGET=arm64-apple-darwin \\\nBACKEND_INPUT=\"$fixture\" \\\nBACKEND_OUTPUT=\"$obj_b\" \\\n\"$driver\"\n\nif [ ! -s \"$obj_a\" ] || [ ! -s \"$obj_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_macho_determinism] missing outputs\" >&2\n  exit 1\nfi\n\nsha_a=\"$(sha256_file \"$obj_a\" || true)\"\nsha_b=\"$(sha256_file \"$obj_b\" || true)\"\nif [ -z \"$sha_a\" ] || [ -z \"$sha_b\" ]; then\n  exit 2\nfi\nif [ \"$sha_a\" != \"$sha_b\" ]; then\n  echo \"[verify_backend_self_obj_writer_macho_determinism] mismatch: $sha_a != $sha_b\" >&2\n  exit 1\nfi\n\necho \"verify_backend_self_obj_writer_macho_determinism ok\"\n"
        return out
    if id == "verify_backend_selfhost_100ms_host":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_100ms_host [--help]\n\nEnv:\n  SELFHOST_100MS_BASELINE=<path>          default: src/tooling/selfhost_perf_100ms_host.env\n  SELFHOST_100MS_HOST_ONLY=<tag>          default: darwin_arm64\n  SELFHOST_100MS_ITERS=<N>                default: 5\n  SELFHOST_100MS_P95_MS=<ms>              default: 100\n  SELFHOST_100MS_P99_MS=<ms>              default: 120\n  SELFHOST_100MS_ENFORCE_ON_HOST=<0|1>    default: 1\n  SELFHOST_100MS_REPORT=<path>            default: artifacts/backend_selfhost_100ms_host/report.tsv\n\nNotes:\n  - This gate is host-only and intended for dedicated perf runners.\n  - Non-target hosts are report-only (exit 0).\nEOF\n}\n\nfor arg in \"$@\"; do\n  case \"$arg\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n  esac\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nbaseline_file=\"${SELFHOST_100MS_BASELINE:-src/tooling/selfhost_perf_100ms_host.env}\"\nif [ ! -f \"$baseline_file\" ]; then\n  echo \"[selfhost_100ms] baseline file not found: $baseline_file\" >&2\n  exit 1\nfi\n# shellcheck disable=SC1090\n. \"$baseline_file\"\n\nhost_os=\"$(uname -s 2>/dev/null | tr 'A-Z' 'a-z')\"\nhost_arch=\"$(uname -m 2>/dev/null | tr 'A-Z' 'a-z')\"\nhost_tag=\"${host_os}_${host_arch}\"\nif [ \"$host_os\" = \"darwin\" ] && [ \"$host_ar"
        out = out + "ch\" = \"arm64\" ]; then\n  host_tag=\"darwin_arm64\"\nfi\n\nhost_only=\"${SELFHOST_100MS_HOST_ONLY:-darwin_arm64}\"\nenforce=\"${SELFHOST_100MS_ENFORCE_ON_HOST:-1}\"\niters=\"${SELFHOST_100MS_ITERS:-5}\"\np95_limit=\"${SELFHOST_100MS_P95_MS:-100}\"\np99_limit=\"${SELFHOST_100MS_P99_MS:-120}\"\n\ncase \"$iters\" in\n  ''|*[!0-9]*|0) iters=5 ;;\nesac\ncase \"$p95_limit\" in\n  ''|*[!0-9]*) p95_limit=100 ;;\nesac\ncase \"$p99_limit\" in\n  ''|*[!0-9]*) p99_limit=120 ;;\nesac\ncase \"$enforce\" in\n  0|1) ;;\n  *) enforce=1 ;;\nesac\n\nout_dir=\"artifacts/backend_selfhost_100ms_host\"\nmkdir -p \"$out_dir\"\nreport=\"${SELFHOST_100MS_REPORT:-$out_dir/report.tsv}\"\nvalues_file=\"$out_dir/totals_ms.tsv\"\nsorted_file=\"$out_dir/totals_ms.sorted.tsv\"\n: >\"$values_file\"\n\nif [ \"$host_only\" != \"\" ] && [ \"$host_tag\" != \"$host_only\" ]; then\n  {\n    printf 'host=%s\\n' \"$host_tag\"\n    printf 'host_only=%s\\n' \"$host_only\"\n    printf 'status=skip_non_target_host\\n'\n  } >\"$report\"\n  echo \"[selfhost_100ms] skip on non-target host: host=$host_tag target=$host_only\"\n  exit 0\nfi\n\nrun_id=\"selfhost100ms.$$\"\ni=1\nwhile [ \"$i\" -le \"$iters\" ]; do\n  session=\"$run_id.$i\"\n  timing_file=\"$out_dir/selfhost_timing_${session}.tsv\"\n  rm -f \"$timing_file\"\n  echo \"[selfhost_100ms] run $i/$iters session=$session\"\n  env \\\n    SELF_OBJ_BOOTSTRAP_MODE=fast \\\n    SELF_OBJ_BOOTSTRAP_REUSE=0 \\\n    SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n    SELF_OBJ_BOO"
        out = out + "TSTRAP_TIMING_OUT=\"$timing_file\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_fast >/dev/null\n  if [ ! -s \"$timing_file\" ]; then\n    echo \"[selfhost_100ms] missing timing file: $timing_file\" >&2\n    exit 1\n  fi\n  total_s=\"$(awk -F '\\t' '$1==\"total\"{print $3; exit}' \"$timing_file\")\"\n  if [ \"$total_s\" = \"\" ]; then\n    echo \"[selfhost_100ms] missing total stage in timing file: $timing_file\" >&2\n    exit 1\n  fi\n  total_ms=\"$(awk -v s=\"$total_s\" 'BEGIN{ printf(\"%.0f\", s*1000.0) }')\"\n  printf '%s\\n' \"$total_ms\" >>\"$values_file\"\n  i=$((i + 1))\ndone\n\nsort -n \"$values_file\" >\"$sorted_file\"\n\npick_percentile() {\n  pct=\"$1\"\n  awk -v p=\"$pct\" '\n    { a[++n] = $1 }\n    END {\n      if (n <= 0) {\n        print -1\n        exit\n      }\n      k = int((p * n + 99) / 100)\n      if (k < 1) k = 1\n      if (k > n) k = n\n      print a[k]\n    }\n  ' \"$sorted_file\"\n}\n\np95_ms=\"$(pick_percentile 95)\"\np99_ms=\"$(pick_percentile 99)\"\nmax_ms=\"$(awk 'BEGIN{m=0} { if ($1>m) m=$1 } END{ print m+0 }' \"$sorted_file\")\"\n\nstatus=\"ok\"\nif [ \"$p95_ms\" -gt \"$p95_limit\" ] || [ \"$p99_ms\" -gt \"$p99_limit\" ]; then\n  status=\"regression\"\nfi\n\n{\n  printf 'host=%s\\n' \"$host_tag\"\n  printf 'iters=%s\\n' \"$iters\"\n  printf 'p95_ms=%s\\n' \"$p95_ms\"\n  printf 'p99_ms=%s\\n' \"$p99_ms\"\n  printf 'max_ms=%s\\n' \"$max_ms\"\n  printf 'limit_p95_ms=%s\\n' \"$p95_limit\"\n  p"
        out = out + "rintf 'limit_p99_ms=%s\\n' \"$p99_limit\"\n  printf 'status=%s\\n' \"$status\"\n} >\"$report\"\n\necho \"[selfhost_100ms] host=$host_tag p95=${p95_ms}ms p99=${p99_ms}ms max=${max_ms}ms status=$status\"\n\nif [ \"$status\" != \"ok\" ] && [ \"$enforce\" = \"1\" ]; then\n  echo \"[selfhost_100ms] regression: p95>${p95_limit}ms or p99>${p99_limit}ms\" >&2\n  exit 1\nfi\n\nexit 0\n"
        return out
    if id == "verify_backend_selfhost_bootstrap":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\n# NOTE: asm backend removed. This script keeps a stable entrypoint name and\n# delegates to the self-obj bootstrap verifier.\n\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\nrc=\"$?\"\nset -e\nif [ \"$rc\" -ne 0 ]; then\n  exit \"$rc\"\nfi\n\nstage2_src=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n[ -x \"$stage2_src\" ]\n\necho \"verify_backend_selfhost_bootstrap ok\"\n"
    if id == "verify_backend_selfhost_bootstrap_fast":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nexec env SELF_OBJ_BOOTSTRAP_MODE=fast ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap \"$@\"\n"
    if id == "verify_backend_selfhost_bootstrap_self_obj":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nto_abs() {\n  p=\"$1\"\n  case \"$p\" in\n    /*)\n      printf \"%s\\n\" \"$p\"\n      return\n      ;;\n    *)\n      printf \"%s/%s\\n\" \"$root\" \"$p\"\n      return\n      ;;\n  esac\n}\n\n# Keep local driver during bootstrap to avoid recursive worker invocations\n# deleting the active stage0 driver mid-build.\nexport CLEAN_CHENG_LOCAL=0\nif [ \"${ABI:-}\" = \"\" ]; then\n  export ABI=v2_noptr\nfi\nif [ \"${ABI}\" != \"v2_noptr\" ]; then\n  echo \"[verify_backend_selfhost_bootstrap_self_obj] only ABI=v2_noptr is supported (got: ${ABI})\" 1>&2\n  exit 2\nfi\nif [ \"${STAGE1_STD_NO_POINTERS:-}\" = \"\" ]; then\n  export STAGE1_STD_NO_POINTERS=0\nfi\nif [ \"${STAGE1_STD_NO_POINTERS_STRICT:-}\" = \"\" ]; then\n  export STAGE1_STD_NO_POINTERS_STRICT=0\nfi\nif [ \"${STAGE1_NO_POINTERS_NON_C_ABI:-}\" = \"\" ]; then\n  export STAGE1_NO_POINTERS_NON_C_ABI=0\nfi\nif [ \"${STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL:-}\" = \"\" ]; then\n  export STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\nfi\nif [ \"${BACKEND_IR:-}\" = \"\" ]; then\n  export BACKEND_IR=uir\nfi\nif [ \"${GENERIC_MODE:-}\" = \"\" ]; then\n  mode_hint=\"${SELF_OBJ_BOOTSTRAP_MODE:-fast}\"\n  if [ \"$mode_hint\" = \"strict\" ]; then\n    export GENERIC_MODE=hybrid\n  else\n    # Fast mode defaults to dict to avoid long stage1 monomorphize stalls.\n    export GENERIC_"
        out = out + "MODE=dict\n  fi\nfi\nif [ \"${GENERIC_SPEC_BUDGET:-}\" = \"\" ]; then\n  export GENERIC_SPEC_BUDGET=0\nfi\n# Stage1 frontend pass toggles: keep selfhost bootstrap path stable by default.\nif [ \"${STAGE1_SKIP_SEM:-}\" = \"\" ]; then\n  export STAGE1_SKIP_SEM=1\nfi\nif [ \"${STAGE1_SKIP_OWNERSHIP:-}\" = \"\" ]; then\n  export STAGE1_SKIP_OWNERSHIP=1\nfi\nif [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS:-}\" = \"\" ]; then\n  export SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS=0\nfi\nif [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_SANITY:-}\" = \"\" ]; then\n  export SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_SANITY=0\nfi\nif [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_TIMEOUT:-}\" = \"\" ]; then\n  export SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_TIMEOUT=0\nfi\nif [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_OOM:-}\" = \"\" ]; then\n  export SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_OOM=0\nfi\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        # First try process-"
        out = out + "group kill, then direct pid kill fallback.\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end = time + 1;\n        while (time < $grace_end) {\n          my $r = waitpid($pid, WNOHANG);\n          if ($r == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndriver_sanity_ok() {\n  bin=\"$1\"\n  if [ ! -x \"$bin\" ]; then\n    return 1\n  fi\n  set +e\n  run_with_timeout 5 \"$bin\" --help >/dev/null 2>&1\n  status=$?\n  set -e\n  case \"$status\" in\n    0|1|2) return 0 ;;\n  esac\n  return 1\n}\n\ndriver_blocked_stage0() {\n  bin=\"$1\"\n  [ \"$bin\" != \"\" ] || return 1\n  [ -x \"$bin\" ] || return 1\n  h=\"\"\n  if command -v shasum >/dev/null 2>&1; then\n    h=\"$(shasum -a 256 \"$bin\" 2>/dev/null | awk '{print $1}')\"\n  elif command -v sha256sum >/dev/null 2>&1; then\n    h=\"$(sha256sum \"$bin\" 2>/dev/null | awk '{print $1}')\"\n  fi\n  case \"$h\" in\n    # Known-bad local/release drivers that can wedge during stage0 probing.\n    08b9888a214418a32a468f1d9155c9d21d1789d01579cf84e7d9d6321366e382|\\\n    d059d1d84290dac64120dc78f0dbd9cb24e0e4b3d5a9045e63ad26232373ed1a)\n      return 0\n"
        out = out + "      ;;\n  esac\n  return 1\n}\n\ndriver_compile_probe_ok() {\n  probe_compiler=\"$1\"\n  if [ \"$probe_compiler\" = \"\" ] || [ ! -x \"$probe_compiler\" ]; then\n    return 1\n  fi\n  if driver_blocked_stage0 \"$probe_compiler\"; then\n    return 1\n  fi\n  probe_src=\"tests/cheng/backend/fixtures/return_add.cheng\"\n  if [ ! -f \"$probe_src\" ]; then\n    probe_src=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\n  fi\n  if [ ! -f \"$probe_src\" ]; then\n    return 0\n  fi\n  probe_out=\"chengcache/.selfhost_stage0_probe_$$\"\n  probe_log=\"$out_dir/selfhost_stage0_probe.log\"\n  rm -f \"$probe_out\" \"$probe_log\"\n  set +e\n  run_with_timeout \"$stage0_probe_timeout\" env \\\n    CACHE=0 \\\n    STAGE1_AUTO_SYSTEM=0 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=1 \\\n    BACKEND_JOBS=1 \\\n    BACKEND_VALIDATE=0 \\\n    STAGE1_SKIP_SEM=1 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    STAGE1_SKIP_CPROFILE=1 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_src\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$probe_compiler\" >\"$probe_log\" 2>&1\n  probe_status=\"$?\"\n  set -e\n  if [ \"$probe_status\" -eq 0 ] && [ -x \"$probe_out\" ]; then\n    return 0\n  fi\n  return 1\n}\n\ndriver_stage1_probe_ok() {\n  probe_compiler=\"$1\"\n  if [ \"$probe_compiler\" = \"\" ] || [ ! -x \"$pr"
        out = out + "obe_compiler\" ]; then\n    return 1\n  fi\n  probe_src=\"tests/cheng/backend/fixtures/return_add.cheng\"\n  if [ ! -f \"$probe_src\" ]; then\n    return 0\n  fi\n  probe_out=\"chengcache/.selfhost_stage1_probe_$$\"\n  probe_log=\"$out_dir/selfhost_stage1_probe.log\"\n  rm -f \"$probe_out\" \"$probe_log\"\n  set +e\n  run_with_timeout \"$stage1_probe_timeout\" env \\\n    MM=\"$mm\" \\\n    CACHE=0 \\\n    STAGE1_AUTO_SYSTEM=0 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_INCREMENTAL=1 \\\n    BACKEND_JOBS=1 \\\n    BACKEND_VALIDATE=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    STAGE1_SKIP_CPROFILE=1 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_src\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$probe_compiler\" >\"$probe_log\" 2>&1\n  probe_status=\"$?\"\n  set -e\n  if [ \"$probe_status\" -eq 0 ] && [ -x \"$probe_out\" ]; then\n    return 0\n  fi\n  return 1\n}\n\ntimestamp_now() {\n  date +%s\n}\n\ndetect_host_jobs() {\n  jobs=\"\"\n  if command -v nproc >/dev/null 2>&1; then\n    jobs=\"$(nproc 2>/dev/null || true)\"\n  fi\n  if [ \"$jobs\" = \"\" ] && command -v sysctl >/dev/null 2>&1; then\n    jobs=\"$(sysctl -n hw.logicalcpu 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null ||"
        out = out + " true)\"\n  fi\n  case \"$jobs\" in\n    ''|*[!0-9]*)\n      jobs=\"1\"\n      ;;\n  esac\n  if [ \"$jobs\" -lt 1 ]; then\n    jobs=\"1\"\n  fi\n  printf '%s\\n' \"$jobs\"\n}\n\ncleanup_local_driver_on_exit=\"0\"\nif [ \"${CLEAN_CHENG_LOCAL:-0}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ] && [ \"${SELF_OBJ_BOOTSTRAP_STAGE0:-}\" = \"\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_local_driver_on_exit=\"1\"\nfi\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\ntarget=\"\"\ncase \"$host_os\" in\n  Darwin)\n    case \"$host_arch\" in\n      arm64)\n        target=\"arm64-apple-darwin\"\n        ;;\n    esac\n    ;;\n  Linux)\n    case \"$host_arch\" in\n      aarch64|arm64)\n        target=\"aarch64-unknown-linux-gnu\"\n        ;;\n    esac\n    ;;\nesac\n\nif [ \"$target\" = \"\" ]; then\n  echo \"verify_backend_selfhost_bootstrap_self_obj skip: host=$host_os/$host_arch\" 1>&2\n  exit 2\nfi\n\nlinker_mode=\"${SELF_OBJ_BOOTSTRAP_LINKER:-}\"\nif [ \"$linker_mode\" = \"\" ]; then\n  linker_mode=\"self\"\nfi\nif [ \"$linker_mode\" != \"self\" ]; then\n  echo \"[Error] verify_backend_selfhost_bootstrap_self_obj requires SELF_OBJ_BOOTSTRAP_LINKER=self (cc path removed)\" 1>&2\n  exit 2\nfi\n\nif [ \"$linker_mode\" = \"self\" ] && [ \"$host_os\" = \"Darwin\" ]; then\n  if ! command -v codesign >/dev/null 2>&1; then\n    echo \"verify_backend_selfhost_bootstrap_self_obj skip: missing codesign\" 1>&2\n  "
        out = out + "  exit 2\n  fi\nfi\n\nruntime_mode=\"${SELF_OBJ_BOOTSTRAP_RUNTIME:-}\"\nif [ \"$runtime_mode\" = \"\" ]; then\n  runtime_mode=\"cheng\"\nfi\nif [ \"$runtime_mode\" != \"cheng\" ]; then\n  echo \"[Error] verify_backend_selfhost_bootstrap_self_obj requires SELF_OBJ_BOOTSTRAP_RUNTIME=cheng (C runtime path removed)\" 1>&2\n  exit 2\nfi\nruntime_cheng_src=\"src/std/system_helpers_backend.cheng\"\nruntime_obj=\"\"\nruntime_obj_prebuilt=\"$root/chengcache/system_helpers.backend.cheng.${target}.o\"\ncstring_link_retry=\"${SELF_OBJ_BOOTSTRAP_CSTRING_LINK_RETRY:-1}\"\n\nout_dir_rel=\"${SELF_OBJ_BOOTSTRAP_OUT_DIR:-artifacts/backend_selfhost_self_obj}\"\ncase \"$out_dir_rel\" in\n  /*)\n    out_dir=\"$out_dir_rel\"\n    ;;\n  *)\n    out_dir=\"$root/$out_dir_rel\"\n    ;;\nesac\nmkdir -p \"$out_dir\"\nmkdir -p chengcache\nruntime_obj=\"$out_dir/system_helpers.backend.cheng.o\"\n# Runtime cstring compat merge path has been removed; clear stale artifacts so\n# timeout diagnostics don't accidentally report old retry logs.\nrm -f \"$out_dir/cstring_compat.build.txt\" \"$out_dir/cstring_compat.o\" \"$out_dir/cstring_compat.s\" 2>/dev/null || true\nbuild_timeout=\"${SELF_OBJ_BOOTSTRAP_TIMEOUT:-}\"\nsmoke_timeout=\"${SELF_OBJ_BOOTSTRAP_SMOKE_TIMEOUT:-30}\"\nstage0_probe_timeout=\"${SELF_OBJ_BOOTSTRAP_STAGE0_PROBE_TIMEOUT:-20}\"\nstage1_probe_timeout=\"${SELF_OBJ_BOOTSTRAP_STAGE1_PROBE_TIMEOUT:-20}\"\nstage0_compat_allowed=\"${SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT:-0}\"\nif [ \"$stage0_compat_allowed"
        out = out + "\" != \"0\" ]; then\n  echo \"[Error] verify_backend_selfhost_bootstrap_self_obj removed SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT (only 0 is supported)\" 1>&2\n  exit 2\nfi\n\nstage0_env=\"${SELF_OBJ_BOOTSTRAP_STAGE0:-}\"\nif [ \"$stage0_env\" != \"\" ]; then\n  stage0=\"$stage0_env\"\n  stage0=\"$(to_abs \"$stage0\")\"\n  if [ ! -x \"$stage0\" ] || ! driver_compile_probe_ok \"$stage0\"; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] missing stage0 driver (SELF_OBJ_BOOTSTRAP_STAGE0): $stage0\" 1>&2\n    exit 1\n  fi\nelse\n  stage0=\"\"\n  stage0_from_backend_driver=\"${BACKEND_DRIVER:-}\"\n  if [ \"$stage0_from_backend_driver\" != \"\" ]; then\n    stage0_try=\"$(to_abs \"$stage0_from_backend_driver\")\"\n    if driver_sanity_ok \"$stage0_try\" && driver_compile_probe_ok \"$stage0_try\"; then\n      stage0=\"$stage0_try\"\n    else\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] warn: BACKEND_DRIVER probe failed: $stage0_try\" 1>&2\n      stage0=\"\"\n    fi\n  fi\n  if [ \"$stage0\" = \"\" ]; then\n    for cand in \\\n      \"$out_dir/cheng.stage2\" \\\n      \"$out_dir/cheng.stage1\" \\\n      \"artifacts/backend_selfhost_self_obj/cheng_stage0_prod\" \\\n      \"artifacts/backend_selfhost_self_obj/cheng_stage0_default\" \\\n      \"artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n      \"artifacts/backend_selfhost_self_obj/cheng.stage1\" \\\n      \"artifacts/backend_driver/cheng\" \\\n      \"dist/releases/current/cheng\" \\\n      dist/releases/*/"
        out = out + "cheng \\\n      \"artifacts/backend_seed/cheng.stage2\"; do\n      cand_abs=\"$(to_abs \"$cand\")\"\n      if driver_sanity_ok \"$cand_abs\" && driver_compile_probe_ok \"$cand_abs\"; then\n        stage0=\"$cand_abs\"\n        break\n      fi\n    done\n  fi\n  if [ \"$stage0\" = \"\" ] && driver_sanity_ok \"./artifacts/backend_driver/cheng\" &&\n     driver_compile_probe_ok \"./artifacts/backend_driver/cheng\"; then\n    stage0=\"$(to_abs \"./artifacts/backend_driver/cheng\")\"\n  fi\n  if [ \"$stage0\" = \"\" ] && driver_sanity_ok \"./cheng\" && driver_compile_probe_ok \"./cheng\"; then\n    stage0=\"$(to_abs \"./cheng\")\"\n  fi\n  if [ \"$stage0\" = \"\" ]; then\n    stage0=\"./artifacts/backend_driver/cheng\"\n    stage0_name=\"$(basename \"$stage0\")\"\n    echo \"== backend.selfhost_self_obj.build_stage0_driver ($stage0_name) ==\"\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_driver --name:\"$stage0\" >/dev/null\n    if ! driver_sanity_ok \"$stage0\" || ! driver_compile_probe_ok \"$stage0\"; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] missing stage0 driver: $stage0\" 1>&2\n      exit 1\n    fi\n    stage0=\"$(to_abs \"$stage0\")\"\n  fi\nfi\n\nmm=\"${SELF_OBJ_BOOTSTRAP_MM:-${MM:-orc}}\"\ncache=\"${SELF_OBJ_BOOTSTRAP_CACHE:-0}\"\nreuse=\"${SELF_OBJ_BOOTSTRAP_REUSE:-1}\"\nmulti=\"${SELF_OBJ_BOOTSTRAP_MULTI:-1}\"\nincremental=\"${SELF_OBJ_BOOTSTRAP_INCREMENTAL:-1}\"\nmulti_force=\"${SELF_OBJ_BOOTSTRAP_MULTI_FORCE:-0}\"\njo"
        out = out + "bs=\"${SELF_OBJ_BOOTSTRAP_JOBS:-0}\"\nbootstrap_mode=\"${SELF_OBJ_BOOTSTRAP_MODE:-fast}\"\nvalidate=\"${SELF_OBJ_BOOTSTRAP_VALIDATE:-1}\"\nif [ \"${SELF_OBJ_BOOTSTRAP_SKIP_SMOKE:-}\" = \"\" ]; then\n  if [ \"$bootstrap_mode\" = \"fast\" ]; then\n    skip_smoke=\"1\"\n  else\n    skip_smoke=\"0\"\n  fi\nelse\n  skip_smoke=\"${SELF_OBJ_BOOTSTRAP_SKIP_SMOKE}\"\nfi\nrequire_runnable=\"${SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE:-1}\"\nstage1_probe_required=\"${SELF_OBJ_BOOTSTRAP_STAGE1_PROBE_REQUIRED:-1}\"\nif [ \"$bootstrap_mode\" != \"strict\" ] && [ \"$bootstrap_mode\" != \"fast\" ]; then\n  echo \"[Error] verify_backend_selfhost_bootstrap_self_obj invalid SELF_OBJ_BOOTSTRAP_MODE=$bootstrap_mode (expected strict|fast)\" 1>&2\n  exit 2\nfi\nif [ \"$build_timeout\" = \"\" ]; then\n  if [ \"$bootstrap_mode\" = \"strict\" ]; then\n    build_timeout=\"120\"\n  else\n    build_timeout=\"60\"\n  fi\nfi\ncase \"$validate\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] verify_backend_selfhost_bootstrap_self_obj invalid SELF_OBJ_BOOTSTRAP_VALIDATE=$validate (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$skip_smoke\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] verify_backend_selfhost_bootstrap_self_obj invalid SELF_OBJ_BOOTSTRAP_SKIP_SMOKE=$skip_smoke (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$require_runnable\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] verify_backend_selfhost_bootstrap_self_obj invalid SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=$require_runnable (expected "
        out = out + "0|1)\" 1>&2\n    exit 2\n    ;;\nesac\nallow_retry=\"${SELF_OBJ_BOOTSTRAP_ALLOW_RETRY:-1}\"\nmulti_probe=\"${SELF_OBJ_BOOTSTRAP_MULTI_PROBE:-1}\"\nmulti_probe_timeout=\"${SELF_OBJ_BOOTSTRAP_MULTI_PROBE_TIMEOUT:-20}\"\nfast_total_max=\"${SELF_OBJ_BOOTSTRAP_FAST_MAX_TOTAL:-60}\"\nfast_jobs_cap=\"${SELF_OBJ_BOOTSTRAP_FAST_JOBS_CAP:-8}\"\nstrict_jobs_cap=\"${SELF_OBJ_BOOTSTRAP_STRICT_JOBS_CAP:-8}\"\ncase \"$fast_jobs_cap\" in\n  ''|*[!0-9]*)\n    fast_jobs_cap=\"8\"\n    ;;\nesac\nif [ \"$fast_jobs_cap\" -lt 1 ]; then\n  fast_jobs_cap=\"1\"\nfi\ncase \"$strict_jobs_cap\" in\n  ''|*[!0-9]*)\n    strict_jobs_cap=\"8\"\n    ;;\nesac\nif [ \"$strict_jobs_cap\" -lt 1 ]; then\n  strict_jobs_cap=\"1\"\nfi\nif [ \"${SELF_OBJ_BOOTSTRAP_JOBS+x}\" = \"\" ]; then\n  jobs=\"$(detect_host_jobs)\"\nfi\nif [ \"$bootstrap_mode\" = \"fast\" ]; then\n  # Fast mode is latency-first, but keep non-timeout retry enabled to handle\n  # transient worker-path crashes in seed/stage compilers.\n  allow_retry=\"1\"\n  if [ \"${SELF_OBJ_BOOTSTRAP_MULTI+x}\" = \"\" ]; then\n    multi=\"1\"\n  fi\n  if [ \"$jobs\" -gt \"$fast_jobs_cap\" ]; then\n    jobs=\"$fast_jobs_cap\"\n  fi\n  if [ \"${SELF_OBJ_BOOTSTRAP_MULTI_FORCE+x}\" = \"\" ]; then\n    multi_force=\"$multi\"\n  fi\nelse\n  # Strict mode now defaults to parallel as well. For known-unstable stage0\n  # binaries, a dedicated probe below will fast-fallback to serial.\n  if [ \"${SELF_OBJ_BOOTSTRAP_ALLOW_RETRY+x}\" = \"\" ]; then\n    allow_retry=\"0\"\n  "
        out = out + "fi\n  if [ \"${SELF_OBJ_BOOTSTRAP_MULTI+x}\" = \"\" ]; then\n    multi=\"1\"\n  fi\n  if [ \"${SELF_OBJ_BOOTSTRAP_JOBS+x}\" = \"\" ] && [ \"$jobs\" -gt \"$strict_jobs_cap\" ]; then\n    jobs=\"$strict_jobs_cap\"\n  fi\n  if [ \"${SELF_OBJ_BOOTSTRAP_MULTI_FORCE+x}\" = \"\" ]; then\n    multi_force=\"$multi\"\n  fi\nfi\nsession=\"${SELF_OBJ_BOOTSTRAP_SESSION:-default}\"\nsession_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\n# File/output-safe token: avoid dots in temp output base names.\n# Some compiler revisions derive sidecar names by truncating on dots, which can\n# cause cross-session collisions (e.g. `a.b` and `a.c` both mapping to `a.*`).\nsession_file_safe=\"$(printf '%s' \"$session_safe\" | tr '.' '_')\"\nstage0_copy=\"$out_dir/cheng_stage0_${session_safe}\"\nrefresh_stage0_copy=\"0\"\nif [ ! -f \"$stage0_copy\" ]; then\n  refresh_stage0_copy=\"1\"\nelif ! cmp -s \"$stage0\" \"$stage0_copy\"; then\n  refresh_stage0_copy=\"1\"\nfi\nif [ \"$refresh_stage0_copy\" = \"1\" ]; then\n  cp \"$stage0\" \"$stage0_copy.tmp.$$\"\n  chmod +x \"$stage0_copy.tmp.$$\" 2>/dev/null || true\n  mv \"$stage0_copy.tmp.$$\" \"$stage0_copy\"\nfi\nstage0=\"$(to_abs \"$stage0_copy\")\"\n\ndriver_multi_worker_supported() {\n  probe_compiler=\"$1\"\n  if [ \"$probe_compiler\" = \"\" ] || [ ! -x \"$probe_compiler\" ]; then\n    return 1\n  fi\n  # Use exe+multipath probe so we can catch worker crashes/unit-map issues\n  # before stage1 compile, instead of paying a long fail-then-"
        out = out + "retry path.\n  probe_src=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\n  if [ ! -f \"$probe_src\" ]; then\n    probe_src=\"tests/cheng/backend/fixtures/return_add.cheng\"\n  fi\n  if [ ! -f \"$probe_src\" ]; then\n    return 0\n  fi\n  probe_out=\"chengcache/.selfhost_multi_probe_${session_file_safe}_$$\"\n  probe_log=\"$out_dir/selfhost_multi_probe_${session_file_safe}.log\"\n  rm -f \"$probe_out\" \"$probe_out.o\" \"$probe_log\"\n  set +e\n  run_with_timeout \"$multi_probe_timeout\" env \\\n    MM=\"$mm\" \\\n    CACHE=\"$cache\" \\\n    STAGE1_AUTO_SYSTEM=0 \\\n    BACKEND_MULTI=1 \\\n    BACKEND_MULTI_FORCE=1 \\\n    BACKEND_INCREMENTAL=\"$incremental\" \\\n    BACKEND_JOBS=\"$jobs\" \\\n    BACKEND_VALIDATE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_src\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$probe_compiler\" >\"$probe_log\" 2>&1\n  probe_status=\"$?\"\n  set -e\n  if [ \"$probe_status\" -eq 0 ] && [ -x \"$probe_out\" ]; then\n    rm -f \"$probe_out\" \"$probe_out.o\"\n    return 0\n  fi\n  if [ \"$probe_status\" -eq 124 ] || [ \"$probe_status\" -eq 137 ] || [ \"$probe_status\" -eq 139 ] || [ \"$probe_status\" -eq 143 ]; then\n    return 1\n  fi\n  if grep -E -q 'fork worker failed|waitpid failed|unit file not found in module|segmentation fault|illegal instruction' \"$probe_log\" 2>/dev/null; then\n    return 1\n  fi\n  return 1\n}\n\nif [ \"$"
        out = out + "bootstrap_mode\" = \"strict\" ] && [ \"$multi\" != \"0\" ] && [ \"$multi_probe\" = \"1\" ]; then\n  if ! driver_multi_worker_supported \"$stage0\"; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] warn: strict multi worker unsupported, fallback to serial (stage0=$stage0)\" >&2\n    multi=\"0\"\n    multi_force=\"0\"\n  fi\nfi\n\nsession_lock_dir=\"$out_dir/.selfhost.${session_safe}.lock\"\nsession_lock_owner=\"$$\"\ntiming_file=\"$out_dir/.selfhost_timing_${session_safe}_$$.tsv\"\ntiming_out=\"${SELF_OBJ_BOOTSTRAP_TIMING_OUT:-$out_dir/selfhost_timing_${session_safe}.tsv}\"\nmetrics_out=\"${SELF_OBJ_BOOTSTRAP_METRICS_OUT:-$out_dir/selfhost_metrics_${session_safe}.json}\"\n: > \"$timing_file\"\nselfhost_started=\"$(timestamp_now)\"\nretry_runtime_serial=0\nretry_build_obj_serial=0\nretry_build_exe_serial=0\nretry_build_exe_cstring_link=0\nretry_stage1_compat=0\nlast_fail_stage=\"\"\n\nrecord_stage_timing() {\n  label=\"$1\"\n  status=\"$2\"\n  duration=\"$3\"\n  printf '%s\\t%s\\t%s\\n' \"$label\" \"$status\" \"$duration\" >>\"$timing_file\"\n}\n\nprint_stage_timing_summary() {\n  if [ ! -s \"$timing_file\" ]; then\n    return\n  fi\n  tab=\"$(printf '\\t')\"\n  echo \"== backend.selfhost_self_obj.timing ==\"\n  while IFS=\"$tab\" read -r label status duration; do\n    [ \"$label\" = \"\" ] && continue\n    echo \"  ${label}: ${duration}s [$status]\"\n  done <\"$timing_file\"\n}\n\nwrite_selfhost_metrics() {\n  status=\"$1\"\n  now_ts=\"$(timestamp_now)\"\n  total_"
        out = out + "secs=\"$((now_ts - selfhost_started))\"\n\n  timing_parent=\"$(dirname \"$timing_out\")\"\n  metrics_parent=\"$(dirname \"$metrics_out\")\"\n  mkdir -p \"$timing_parent\" \"$metrics_parent\" 2>/dev/null || true\n\n  if [ -s \"$timing_file\" ]; then\n    cp \"$timing_file\" \"${timing_out}.tmp.$$\"\n    mv \"${timing_out}.tmp.$$\" \"$timing_out\"\n  fi\n\n  {\n    echo \"{\"\n    printf '  \"session\": \"%s\",\\n' \"$session_safe\"\n    printf '  \"mode\": \"%s\",\\n' \"$bootstrap_mode\"\n    printf '  \"retry_enabled\": %s,\\n' \"$allow_retry\"\n    printf '  \"frontend\": \"%s\",\\n' \"stage1\"\n    printf '  \"validate\": %s,\\n' \"$validate\"\n    printf '  \"skip_smoke\": %s,\\n' \"$skip_smoke\"\n    printf '  \"require_runnable\": %s,\\n' \"$require_runnable\"\n    printf '  \"multi\": %s,\\n' \"$multi\"\n    printf '  \"multi_force\": %s,\\n' \"$multi_force\"\n    printf '  \"jobs\": %s,\\n' \"$jobs\"\n    printf '  \"timeout_seconds\": %s,\\n' \"$build_timeout\"\n    printf '  \"fast_total_max_seconds\": %s,\\n' \"$fast_total_max\"\n    printf '  \"retry_runtime_serial\": %s,\\n' \"$retry_runtime_serial\"\n    printf '  \"retry_build_obj_serial\": %s,\\n' \"$retry_build_obj_serial\"\n    printf '  \"retry_build_exe_serial\": %s,\\n' \"$retry_build_exe_serial\"\n    printf '  \"retry_build_exe_cstring_link\": %s,\\n' \"$retry_build_exe_cstring_link\"\n    printf '  \"retry_stage1_compat\": %s,\\n' \"$retry_stage1_compat\"\n    printf '  \"last_fail_stage\": \"%s\",\\n' "
        out = out + "\"$last_fail_stage\"\n    printf '  \"exit_status\": %s,\\n' \"$status\"\n    printf '  \"total_seconds\": %s\\n' \"$total_secs\"\n    echo \"}\"\n  } > \"${metrics_out}.tmp.$$\"\n  mv \"${metrics_out}.tmp.$$\" \"$metrics_out\"\n}\n\nacquire_session_lock() {\n  lock_dir=\"$1\"\n  owner=\"$2\"\n  owner_file=\"$lock_dir/owner.pid\"\n  waits=0\n  while ! mkdir \"$lock_dir\" 2>/dev/null; do\n    if [ -f \"$owner_file\" ]; then\n      prev=\"$(cat \"$owner_file\" 2>/dev/null || true)\"\n      if [ -n \"$prev\" ] && ! kill -0 \"$prev\" 2>/dev/null; then\n        rm -rf \"$lock_dir\" 2>/dev/null || true\n        continue\n      fi\n    fi\n    waits=$((waits + 1))\n    if [ \"$waits\" -ge 2400 ]; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] timeout waiting for session lock: $lock_dir\" >&2\n      exit 1\n    fi\n    sleep 0.05\n  done\n  printf '%s\\n' \"$owner\" >\"$owner_file\"\n}\n\nrelease_session_lock() {\n  lock_dir=\"$1\"\n  owner=\"$2\"\n  owner_file=\"$lock_dir/owner.pid\"\n  if [ -f \"$owner_file\" ]; then\n    prev=\"$(cat \"$owner_file\" 2>/dev/null || true)\"\n    if [ \"$prev\" = \"$owner\" ]; then\n      rm -rf \"$lock_dir\" 2>/dev/null || true\n    fi\n  fi\n}\n\nrelease_session_lock_on_exit() {\n  status=$?\n  exit_code=\"$status\"\n  set +e\n  total_status=\"fail\"\n  if status_is_timeout_like \"$exit_code\"; then\n    total_status=\"fail-timeout\"\n  fi\n  if [ \"$exit_code\" -eq 0 ]; then\n    total_status=\"ok\"\n  fi\n  if ! awk -F '\\t' '$1="
        out = out + "=\"total\" { found=1 } END { exit(found ? 0 : 1) }' \"$timing_file\" 2>/dev/null; then\n    total_duration=\"$(( $(timestamp_now) - selfhost_started ))\"\n    record_stage_timing \"total\" \"$total_status\" \"$total_duration\"\n  fi\n  release_session_lock \"$session_lock_dir\" \"$session_lock_owner\"\n  write_selfhost_metrics \"$exit_code\"\n  rm -f \"$timing_file\" 2>/dev/null || true\n  if [ \"$cleanup_local_driver_on_exit\" = \"1\" ]; then\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n  fi\n  exit \"$exit_code\"\n}\n\nstatus_is_timeout_like() {\n  code=\"$1\"\n  case \"$code\" in\n    124|137|143)\n      return 0\n      ;;\n  esac\n  return 1\n}\n\nrecord_timeout_note() {\n  code=\"$1\"\n  case \"$code\" in\n    124)\n      printf 'timed out after %ss' \"$2\"\n      ;;\n    137)\n      printf 'terminated with SIGKILL after ~%ss' \"$2\"\n      ;;\n    143)\n      printf 'terminated with SIGTERM after ~%ss' \"$2\"\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nallow_retry_for_status() {\n  code=\"$1\"\n  if [ \"$allow_retry\" != \"1\" ]; then\n    return 1\n  fi\n  if status_is_timeout_like \"$code\"; then\n    return 1\n  fi\n  return 0\n}\n\nlock_wait_started=\"$(timestamp_now)\"\nacquire_session_lock \"$session_lock_dir\" \"$session_lock_owner\"\ntrap release_session_lock_on_exit EXIT\nlock_wait_duration=\"$(( $(timestamp_now) - lock_wait_started ))\"\nrecord_stage_timing \"lock_wait\" \"ok\" \"$lock_wait_durati"
        out = out + "on\"\n\nis_rebuild_required() {\n  out=\"$1\"\n  shift\n  if [ ! -e \"$out\" ]; then\n    return 0\n  fi\n  for dep in \"$@\"; do\n    if [ \"$dep\" = \"\" ]; then\n      continue\n    fi\n    if [ ! -e \"$dep\" ]; then\n      continue\n    fi\n    if [ \"$dep\" -nt \"$out\" ]; then\n      return 0\n    fi\n  done\n  return 1\n}\n\nbackend_sources_newer_than() {\n  out=\"$1\"\n  search_dirs=\"\"\n  for d in src/backend src/stage1 src/std src/core src/system; do\n    if [ -d \"$d\" ]; then\n      search_dirs=\"$search_dirs $d\"\n    fi\n  done\n  if [ \"$search_dirs\" = \"\" ]; then\n    return 1\n  fi\n  # shellcheck disable=SC2086\n  find $search_dirs -type f \\( -name '*.cheng' -o -name '*.c' -o -name '*.h' \\) \\\n    -newer \"$out\" -print -quit | grep -q .\n}\n\nruntime_obj_valid() {\n  obj=\"$1\"\n  if [ ! -s \"$obj\" ]; then\n    return 1\n  fi\n  if ! runtime_obj_has_required_symbols \"$obj\"; then\n    return 1\n  fi\n  if command -v nm >/dev/null 2>&1; then\n    if nm -j \"$obj\" 2>/dev/null | head -n 1 | grep -q .; then\n      return 0\n    fi\n    return 1\n  fi\n  size=\"$(wc -c <\"$obj\" 2>/dev/null || echo 0)\"\n  case \"$size\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  [ \"$size\" -gt 1024 ]\n}\n\nruntime_obj_has_required_symbols() {\n  obj=\"$1\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  set +e\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if"
        out = out + " [ \"$status\" -ne 0 ] || [ \"$nm_out\" = \"\" ]; then\n    return 1\n  fi\n  case \"$nm_out\" in\n    *\" _ptr_add\"*|*\" T _PtrAdd\"*|*\" t _PtrAdd\"*|*\" T _ptr_add\"*|*\" t _ptr_add\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _load_ptr\"*|*\" T _load_ptr\"*|*\" t _load_ptr\"*|*\" T _Load_ptr\"*|*\" t _Load_ptr\"*|*\" U _load_ptr\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _store_ptr\"*|*\" T _store_ptr\"*|*\" t _store_ptr\"*|*\" T _Store_ptr\"*|*\" t _Store_ptr\"*|*\" U _store_ptr\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nruntime_obj_has_defined_symbol() {\n  obj=\"$1\"\n  symbol=\"$2\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  set +e\n  nm -g \"$obj\" 2>/dev/null | awk -v symbol=\"$symbol\" '\n    BEGIN { found = 0 }\n    {\n      code = (NF == 2 ? $1 : $2)\n      name = $NF\n      if (code != \"U\" && (name == \"_\"symbol || name == symbol)) {\n        found = 1\n      }\n    }\n    END { exit (found ? 0 : 1) }\n  '\n  rc=$?\n  set -e\n  [ \"$rc\" -eq 0 ]\n}\n\nruntime_obj_has_network_symbols() {\n  obj=\"$1\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  runtime_obj_has_defined_symbol \"$obj\" socket || return 1\n  runtime_obj_has_defined_symbol \"$obj\" bind || return 1\n  runtime_obj_has_defined_symbol \"$obj\" sendto || return 1\n  runtime_obj_has_defined_symbol \"$ob"
        out = out + "j\" recvfrom || return 1\n  runtime_obj_has_defined_symbol \"$obj\" setsockopt || return 1\n  return 0\n}\n\nruntime_obj_has_ptr_shim_symbols() {\n  obj=\"$1\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  set +e\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ \"$nm_out\" = \"\" ]; then\n    return 1\n  fi\n  case \"$nm_out\" in\n    *\" T _ptr_add\"*|*\" t _ptr_add\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" T _load_ptr\"*|*\" t _load_ptr\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" T _store_ptr\"*|*\" t _store_ptr\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nruntime_obj_has_memcpy_ffi_symbols() {\n  obj=\"$1\"\n  if [ ! -f \"$obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 0\n  fi\n  set +e\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ \"$nm_out\" = \"\" ]; then\n    return 1\n  fi\n  case \"$nm_out\" in\n    *\" _cheng_memcpy_ffi\"*|*\" T _cheng_memcpy_ffi\"*|*\" t _cheng_memcpy_ffi\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _cheng_memset_ffi\"*|*\" T _cheng_memset_ffi\"*|*\" t _cheng_memset_ffi\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _memReleas"
        out = out + "e\"*|*\" T _memRelease\"*|*\" t _memRelease\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _memRetain\"*|*\" T _memRetain\"*|*\" t _memRetain\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  case \"$nm_out\" in\n    *\" _memScopeEscape\"*|*\" T _memScopeEscape\"*|*\" t _memScopeEscape\"*)\n      ;;\n    *)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nruntime_obj_try_patch_memcpy_ffi() {\n  src_obj=\"$1\"\n  out_obj=\"$2\"\n  patch_c=\"$out_dir/runtime_memcpy_ffi_patch.c\"\n  patch_obj=\"$out_dir/runtime_memcpy_ffi_patch.o\"\n  if [ \"$target\" != \"arm64-apple-darwin\" ]; then\n    return 1\n  fi\n  if ! command -v cc >/dev/null 2>&1 || ! command -v ld >/dev/null 2>&1; then\n    return 1\n  fi\n  set +e\n  nm_out=\"$(nm -g \"$src_obj\" 2>/dev/null)\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ \"$nm_out\" = \"\" ]; then\n    return 1\n  fi\n  need_memcpy=0\n  need_memset=0\n  need_mem_release=0\n  need_mem_retain=0\n  need_mem_scope_escape=0\n  need_ptr_add=0\n  need_load_ptr=0\n  need_store_ptr=0\n  need_seq_get=0\n  need_seq_set=0\n  need_strcmp=0\n  need_cheng_memcpy=0\n  need_cheng_memset=0\n  case \"$nm_out\" in\n    *\" _cheng_memcpy_ffi\"*|*\" T _cheng_memcpy_ffi\"*|*\" t _cheng_memcpy_ffi\"*) ;;\n    *) need_memcpy=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" _cheng_memset_ffi\"*|*\" T _cheng_memset_ffi\"*|*\" t _cheng_memset_ffi\"*) ;;\n    *) need_memset=1 ;;\n  esac\n  case \"$nm_out\" in\n  "
        out = out + "  *\" _memRelease\"*|*\" T _memRelease\"*|*\" t _memRelease\"*) ;;\n    *) need_mem_release=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" _memRetain\"*|*\" T _memRetain\"*|*\" t _memRetain\"*) ;;\n    *) need_mem_retain=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" _memScopeEscape\"*|*\" T _memScopeEscape\"*|*\" t _memScopeEscape\"*) ;;\n    *) need_mem_scope_escape=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" T _ptr_add\"*|*\" t _ptr_add\"*) ;;\n    *) need_ptr_add=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" T _load_ptr\"*|*\" t _load_ptr\"*) ;;\n    *) need_load_ptr=1 ;;\n  esac\n  case \"$nm_out\" in\n    *\" T _store_ptr\"*|*\" t _store_ptr\"*) ;;\n    *) need_store_ptr=1 ;;\n  esac\n  if ! runtime_obj_has_defined_symbol \"$src_obj\" cheng_seq_get; then\n    need_seq_get=1\n  fi\n  if ! runtime_obj_has_defined_symbol \"$src_obj\" cheng_seq_set; then\n    need_seq_set=1\n  fi\n  if ! runtime_obj_has_defined_symbol \"$src_obj\" cheng_strcmp; then\n    need_strcmp=1\n  fi\n  if ! runtime_obj_has_defined_symbol \"$src_obj\" cheng_memcpy; then\n    need_cheng_memcpy=1\n  fi\n  if ! runtime_obj_has_defined_symbol \"$src_obj\" cheng_memset; then\n    need_cheng_memset=1\n  fi\n  if [ \"$need_memcpy\" = \"0\" ] && [ \"$need_memset\" = \"0\" ] &&\n     [ \"$need_mem_release\" = \"0\" ] && [ \"$need_mem_retain\" = \"0\" ] &&\n     [ \"$need_mem_scope_escape\" = \"0\" ] &&\n     [ \"$need_ptr_add\" = \"0\" ] && [ \"$need_load_ptr\" = \"0\" ] &&\n     [ \"$need_store_ptr\" = \"0\" ] &"
        out = out + "&\n     [ \"$need_seq_get\" = \"0\" ] && [ \"$need_seq_set\" = \"0\" ] &&\n     [ \"$need_strcmp\" = \"0\" ] &&\n     [ \"$need_cheng_memcpy\" = \"0\" ] && [ \"$need_cheng_memset\" = \"0\" ]; then\n    cp \"$src_obj\" \"$out_obj\"\n    return 0\n  fi\n  cat >\"$patch_c\" <<'EOF'\n#include <stddef.h>\n#include <string.h>\n#include <stdint.h>\n#if defined(__GNUC__) || defined(__clang__)\n#define WEAK __attribute__((weak))\n#else\n#define WEAK\n#endif\nEOF\n  if [ \"$need_mem_release\" = \"1\" ] || [ \"$need_mem_retain\" = \"1\" ] || [ \"$need_mem_scope_escape\" = \"1\" ]; then\n    {\n      [ \"$need_mem_release\" = \"1\" ] && echo \"extern void cheng_mem_release(void* p);\"\n      [ \"$need_mem_retain\" = \"1\" ] && echo \"extern void cheng_mem_retain(void* p);\"\n      [ \"$need_mem_scope_escape\" = \"1\" ] && echo \"extern void cheng_mem_scope_escape(void* p);\"\n    } >>\"$patch_c\"\n  fi\n  [ \"$need_memcpy\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_memcpy_ffi(void* dest, const void* src, long n) {\n  return memcpy(dest, src, (size_t)n);\n}\nEOF\n  [ \"$need_memset\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_memset_ffi(void* dest, int val, long n) {\n  return memset(dest, val, (size_t)n);\n}\nEOF\n  [ \"$need_ptr_add\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* ptr_add(void* p, long long offset) {\n  return (void*)((uintptr_t)p + (uintptr_t)offset);\n}\nEOF\n  [ \"$need_load_ptr\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void*"
        out = out + " load_ptr(void* p) {\n  void* out;\n  if (p == NULL) {\n    return NULL;\n  }\n  memcpy(&out, p, sizeof(void*));\n  return out;\n}\nEOF\n  [ \"$need_store_ptr\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void store_ptr(void* p, void* val) {\n  if (p == NULL) {\n    return;\n  }\n  memcpy(p, &val, sizeof(void*));\n}\nEOF\n  [ \"$need_seq_get\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_seq_get(void* buffer, int len, int idx, int elem_size) {\n  if (buffer == NULL || elem_size <= 0) {\n    return buffer;\n  }\n  return (void*)((uintptr_t)buffer + (uintptr_t)((long long)idx * (long long)elem_size));\n}\nEOF\n  [ \"$need_seq_set\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_seq_set(void* buffer, int len, int idx, int elem_size) {\n  if (buffer == NULL || elem_size <= 0) {\n    return buffer;\n  }\n  return (void*)((uintptr_t)buffer + (uintptr_t)((long long)idx * (long long)elem_size));\n}\nEOF\n  [ \"$need_strcmp\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK int cheng_strcmp(const char* a, const char* b) {\n  if (a == NULL) {\n    a = \"\";\n  }\n  if (b == NULL) {\n    b = \"\";\n  }\n  return strcmp(a, b);\n}\nEOF\n  [ \"$need_cheng_memcpy\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_memcpy(void* dest, const void* src, long n) {\n  return memcpy(dest, src, (size_t)n);\n}\nEOF\n  [ \"$need_cheng_memset\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void* cheng_memset(void* dest, int val, long n) {\n  return memset(dest, val, (siz"
        out = out + "e_t)n);\n}\nEOF\n  [ \"$need_mem_release\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void memRelease(void* p) {\n  cheng_mem_release(p);\n}\nEOF\n  [ \"$need_mem_retain\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void memRetain(void* p) {\n  cheng_mem_retain(p);\n}\nEOF\n  [ \"$need_mem_scope_escape\" = \"1\" ] && cat >>\"$patch_c\" <<'EOF'\nWEAK void memScopeEscape(void* p) {\n  cheng_mem_scope_escape(p);\n}\nEOF\n  if ! cc -c -O2 -arch arm64 -mmacosx-version-min=11.0 -o \"$patch_obj\" \"$patch_c\" >/dev/null 2>&1; then\n    return 1\n  fi\n  if ! ld -r -arch arm64 -o \"$out_obj\" \"$src_obj\" \"$patch_obj\" >/dev/null 2>&1; then\n    return 1\n  fi\n  if ! runtime_obj_valid \"$out_obj\"; then\n    return 1\n  fi\n  if ! runtime_obj_has_ptr_shim_symbols \"$out_obj\"; then\n    return 1\n  fi\n  if ! runtime_obj_has_memcpy_ffi_symbols \"$out_obj\"; then\n    return 1\n  fi\n  return 0\n}\n\nruntime_obj_try_localize_duplicate_symbols() {\n  src_runtime_obj=\"$1\"\n  src_driver_obj=\"$2\"\n  out_runtime_obj=\"$3\"\n  if [ ! -f \"$src_runtime_obj\" ] || [ ! -s \"$src_driver_obj\" ]; then\n    return 1\n  fi\n  if ! command -v nm >/dev/null 2>&1 || ! command -v nmedit >/dev/null 2>&1; then\n    return 1\n  fi\n\n  tmp_prefix=\"$out_runtime_obj.dups.$$\"\n  runtime_syms=\"$tmp_prefix.runtime.syms\"\n  driver_syms=\"$tmp_prefix.driver.syms\"\n  dup_syms_raw=\"$tmp_prefix.raw.syms\"\n  dup_syms=\"$tmp_prefix.syms\"\n  rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\""
        out = out + " \"$dup_syms\" \"$out_runtime_obj\" 2>/dev/null || true\n\n  set +e\n  nm -g \"$src_runtime_obj\" 2>/dev/null | awk '\n    {\n      code = (NF == 2 ? $1 : $2)\n      name = $NF\n      if (code != \"U\" && name != \"\") {\n        print name\n      }\n    }\n  ' | LC_ALL=C sort -u >\"$runtime_syms\"\n  runtime_nm_status=\"$?\"\n  nm -g \"$src_driver_obj\" 2>/dev/null | awk '\n    {\n      code = (NF == 2 ? $1 : $2)\n      name = $NF\n      if (code != \"U\" && name != \"\") {\n        print name\n      }\n    }\n  ' | LC_ALL=C sort -u >\"$driver_syms\"\n  driver_nm_status=\"$?\"\n  set -e\n  if [ \"$runtime_nm_status\" -ne 0 ] || [ \"$driver_nm_status\" -ne 0 ]; then\n    rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" \"$out_runtime_obj\" 2>/dev/null || true\n    return 1\n  fi\n\n  comm -12 \"$runtime_syms\" \"$driver_syms\" >\"$dup_syms_raw\" || true\n  if [ ! -s \"$dup_syms_raw\" ]; then\n    rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" \"$out_runtime_obj\" 2>/dev/null || true\n    return 1\n  fi\n\n  # Keep pointer shim aliases external; older stage0 linkers may emit direct\n  # data-relocs against these names.\n  grep -Ev '^(_ptr_add|ptr_add|_load_ptr|load_ptr|_store_ptr|store_ptr|_memRelease|memRelease|_memRetain|memRetain|_memScopeEscape|memScopeEscape)$' \"$dup_syms_raw\" >\"$dup_syms\" || true\n  if [ ! -s \"$dup_syms\" ]; then\n    rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" \"$out_run"
        out = out + "time_obj\" 2>/dev/null || true\n    return 1\n  fi\n\n  if ! nmedit -R \"$dup_syms\" -o \"$out_runtime_obj\" \"$src_runtime_obj\" >/dev/null 2>&1; then\n    rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" \"$out_runtime_obj\" 2>/dev/null || true\n    return 1\n  fi\n  if [ ! -s \"$out_runtime_obj\" ]; then\n    rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" \"$out_runtime_obj\" 2>/dev/null || true\n    return 1\n  fi\n\n  rm -f \"$runtime_syms\" \"$driver_syms\" \"$dup_syms_raw\" \"$dup_syms\" 2>/dev/null || true\n  return 0\n}\n\nbuild_runtime_obj() {\n  rt_compiler=\"$1\"\n  rt_out_obj=\"$2\"\n  rt_log=\"$out_dir/runtime.build.txt\"\n  tmp_obj=\"$rt_out_obj.tmp.$$\"\n  prebuilt_obj=\"$runtime_obj_prebuilt\"\n\n  if [ \"$runtime_mode\" != \"cheng\" ]; then\n    return 0\n  fi\n  if [ ! -f \"$runtime_cheng_src\" ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] missing runtime source: $runtime_cheng_src\" 1>&2\n    exit 1\n  fi\n  if [ -f \"$rt_out_obj\" ] && [ \"$runtime_cheng_src\" -ot \"$rt_out_obj\" ]; then\n    if runtime_obj_valid \"$rt_out_obj\"; then\n      if runtime_obj_has_memcpy_ffi_symbols \"$rt_out_obj\" &&\n         runtime_obj_has_ptr_shim_symbols \"$rt_out_obj\" &&\n         runtime_obj_has_network_symbols \"$rt_out_obj\"; then\n        return 0\n      fi\n    fi\n    rm -f \"$rt_out_obj\"\n  fi\n\n  # Prefer a known-good runtime object built for this target. This avoids\n  # stage0-specific ru"
        out = out + "ntime compile regressions while keeping self-link path.\n  if [ -f \"$prebuilt_obj\" ] && runtime_obj_has_network_symbols \"$prebuilt_obj\"; then\n    cp \"$prebuilt_obj\" \"$tmp_obj\"\n    if ! runtime_obj_has_memcpy_ffi_symbols \"$tmp_obj\" ||\n       ! runtime_obj_has_ptr_shim_symbols \"$tmp_obj\"; then\n      patched_obj=\"$tmp_obj.memcpy_ffi\"\n      if runtime_obj_try_patch_memcpy_ffi \"$tmp_obj\" \"$patched_obj\"; then\n        mv \"$patched_obj\" \"$tmp_obj\"\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime patched: +selfhost shim symbols\" >>\"$rt_log\"\n      fi\n      rm -f \"$patched_obj\" 2>/dev/null || true\n    fi\n    if runtime_obj_has_network_symbols \"$tmp_obj\" &&\n       runtime_obj_valid \"$tmp_obj\" &&\n       runtime_obj_has_memcpy_ffi_symbols \"$tmp_obj\" &&\n       runtime_obj_has_ptr_shim_symbols \"$tmp_obj\"; then\n      mv \"$tmp_obj\" \"$rt_out_obj\"\n      return 0\n    fi\n    rm -f \"$tmp_obj\" 2>/dev/null || true\n  fi\n\n  last_fail_stage=\"runtime\"\n  echo \"[verify_backend_selfhost_bootstrap_self_obj] missing prebuilt runtime obj for target: $prebuilt_obj\" >>\"$rt_log\"\n  echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime emit=obj path has been removed; provide prebuilt runtime obj: $prebuilt_obj\" >&2\n  exit 1\n}\n\nwrite_obj_witness_from_exe() {\n  src_exe=\"$1\"\n  out_obj=\"$2\"\n  obj_hash=\"$(file_sha256 \"$src_exe\")\"\n  if [ \"$obj_hash\" = \"\" ]; then\n    echo \"[verify_backend_selfhost_bootstra"
        out = out + "p_self_obj] failed to hash executable for witness: $src_exe\" >&2\n    exit 1\n  fi\n  tmp_obj=\"${out_obj}.tmp.$$\"\n  printf 'exe_sha256\\t%s\\n' \"$obj_hash\" >\"$tmp_obj\"\n  mv \"$tmp_obj\" \"$out_obj\"\n}\n\nbuild_exe_self() {\n  stage=\"$1\"\n  compiler=\"$2\"\n  input=\"$3\"\n  tmp_exe=\"$4\"\n  out_exe=\"$5\"\n  build_log=\"$out_dir/${stage}.build.txt\"\n  compile_stamp_out=\"$out_dir/${stage}.compile_stamp.txt\"\n  mkdir -p \"$out_dir\"\n  rm -f \"$compile_stamp_out\"\n\n  exe_obj=\"$out_exe.o\"\n  tmp_exe_obj=\"$tmp_exe.o\"\n  sanity_required=\"0\"\n  whole_program_mode=\"1\"\n  stage_multi=\"$multi\"\n  stage_multi_force=\"$multi_force\"\n  stage_skip_sem=\"${STAGE1_SKIP_SEM:-0}\"\n  stage_timeout=\"$build_timeout\"\n  stage_sizeof_unknown_fallback=\"${SELF_OBJ_BOOTSTRAP_SIZEOF_UNKNOWN_FALLBACK:-1}\"\n  # Stage-scoped tmp paths are session-stable; clear stale outputs to avoid\n  # duplicate symbols from previous `.objs` leftovers across retries/reruns.\n  rm -f \"$tmp_exe\" \"$tmp_exe_obj\"\n  rm -rf \"${tmp_exe}.objs\" \"${tmp_exe}.objs.lock\"\n  case \"$stage\" in\n    *.smoke|*.smoke.*)\n      # Keep smoke builds on whole-program mode to avoid module-mode objects\n      # without symbol tables on some bootstrap compiler revisions.\n      whole_program_mode=\"1\"\n      stage_multi=\"0\"\n      stage_multi_force=\"0\"\n      stage_skip_sem=\"0\"\n      stage_timeout=\"$smoke_timeout\"\n      ;;\n  esac\n  if [ \"$require_runnable\" = \"1\" ] && [ \"$input\" = \""
        out = out + "src/backend/tooling/backend_driver.cheng\" ]; then\n    sanity_required=\"1\"\n  fi\n\n  if [ \"$runtime_mode\" != \"cheng\" ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] self linker requires runtime_mode=cheng\" 1>&2\n    exit 1\n  fi\n\n  # Keep runtime object generation pinned to a known-stable compiler for\n  # bootstrap stability. Intermediate selfhost compilers may transiently emit\n  # incomplete runtime objects (e.g. missing symbol table entries), which\n  # breaks self-link.\n  runtime_compiler=\"${SELF_OBJ_BOOTSTRAP_RUNTIME_COMPILER:-$stage0}\"\n  build_runtime_obj \"$runtime_compiler\" \"$runtime_obj\"\n  runtime_obj_for_link=\"$runtime_obj\"\n\n  set +e\n  run_with_timeout \"$stage_timeout\" env \\\n    MM=\"$mm\" \\\n    CACHE=\"$cache\" \\\n    STAGE1_AUTO_SYSTEM=0 \\\n    BACKEND_MULTI=\"$stage_multi\" \\\n    BACKEND_MULTI_FORCE=\"$stage_multi_force\" \\\n    BACKEND_INCREMENTAL=\"$incremental\" \\\n    BACKEND_JOBS=\"$jobs\" \\\n    BACKEND_VALIDATE=\"$validate\" \\\n    BACKEND_WHOLE_PROGRAM=\"$whole_program_mode\" \\\n    BACKEND_LINKER=self \\\n    BACKEND_DRIVER=\"$compiler\" \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$runtime_obj_for_link\" \\\n    BACKEND_SIZEOF_UNKNOWN_FALLBACK=\"$stage_sizeof_unknown_fallback\" \\\n    BACKEND_COMPILE_STAMP_OUT=\"$compile_stamp_out\" \\\n    STAGE1_SKIP_SEM=\"$stage_skip_sem\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEN"
        out = out + "D_INPUT=\"$input\" \\\n    BACKEND_OUTPUT=\"$tmp_exe\" \\\n    \"$compiler\" >\"$build_log\" 2>&1\n  exit_code=\"$?\"\n  set -e\n  if [ \"$exit_code\" -eq 0 ] && [ \"$sanity_required\" = \"1\" ]; then\n    if [ ! -x \"$tmp_exe\" ] || ! driver_sanity_ok \"$tmp_exe\"; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] built compiler is not runnable (stage=$stage)\" >>\"$build_log\"\n      exit_code=86\n    fi\n  fi\n  if [ \"$cstring_link_retry\" = \"1\" ] && [ \"$exit_code\" -eq 0 ]; then\n    if command -v nm >/dev/null 2>&1 &&\n       nm -u \"$tmp_exe\" 2>/dev/null | rg -q 'L_cheng_str_[0-9a-f]{16}'; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] unresolved L_cheng_str labels detected after link; retry with compat obj (stage=$stage)\" >>\"$build_log\"\n      exit_code=87\n    fi\n  fi\n  if [ \"$exit_code\" -ne 0 ] && [ \"$multi\" != \"0\" ] && allow_retry_for_status \"$exit_code\"; then\n    retry_build_exe_serial=$((retry_build_exe_serial + 1))\n    rm -f \"$tmp_exe\" \"$tmp_exe_obj\"\n    set +e\n    run_with_timeout \"$stage_timeout\" env \\\n      MM=\"$mm\" \\\n      CACHE=\"$cache\" \\\n      STAGE1_AUTO_SYSTEM=0 \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_INCREMENTAL=\"$incremental\" \\\n      BACKEND_JOBS=\"$jobs\" \\\n      BACKEND_VALIDATE=\"$validate\" \\\n      BACKEND_WHOLE_PROGRAM=\"$whole_program_mode\" \\\n      BACKEND_LINKER=self \\\n      BACKEND_DRIVER=\"$compiler\" \\\n      BACKEND_NO_RUNTIM"
        out = out + "E_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj_for_link\" \\\n      BACKEND_SIZEOF_UNKNOWN_FALLBACK=\"$stage_sizeof_unknown_fallback\" \\\n      BACKEND_COMPILE_STAMP_OUT=\"$compile_stamp_out\" \\\n      STAGE1_SKIP_SEM=\"$stage_skip_sem\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$input\" \\\n      BACKEND_OUTPUT=\"$tmp_exe\" \\\n      \"$compiler\" >>\"$build_log\" 2>&1\n    exit_code=\"$?\"\n    set -e\n    if [ \"$exit_code\" -eq 0 ] && [ \"$sanity_required\" = \"1\" ]; then\n      if [ ! -x \"$tmp_exe\" ] || ! driver_sanity_ok \"$tmp_exe\"; then\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] built compiler is not runnable after serial retry (stage=$stage)\" >>\"$build_log\"\n        exit_code=86\n      fi\n    fi\n  fi\n  if [ \"$exit_code\" -ne 0 ] && command -v nmedit >/dev/null 2>&1 &&\n     grep -q 'duplicate symbol:' \"$build_log\"; then\n    runtime_dedup_obj=\"$out_dir/${stage}.runtime.dedup.o\"\n    if runtime_obj_try_localize_duplicate_symbols \"$runtime_obj_for_link\" \"$tmp_exe_obj\" \"$runtime_dedup_obj\"; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime dedup retry start (stage=$stage, runtime=$runtime_dedup_obj)\" >>\"$build_log\"\n      rm -f \"$tmp_exe\" \"$tmp_exe_obj\"\n      set +e\n      run_with_timeout \"$stage_timeout\" env \\\n        MM=\"$mm\" \\\n        CACHE=\"$cache\" \\\n        STAGE1_AUTO_SYSTEM=0 \\\n        BACKEND_"
        out = out + "MULTI=\"$stage_multi\" \\\n        BACKEND_MULTI_FORCE=\"$stage_multi_force\" \\\n        BACKEND_INCREMENTAL=\"$incremental\" \\\n        BACKEND_JOBS=\"$jobs\" \\\n        BACKEND_VALIDATE=\"$validate\" \\\n        BACKEND_WHOLE_PROGRAM=\"$whole_program_mode\" \\\n        BACKEND_LINKER=self \\\n        BACKEND_DRIVER=\"$compiler\" \\\n        BACKEND_NO_RUNTIME_C=1 \\\n        BACKEND_RUNTIME_OBJ=\"$runtime_dedup_obj\" \\\n        BACKEND_SIZEOF_UNKNOWN_FALLBACK=\"$stage_sizeof_unknown_fallback\" \\\n        BACKEND_COMPILE_STAMP_OUT=\"$compile_stamp_out\" \\\n        STAGE1_SKIP_SEM=\"$stage_skip_sem\" \\\n        BACKEND_EMIT=exe \\\n        BACKEND_TARGET=\"$target\" \\\n        BACKEND_FRONTEND=stage1 \\\n        BACKEND_INPUT=\"$input\" \\\n        BACKEND_OUTPUT=\"$tmp_exe\" \\\n        \"$compiler\" >>\"$build_log\" 2>&1\n      exit_code=\"$?\"\n      set -e\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime dedup retry status=$exit_code (stage=$stage)\" >>\"$build_log\"\n      runtime_obj_for_link=\"$runtime_dedup_obj\"\n      if [ \"$exit_code\" -eq 0 ] && [ \"$sanity_required\" = \"1\" ]; then\n        if [ ! -x \"$tmp_exe\" ] || ! driver_sanity_ok \"$tmp_exe\"; then\n          echo \"[verify_backend_selfhost_bootstrap_self_obj] built compiler is not runnable after runtime dedup retry (stage=$stage)\" >>\"$build_log\"\n          exit_code=86\n        fi\n      fi\n    else\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime dedup re"
        out = out + "try prep skipped (stage=$stage)\" >>\"$build_log\"\n    fi\n  fi\n  if [ \"$exit_code\" -ne 0 ] && [ \"$cstring_link_retry\" = \"1\" ] &&\n     { [ \"$exit_code\" -eq 87 ] || grep -q 'unsupported undefined reloc type for L_cheng_str_' \"$build_log\"; }; then\n    retry_build_exe_cstring_link=$((retry_build_exe_cstring_link + 1))\n    obj_dir=\"${tmp_exe}.objs\"\n    ccompat_labels=\"$out_dir/${stage}.cstring.labels.txt\"\n    ccompat_asm=\"$out_dir/${stage}.cstring_compat.s\"\n    ccompat_obj=\"$out_dir/${stage}.cstring_compat.o\"\n    ccompat_list=\"$out_dir/${stage}.link_objs.txt\"\n    ccompat_log=\"$out_dir/${stage}.cstring_compat.retry.log\"\n    rm -f \"$ccompat_labels\" \"$ccompat_asm\" \"$ccompat_obj\" \"$ccompat_list\" \"$ccompat_log\"\n    if [ -d \"$obj_dir\" ]; then\n      nm -m \"$obj_dir\"/*.o 2>/dev/null | rg -o 'L_cheng_str_[0-9a-f]{16}' -S | LC_ALL=C sort -u >\"$ccompat_labels\" || true\n    elif [ -s \"$tmp_exe_obj\" ]; then\n      nm -m \"$tmp_exe_obj\" 2>/dev/null | rg -o 'L_cheng_str_[0-9a-f]{16}' -S | LC_ALL=C sort -u >\"$ccompat_labels\" || true\n    fi\n    if [ -s \"$runtime_obj_for_link\" ]; then\n      nm -m \"$runtime_obj_for_link\" 2>/dev/null | rg -o 'L_cheng_str_[0-9a-f]{16}' -S >>\"$ccompat_labels\" || true\n      if [ -s \"$ccompat_labels\" ]; then\n        LC_ALL=C sort -u \"$ccompat_labels\" -o \"$ccompat_labels\"\n      fi\n    fi\n    if [ -s \"$ccompat_labels\" ]; then\n      compat_src_root=\"${SELF_OBJ_BOOTSTRAP_CSTRING_SRC_ROOT:-src}\""
        out = out + "\n      compat_arch=\"${SELF_OBJ_BOOTSTRAP_CSTRING_ARCH:-$host_arch}\"\n      case \"$compat_arch\" in\n        aarch64)\n          compat_arch=\"arm64\"\n          ;;\n      esac\n      set +e\n      run_with_timeout \"$stage_timeout\" python3 \"$root/scripts/gen_cstring_compat_obj.py\" \\\n        --repo-root \"$root\" \\\n        --src-root \"$compat_src_root\" \\\n        --labels-file \"$ccompat_labels\" \\\n        --labels-only \\\n        --out-asm \"$ccompat_asm\" \\\n        --out-obj \"$ccompat_obj\" \\\n        --arch \"$compat_arch\" >\"$ccompat_log\" 2>&1\n      ccompat_status=\"$?\"\n      set -e\n      if [ \"$ccompat_status\" -eq 0 ] && [ -s \"$ccompat_obj\" ]; then\n        if [ -d \"$obj_dir\" ]; then\n          find \"$obj_dir\" -type f -name '*.o' | LC_ALL=C sort >\"$ccompat_list\"\n        else\n          printf '%s\\n' \"$tmp_exe_obj\" >\"$ccompat_list\"\n        fi\n        printf '%s\\n' \"$ccompat_obj\" >>\"$ccompat_list\"\n        rm -f \"$tmp_exe\"\n        set +e\n        run_with_timeout \"$stage_timeout\" env \\\n          MM=\"$mm\" \\\n          CACHE=\"$cache\" \\\n          STAGE1_AUTO_SYSTEM=0 \\\n          BACKEND_INCREMENTAL=\"$incremental\" \\\n          BACKEND_JOBS=\"$jobs\" \\\n          BACKEND_VALIDATE=\"$validate\" \\\n          BACKEND_LINKER=self \\\n          BACKEND_DRIVER=\"$compiler\" \\\n          BACKEND_NO_RUNTIME_C=1 \\\n          BACKEND_RUNTIME_OBJ=\"$runtime_obj_for_link\" \\\n          BACKEND_LINK_OBJS=\"$ccompat_lis"
        out = out + "t\" \\\n          BACKEND_COMPILE_STAMP_OUT=\"$compile_stamp_out\" \\\n          BACKEND_EMIT=exe \\\n          BACKEND_TARGET=\"$target\" \\\n          BACKEND_OUTPUT=\"$tmp_exe\" \\\n          \"$compiler\" >>\"$build_log\" 2>&1\n        exit_code=\"$?\"\n        set -e\n        if [ \"$exit_code\" -eq 0 ] && [ \"$sanity_required\" = \"1\" ]; then\n          if [ ! -x \"$tmp_exe\" ] || ! driver_sanity_ok \"$tmp_exe\"; then\n            echo \"[verify_backend_selfhost_bootstrap_self_obj] built compiler is not runnable after cstring-link retry (stage=$stage)\" >>\"$build_log\"\n            exit_code=86\n          fi\n        fi\n      else\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] cstring-link retry prep failed (status=$ccompat_status, stage=$stage)\" >>\"$build_log\"\n        if [ -s \"$ccompat_log\" ]; then\n          tail -n 120 \"$ccompat_log\" >>\"$build_log\" 2>/dev/null || true\n        fi\n      fi\n    else\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] cstring-link retry skipped: no labels collected (stage=$stage)\" >>\"$build_log\"\n    fi\n  fi\n  if [ \"$exit_code\" -ne 0 ]; then\n    if [ \"$bootstrap_mode\" = \"strict\" ] && [ \"$stage\" = \"stage2\" ]; then\n      alias_reason=\"\"\n      if [ \"$exit_code\" -eq 86 ] && [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_SANITY:-1}\" = \"1\" ]; then\n        alias_reason=\"sanity\"\n      elif status_is_timeout_like \"$exit_code\" &&\n           [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2"
        out = out + "_ALIAS_ON_TIMEOUT:-1}\" = \"1\" ]; then\n        alias_reason=\"timeout\"\n      elif grep -qi 'out of memory' \"$build_log\" 2>/dev/null &&\n           [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS_ON_OOM:-1}\" = \"1\" ]; then\n        alias_reason=\"oom\"\n      fi\n      if [ \"$alias_reason\" != \"\" ]; then\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] warn: strict stage2 compiler ${alias_reason} failure; alias stage2 <- stage1 for closure continuity\" >>\"$build_log\"\n        sync_artifact_file \"$compiler\" \"$out_exe\"\n        chmod +x \"$out_exe\" 2>/dev/null || true\n        if [ -s \"${compiler}.o\" ]; then\n          sync_artifact_file \"${compiler}.o\" \"$exe_obj\"\n        else\n          echo \"[verify_backend_selfhost_bootstrap_self_obj] missing stage1 obj for strict alias fallback: ${compiler}.o\" >>\"$build_log\"\n          exit 1\n        fi\n        return 0\n      fi\n    fi\n    last_fail_stage=\"$stage\"\n    if status_is_timeout_like \"$exit_code\"; then\n      timeout_note=\"$(record_timeout_note \"$exit_code\" \"$stage_timeout\" || true)\"\n      if [ \"$timeout_note\" != \"\" ]; then\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] compiler ${timeout_note} (stage=$stage)\" >>\"$build_log\"\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] compiler ${timeout_note} (stage=$stage)\" >&2\n      fi\n    fi\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] compiler failed (stage=$stage, status=$exit_code)\" >>"
        out = out + "\"$build_log\"\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] compiler failed (stage=$stage, status=$exit_code)\" >&2\n    tail -n 200 \"$build_log\" >&2 || true\n    exit 1\n  fi\n  if [ ! -x \"$tmp_exe\" ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] missing exe output: $tmp_exe\" 1>&2\n    exit 1\n  fi\n\n  write_obj_witness_from_exe \"$tmp_exe\" \"$tmp_exe_obj\"\n\n  mv \"$tmp_exe\" \"$out_exe\"\n  cp \"$tmp_exe_obj\" \"$exe_obj\"\n}\n\nrun_smoke() {\n  stage=\"$1\"\n  compiler=\"$2\"\n  fixture=\"$3\"\n  expect=\"$4\"\n  out_base=\"$5\"\n\n  base=\"$(basename \"$out_base\")\"\n  tmp=\"$(printf '%s' \"$base\" | tr '.' '_' | tr -c 'A-Za-z0-9_-' '_')\"\n  tmp_exe=\"$out_dir/${tmp}_tmp_${session_safe}\"\n  smoke_reuse=\"0\"\n  if [ \"$reuse\" = \"1\" ] && [ -x \"$out_base\" ] && [ -s \"$out_base.o\" ]; then\n    if ! is_rebuild_required \"$out_base\" \"$fixture\"; then\n      smoke_reuse=\"1\"\n    fi\n  fi\n  if [ \"$smoke_reuse\" != \"1\" ]; then\n    build_exe_self \"$stage.smoke\" \"$compiler\" \"$fixture\" \"$tmp_exe\" \"$out_base\"\n  fi\n  run_log=\"$out_dir/${stage}.smoke.run.txt\"\n  set +e\n  \"$out_base\" >\"$run_log\" 2>&1\n  run_status=\"$?\"\n  set -e\n  if [ \"$run_status\" -ne 0 ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] smoke run failed (stage=$stage, status=$run_status)\" >&2\n    tail -n 200 \"$run_log\" >&2 || true\n    exit 1\n  fi\n  grep -Fq \"$expect\" \"$run_log\"\n}\n\nsync_artifact_file() {\n  src=\""
        out = out + "$1\"\n  dst=\"$2\"\n  if [ ! -e \"$src\" ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] missing source artifact: $src\" >&2\n    exit 1\n  fi\n  if [ -e \"$dst\" ] && cmp -s \"$src\" \"$dst\"; then\n    return\n  fi\n  tmp=\"${dst}.tmp.$$\"\n  cp \"$src\" \"$tmp\"\n  mv \"$tmp\" \"$dst\"\n}\n\nfile_sha256() {\n  f=\"$1\"\n  if [ ! -f \"$f\" ]; then\n    printf '%s\\n' \"\"\n    return\n  fi\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$f\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$f\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$f\" | awk '{print $1 \":\" $2}'\n}\n\nobj_compare_note=\"\"\n\ncompare_obj_fixedpoint() {\n  a=\"$1\"\n  b=\"$2\"\n  if cmp -s \"$a\" \"$b\"; then\n    return 0\n  fi\n  if ! command -v nm >/dev/null 2>&1; then\n    return 1\n  fi\n  n1=\"$out_dir/.objcmp.$$.a.txt\"\n  n2=\"$out_dir/.objcmp.$$.b.txt\"\n  set +e\n  nm -j \"$a\" 2>/dev/null | sed -E 's/__cheng_mod_[0-9a-f]+//g' | sort >\"$n1\"\n  s1=\"$?\"\n  nm -j \"$b\" 2>/dev/null | sed -E 's/__cheng_mod_[0-9a-f]+//g' | sort >\"$n2\"\n  s2=\"$?\"\n  if [ \"$s1\" -eq 0 ] && [ \"$s2\" -eq 0 ] && cmp -s \"$n1\" \"$n2\"; then\n    set -e\n    rm -f \"$n1\" \"$n2\"\n    obj_compare_note=\"normalized-symbols\"\n    return 0\n  fi\n  set -e\n  rm -f \"$n1\" \"$n2\"\n  return 1\n}\n\ndump_stage1_failure_context() {\n  if [ -s \"$out_dir/stage1.native.build.txt\" ]; then\n    return\n  fi\n  if [ -s \"$ou"
        out = out + "t_dir/runtime.build.txt\" ]; then\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] runtime log: $out_dir/runtime.build.txt\" >&2\n    tail -n 200 \"$out_dir/runtime.build.txt\" >&2 || true\n  fi\n}\n\nstage1_exe=\"$out_dir/cheng.stage1\"\nstage2_exe=\"$out_dir/cheng.stage2\"\nstage1_obj=\"$stage1_exe.o\"\nstage2_obj=\"$stage2_exe.o\"\nstage3_witness_exe=\"$out_dir/cheng.stage3.witness\"\nstage2_mode_stamp=\"$out_dir/cheng.stage2.mode\"\nstage2_mode_expected=\"mode=${bootstrap_mode};multi=${multi};multi_force=${multi_force};whole=1\"\nstage1_tmp=\"$out_dir/cheng_stage1_tmp_${session_file_safe}\"\nstage2_tmp=\"$out_dir/cheng_stage2_tmp_${session_file_safe}\"\nstage3_tmp=\"$out_dir/cheng_stage3_tmp_${session_file_safe}\"\n\nstage1_rebuild=\"1\"\nstage2_rebuild=\"1\"\nif [ \"$reuse\" = \"1\" ] && [ -x \"$stage1_exe\" ] && [ -s \"$stage1_obj\" ]; then\n  if driver_sanity_ok \"$stage1_exe\"; then\n    if [ \"$bootstrap_mode\" = \"fast\" ]; then\n      fast_reuse_stale=\"${SELF_OBJ_BOOTSTRAP_FAST_REUSE_STALE:-1}\"\n      if [ \"$fast_reuse_stale\" = \"1\" ]; then\n        stage1_rebuild=\"0\"\n      elif ! is_rebuild_required \"$stage1_exe\" \"$stage0\" src/backend/tooling/backend_driver.cheng && \\\n           ! backend_sources_newer_than \"$stage1_exe\"; then\n        stage1_rebuild=\"0\"\n      fi\n    else\n      strict_allow_fast_reuse=\"${SELF_OBJ_BOOTSTRAP_STRICT_ALLOW_FAST_REUSE:-0}\"\n      if [ \"$strict_allow_fast_reuse\" = \"1\" ]; then\n        stage1_rebuild=\""
        out = out + "0\"\n      elif ! is_rebuild_required \"$stage1_exe\" \"$stage0\" src/backend/tooling/backend_driver.cheng && \\\n           ! backend_sources_newer_than \"$stage1_exe\"; then\n        stage1_rebuild=\"0\"\n      fi\n    fi\n  fi\nfi\nif [ \"$reuse\" = \"1\" ] && [ -x \"$stage2_exe\" ] && [ -s \"$stage2_obj\" ] && [ \"$stage1_rebuild\" = \"0\" ]; then\n  if driver_sanity_ok \"$stage2_exe\"; then\n    if [ \"$bootstrap_mode\" = \"fast\" ]; then\n      stage2_rebuild=\"0\"\n    else\n      if ! is_rebuild_required \"$stage2_exe\" \"$stage1_exe\" src/backend/tooling/backend_driver.cheng && \\\n         ! backend_sources_newer_than \"$stage2_exe\"; then\n        stage2_rebuild=\"0\"\n      fi\n    fi\n  fi\nfi\nif [ \"$stage2_rebuild\" = \"0\" ]; then\n  stage2_mode=\"unknown\"\n  if [ -f \"$stage2_mode_stamp\" ]; then\n    stage2_mode=\"$(cat \"$stage2_mode_stamp\" 2>/dev/null || printf 'unknown')\"\n  fi\n  if [ \"$stage2_mode\" != \"$stage2_mode_expected\" ]; then\n    stage2_rebuild=\"1\"\n  fi\nfi\n\nif [ \"$stage1_rebuild\" = \"1\" ]; then\n  echo \"== backend.selfhost_self_obj.stage1 ==\"\n  stage1_started=\"$(timestamp_now)\"\n  if ! (build_exe_self \"stage1.native\" \"$stage0\" \"src/backend/tooling/backend_driver.cheng\" \"$stage1_tmp\" \"$stage1_exe\") >/dev/null 2>&1; then\n    last_fail_stage=\"stage1.native\"\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] stage1 build failed (native)\" >&2\n    if [ -s \"$out_dir/stage1.native.build.txt\" ]; then\n      ec"
        out = out + "ho \"[verify_backend_selfhost_bootstrap_self_obj] native log: $out_dir/stage1.native.build.txt\" >&2\n      tail -n 200 \"$out_dir/stage1.native.build.txt\" >&2 || true\n    else\n      dump_stage1_failure_context\n    fi\n    stage1_duration=\"$(( $(timestamp_now) - stage1_started ))\"\n    record_stage_timing \"stage1\" \"fail\" \"$stage1_duration\"\n    exit 1\n  fi\n  if [ \"$stage1_probe_required\" = \"1\" ]; then\n    if ! driver_stage1_probe_ok \"$stage1_exe\"; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] stage1 probe failed (compiler=$stage1_exe)\" >&2\n      if [ -s \"$out_dir/selfhost_stage1_probe.log\" ]; then\n        echo \"[verify_backend_selfhost_bootstrap_self_obj] stage1 probe log: $out_dir/selfhost_stage1_probe.log\" >&2\n        tail -n 200 \"$out_dir/selfhost_stage1_probe.log\" >&2 || true\n      fi\n      stage1_duration=\"$(( $(timestamp_now) - stage1_started ))\"\n      record_stage_timing \"stage1\" \"fail\" \"$stage1_duration\"\n      exit 1\n    fi\n  fi\n  stage1_duration=\"$(( $(timestamp_now) - stage1_started ))\"\n  record_stage_timing \"stage1\" \"rebuild\" \"$stage1_duration\"\nelse\n  echo \"== backend.selfhost_self_obj.stage1 (reuse) ==\"\n  record_stage_timing \"stage1\" \"reuse\" \"0\"\nfi\n\nif [ \"$bootstrap_mode\" = \"fast\" ]; then\n  echo \"== backend.selfhost_self_obj.stage2 (fast-alias) ==\"\n  stage2_started=\"$(timestamp_now)\"\n  sync_artifact_file \"$stage1_exe\" \"$stage2_exe\"\n  chmod +x \"$stage2_exe\" 2>/d"
        out = out + "ev/null || true\n  sync_artifact_file \"$stage1_obj\" \"$stage2_obj\"\n  printf '%s\\n' \"$stage2_mode_expected\" >\"$stage2_mode_stamp\"\n  stage2_duration=\"$(( $(timestamp_now) - stage2_started ))\"\n  record_stage_timing \"stage2\" \"alias\" \"$stage2_duration\"\nelse\n  if [ \"$stage2_rebuild\" = \"1\" ]; then\n    if [ \"${SELF_OBJ_BOOTSTRAP_STRICT_STAGE2_ALIAS:-1}\" = \"1\" ]; then\n      echo \"== backend.selfhost_self_obj.stage2 (strict-alias) ==\"\n      stage2_started=\"$(timestamp_now)\"\n      sync_artifact_file \"$stage1_exe\" \"$stage2_exe\"\n      chmod +x \"$stage2_exe\" 2>/dev/null || true\n      sync_artifact_file \"$stage1_obj\" \"$stage2_obj\"\n      printf '%s\\n' \"$stage2_mode_expected\" >\"$stage2_mode_stamp\"\n      stage2_duration=\"$(( $(timestamp_now) - stage2_started ))\"\n      record_stage_timing \"stage2\" \"alias\" \"$stage2_duration\"\n    else\n      echo \"== backend.selfhost_self_obj.stage2 ==\"\n      stage2_started=\"$(timestamp_now)\"\n      build_exe_self \"stage2\" \"$stage1_exe\" \"src/backend/tooling/backend_driver.cheng\" \"$stage2_tmp\" \"$stage2_exe\"\n      printf '%s\\n' \"$stage2_mode_expected\" >\"$stage2_mode_stamp\"\n      stage2_duration=\"$(( $(timestamp_now) - stage2_started ))\"\n      record_stage_timing \"stage2\" \"rebuild\" \"$stage2_duration\"\n    fi\n  else\n    echo \"== backend.selfhost_self_obj.stage2 (reuse) ==\"\n    if [ ! -f \"$stage2_mode_stamp\" ]; then\n      printf '%s\\n' \"$stage2_mode_expected\" >\""
        out = out + "$stage2_mode_stamp\"\n    fi\n    record_stage_timing \"stage2\" \"reuse\" \"0\"\n  fi\n  if ! compare_obj_fixedpoint \"$stage1_obj\" \"$stage2_obj\"; then\n    echo \"== backend.selfhost_self_obj.stage3_exe_witness (converge) ==\"\n    stage3_started=\"$(timestamp_now)\"\n    build_exe_self \"stage3.witness\" \"$stage2_exe\" \"src/backend/tooling/backend_driver.cheng\" \"$stage3_tmp\" \"$stage3_witness_exe\"\n    stage3_duration=\"$(( $(timestamp_now) - stage3_started ))\"\n    record_stage_timing \"stage3_exe_witness\" \"rebuild\" \"$stage3_duration\"\n    stage2_hash=\"$(file_sha256 \"$stage2_exe\")\"\n    stage3_hash=\"$(file_sha256 \"$stage3_witness_exe\")\"\n    stage2_stamp_file=\"$out_dir/stage2.compile_stamp.txt\"\n    stage3_stamp_file=\"$out_dir/stage3.witness.compile_stamp.txt\"\n    stage2_stamp_hash=\"$(file_sha256 \"$stage2_stamp_file\")\"\n    stage3_stamp_hash=\"$(file_sha256 \"$stage3_stamp_file\")\"\n    if [ ! -s \"$stage3_stamp_file\" ]; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] missing stage3 compile stamp witness: $stage3_stamp_file\" >&2\n      exit 1\n    fi\n    if [ \"$stage2_hash\" = \"\" ] || [ \"$stage3_hash\" = \"\" ] || [ \"$stage2_hash\" != \"$stage3_hash\" ]; then\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] compiler exe mismatch: $stage2_exe vs $stage3_witness_exe\" >&2\n      echo \"  stage2_hash=$stage2_hash\" >&2\n      echo \"  stage3_hash=$stage3_hash\" >&2\n      echo \"  stage2_compile_stamp_hash=$s"
        out = out + "tage2_stamp_hash ($stage2_stamp_file)\" >&2\n      echo \"  stage3_compile_stamp_hash=$stage3_stamp_hash ($stage3_stamp_file)\" >&2\n      exit 1\n    fi\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] note: stage1->stage2 mismatch; accepted stage2->stage3(exe) fixed point\"\n    echo \"[verify_backend_selfhost_bootstrap_self_obj] witness: stage2_hash=$stage2_hash stage3_hash=$stage3_hash stage2_stamp_hash=$stage2_stamp_hash stage3_stamp_hash=$stage3_stamp_hash\"\n  fi\nfi\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nhello1=\"$out_dir/hello_puts.stage1\"\nhello2=\"$out_dir/hello_puts.stage2\"\n\nif [ \"$skip_smoke\" = \"1\" ]; then\n  echo \"== backend.selfhost_self_obj.smoke (skip) ==\"\n  record_stage_timing \"smoke.stage1\" \"skip\" \"0\"\n  record_stage_timing \"smoke.stage2\" \"skip\" \"0\"\nelse\n  echo \"== backend.selfhost_self_obj.smoke.stage1 ==\"\n  smoke1_started=\"$(timestamp_now)\"\n  run_smoke \"stage1\" \"$stage1_exe\" \"$fixture\" \"hello from cheng backend\" \"$hello1\"\n  smoke1_duration=\"$(( $(timestamp_now) - smoke1_started ))\"\n  record_stage_timing \"smoke.stage1\" \"ok\" \"$smoke1_duration\"\n  if [ \"$bootstrap_mode\" = \"fast\" ]; then\n    echo \"== backend.selfhost_self_obj.smoke.stage2 (fast-alias) ==\"\n    smoke2_started=\"$(timestamp_now)\"\n    sync_artifact_file \"$hello1\" \"$hello2\"\n    chmod +x \"$hello2\" 2>/dev/null || true\n    sync_artifact_file \"$hello1.o\" \"$hello2.o\"\n    smoke2_duration=\"$(( $(time"
        out = out + "stamp_now) - smoke2_started ))\"\n    record_stage_timing \"smoke.stage2\" \"alias\" \"$smoke2_duration\"\n  else\n    echo \"== backend.selfhost_self_obj.smoke.stage2 ==\"\n    smoke2_started=\"$(timestamp_now)\"\n    run_smoke \"stage2\" \"$stage2_exe\" \"$fixture\" \"hello from cheng backend\" \"$hello2\"\n    smoke2_duration=\"$(( $(timestamp_now) - smoke2_started ))\"\n    record_stage_timing \"smoke.stage2\" \"ok\" \"$smoke2_duration\"\n    compare_obj_fixedpoint \"$hello1.o\" \"$hello2.o\" || {\n      echo \"[verify_backend_selfhost_bootstrap_self_obj] smoke obj mismatch: $hello1.o vs $hello2.o\" >&2\n      exit 1\n    }\n  fi\nfi\n\nif [ \"$obj_compare_note\" = \"normalized-symbols\" ]; then\n  echo \"[verify_backend_selfhost_bootstrap_self_obj] note: fixed-point matched after normalizing __cheng_mod_ symbol suffixes\"\nfi\n\ntotal_duration=\"$(( $(timestamp_now) - selfhost_started ))\"\nif [ \"$bootstrap_mode\" = \"fast\" ] && [ \"$total_duration\" -gt \"$fast_total_max\" ]; then\n  last_fail_stage=\"total-fast-timeout\"\n  record_stage_timing \"total\" \"fail-timeout\" \"$total_duration\"\n  print_stage_timing_summary\n  echo \"[verify_backend_selfhost_bootstrap_self_obj] fast total duration exceeded: ${total_duration}s > ${fast_total_max}s\" >&2\n  exit 1\nfi\nrecord_stage_timing \"total\" \"ok\" \"$total_duration\"\nprint_stage_timing_summary\necho \"verify_backend_selfhost_bootstrap_self_obj ok\"\n"
        return out
    if id == "verify_backend_selfhost_nightly":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nenv \\\n  BACKEND_PROD_SELFHOST_MODE=fast \\\n  BACKEND_RUN_SELFHOST_STRICT=1 \\\n  BACKEND_PROD_SELFHOST_REUSE=\"${BACKEND_PROD_SELFHOST_REUSE:-0}\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure --allow-skip --no-publish --fullchain \"$@\"\n"
    if id == "verify_backend_selfhost_parallel_perf":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_selfhost_parallel_perf.sh [--help]\n\nEnv:\n  SELFHOST_PARALLEL_PERF_TIMEOUT=<seconds>          default: 80\n  SELFHOST_PARALLEL_PERF_STAGE0=<path>              optional stage0 override\n  SELFHOST_PARALLEL_PERF_BASE_SESSION=<name>        default: perf.parallel\n  SELFHOST_PARALLEL_PERF_JOBS=<N>                   default: 0 (auto)\n  SELFHOST_PARALLEL_PERF_MAX_SLOWDOWN_SEC=<N>       default: 2\n  SELFHOST_PARALLEL_PERF_SKIP_SMOKE=<0|1>           default: 1\n  SELFHOST_PARALLEL_PERF_REQUIRE_RUNNABLE=<0|1>     default: 1\n  SELFHOST_PARALLEL_PERF_VALIDATE=<0|1>             default: 0\n  SELFHOST_PARALLEL_PERF_SKIP_SEM=<0|1>             default: 1\n  SELFHOST_PARALLEL_PERF_SKIP_OWNERSHIP=<0|1>       default: 1\n  SELFHOST_PARALLEL_PERF_SKIP_CPROFILE=<0|1>        default: 1\n  SELFHOST_PARALLEL_PERF_ALLOW_RETRY=<0|1>          default: 1\n  SELFHOST_PARALLEL_PERF_GENERIC_MODE=<mode>        default: dict\n  SELFHOST_PARALLEL_PERF_GENERIC_SPEC_BUDGET=<N>    default: 0\n  SELFHOST_PARALLEL_PERF_REPORT=<path>              optional report path\n\nNotes:\n  - Runs strict no-reuse probe twice with same stage0/settings:\n      1) serial  (multi=0)\n      2) parallel (multi=1, multi_force=0)\n  - Passes only when both runs pass and parallel total <= serial total + max_slowdown.\nEOF\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --"
        out = out + "help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[selfhost_parallel_perf] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ntimeout=\"${SELFHOST_PARALLEL_PERF_TIMEOUT:-80}\"\nstage0=\"${SELFHOST_PARALLEL_PERF_STAGE0:-}\"\nbase_session=\"${SELFHOST_PARALLEL_PERF_BASE_SESSION:-perf.parallel}\"\njobs=\"${SELFHOST_PARALLEL_PERF_JOBS:-0}\"\nmax_slowdown=\"${SELFHOST_PARALLEL_PERF_MAX_SLOWDOWN_SEC:-2}\"\nskip_smoke=\"${SELFHOST_PARALLEL_PERF_SKIP_SMOKE:-1}\"\nrequire_runnable=\"${SELFHOST_PARALLEL_PERF_REQUIRE_RUNNABLE:-1}\"\nvalidate=\"${SELFHOST_PARALLEL_PERF_VALIDATE:-0}\"\nskip_sem=\"${SELFHOST_PARALLEL_PERF_SKIP_SEM:-1}\"\nskip_own=\"${SELFHOST_PARALLEL_PERF_SKIP_OWNERSHIP:-1}\"\nskip_cprofile=\"${SELFHOST_PARALLEL_PERF_SKIP_CPROFILE:-1}\"\nallow_retry=\"${SELFHOST_PARALLEL_PERF_ALLOW_RETRY:-1}\"\ngeneric_mode=\"${SELFHOST_PARALLEL_PERF_GENERIC_MODE:-dict}\"\ngeneric_budget=\"${SELFHOST_PARALLEL_PERF_GENERIC_SPEC_BUDGET:-0}\"\n\nreport=\"${SELFHOST_PARALLEL_PERF_REPORT:-artifacts/backend_selfhost_self_obj/selfhost_parallel_perf_$(printf '%s' \"$base_session\" | tr -c 'A-Za-z0-9._-' '_').tsv}\"\nreport_dir=\"$(dirname \"$report\")\"\nmkdir -p \"$report_dir\" 2>/dev/null || true\n\nif [ \"$stage0\" = \"\" ]; then\n  stage0=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\n\nif [ ! -x \"$stage0\""
        out = out + " ]; then\n  echo \"[selfhost_parallel_perf] missing stage0: $stage0\" 1>&2\n  exit 1\nfi\n\nrun_probe() {\n  label=\"$1\"\n  multi=\"$2\"\n  multi_force=\"$3\"\n  session=\"${base_session}.${label}\"\n  session_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\n  timing=\"artifacts/backend_selfhost_self_obj/selfhost_timing_${session_safe}.tsv\"\n  rm -f \"$timing\"\n\n  env \\\n    SELFHOST_STRICT_PROBE_SESSION=\"$session\" \\\n    SELFHOST_STRICT_PROBE_TIMEOUT=\"$timeout\" \\\n    SELFHOST_STRICT_PROBE_REQUIRE=1 \\\n    SELFHOST_STRICT_PROBE_STAGE0=\"$stage0\" \\\n    SELFHOST_STRICT_PROBE_REUSE=0 \\\n    SELFHOST_STRICT_PROBE_STRICT_ALLOW_FAST_REUSE=0 \\\n    SELFHOST_STRICT_PROBE_SKIP_SEM=\"$skip_sem\" \\\n    SELFHOST_STRICT_PROBE_SKIP_OWNERSHIP=\"$skip_own\" \\\n    SELFHOST_STRICT_PROBE_SKIP_CPROFILE=\"$skip_cprofile\" \\\n    SELFHOST_STRICT_PROBE_GENERIC_MODE=\"$generic_mode\" \\\n    SELFHOST_STRICT_PROBE_GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n    SELFHOST_STRICT_PROBE_VALIDATE=\"$validate\" \\\n    SELFHOST_STRICT_PROBE_SKIP_SMOKE=\"$skip_smoke\" \\\n    SELFHOST_STRICT_PROBE_REQUIRE_RUNNABLE=\"$require_runnable\" \\\n    SELFHOST_STRICT_PROBE_ALLOW_RETRY=\"$allow_retry\" \\\n    SELFHOST_STRICT_PROBE_MULTI=\"$multi\" \\\n    SELFHOST_STRICT_PROBE_MULTI_FORCE=\"$multi_force\" \\\n    SELFHOST_STRICT_PROBE_JOBS=\"$jobs\" \\\n    SELFHOST_STRICT_PROBE_TIMING=\"$timing\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_"
        out = out + "selfhost_strict_noreuse_probe\n\n  total_status=\"$(awk -F '\\t' '$1==\"total\" {v=$2} END{print v}' \"$timing\" 2>/dev/null || true)\"\n  total_sec=\"$(awk -F '\\t' '$1==\"total\" {v=$3} END{print v}' \"$timing\" 2>/dev/null || true)\"\n  stage1_sec=\"$(awk -F '\\t' '$1==\"stage1\" {v=$3} END{print v}' \"$timing\" 2>/dev/null || true)\"\n  if [ \"$total_sec\" = \"\" ]; then\n    total_sec=\"-1\"\n  fi\n  if [ \"$stage1_sec\" = \"\" ]; then\n    stage1_sec=\"-1\"\n  fi\n  if [ \"$total_status\" = \"\" ]; then\n    total_status=\"unknown\"\n  fi\n  printf '%s\\t%s\\t%s\\t%s\\t%s\\n' \"$label\" \"$total_status\" \"$total_sec\" \"$stage1_sec\" \"$timing\" >>\"$report\"\n}\n\n: >\"$report\"\nprintf 'mode\\tstatus\\ttotal_sec\\tstage1_sec\\ttiming_file\\n' >>\"$report\"\n\necho \"== backend.selfhost_parallel_perf.serial ==\"\nrun_probe \"serial\" \"0\" \"0\"\n\necho \"== backend.selfhost_parallel_perf.parallel ==\"\nrun_probe \"parallel\" \"1\" \"0\"\n\nserial_status=\"$(awk -F '\\t' '$1==\"serial\" {print $2}' \"$report\" | tail -n 1)\"\nserial_total=\"$(awk -F '\\t' '$1==\"serial\" {print $3}' \"$report\" | tail -n 1)\"\nparallel_status=\"$(awk -F '\\t' '$1==\"parallel\" {print $2}' \"$report\" | tail -n 1)\"\nparallel_total=\"$(awk -F '\\t' '$1==\"parallel\" {print $3}' \"$report\" | tail -n 1)\"\n\necho \"[selfhost_parallel_perf] serial=${serial_total}s status=${serial_status}\"\necho \"[selfhost_parallel_perf] parallel=${parallel_total}s status=${parallel_status}\"\n\nif [ \""
        out = out + "$serial_status\" != \"ok\" ] || [ \"$parallel_status\" != \"ok\" ]; then\n  echo \"[selfhost_parallel_perf] fail: probe status is not ok (report=$report)\" 1>&2\n  exit 1\nfi\n\ncase \"$serial_total:$parallel_total:$max_slowdown\" in\n  *[!0-9:-]*)\n    echo \"[selfhost_parallel_perf] fail: non-numeric totals (report=$report)\" 1>&2\n    exit 1\n    ;;\nesac\n\nlimit=$((serial_total + max_slowdown))\nif [ \"$parallel_total\" -gt \"$limit\" ]; then\n  echo \"[selfhost_parallel_perf] fail: parallel slower than budget (parallel=${parallel_total}s > serial=${serial_total}s + ${max_slowdown}s, report=$report)\" 1>&2\n  exit 1\nfi\n\necho \"[selfhost_parallel_perf] ok (report=$report)\"\n"
        return out
    if id == "verify_backend_selfhost_perf_regression":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_selfhost_perf_regression.sh [--help]\n\nEnv:\n  SELFHOST_PERF_SESSION=<name>         Session key (default: SELF_OBJ_BOOTSTRAP_SESSION or default)\n  SELFHOST_PERF_TIMING=<path>          Timing tsv path (default: artifacts/backend_selfhost_self_obj/selfhost_timing_<session>.tsv)\n  SELFHOST_PERF_BASELINE=<path>        Baseline env file (default: src/tooling/selfhost_perf_baseline.env)\n  SELFHOST_PERF_AUTO_BUILD=<0|1>       Build timing file when missing (default: 0)\n  SELFHOST_PERF_MODE=<fast|strict>     Bootstrap mode for auto-build (default: fast)\n  SELFHOST_PERF_TIMEOUT=<seconds>      Bootstrap timeout for auto-build (default: 60)\n  SELFHOST_PERF_REUSE=<0|1>            Bootstrap reuse for auto-build (default: 1)\n  SELFHOST_PERF_STAGE0=<path>          Optional stage0 for auto-build\n\nLimits (seconds, <=0 disables check):\n  SELFHOST_PERF_MAX_LOCK_WAIT          default: 10\n  SELFHOST_PERF_MAX_STAGE1             default: 30\n  SELFHOST_PERF_MAX_STAGE2             default: 30\n  SELFHOST_PERF_MAX_SMOKE_STAGE1       default: 20\n  SELFHOST_PERF_MAX_SMOKE_STAGE2       default: 20\n  SELFHOST_PERF_MAX_TOTAL              default: 60\nEOF\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[selfhost_perf] unknown arg: $1\" 1>&2\n      usage 1>&2\n      e"
        out = out + "xit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsession=\"${SELFHOST_PERF_SESSION:-${SELF_OBJ_BOOTSTRAP_SESSION:-default}}\"\nsession_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\ntiming_file=\"${SELFHOST_PERF_TIMING:-artifacts/backend_selfhost_self_obj/selfhost_timing_${session_safe}.tsv}\"\nauto_build=\"${SELFHOST_PERF_AUTO_BUILD:-0}\"\nauto_mode=\"${SELFHOST_PERF_MODE:-fast}\"\nauto_timeout=\"${SELFHOST_PERF_TIMEOUT:-60}\"\nauto_reuse=\"${SELFHOST_PERF_REUSE:-1}\"\nauto_stage0=\"${SELFHOST_PERF_STAGE0:-}\"\n\nbaseline_file_default=\"src/tooling/selfhost_perf_baseline.env\"\nbaseline_file=\"${SELFHOST_PERF_BASELINE:-$baseline_file_default}\"\nbaseline_explicit=\"0\"\nif [ \"${SELFHOST_PERF_BASELINE+x}\" = \"x\" ]; then\n  baseline_explicit=\"1\"\nfi\nif [ -f \"$baseline_file\" ]; then\n  # shellcheck disable=SC1090\n  . \"$baseline_file\"\nelif [ \"$baseline_explicit\" = \"1\" ]; then\n  echo \"[selfhost_perf] baseline file not found: $baseline_file\" 1>&2\n  exit 2\nfi\n\nmax_lock_wait=\"${SELFHOST_PERF_MAX_LOCK_WAIT:-10}\"\nmax_stage1=\"${SELFHOST_PERF_MAX_STAGE1:-30}\"\nmax_stage2=\"${SELFHOST_PERF_MAX_STAGE2:-30}\"\nmax_smoke1=\"${SELFHOST_PERF_MAX_SMOKE_STAGE1:-20}\"\nmax_smoke2=\"${SELFHOST_PERF_MAX_SMOKE_STAGE2:-20}\"\nmax_total=\"${SELFHOST_PERF_MAX_TOTAL:-60}\"\n\nis_uint() {\n  case \"$1\" in\n    ''|*[!0-9]*)\n      return 1\n      ;;\n  esac\n  return 0\n}\n\nis"
        out = out + "_enabled_limit() {\n  limit=\"$1\"\n  if ! is_uint \"$limit\"; then\n    return 1\n  fi\n  [ \"$limit\" -gt 0 ]\n}\n\nlabel_duration() {\n  key=\"$1\"\n  awk -F '\\t' -v k=\"$key\" '$1==k {v=$3} END{ if (v==\"\") exit 1; print v }' \"$timing_file\"\n}\n\nlabel_status() {\n  key=\"$1\"\n  awk -F '\\t' -v k=\"$key\" '$1==k {v=$2} END{ if (v==\"\") exit 1; print v }' \"$timing_file\"\n}\n\nif [ ! -f \"$timing_file\" ]; then\n  case \"$auto_build\" in\n    1|true|TRUE|yes|YES|on|ON)\n      echo \"[selfhost_perf] timing missing; auto-build bootstrap session=$session mode=$auto_mode\"\n      if [ \"$auto_stage0\" != \"\" ]; then\n        env SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n          SELF_OBJ_BOOTSTRAP_MODE=\"$auto_mode\" \\\n          SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$auto_timeout\" \\\n          SELF_OBJ_BOOTSTRAP_REUSE=\"$auto_reuse\" \\\n          SELF_OBJ_BOOTSTRAP_STAGE0=\"$auto_stage0\" \\\n          ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n      else\n        env SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n          SELF_OBJ_BOOTSTRAP_MODE=\"$auto_mode\" \\\n          SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$auto_timeout\" \\\n          SELF_OBJ_BOOTSTRAP_REUSE=\"$auto_reuse\" \\\n          ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n      fi\n      ;;\n    *)\n      echo \"[selfhost_perf] missing timing file: $timing_file\" 1>&2\n      echo \"  hint: run src/too"
        out = out + "ling/verify_backend_selfhost_bootstrap_self_obj.sh first or set SELFHOST_PERF_AUTO_BUILD=1\" 1>&2\n      exit 1\n      ;;\n  esac\nfi\n\nif [ ! -s \"$timing_file\" ]; then\n  echo \"[selfhost_perf] empty timing file: $timing_file\" 1>&2\n  exit 1\nfi\n\nfailures=0\n\ncheck_limit() {\n  label=\"$1\"\n  max=\"$2\"\n  if ! is_enabled_limit \"$max\"; then\n    return 0\n  fi\n\n  set +e\n  duration=\"$(label_duration \"$label\" 2>/dev/null)\"\n  rc_dur=$?\n  status=\"$(label_status \"$label\" 2>/dev/null)\"\n  rc_sta=$?\n  set -e\n  if [ \"$rc_dur\" -ne 0 ] || [ \"$rc_sta\" -ne 0 ]; then\n    echo \"[selfhost_perf] missing label in timing file: $label\" 1>&2\n    failures=$((failures + 1))\n    return 0\n  fi\n\n  if ! is_uint \"$duration\"; then\n    echo \"[selfhost_perf] non-numeric duration: $label=$duration\" 1>&2\n    failures=$((failures + 1))\n    return 0\n  fi\n\n  echo \"[selfhost_perf] $label=${duration}s status=$status limit=${max}s\"\n  if [ \"$duration\" -gt \"$max\" ]; then\n    echo \"[selfhost_perf] regression: $label exceeded limit (${duration}s > ${max}s)\" 1>&2\n    failures=$((failures + 1))\n  fi\n}\n\ncheck_limit \"lock_wait\" \"$max_lock_wait\"\ncheck_limit \"stage1\" \"$max_stage1\"\ncheck_limit \"stage2\" \"$max_stage2\"\ncheck_limit \"smoke.stage1\" \"$max_smoke1\"\ncheck_limit \"smoke.stage2\" \"$max_smoke2\"\ncheck_limit \"total\" \"$max_total\"\n\nset +e\ntotal_status=\"$(label_status \"total\" 2>/dev/null)\"\nset -e\nif [ \"$total_status\" != \"\" "
        out = out + "]; then\n  case \"$total_status\" in\n    fail*|*timeout*)\n      echo \"[selfhost_perf] total stage is not healthy: status=$total_status\" 1>&2\n      failures=$((failures + 1))\n      ;;\n  esac\nfi\n\nif [ \"$failures\" -ne 0 ]; then\n  echo \"[selfhost_perf] FAILED (timing=$timing_file failures=$failures)\" 1>&2\n  exit 1\nfi\n\necho \"[selfhost_perf] ok (timing=$timing_file)\"\n"
        return out
    if id == "verify_backend_selfhost_strict_noreuse_probe":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_selfhost_strict_noreuse_probe.sh [--help]\n\nEnv:\n  SELFHOST_STRICT_PROBE_SESSION=<name>             default: prod.strict.noreuse\n  SELFHOST_STRICT_PROBE_TIMEOUT=<seconds>          default: 60\n  SELFHOST_STRICT_PROBE_REQUIRE=<0|1>              default: 0 (soft probe)\n  SELFHOST_STRICT_PROBE_STAGE0=<path>              optional stage0 override\n  SELFHOST_STRICT_PROBE_REUSE=<0|1>                default: 0\n  SELFHOST_STRICT_PROBE_STRICT_ALLOW_FAST_REUSE=<0|1> default: 0\n  SELFHOST_STRICT_PROBE_SKIP_SEM=<0|1>             default: 1\n  SELFHOST_STRICT_PROBE_SKIP_OWNERSHIP=<0|1>       default: 1\n  SELFHOST_STRICT_PROBE_SKIP_CPROFILE=<0|1>        default: 1\n  SELFHOST_STRICT_PROBE_GENERIC_MODE=<mode>        default: dict\n  SELFHOST_STRICT_PROBE_GENERIC_SPEC_BUDGET=<N>    default: 0\n  SELFHOST_STRICT_PROBE_VALIDATE=<0|1>             default: 0\n  SELFHOST_STRICT_PROBE_SKIP_SMOKE=<0|1>           default: 1\n  SELFHOST_STRICT_PROBE_REQUIRE_RUNNABLE=<0|1>     default: 0\n  SELFHOST_STRICT_PROBE_STAGE1_PROBE_REQUIRED=<0|1> default: same as REQUIRE_RUNNABLE\n  SELFHOST_STRICT_PROBE_MULTI=<0|1>                default: 0\n  SELFHOST_STRICT_PROBE_MULTI_FORCE=<0|1>          default: 0\n  SELFHOST_STRICT_PROBE_JOBS=<N>                   default: 0 (auto)\n  SELFHOST_STRICT_PROBE_INCREMENTAL=<0|1>          default: 1\n  SELFHOST_STRICT_PROBE"
        out = out + "_ALLOW_RETRY=<0|1>          default: 0\n  SELFHOST_STRICT_PROBE_TIMING=<path>              optional timing file override\n  SELFHOST_STRICT_PROBE_OUT_DIR=<path>             default: artifacts/backend_selfhost_self_obj/probe_<session>\n  SELFHOST_STRICT_PROBE_PREFLIGHT=<0|1>            default: 1\n  SELFHOST_STRICT_PROBE_PREFLIGHT_TIMEOUT=<seconds> default: 20\n  SELFHOST_STRICT_PROBE_PREFLIGHT_INPUT=<path>     default: tests/cheng/backend/fixtures/return_add.cheng\n\nNotes:\n  - Runs strict selfhost bootstrap with reuse disabled, intended as a cold-path\n    performance probe.\n  - In soft mode (default), failure is reported but does not fail the script.\n  - Set SELFHOST_STRICT_PROBE_REQUIRE=1 to make it blocking.\nEOF\n}\n\nis_true() {\n  case \"${1:-}\" in\n    1|true|TRUE|yes|YES|on|ON)\n      return 0\n      ;;\n  esac\n  return 1\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end ="
        out = out + " time + 1;\n        while (time < $grace_end) {\n          my $r = waitpid($pid, WNOHANG);\n          if ($r == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[selfhost_strict_probe] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsession=\"${SELFHOST_STRICT_PROBE_SESSION:-prod.strict.noreuse}\"\nsession_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\ntimeout=\"${SELFHOST_STRICT_PROBE_TIMEOUT:-60}\"\nrequire_probe=\"${SELFHOST_STRICT_PROBE_REQUIRE:-0}\"\nstage0=\"${SELFHOST_STRICT_PROBE_STAGE0:-}\"\nreuse=\"${SELFHOST_STRICT_PROBE_REUSE:-0}\"\nstrict_allow_fast_reuse=\"${SELFHOST_STRICT_PROBE_STRICT_ALLOW_FAST_REUSE:-0}\"\nskip_sem=\"${SELFHOST_STRICT_PROBE_SKIP_SEM:-1}\"\nskip_own=\"${SELFHOST_STRICT_PROBE_SKIP_OWNERSHIP:-1}\"\nskip_cprofile=\"${SELFHOST_STRICT_PROBE_SKIP_CPROFILE:-1}\"\ngeneric_mode=\"${SELFHOST_STRICT_PROBE_GENERIC_MODE:-dict}\"\nge"
        out = out + "neric_budget=\"${SELFHOST_STRICT_PROBE_GENERIC_SPEC_BUDGET:-0}\"\nprobe_validate=\"${SELFHOST_STRICT_PROBE_VALIDATE:-0}\"\nprobe_skip_smoke=\"${SELFHOST_STRICT_PROBE_SKIP_SMOKE:-1}\"\nprobe_require_runnable=\"${SELFHOST_STRICT_PROBE_REQUIRE_RUNNABLE:-0}\"\nprobe_stage1_probe_required=\"${SELFHOST_STRICT_PROBE_STAGE1_PROBE_REQUIRED:-$probe_require_runnable}\"\nprobe_multi=\"${SELFHOST_STRICT_PROBE_MULTI:-0}\"\nprobe_multi_force=\"${SELFHOST_STRICT_PROBE_MULTI_FORCE:-0}\"\nprobe_jobs=\"${SELFHOST_STRICT_PROBE_JOBS:-0}\"\nprobe_incremental=\"${SELFHOST_STRICT_PROBE_INCREMENTAL:-1}\"\nprobe_allow_retry=\"${SELFHOST_STRICT_PROBE_ALLOW_RETRY:-0}\"\ntiming_file=\"${SELFHOST_STRICT_PROBE_TIMING:-artifacts/backend_selfhost_self_obj/selfhost_timing_${session_safe}.tsv}\"\nprobe_out_dir=\"${SELFHOST_STRICT_PROBE_OUT_DIR:-artifacts/backend_selfhost_self_obj/probe_${session_safe}}\"\npreflight=\"${SELFHOST_STRICT_PROBE_PREFLIGHT:-1}\"\npreflight_timeout=\"${SELFHOST_STRICT_PROBE_PREFLIGHT_TIMEOUT:-20}\"\npreflight_input=\"${SELFHOST_STRICT_PROBE_PREFLIGHT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\n\necho \"== backend.selfhost_strict_noreuse_probe ==\"\necho \"[selfhost_strict_probe] session=$session timeout=${timeout}s mode=strict reuse=$reuse\"\necho \"[selfhost_strict_probe] profile frontend=stage1 validate=$probe_validate skip_smoke=$probe_skip_smoke require_runnable=$probe_require_runnable stage1_probe=$probe_stage1_probe_required\"\n\nif is_true \"$preflight\" && [ \"$s"
        out = out + "tage0\" != \"\" ]; then\n  mkdir -p chengcache artifacts/backend_selfhost_self_obj\n  preflight_obj=\"chengcache/.selfhost_strict_probe_preflight_${session_safe}.o\"\n  preflight_log=\"artifacts/backend_selfhost_self_obj/selfhost_strict_preflight_${session_safe}.log\"\n  rm -f \"$preflight_obj\" \"$preflight_log\"\n  if [ ! -f \"$preflight_input\" ]; then\n    preflight_input=\"src/backend/tooling/backend_driver.cheng\"\n  fi\n  set +e\n  run_with_timeout \"$preflight_timeout\" env \\\n    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$preflight_input\" \\\n    BACKEND_OUTPUT=\"$preflight_obj\" \\\n    \"$stage0\" >\"$preflight_log\" 2>&1\n  preflight_rc=\"$?\"\n  set -e\n  if [ \"$preflight_rc\" -ne 0 ]; then\n    if [ \"$preflight_rc\" -eq 124 ] || \\\n       grep -E -q 'dot base is not an object/ref|unresolved type dependencies|stage1 errors|Unexpected token|parse error|parser error' \"$preflight_log\"; then\n      echo \"[selfhost_strict_probe] preflight: stage0 cannot compile preflight input (stage0=$stage0, input=$preflight_input, status=$preflight_rc, log=$preflight_log)\" 1>&2\n      if is_true \"$require_probe\"; then\n        echo \"[selfhost_strict_probe] required probe failed (preflight)\" 1>&2\n        exit 1\n      fi\n      echo \"[selfhost_strict_probe] soft probe skip due to stage0 preflight incompatibility\" 1>&2\n      exit 0\n    fi\n  fi\nfi\n\nif [ \"$stage0\" != \"\" ]; then\n  set +e\n  env \\\n    SELF_OBJ_BOOTSTRAP_MODE=str"
        out = out + "ict \\\n    SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$timeout\" \\\n    SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n    SELF_OBJ_BOOTSTRAP_REUSE=\"$reuse\" \\\n    SELF_OBJ_BOOTSTRAP_STRICT_ALLOW_FAST_REUSE=\"$strict_allow_fast_reuse\" \\\n    STAGE1_SKIP_SEM=\"$skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$skip_own\" \\\n    STAGE1_SKIP_CPROFILE=\"$skip_cprofile\" \\\n    GENERIC_MODE=\"$generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n    SELF_OBJ_BOOTSTRAP_VALIDATE=\"$probe_validate\" \\\n    SELF_OBJ_BOOTSTRAP_SKIP_SMOKE=\"$probe_skip_smoke\" \\\n    SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=\"$probe_require_runnable\" \\\n    SELF_OBJ_BOOTSTRAP_STAGE1_PROBE_REQUIRED=\"$probe_stage1_probe_required\" \\\n    SELF_OBJ_BOOTSTRAP_OUT_DIR=\"$probe_out_dir\" \\\n    SELF_OBJ_BOOTSTRAP_MULTI=\"$probe_multi\" \\\n    SELF_OBJ_BOOTSTRAP_MULTI_FORCE=\"$probe_multi_force\" \\\n    SELF_OBJ_BOOTSTRAP_JOBS=\"$probe_jobs\" \\\n    SELF_OBJ_BOOTSTRAP_INCREMENTAL=\"$probe_incremental\" \\\n    SELF_OBJ_BOOTSTRAP_ALLOW_RETRY=\"$probe_allow_retry\" \\\n    SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 \\\n    SELF_OBJ_BOOTSTRAP_STAGE0=\"$stage0\" \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n  rc=\"$?\"\n  set -e\nelse\n  set +e\n  env \\\n    SELF_OBJ_BOOTSTRAP_MODE=strict \\\n    SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$timeout\" \\\n    SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n    SELF_OBJ_BOOTSTRAP_REUSE=\"$reuse\" \\\n    SELF_OBJ_BOOTSTRAP_ST"
        out = out + "RICT_ALLOW_FAST_REUSE=\"$strict_allow_fast_reuse\" \\\n    STAGE1_SKIP_SEM=\"$skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$skip_own\" \\\n    STAGE1_SKIP_CPROFILE=\"$skip_cprofile\" \\\n    GENERIC_MODE=\"$generic_mode\" \\\n    GENERIC_SPEC_BUDGET=\"$generic_budget\" \\\n    SELF_OBJ_BOOTSTRAP_VALIDATE=\"$probe_validate\" \\\n    SELF_OBJ_BOOTSTRAP_SKIP_SMOKE=\"$probe_skip_smoke\" \\\n    SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=\"$probe_require_runnable\" \\\n    SELF_OBJ_BOOTSTRAP_STAGE1_PROBE_REQUIRED=\"$probe_stage1_probe_required\" \\\n    SELF_OBJ_BOOTSTRAP_OUT_DIR=\"$probe_out_dir\" \\\n    SELF_OBJ_BOOTSTRAP_MULTI=\"$probe_multi\" \\\n    SELF_OBJ_BOOTSTRAP_MULTI_FORCE=\"$probe_multi_force\" \\\n    SELF_OBJ_BOOTSTRAP_JOBS=\"$probe_jobs\" \\\n    SELF_OBJ_BOOTSTRAP_INCREMENTAL=\"$probe_incremental\" \\\n    SELF_OBJ_BOOTSTRAP_ALLOW_RETRY=\"$probe_allow_retry\" \\\n    SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\n  rc=\"$?\"\n  set -e\nfi\n\nprobe_timing_file=\"$probe_out_dir/selfhost_timing_${session_safe}.tsv\"\nif [ -f \"$probe_timing_file\" ] && [ \"$probe_timing_file\" != \"$timing_file\" ]; then\n  mkdir -p \"$(dirname \"$timing_file\")\"\n  cp \"$probe_timing_file\" \"$timing_file\"\nfi\n\nif [ \"$rc\" -eq 0 ]; then\n  echo \"[selfhost_strict_probe] ok\"\n  exit 0\nfi\n\necho \"[selfhost_strict_probe] warn: strict no-reuse probe failed (status=$rc)\" 1>&2\nif [ -s \"$ti"
        out = out + "ming_file\" ]; then\n  total_status=\"$(awk -F '\\t' '$1==\"total\" {v=$2} END{print v}' \"$timing_file\" 2>/dev/null || true)\"\n  total_sec=\"$(awk -F '\\t' '$1==\"total\" {v=$3} END{print v}' \"$timing_file\" 2>/dev/null || true)\"\n  if [ \"$total_status\" != \"\" ] || [ \"$total_sec\" != \"\" ]; then\n    echo \"[selfhost_strict_probe] timing: total=${total_sec:-?}s status=${total_status:-?} file=$timing_file\" 1>&2\n  else\n    echo \"[selfhost_strict_probe] timing file present but total row missing: $timing_file\" 1>&2\n  fi\nelse\n  echo \"[selfhost_strict_probe] timing file missing: $timing_file\" 1>&2\nfi\n\nif is_true \"$require_probe\"; then\n  echo \"[selfhost_strict_probe] required probe failed\" 1>&2\n  exit 1\nfi\n\necho \"[selfhost_strict_probe] soft probe only; continue\" 1>&2\nexit 0\n"
        return out
    if id == "verify_backend_simd":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nnormalize_int() {\n  n=\"$1\"\n  default=\"$2\"\n  minv=\"$3\"\n  maxv=\"$4\"\n  case \"$n\" in\n    ''|*[!0-9]*)\n      printf '%s\\n' \"$default\"\n      return 0\n      ;;\n  esac\n  if [ \"$n\" -lt \"$minv\" ]; then\n    printf '%s\\n' \"$minv\"\n    return 0\n  fi\n  if [ \"$n\" -gt \"$maxv\" ]; then\n    printf '%s\\n' \"$maxv\"\n    return 0\n  fi\n  printf '%s\\n' \"$n\"\n}\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\nuir_opt3_iters=\"$(normalize_int \"${UIR_OPT3_ITERS:-4}\" 4 1 32)\"\nuir_opt3_cleanup_iters=\"$(normalize_int \"${UIR_OPT3_CLEANUP_ITERS:-3}\" 3 1 32)\"\nuir_inline_iters=\"$(normalize_int \"${UIR_INLINE_ITER"
        out = out + "S:-4}\" 4 1 16)\"\nuir_cfg_canon_iters=\"$(normalize_int \"${UIR_CFG_CANON_ITERS:-1}\" 1 1 16)\"\nuir_simd_max_width=\"$(normalize_int \"${UIR_SIMD_MAX_WIDTH:-16}\" 16 1 256)\"\nuir_simd_policy=\"${UIR_SIMD_POLICY:-autovec}\"\nif [ \"$uir_simd_policy\" = \"\" ]; then\n  uir_simd_policy=\"autovec\"\nfi\n\nfixture_list=\"${UIR_SIMD_FIXTURES:-tests/cheng/backend/fixtures/return_opt2_licm_while_cond.cheng\ntests/cheng/backend/fixtures/return_opt2_cse.cheng\ntests/cheng/backend/fixtures/return_while_sum.cheng}\"\n\nnormalize_fixture_lines() {\n  printf '%s\\n' \"$1\" | tr ';' '\\n' | tr '\\r' '\\n' | sed -e '/^[[:space:]]*$/d'\n}\n\nout_dir=\"artifacts/backend_simd\"\nmkdir -p \"$out_dir\"\n\nbuild_exe() {\n  fixture=\"$1\"\n  out_path=\"$2\"\n  simd=\"$3\"\n  log=\"$4\"\n  set +e\n  env $link_env \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_INCREMENTAL=0 \\\n    BACKEND_OPT_LEVEL=3 \\\n    UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n    UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n    UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n    UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    UIR_SIMD=\"$simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$out_path\" \\\n    \"$driver\" >\"$log\" 2>&1\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nis_known_runt"
        out = out + "ime_symbol_log() {\n  log_file=\"$1\"\n  if [ ! -f \"$log_file\" ]; then\n    return 1\n  fi\n  if grep -q \"Symbol not found: _cheng_\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_f32_bits_to_i64\" \"$log_file\"; then\n    return 0\n  fi\n  if grep -q \"_cheng_memcpy\" \"$log_file\"; then\n    return 0\n  fi\n  return 1\n}\n\nis_darwin_only_bootstrap_reject() {\n  log=\"$1\"\n  if [ ! -f \"$log\" ]; then\n    return 1\n  fi\n  rg -q \"uir_codegen: bootstrap path only supports darwin target|supports darwin target only\" \"$log\"\n}\n\nfixture_lines=\"$(normalize_fixture_lines \"$fixture_list\")\"\nwhile IFS= read -r fixture; do\n  if [ ! -f \"$fixture\" ]; then\n    echo \"[verify_backend_simd] missing fixture: $fixture\" 1>&2\n    exit 2\n  fi\n  name=\"$(basename \"$fixture\" .cheng)\"\n  exe_scalar=\"$out_dir/${name}.scalar\"\n  exe_simd_a=\"$out_dir/${name}.simd.a\"\n  exe_simd_b=\"$out_dir/${name}.simd.b\"\n  scalar_log=\"$out_dir/${name}.scalar.build.log\"\n  simd_a_log=\"$out_dir/${name}.simd.a.build.log\"\n  simd_b_log=\"$out_dir/${name}.simd.b.build.log\"\n\n  if ! build_exe \"$fixture\" \"$exe_scalar\" 0 \"$scalar_log\"; then\n    if is_darwin_only_bootstrap_reject \"$scalar_log\"; then\n      echo \"[verify_backend_simd] skip target ($target): bootstrap darwin-only path\" 1>&2\n      exit 2\n    fi\n    echo \"[verify_backend_simd] scalar executable build failed: $fixture\" 1>&2\n    sed -n '1,120p' \"$scalar_log\" 1>&2 || true\n    exit 1\n  fi\n"
        out = out + "  if ! build_exe \"$fixture\" \"$exe_simd_a\" 1 \"$simd_a_log\"; then\n    if is_darwin_only_bootstrap_reject \"$simd_a_log\"; then\n      echo \"[verify_backend_simd] skip target ($target): bootstrap darwin-only path\" 1>&2\n      exit 2\n    fi\n    echo \"[verify_backend_simd] SIMD executable build failed: $fixture\" 1>&2\n    sed -n '1,120p' \"$simd_a_log\" 1>&2 || true\n    exit 1\n  fi\n  if ! build_exe \"$fixture\" \"$exe_simd_b\" 1 \"$simd_b_log\"; then\n    if is_darwin_only_bootstrap_reject \"$simd_b_log\"; then\n      echo \"[verify_backend_simd] skip target ($target): bootstrap darwin-only path\" 1>&2\n      exit 2\n    fi\n    echo \"[verify_backend_simd] SIMD determinism build failed: $fixture\" 1>&2\n    sed -n '1,120p' \"$simd_b_log\" 1>&2 || true\n    exit 1\n  fi\n\n  if [ ! -x \"$exe_scalar\" ] || [ ! -x \"$exe_simd_a\" ] || [ ! -x \"$exe_simd_b\" ]; then\n    echo \"[verify_backend_simd] missing executable output: $fixture\" 1>&2\n    exit 1\n  fi\n\n  scalar_run_log=\"$out_dir/${name}.scalar.run.log\"\n  simd_a_run_log=\"$out_dir/${name}.simd.a.run.log\"\n  simd_b_run_log=\"$out_dir/${name}.simd.b.run.log\"\n\n  set +e\n  out_scalar=\"$(\"$exe_scalar\" 2>\"$scalar_run_log\")\"\n  scalar_status=\"$?\"\n  out_simd_a=\"$(\"$exe_simd_a\" 2>\"$simd_a_run_log\")\"\n  simd_a_status=\"$?\"\n  out_simd_b=\"$(\"$exe_simd_b\" 2>\"$simd_b_run_log\")\"\n  simd_b_status=\"$?\"\n  set -e\n\n  if [ \"$scalar_status\" -ne 0 ] || [ \"$simd_a_status\" -ne 0 ] || [ \"$simd_b"
        out = out + "_status\" -ne 0 ]; then\n    known_runtime_symbol=\"1\"\n    if [ \"$scalar_status\" -ne 0 ] && ! is_known_runtime_symbol_log \"$scalar_run_log\"; then\n      known_runtime_symbol=\"0\"\n    fi\n    if [ \"$simd_a_status\" -ne 0 ] && ! is_known_runtime_symbol_log \"$simd_a_run_log\"; then\n      known_runtime_symbol=\"0\"\n    fi\n    if [ \"$simd_b_status\" -ne 0 ] && ! is_known_runtime_symbol_log \"$simd_b_run_log\"; then\n      known_runtime_symbol=\"0\"\n    fi\n    if [ \"$known_runtime_symbol\" = \"1\" ]; then\n      echo \"[verify_backend_simd] known runtime-symbol instability, fallback compile-only: $fixture\" 1>&2\n      continue\n    fi\n    if [ \"$scalar_status\" -ne 0 ]; then\n      cat \"$scalar_run_log\" 1>&2 || true\n    fi\n    if [ \"$simd_a_status\" -ne 0 ]; then\n      cat \"$simd_a_run_log\" 1>&2 || true\n    fi\n    if [ \"$simd_b_status\" -ne 0 ]; then\n      cat \"$simd_b_run_log\" 1>&2 || true\n    fi\n    exit 1\n  fi\n\n  if [ \"$out_scalar\" != \"$out_simd_a\" ] || [ \"$out_scalar\" != \"$out_simd_b\" ]; then\n    echo \"[verify_backend_simd] scalar/simd output mismatch: $fixture\" 1>&2\n    exit 1\n  fi\n\n  echo \"verify_backend_simd: ok $fixture\"\ndone <<EOF\n$fixture_lines\nEOF\n\necho \"verify_backend_simd ok\"\n"
        return out
    if id == "verify_backend_spawn_api_gate":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  case \"$seconds\" in\n    ''|*[!0-9]*)\n      \"$@\"\n      return $?\n      ;;\n  esac\n  if command -v timeout >/dev/null 2>&1; then\n    timeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  if command -v gtimeout >/dev/null 2>&1; then\n    gtimeout \"$seconds\" \"$@\"\n    return $?\n  fi\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$driver\" ]; then\n  echo \"[Error] backend driver not executable: $driver\" 1>&2\n  exit 2\n"
        out = out + "fi\n\ntarget=\"${BACKEND_TARGET:-}\"\nif [ \"$target\" = \"\" ] || [ \"$target\" = \"auto\" ]; then\n  target=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target)\"\nfi\n\nout_dir=\"artifacts/backend_spawn_api_gate\"\nmkdir -p \"$out_dir\"\ntimeout_s=\"${BACKEND_SPAWN_GATE_TIMEOUT:-60}\"\n\nraw_spawn_pattern=\"fn[[:space:]]+spawn\\\\(fn_ptr:[[:space:]]*void\\\\*,[[:space:]]*ctx:[[:space:]]*void\\\\*\\\\)\"\nfind_raw_spawn() {\n  path=\"$1\"\n  if command -v rg >/dev/null 2>&1; then\n    rg -q \"$raw_spawn_pattern\" \"$path\"\n    return $?\n  fi\n  grep -Eq \"$raw_spawn_pattern\" \"$path\"\n}\n\nif find_raw_spawn src/std/async_rt.cheng; then\n  echo \"[Error] std/async_rt still exposes raw spawn(fn_ptr: void*, ctx: void*)\" 1>&2\n  exit 1\nfi\nif ! find_raw_spawn src/std/async_rt_legacy.cheng; then\n  echo \"[Error] std/async_rt_legacy missing legacy raw spawn(fn_ptr: void*, ctx: void*)\" 1>&2\n  exit 1\nfi\n\ncompile_ok() {\n  name=\"$1\"\n  fixture=\"$2\"\n  obj=\"$3\"\n  log=\"$4\"\n  set +e\n  run_with_timeout \"$timeout_s\" env \\\n    MM=orc \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=0 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$obj\" \\\n    \"$driver\" >\"$log\" 2>&1\n  status=\"$"
        out = out + "?\"\n  set -e\n  if [ \"$status\" = \"124\" ]; then\n    echo \"[Error] ${name} timed out after ${timeout_s}s\" 1>&2\n    exit 1\n  fi\n  if [ \"$status\" -ge \"128\" ]; then\n    echo \"[Error] ${name} crashed (status=$status)\" 1>&2\n    cat \"$log\" 1>&2\n    exit 1\n  fi\n  if [ \"$status\" != \"0\" ]; then\n    echo \"[Error] ${name} failed (status=$status)\" 1>&2\n    cat \"$log\" 1>&2\n    exit 1\n  fi\n}\n\ncompile_fail() {\n  name=\"$1\"\n  fixture=\"$2\"\n  obj=\"$3\"\n  log=\"$4\"\n  set +e\n  run_with_timeout \"$timeout_s\" env \\\n    MM=orc \\\n    STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n    STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n    STAGE1_SKIP_SEM=0 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$obj\" \\\n    \"$driver\" >\"$log\" 2>&1\n  status=\"$?\"\n  set -e\n  if [ \"$status\" = \"0\" ]; then\n    echo \"[Error] ${name} unexpectedly succeeded: $fixture\" 1>&2\n    exit 1\n  fi\n  if [ \"$status\" = \"124\" ]; then\n    echo \"[Error] ${name} timed out after ${timeout_s}s\" 1>&2\n    exit 1\n  fi\n  if [ \"$status\" -ge \"128\" ]; then\n    echo \"[Error] ${name} crashed (status=$status)\" 1>&2\n    cat \"$log\" 1>&2\n    exit 1\n  fi\n  if ! grep -Fq \"spawn\" \"$log\"; then\n    echo \"[Error] ${name} failed without spawn-related diagnostics\" 1>&2\n    cat \"$log"
        out = out + "\" 1>&2\n    exit 1\n  fi\n}\n\ndefault_obj=\"$out_dir/return_spawn_default_thread_entry_gate.o\"\ndefault_log=\"$out_dir/return_spawn_default_thread_entry_gate.log\"\ntyped_obj=\"$out_dir/return_spawn_typed_value_gate.o\"\ntyped_log=\"$out_dir/return_spawn_typed_value_gate.log\"\nlegacy_obj=\"$out_dir/return_spawn_legacy_namespaced_gate.o\"\nlegacy_log=\"$out_dir/return_spawn_legacy_namespaced_gate.log\"\n\ncompile_ok \\\n  \"spawn.thread_entry.default\" \\\n  \"tests/cheng/backend/fixtures/return_spawn_default_thread_entry_gate.cheng\" \\\n  \"$default_obj\" \\\n  \"$default_log\"\n\ncompile_ok \\\n  \"spawn.typed.default\" \\\n  \"tests/cheng/backend/fixtures/return_spawn_typed_value_gate.cheng\" \\\n  \"$typed_obj\" \\\n  \"$typed_log\"\n\ncompile_ok \\\n  \"spawn.legacy.explicit\" \\\n  \"tests/cheng/backend/fixtures/return_spawn_legacy_namespaced_gate.cheng\" \\\n  \"$legacy_obj\" \\\n  \"$legacy_log\"\n\ncompile_fail \\\n  \"spawn.raw.default_forbidden\" \\\n  \"tests/cheng/backend/fixtures/compile_fail_spawn_raw_default_gate.cheng\" \\\n  \"$out_dir/compile_fail_spawn_raw_default_gate.o\" \\\n  \"$out_dir/compile_fail_spawn_raw_default_gate.log\"\n\necho \"verify_backend_spawn_api_gate ok\"\n"
        return out
    if id == "verify_backend_ssa":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nout_dir=\"artifacts/backend_ssa\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/return_while_break.cheng\"\nif [ ! -f \"$fixture\" ]; then\n  echo \"[Error] missing fixture: $fixture\" 1>&2\n  exit 2\nfi\n\nrun_generic_mode() {\n  mode=\"$1\"\n  budget=\"$2\"\n  outfile=\"$3\"\n  env $link_env \\\n    GENERIC_MODE=\"$mode\" \\\n    GENERIC_SPEC_BUDGET=\"$budget\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$outfile\" \\\n    \"$driver\"\n}\n\nexe_a=\"$out_dir/dict_mode\"\nrun_generic_mode dict 0 \"$exe_a\"\n\nexe_b=\"$out_dir/hybrid_mode\"\nrun_generic_mode hybrid"
        out = out + " 0 \"$exe_b\"\n\nif [ ! -x \"$exe_a\" ] || [ ! -x \"$exe_b\" ]; then\n  echo \"verify_backend_ssa: compile failed\" 1>&2\n  exit 1\nfi\n\n\"$exe_a\"\n\"$exe_b\"\n\nif [ \"$(\"$exe_a\")\" != \"$(\"$exe_b\")\" ]; then\n  echo \"verify_backend_ssa: dict/hybrid outputs differ\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_ssa ok\"\n"
        return out
    if id == "verify_backend_stage0_no_compat":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_backend_stage0_no_compat.sh [--help]\n\nEnv:\n  STAGE0_NO_COMPAT_STAGE0=<path>                 optional stage0 override\n  STAGE0_NO_COMPAT_SESSION=<name>                default: prod.stage0_no_compat\n  STAGE0_NO_COMPAT_MODE=<fast|strict>            default: fast\n  STAGE0_NO_COMPAT_TIMEOUT=<seconds>             default: 60\n  STAGE0_NO_COMPAT_REUSE=<0|1>                   default: 0\n  STAGE0_NO_COMPAT_VALIDATE=<0|1>                default: 0\n  STAGE0_NO_COMPAT_SKIP_SMOKE=<0|1>              default: 1\n  STAGE0_NO_COMPAT_REQUIRE_RUNNABLE=<0|1>        default: 0\n  STAGE0_NO_COMPAT_STAGE1_PROBE_REQUIRED=<0|1>   default: same as REQUIRE_RUNNABLE\n  STAGE0_NO_COMPAT_PROBE_TIMEOUT=<seconds>       default: 20\n  STAGE0_NO_COMPAT_INPUT=<path>                  default: tests/cheng/backend/fixtures/return_add.cheng\n  STAGE0_NO_COMPAT_OUT_DIR=<path>                default: artifacts/backend_selfhost_self_obj/stage0_no_compat_<session>\n  STAGE0_NO_COMPAT_METRICS=<path>                default: <out_dir>/selfhost_metrics_<session>.json\n\nNotes:\n  - This gate enforces native stage0->stage1 bootstrap without stage0 compat overlay.\n  - It hard-sets SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 and requires retry_stage1_compat=0.\nEOF\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift"
        out = out + ";\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        kill \"TERM\", $pid;\n        my $grace_end = time + 1;\n        while (time < $grace_end) {\n          my $r = waitpid($pid, WNOHANG);\n          if ($r == $pid) {\n            my $status = $?;\n            if (($status & 127) != 0) {\n              exit(128 + ($status & 127));\n            }\n            exit($status >> 8);\n          }\n          select(undef, undef, undef, 0.1);\n        }\n        kill \"KILL\", -$pid;\n        kill \"KILL\", $pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nto_abs() {\n  p=\"$1\"\n  case \"$p\" in\n    /*) printf \"%s\\n\" \"$p\" ;;\n    *) printf \"%s/%s\\n\" \"$root\" \"$p\" ;;\n  esac\n}\n\ndriver_stage0_probe_ok() {\n  probe_compiler=\"$1\"\n  if [ ! -x \"$probe_compiler\" ]; then\n    return 1\n  fi\n  probe_out=\"chengcache/.stage0_no_compat_probe_$$.o\"\n  probe_log=\"$out_dir/stage0_probe.log\"\n  rm -f \"$probe_out\" \"$probe_log\"\n  set +e\n  run_with_timeout \"$probe_timeout\" env \\\n    "
        out = out + "BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    CHENG_BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$probe_input\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$probe_compiler\" >\"$probe_log\" 2>&1\n  probe_rc=\"$?\"\n  set -e\n  rm -f \"$probe_out\"\n  if [ \"$probe_rc\" -ne 0 ]; then\n    return 1\n  fi\n  return 0\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[verify_backend_stage0_no_compat] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nsession=\"${STAGE0_NO_COMPAT_SESSION:-prod.stage0_no_compat}\"\nsession_safe=\"$(printf '%s' \"$session\" | tr -c 'A-Za-z0-9._-' '_')\"\nmode=\"${STAGE0_NO_COMPAT_MODE:-fast}\"\ntimeout=\"${STAGE0_NO_COMPAT_TIMEOUT:-60}\"\nreuse=\"${STAGE0_NO_COMPAT_REUSE:-0}\"\nvalidate=\"${STAGE0_NO_COMPAT_VALIDATE:-0}\"\nskip_smoke=\"${STAGE0_NO_COMPAT_SKIP_SMOKE:-1}\"\nrequire_runnable=\"${STAGE0_NO_COMPAT_REQUIRE_RUNNABLE:-0}\"\nstage1_probe_required=\"${STAGE0_NO_COMPAT_STAGE1_PROBE_REQUIRED:-$require_runnable}\"\nprobe_timeout=\"${STAGE0_NO_COMPAT_PROBE_TIMEOUT:-20}\"\nprobe_input=\"${STAGE0_NO_COMPAT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\n\ncase \"$mode\" in\n  fast|strict)\n    ;;\n  *)\n    echo \"[verify_backend_stage0_no_compat] invalid mode: $mode (expected fast|strict)\" 1>&2\n    exit 2\n    ;;\nesac\n\nout_dir_rel=\"${STAGE0_NO_COM"
        out = out + "PAT_OUT_DIR:-artifacts/backend_selfhost_self_obj/stage0_no_compat_${session_safe}}\"\ncase \"$out_dir_rel\" in\n  /*)\n    out_dir=\"$out_dir_rel\"\n    ;;\n  *)\n    out_dir=\"$root/$out_dir_rel\"\n    ;;\nesac\nmkdir -p \"$out_dir\" chengcache\n\nmetrics_out=\"${STAGE0_NO_COMPAT_METRICS:-$out_dir/selfhost_metrics_${session_safe}.json}\"\nrm -f \"$metrics_out\"\n\nstage0=\"${STAGE0_NO_COMPAT_STAGE0:-}\"\nif [ \"$stage0\" != \"\" ]; then\n  stage0=\"$(to_abs \"$stage0\")\"\n  if ! driver_stage0_probe_ok \"$stage0\"; then\n    echo \"[verify_backend_stage0_no_compat] explicit stage0 probe failed: $stage0\" 1>&2\n    [ -s \"$out_dir/stage0_probe.log\" ] && echo \"[verify_backend_stage0_no_compat] probe log: $out_dir/stage0_probe.log\" 1>&2\n    exit 1\n  fi\nelse\n  stage0=\"\"\n  for cand in \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n    \"artifacts/backend_selfhost_self_obj/cheng.stage1\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\" \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"./cheng\"; do\n    [ \"$cand\" != \"\" ] || continue\n    cand_abs=\"$(to_abs \"$cand\")\"\n    if driver_stage0_probe_ok \"$cand_abs\"; then\n      stage0=\"$cand_abs\"\n      break\n    fi\n  done\n  if [ \"$stage0\" = \"\" ]; then\n    echo \"[verify_backend_stage0_no_compat] missing runnable stage0 candidate\" 1>&2\n    [ -s \"$out_dir/stage0_probe.log\" ] && echo \"[verify_backend_stage0_no_comp"
        out = out + "at] last probe log: $out_dir/stage0_probe.log\" 1>&2\n    exit 1\n  fi\nfi\n\necho \"== backend.stage0_no_compat ==\"\necho \"[verify_backend_stage0_no_compat] stage0=$stage0 mode=$mode timeout=${timeout}s\"\n\nselfhost_log=\"$out_dir/selfhost_stage0_no_compat.log\"\nrm -f \"$selfhost_log\"\nset +e\nenv \\\n  STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n  STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n  SELF_OBJ_BOOTSTRAP_MODE=\"$mode\" \\\n  SELF_OBJ_BOOTSTRAP_TIMEOUT=\"$timeout\" \\\n  SELF_OBJ_BOOTSTRAP_SESSION=\"$session\" \\\n  SELF_OBJ_BOOTSTRAP_OUT_DIR=\"$out_dir\" \\\n  SELF_OBJ_BOOTSTRAP_METRICS_OUT=\"$metrics_out\" \\\n  SELF_OBJ_BOOTSTRAP_REUSE=\"$reuse\" \\\n  SELF_OBJ_BOOTSTRAP_STAGE0=\"$stage0\" \\\n  SELF_OBJ_BOOTSTRAP_STAGE0_COMPAT=0 \\\n  SELF_OBJ_BOOTSTRAP_VALIDATE=\"$validate\" \\\n  SELF_OBJ_BOOTSTRAP_SKIP_SMOKE=\"$skip_smoke\" \\\n  SELF_OBJ_BOOTSTRAP_REQUIRE_RUNNABLE=\"$require_runnable\" \\\n  SELF_OBJ_BOOTSTRAP_STAGE1_PROBE_REQUIRED=\"$stage1_probe_required\" \\\n  SELF_OBJ_BOOTSTRAP_MULTI=0 \\\n  SELF_OBJ_BOOTSTRAP_MULTI_FORCE=0 \\\n  SELF_OBJ_BOOTSTRAP_ALLOW_RETRY=0 \\\n  GENERIC_MODE=\"${GENERIC_MODE:-dict}\" \\\n  GENERIC_SPEC_BUDGET=\"${GENERIC_SPEC_BUDGET:-0}\" \\\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj >\"$selfhost_log\" 2>&1\nselfhost_status=\"$?\"\nset -e\ncat \"$selfhost_log\"\nif [ \"$selfhost_status\" -ne 0 ]; then\n  exit \"$selfhost_status\"\nfi\n\nif [ ! -s \"$metrics_out\" ]; then\n  {\n    echo \"{\"\n    printf '  \"session\": \"%s\",\\n' \"$session_safe\"\n    printf '  \"mode\": \"%s\",\\n' \"$mode\"\n    echo '  \"retry_stage1_compat\": 0,'\n    echo '  \"metrics_mode\": \"native_selfhost_fast_host\",'\n    printf '  \"exit_status\": %s\\n' \"$selfhost_status\"\n    echo \"}\"\n  } >\"$metrics_out\"\nfi\n\nif ! grep -Eq '\"retry_stage1_compat\"[[:space:]]*:[[:space:]]*0' \"$metrics_out\"; then\n  echo \"[verify_backend_stage0_no_compat] stage0 comp"
        out = out + "at fallback was used unexpectedly: $metrics_out\" 1>&2\n  exit 1\nfi\n\necho \"backend.stage0_no_compat ok\"\n"
        return out
    if id == "verify_backend_stress":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\ntarget=\"${BACKEND_TARGET:-arm64-apple-darwin}\"\nlink_env=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooli"
        out = out + "ng} backend_link_env --driver:\"$driver\" --target:\"$target\" --linker:\"${BACKEND_LINKER:-auto}\")\"\n\n\nn=\"${BACKEND_STRESS_N:-10}\"\ntimeout_s=\"${BACKEND_STRESS_TIMEOUT:-60}\"\nout_dir=\"artifacts/backend_stress\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\nexe_path=\"$out_dir/stage1_smoke\"\n\n# shellcheck disable=SC2086\nset +e\nrun_with_timeout \"$timeout_s\" env $link_env \\\n  MM=orc \\\n  STAGE1_SKIP_SEM=\"${STAGE1_SKIP_SEM:-1}\" \\\n  GENERIC_MODE=\"${BACKEND_STRESS_GENERIC_MODE:-dict}\" \\\n  GENERIC_SPEC_BUDGET=\"${BACKEND_STRESS_GENERIC_SPEC_BUDGET:-0}\" \\\n  STAGE1_SKIP_OWNERSHIP=\"${STAGE1_SKIP_OWNERSHIP:-1}\" \\\n  BACKEND_FRONTEND=stage1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\"\nstatus=$?\nset -e\nif [ \"$status\" = \"124\" ]; then\n  echo \"[Error] verify_backend_stress compile timed out after ${timeout_s}s\" 1>&2\n  exit 124\nfi\nif [ \"$status\" != \"0\" ]; then\n  exit \"$status\"\nfi\n\ni=0\nwhile [ \"$i\" -lt \"$n\" ]; do\n  set +e\n  out=\"$(run_with_timeout \"$timeout_s\" \"$exe_path\" 2>&1)\"\n  status=$?\n  set -e\n  if [ \"$status\" = \"124\" ]; then\n    echo \"[Error] verify_backend_stress run timed out after ${timeout_s}s (iter=$i)\" 1>&2\n    exit 124\n  fi\n  if [ \"$status\" != \"0\" ]; then\n    printf \"%s\\n\" \"$out\" >&2\n    exit \"$status\"\n  fi\n  if ! printf \"%s\\n\" \"$out\" | grep -Fq "
        out = out + "\"hello from cheng backend\"; then\n    echo \"[Error] verify_backend_stress output mismatch (iter=$i)\" 1>&2\n    exit 1\n  fi\n  i=$((i + 1))\ndone\n\necho \"verify_backend_stress ok (n=$n)\"\n"
        return out
    if id == "verify_backend_ast_simhash_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_ast_simhash_contract] $1\" >&2\n  exit 1\n}\n\nline_no() {\n  file=\"$1\"\n  pattern=\"$2\"\n  rg -n --no-messages \"$pattern\" \"$file\" | head -n 1 | cut -d: -f1\n}\n\nrequire_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  marker=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    fail \"missing marker ($marker) in $file\"\n  fi\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nsimhash_file=\"src/decentralized/ast_simhash.cheng\"\nregistry_file=\"src/decentralized/registry.cheng\"\nregistry_local_file=\"src/decentralized/registry_local.cheng\"\n\n[ -f \"$simhash_file\" ] || fail \"missing simhash source: $simhash_file\"\n[ -f \"$registry_file\" ] || fail \"missing registry source: $registry_file\"\n[ -f \"$registry_local_file\" ] || fail \"missing registry local source: $registry_local_file\"\n\nrequire_marker \"$simhash_file\" 'fn simhashStripStdImportLines' 'strip_std_import_fn'\nrequire_marker \"$simhash_file\" 'lineHasStdImport' 'line_std_import_predicate'\nrequire_marker \"$simhash_file\" 'strutil.contains\\(line, \"std/\"\\)' 'std_import_contains_marker'\nrequire_marker \"$simhash_file\" 'filtered = simhashStripStdImportLines\\(content\\)' 'filter_before_tokenize'\nrequire_marker \"$simhash_file\" 'tokenizeSourceShape\\(filtered\\)' 'tokenize_filtered_source'\nrequire_marker \"$registry_file\" 'simhash.computeAstSimhash64ForDir\\(root\\)' 'registry_simhash_call'\nrequire_marker \"$registry_local_file\" 'simhash.computeAstSimhash64ForDir\\(root\\)' 'registry_local_simhash_call'\n\nif rg -q 'monomorphize|seqs_mono_' \"$simhash_file\"; then\n  fail \"ast simhash module must not depend on monomorphize/seqs_mono surfaces\"\nfi\n\nstrip_fn_line=\"$(line_no \"$simhash_file\" 'fn simhashStripStdImportLines')\"\nfilter_use_line=\"$(line_no \"$simhash_file\" 'filtered = simhashStripStdImportLines\\(content\\)')\"\ntokenize_filtered_line=\"$(line_no \"$simhash_file\" 'tokenizeSourceShape\\(filtered\\)')\"\n\nfor v in \"$strip_fn_line\" \"$filter_use_line\" \"$tokenize_filtered_line\"; do\n  case \"$v\" in\n    ''|*[!0-9]*)\n      fail \"failed to resolve ast simhash contract marker line numbers\"\n      ;;\n  esac\ndone\n\nif [ \"$strip_fn_line\" -ge \"$filter_use_line\" ]; then\n  fail \"std import filter function must be declared before compute call-site\"\nfi\nif [ \"$filter_use_line\" -ge \"$tokenize_filtered_line\" ]; then\n  fail \"tokenization must use filtered source after std-import stripping\"\nfi\n\nout_dir=\"artifacts/backend_ast_simhash_contract\"\nmkdir -p \"$out_dir\"\nreport=\"$out_dir/backend_ast_simhash_contract.report.txt\"\n\n{\n  echo \"verify_backend_ast_simhash_contract report\"\n  echo \"status=ok\"\n  echo \"simhash_file=$simhash_file\"\n  echo \"registry_file=$registry_file\"\n  echo \"registry_local_file=$registry_local_file\"\n  echo \"strip_fn_line=$strip_fn_line\"\n  echo \"filter_use_line=$filter_use_line\"\n  echo \"tokenize_filtered_line=$tokenize_filtered_line\"\n"
        out = out + "  echo \"std_import_filter_enabled=1\"\n  echo \"monomorphize_coupling=0\"\n} >\"$report\"\n\necho \"verify_backend_ast_simhash_contract ok\"\n"
        return out
    if id == "verify_backend_targets":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n\nout_dir=\"artifacts/backend_targets\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\n\ncompile_target() {\n  target=\"$1\"\n  output=\"$2\"\n  log=\"$3\"\n  set +e\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$output\" \\\n  \"$driver\" >\"$log\" 2>&1\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nis_darwin_only_bootstrap_reject() {\n  log=\"$1\"\n  if [ ! -f \"$log\" ]; then\n    return 1\n  fi\n  rg -q \"uir_codegen: bootstrap path only supports darwin target\" \"$log\"\n}\n\nmagic_hex() {\n  # Prints first 4 bytes as lowercase hex.\n  od -An -tx1 -N4 \"$1\" 2>/dev/null | tr -d ' \\n'\n}\n\ndarwin_obj=\"$out_dir/hello_importc_puts.darwin.o\"\ndarwin_x64_obj=\"$out_dir/hello_importc_puts.darwin_x86_64.o\"\nandroid_obj=\"$out_dir/hello_importc_puts.android.o\"\ndar"
        out = out + "win_log=\"$out_dir/hello_importc_puts.darwin.log\"\ndarwin_x64_log=\"$out_dir/hello_importc_puts.darwin_x86_64.log\"\nandroid_log=\"$out_dir/hello_importc_puts.android.log\"\n\nif ! compile_target \"arm64-apple-darwin\" \"$darwin_obj\" \"$darwin_log\"; then\n  echo \"[verify_backend_targets] failed to build darwin object: $darwin_log\" 1>&2\n  sed -n '1,120p' \"$darwin_log\" 1>&2 || true\n  exit 1\nfi\n\n[ \"$(magic_hex \"$darwin_obj\")\" = \"cffaedfe\" ]\nif ! command -v nm >/dev/null 2>&1; then\n  echo \"verify_backend_targets skip: missing nm\" 1>&2\n  exit 2\nfi\nnm \"$darwin_obj\" | grep -q \" T _main\"\nnm \"$darwin_obj\" | grep -q \" U _puts\"\n\nif ! compile_target \"x86_64-apple-darwin\" \"$darwin_x64_obj\" \"$darwin_x64_log\"; then\n  echo \"[verify_backend_targets] failed to build darwin x86_64 object: $darwin_x64_log\" 1>&2\n  sed -n '1,120p' \"$darwin_x64_log\" 1>&2 || true\n  exit 1\nfi\n\n[ \"$(magic_hex \"$darwin_x64_obj\")\" = \"cffaedfe\" ]\nnm \"$darwin_x64_obj\" | grep -q \" T _main\"\nnm \"$darwin_x64_obj\" | grep -q \" U _puts\"\n\nandroid_supported=\"1\"\nif ! compile_target \"aarch64-linux-android\" \"$android_obj\" \"$android_log\"; then\n  if is_darwin_only_bootstrap_reject \"$android_log\"; then\n    android_supported=\"0\"\n    echo \"[verify_backend_targets] skip android target: bootstrap darwin-only path\" 1>&2\n  else\n    echo \"[verify_backend_targets] failed to build android object: $android_log\" 1>&2\n    sed -n '1,120p' \"$android_log\" 1>"
        out = out + "&2 || true\n    exit 1\n  fi\nfi\n\nif [ \"$android_supported\" = \"1\" ]; then\n  [ \"$(magic_hex \"$android_obj\")\" = \"7f454c46\" ]\n  if command -v llvm-nm >/dev/null 2>&1; then\n    llvm-nm \"$android_obj\" | grep -q \" T main\"\n    llvm-nm \"$android_obj\" | grep -q \" U puts\"\n  elif nm \"$android_obj\" >/dev/null 2>&1; then\n    nm \"$android_obj\" | grep -q \" T main\"\n    nm \"$android_obj\" | grep -q \" U puts\"\n  fi\nfi\n\necho \"verify_backend_targets ok\"\n"
        return out
    if id == "verify_backend_targets_matrix":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nstrict=\"${BACKEND_MATRIX_STRICT:-0}\"\n\nfail_or_warn() {\n  msg=\"$1\"\n  if [ \"$strict\" = \"1\" ]; then\n    echo \"[verify_backend_targets_matrix] $msg\" 1>&2\n    exit 1\n  fi\n  echo \"[verify_backend_targets_matrix] (skip) $msg\" 1>&2\n}\n\nfind_llvm_objdump() {\n  if command -v xcrun >/dev/null 2>&1; then\n    p=\"$(xcrun --find llvm-objdump 2>/dev/null || true)\"\n    if [ \"$p\" != \"\" ]; then\n      printf \"%s\\n\" \"$p\"\n      return 0\n    fi\n  fi\n  for n in llvm-objdump llvm-objdump-19 llvm-objdump-18 llvm-objdump-17 llvm-objdump-16 llvm-objdump-15 llvm-objdump-14; do\n    if command -v \"$n\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\npick_nm_tool_for() {\n  obj=\"$1\"\n  if command -v nm >/dev/null 2>&1 && nm \"$obj\" >/dev/null 2>&1; then\n    printf \"%s\\n\" \"nm\"\n    return 0\n  fi\n  for n in llvm-nm llvm-nm-19 llvm-nm-18 llvm-nm-17 llvm-nm-16 llvm-nm-15 llvm-nm-14; do\n    if command"
        out = out + " -v \"$n\" >/dev/null 2>&1 && \"$n\" \"$obj\" >/dev/null 2>&1; then\n      command -v \"$n\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nhas_macho_cstring_section() {\n  obj=\"$1\"\n  if command -v otool >/dev/null 2>&1; then\n    if otool -lv \"$obj\" | grep -q \"sectname __cstring\"; then\n      return 0\n    fi\n    return 1\n  fi\n  if [ \"$llvm_objdump\" != \"\" ]; then\n    if \"$llvm_objdump\" -h \"$obj\" | grep -q \"__cstring\"; then\n      return 0\n    fi\n    return 1\n  fi\n  return 2\n}\n\nhas_cheng_str_symbol() {\n  obj=\"$1\"\n  nm_tool=\"$2\"\n  [ \"$nm_tool\" != \"\" ] || return 1\n  \"$nm_tool\" \"$obj\" | grep -Eq \"L_cheng_str_[0-9a-fA-F]+\"\n}\n\nllvm_objdump=\"$(find_llvm_objdump || true)\"\n\nout_dir=\"artifacts/backend_targets_matrix\"\nmkdir -p \"$out_dir\"\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nis_macho_x86_64_obj() {\n  obj=\"$1\"\n  if command -v otool >/dev/null 2>&1; then\n    otool -hv \"$obj\" | grep -q \"X86_64\"\n    return $?\n  fi\n  if [ \"$llvm_objdump\" != \"\" ]; then\n    \"$llvm_objdump\" -h \"$obj\" | grep -Eq \"mach-o.*x86-64|x86-64\"\n    return $?\n  fi\n  return 2\n}\n\ndriver_supports_darwin_x86_64() {\n  cand=\"$1\"\n  [ -x \"$cand\" ] || return 1\n  probe_obj=\"$out_dir/.driver_probe_x86_64.o\"\n  probe_log=\"$out_dir/.driver_probe_x86_64.log\"\n  rm -f \"$probe_obj\" \"$probe_log\"\n  set +e\n  BA"
        out = out + "CKEND_EMIT=obj \\\n  BACKEND_TARGET=x86_64-apple-darwin \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$probe_obj\" \\\n  \"$cand\" >\"$probe_log\" 2>&1\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -ne 0 ] || [ ! -s \"$probe_obj\" ]; then\n    return 1\n  fi\n  set +e\n  is_macho_x86_64_obj \"$probe_obj\"\n  rc=\"$?\"\n  set -e\n  [ \"$rc\" -eq 0 ]\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nif [ \"$host_os\" = \"Darwin\" ]; then\n  if ! driver_supports_darwin_x86_64 \"$driver\"; then\n    for cand in \\\n      \"$root/dist/releases/current/cheng\" \\\n      \"$root/artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n      \"$root/artifacts/backend_seed/cheng.stage2\" \\\n      \"$root/artifacts/backend_selfhost_self_obj/cheng.stage1\"; do\n      [ \"$cand\" != \"$driver\" ] || continue\n      if driver_supports_darwin_x86_64 \"$cand\"; then\n        echo \"[verify_backend_targets_matrix] info: switch matrix driver -> $cand\" 1>&2\n        driver=\"$cand\"\n        break\n      fi\n    done\n  fi\nfi\n\ncompile_target() {\n  target=\"$1\"\n  output=\"$2\"\n  log=\"$3\"\n  set +e\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$output\" \\\n  \"$driver\" >\"$log\" 2>&1\n  rc=\"$?\"\n  set -e\n  return \"$rc\"\n}\n\nis_darwin_only_bootstrap_reject() {\n  log=\"$1\"\n  if [ ! -f \"$log\" ]; then\n    return 1\n  fi\n  rg -q \"uir_codegen: bootstrap path only supports darwin target\" \"$log\"\n}\n\n"
        out = out + "compile_required_target() {\n  label=\"$1\"\n  target=\"$2\"\n  output=\"$3\"\n  log=\"$out_dir/hello_importc_puts.${label}.build.log\"\n  if compile_target \"$target\" \"$output\" \"$log\"; then\n    return 0\n  fi\n  echo \"[verify_backend_targets_matrix] failed to build $label target ($target): $log\" 1>&2\n  sed -n '1,120p' \"$log\" 1>&2 || true\n  exit 1\n}\n\ncompile_optional_target() {\n  out_var=\"$1\"\n  label=\"$2\"\n  target=\"$3\"\n  output=\"$4\"\n  log=\"$out_dir/hello_importc_puts.${label}.build.log\"\n  if compile_target \"$target\" \"$output\" \"$log\"; then\n    eval \"$out_var=1\"\n    return 0\n  fi\n  if is_darwin_only_bootstrap_reject \"$log\"; then\n    eval \"$out_var=0\"\n    echo \"[verify_backend_targets_matrix] skip ${label} target (${target}): bootstrap darwin-only path\" 1>&2\n    return 0\n  fi\n  echo \"[verify_backend_targets_matrix] failed to build $label target ($target): $log\" 1>&2\n  sed -n '1,120p' \"$log\" 1>&2 || true\n  exit 1\n}\n\nmagic_hex() {\n  # Prints first 4 bytes as lowercase hex.\n  od -An -tx1 -N4 \"$1\" 2>/dev/null | tr -d ' \\n'\n}\n\nmagic_hex2() {\n  # Prints first 2 bytes as lowercase hex.\n  od -An -tx1 -N2 \"$1\" 2>/dev/null | tr -d ' \\n'\n}\n\ndarwin_obj=\"$out_dir/hello_importc_puts.darwin.o\"\ndarwin_x64_obj=\"$out_dir/hello_importc_puts.darwin_x86_64.o\"\nios_obj=\"$out_dir/hello_importc_puts.ios.o\"\nandroid_obj=\"$out_dir/hello_importc_puts.android.o\"\nlinux_x64_obj=\"$out_dir/hello_importc_puts.linux_x86_64."
        out = out + "o\"\nwindows_obj=\"$out_dir/hello_importc_puts.windows.obj\"\nwindows_x64_obj=\"$out_dir/hello_importc_puts.windows_x86_64.obj\"\n\ncompile_required_target \"darwin\" \"arm64-apple-darwin\" \"$darwin_obj\"\ncompile_required_target \"darwin_x86_64\" \"x86_64-apple-darwin\" \"$darwin_x64_obj\"\ncompile_required_target \"ios\" \"arm64-apple-ios\" \"$ios_obj\"\n\nandroid_enabled=\"1\"\nlinux_x64_enabled=\"1\"\nwindows_enabled=\"1\"\nwindows_x64_enabled=\"1\"\ncompile_optional_target android_enabled \"android\" \"aarch64-linux-android\" \"$android_obj\"\ncompile_optional_target linux_x64_enabled \"linux_x86_64\" \"x86_64-unknown-linux-gnu\" \"$linux_x64_obj\"\ncompile_optional_target windows_enabled \"windows\" \"aarch64-pc-windows-msvc\" \"$windows_obj\"\ncompile_optional_target windows_x64_enabled \"windows_x86_64\" \"x86_64-pc-windows-msvc\" \"$windows_x64_obj\"\n\n[ \"$(magic_hex \"$darwin_obj\")\" = \"cffaedfe\" ] || fail_or_warn \"unexpected darwin object magic: $darwin_obj\"\ndarwin_nm=\"$(pick_nm_tool_for \"$darwin_obj\" || true)\"\nif [ \"$darwin_nm\" != \"\" ]; then\n  \"$darwin_nm\" \"$darwin_obj\" | grep -Eq \" T _?main$\" || fail_or_warn \"missing _main/main in darwin object: $darwin_obj\"\n  \"$darwin_nm\" \"$darwin_obj\" | grep -Eq \" U _?puts$\" || fail_or_warn \"missing _puts/puts in darwin object: $darwin_obj\"\nelse\n  fail_or_warn \"missing nm/llvm-nm (required to validate darwin object symbols): $darwin_obj\"\nfi\ndarwin_cstring_status=0\nset +e\nhas_macho_cst"
        out = out + "ring_section \"$darwin_obj\"\ndarwin_cstring_status=\"$?\"\nset -e\nif [ \"$darwin_cstring_status\" -eq 2 ] && [ \"$darwin_nm\" = \"\" ]; then\n  fail_or_warn \"missing otool/llvm-objdump and nm/llvm-nm (required to validate darwin string storage): $darwin_obj\"\nfi\nif [ \"$darwin_cstring_status\" -ne 0 ] && ! has_cheng_str_symbol \"$darwin_obj\" \"$darwin_nm\"; then\n  fail_or_warn \"missing __cstring section or L_cheng_str_* symbols in darwin object: $darwin_obj\"\nfi\n\n[ \"$(magic_hex \"$darwin_x64_obj\")\" = \"cffaedfe\" ] || fail_or_warn \"unexpected darwin x86_64 object magic: $darwin_x64_obj\"\ndarwin_x64_nm=\"$(pick_nm_tool_for \"$darwin_x64_obj\" || true)\"\nif [ \"$darwin_x64_nm\" != \"\" ]; then\n  \"$darwin_x64_nm\" \"$darwin_x64_obj\" | grep -Eq \" T _?main$\" || fail_or_warn \"missing _main/main in darwin x86_64 object: $darwin_x64_obj\"\n  \"$darwin_x64_nm\" \"$darwin_x64_obj\" | grep -Eq \" U _?puts$\" || fail_or_warn \"missing _puts/puts in darwin x86_64 object: $darwin_x64_obj\"\nelse\n  fail_or_warn \"missing nm/llvm-nm (required to validate darwin x86_64 object symbols): $darwin_x64_obj\"\nfi\nif command -v otool >/dev/null 2>&1; then\n  otool -hv \"$darwin_x64_obj\" | grep -q \"X86_64\" || fail_or_warn \"unexpected darwin x86_64 object header: $darwin_x64_obj\"\nelif [ \"$llvm_objdump\" != \"\" ]; then\n  \"$llvm_objdump\" -h \"$darwin_x64_obj\" > \"$out_dir/hello_importc_puts.darwin_x86_64.objdump.h.txt\" || fail_or_warn \"llvm-objdump failed for darwi"
        out = out + "n x86_64 object: $darwin_x64_obj\"\n  grep -Eq \"mach-o.*x86-64|x86-64\" \"$out_dir/hello_importc_puts.darwin_x86_64.objdump.h.txt\" || fail_or_warn \"unexpected darwin x86_64 object header: $darwin_x64_obj\"\nelse\n  if [ \"$darwin_x64_nm\" = \"\" ]; then\n    fail_or_warn \"missing otool/llvm-objdump and nm/llvm-nm (required to validate darwin x86_64 string storage): $darwin_x64_obj\"\n  fi\nfi\ndarwin_x64_cstring_status=0\nset +e\nhas_macho_cstring_section \"$darwin_x64_obj\"\ndarwin_x64_cstring_status=\"$?\"\nset -e\nif [ \"$darwin_x64_cstring_status\" -eq 2 ] && [ \"$darwin_x64_nm\" = \"\" ]; then\n  fail_or_warn \"missing otool/llvm-objdump and nm/llvm-nm (required to validate darwin x86_64 string storage): $darwin_x64_obj\"\nfi\nif [ \"$darwin_x64_cstring_status\" -ne 0 ] && ! has_cheng_str_symbol \"$darwin_x64_obj\" \"$darwin_x64_nm\"; then\n  fail_or_warn \"missing __cstring section or L_cheng_str_* symbols in darwin x86_64 object: $darwin_x64_obj\"\nfi\n\n[ \"$(magic_hex \"$ios_obj\")\" = \"cffaedfe\" ] || fail_or_warn \"unexpected ios object magic: $ios_obj\"\nios_nm=\"$(pick_nm_tool_for \"$ios_obj\" || true)\"\nif [ \"$ios_nm\" != \"\" ]; then\n  \"$ios_nm\" \"$ios_obj\" | grep -Eq \" T _?main$\" || fail_or_warn \"missing _main/main in ios object: $ios_obj\"\n  \"$ios_nm\" \"$ios_obj\" | grep -Eq \" U _?puts$\" || fail_or_warn \"missing _puts/puts in ios object: $ios_obj\"\nelse\n  fail_or_warn \"missing nm/llvm-nm (required to validate ios object symbols): $ios_o"
        out = out + "bj\"\nfi\n\nif [ \"$android_enabled\" = \"1\" ]; then\n  [ \"$(magic_hex \"$android_obj\")\" = \"7f454c46\" ] || fail_or_warn \"unexpected android object magic: $android_obj\"\n  strings \"$android_obj\" | grep -q \"main\" || fail_or_warn \"missing main in android object: $android_obj\"\n  strings \"$android_obj\" | grep -q \"puts\" || fail_or_warn \"missing puts in android object: $android_obj\"\n  strings \"$android_obj\" | grep -q \"\\\\.rodata\" || fail_or_warn \"missing .rodata in android object: $android_obj\"\nfi\n\nif [ \"$linux_x64_enabled\" = \"1\" ]; then\n  [ \"$(magic_hex \"$linux_x64_obj\")\" = \"7f454c46\" ] || fail_or_warn \"unexpected linux x86_64 object magic: $linux_x64_obj\"\n  strings \"$linux_x64_obj\" | grep -q \"main\" || fail_or_warn \"missing main in linux x86_64 object: $linux_x64_obj\"\n  strings \"$linux_x64_obj\" | grep -q \"puts\" || fail_or_warn \"missing puts in linux x86_64 object: $linux_x64_obj\"\n  strings \"$linux_x64_obj\" | grep -q \"\\\\.rodata\" || fail_or_warn \"missing .rodata in linux x86_64 object: $linux_x64_obj\"\n  if [ \"$llvm_objdump\" != \"\" ]; then\n    \"$llvm_objdump\" -r -d \"$linux_x64_obj\" > \"$out_dir/hello_importc_puts.linux_x86_64.objdump.rd.txt\"\n    grep -q \"file format elf64-x86-64\" \"$out_dir/hello_importc_puts.linux_x86_64.objdump.rd.txt\" || fail_or_warn \"unexpected llvm-objdump format for linux x86_64 object: $linux_x64_obj\"\n    grep -q \"R_X86_64_PC32\" \"$out_dir/hello_importc_puts.linux_x86_64.objd"
        out = out + "ump.rd.txt\" || fail_or_warn \"missing R_X86_64_PC32 relocation in linux x86_64 object: $linux_x64_obj\"\n    grep -q \"R_X86_64_PLT32\" \"$out_dir/hello_importc_puts.linux_x86_64.objdump.rd.txt\" || fail_or_warn \"missing R_X86_64_PLT32 relocation in linux x86_64 object: $linux_x64_obj\"\n    grep -q \"puts-0x4\" \"$out_dir/hello_importc_puts.linux_x86_64.objdump.rd.txt\" || fail_or_warn \"missing ELF x86_64 call addend (-0x4) in linux object: $linux_x64_obj\"\n  else\n    fail_or_warn \"missing llvm-objdump to validate linux x86_64 relocs: $linux_x64_obj\"\n  fi\nfi\n\nif [ \"$windows_enabled\" = \"1\" ]; then\n  # COFF machine AArch64 is 0xaa64 (little-endian: 64 aa).\n  [ \"$(magic_hex2 \"$windows_obj\")\" = \"64aa\" ] || fail_or_warn \"unexpected windows COFF machine: $windows_obj\"\n  strings \"$windows_obj\" | grep -q \"main\" || fail_or_warn \"missing main in windows object: $windows_obj\"\n  strings \"$windows_obj\" | grep -q \"puts\" || fail_or_warn \"missing puts in windows object: $windows_obj\"\n  strings \"$windows_obj\" | grep -q \"\\\\.rdata\" || fail_or_warn \"missing .rdata in windows object: $windows_obj\"\nfi\n\nif [ \"$windows_x64_enabled\" = \"1\" ]; then\n  # COFF machine x86_64 is 0x8664 (little-endian: 64 86).\n  [ \"$(magic_hex2 \"$windows_x64_obj\")\" = \"6486\" ] || fail_or_warn \"unexpected windows x86_64 COFF machine: $windows_x64_obj\"\n  strings \"$windows_x64_obj\" | grep -q \"main\" || fail_or_warn \"missing main in windows x86_64 object: $wi"
        out = out + "ndows_x64_obj\"\n  strings \"$windows_x64_obj\" | grep -q \"puts\" || fail_or_warn \"missing puts in windows x86_64 object: $windows_x64_obj\"\n  strings \"$windows_x64_obj\" | grep -q \"\\\\.rdata\" || fail_or_warn \"missing .rdata in windows x86_64 object: $windows_x64_obj\"\nfi\n\necho \"verify_backend_targets_matrix ok\"\n"
        return out
    if id == "verify_backend_uir_stability":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nnormalize_int() {\n  n=\"$1\"\n  default=\"$2\"\n  minv=\"$3\"\n  maxv=\"$4\"\n  case \"$n\" in\n    ''|*[!0-9]*)\n      printf '%s\\n' \"$default\"\n      return 0\n      ;;\n  esac\n  if [ \"$n\" -lt \"$minv\" ]; then\n    printf '%s\\n' \"$minv\"\n    return 0\n  fi\n  if [ \"$n\" -gt \"$maxv\" ]; then\n    printf '%s\\n' \"$maxv\"\n    return 0\n  fi\n  printf '%s\\n' \"$n\"\n}\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return 0\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return 0\n  fi\n  return 1\n}\n\ntarget=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo auto)}\"\nreps=\"$(normalize_int \"${UIR_STABILITY_ITERS:-3}\" 3 2 12)\"\nuir_opt2_iters=\"$(normalize_int \"${UIR_OPT2"
        out = out + "_ITERS:-5}\" 5 1 32)\"\nuir_opt3_iters=\"$(normalize_int \"${UIR_OPT3_ITERS:-4}\" 4 1 32)\"\nuir_opt3_cleanup_iters=\"$(normalize_int \"${UIR_OPT3_CLEANUP_ITERS:-3}\" 3 1 32)\"\nuir_inline_iters=\"$(normalize_int \"${UIR_INLINE_ITERS:-4}\" 4 1 16)\"\nuir_cfg_canon_iters=\"$(normalize_int \"${UIR_CFG_CANON_ITERS:-1}\" 1 1 16)\"\nuir_profile=\"${UIR_PROFILE:-0}\"\nuir_simd_raw=\"${UIR_SIMD:-}\"\nuir_simd_max_width=\"${UIR_SIMD_MAX_WIDTH:-0}\"\nuir_simd_policy=\"${UIR_SIMD_POLICY:-autovec}\"\nif [ \"$uir_simd_policy\" = \"\" ]; then\n  uir_simd_policy=\"autovec\"\nfi\nmodes_raw=\"${UIR_STABILITY_MODES:-dict}\"\nif [ \"$modes_raw\" = \"all\" ]; then\n  modes_raw=\"dict hybrid\"\nfi\nmodes=\"$(printf '%s' \"$modes_raw\" | tr ',;' '  ' | tr -s ' ')\"\nif [ \"$modes\" = \"\" ]; then\n  modes=\"dict\"\nfi\nif [ \"${UIR_STABILITY_OPT_LEVEL:-}\" = \"\" ]; then\n  opt_level=\"3\"\nelse\n  opt_level=\"$(normalize_int \"${UIR_STABILITY_OPT_LEVEL}\" 3 0 3)\"\nfi\nif [ \"$uir_simd_raw\" = \"\" ]; then\n  if [ \"$opt_level\" -ge 3 ]; then\n    uir_simd=\"1\"\n  else\n    uir_simd=\"0\"\n  fi\nelse\n  uir_simd=\"$uir_simd_raw\"\nfi\nbudget=\"${GENERIC_SPEC_BUDGET:-0}\"\nfixtures=\"${UIR_STABILITY_FIXTURES:-tests/cheng/backend/fixtures/return_add.cheng\ntests/cheng/backend/fixtures/return_object_fields.cheng\ntests/cheng/backend/fixtures/return_while_sum.cheng\ntests/cheng/backend/fixtures/return_call9.cheng\ntests/cheng/backend/fixtures/return_opt2_cbr_mergeable.cheng\ntests/cheng/backend/fix"
        out = out + "tures/return_opt2_merge_identical_ret_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_equiv_blocks.cheng\ntests/cheng/backend/fixtures/return_opt2_merge_jumps.cheng\ntests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\ntests/cheng/backend/fixtures/return_opt2_licm_while_cond.cheng}\"\nnormalize_fixture_lines() {\n  printf '%s\\n' \"$1\" | tr ';' '\\n' | tr '\\r' '\\n' | sed -e '/^[[:space:]]*$/d'\n}\n\nfixture_lines=\"$(normalize_fixture_lines \"$fixtures\")\"\nout_dir=\"${UIR_STABILITY_OUT_DIR:-artifacts/backend_uir_stability}\"\nmkdir -p \"$out_dir\"\n\nif ! sha256_file /dev/null >/dev/null 2>&1; then\n  echo \"[verify_backend_uir_stability] shasum/sha256sum is required to run this check\" 1>&2\n  exit 2\nfi\n\nrun_build() {\n  outfile=\"$1\"\n  fixture=\"$2\"\n  mode=\"$3\"\n  frontend=\"${UIR_STABILITY_FRONTEND:-}\"\n  if [ \"$frontend\" != \"\" ]; then\n    env \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=\"$frontend\" \\\n      BACKEND_EMIT=obj \\\n      BACKEND_OPT_LEVEL=\"$opt_level\" \\\n      UIR_OPT2_ITERS=\"$uir_opt2_iters\" \\\n      UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n      UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n      UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n      UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n      UIR_PROFILE=\"$uir_profile\" \\\n      UIR_SIMD=\"$uir_simd\" \\\n      UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n      UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n      GENERIC_MODE=\"$m"
        out = out + "ode\" \\\n      GENERIC_SPEC_BUDGET=\"$budget\" \\\n      BACKEND_INPUT=\"$fixture\" \\\n      BACKEND_OUTPUT=\"$outfile\" \\\n      \"$driver\"\n    return $?\n  fi\n\n  env \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_EMIT=obj \\\n    BACKEND_OPT_LEVEL=\"$opt_level\" \\\n      UIR_OPT2_ITERS=\"$uir_opt2_iters\" \\\n      UIR_OPT3_ITERS=\"$uir_opt3_iters\" \\\n      UIR_OPT3_CLEANUP_ITERS=\"$uir_opt3_cleanup_iters\" \\\n      UIR_INLINE_ITERS=\"$uir_inline_iters\" \\\n      UIR_CFG_CANON_ITERS=\"$uir_cfg_canon_iters\" \\\n    UIR_PROFILE=\"$uir_profile\" \\\n    UIR_SIMD=\"$uir_simd\" \\\n    UIR_SIMD_MAX_WIDTH=\"$uir_simd_max_width\" \\\n    UIR_SIMD_POLICY=\"$uir_simd_policy\" \\\n    GENERIC_MODE=\"$mode\" \\\n    GENERIC_SPEC_BUDGET=\"$budget\" \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$outfile\" \\\n    \"$driver\"\n}\n\nfor mode in $modes; do\n  while IFS= read -r fixture; do\n    if [ ! -f \"$fixture\" ]; then\n      echo \"[verify_backend_uir_stability] missing fixture: $fixture\" 1>&2\n      exit 2\n    fi\n\n    base_hash=\"\"\n    i=\"1\"\n    while [ \"$i\" -le \"$reps\" ]; do\n      base_name=\"$(basename \"$fixture\" .cheng)\"\n      out_path=\"$out_dir/${base_name}.${mode}.${i}.o\"\n      rm -f \"$out_path\"\n      run_build \"$out_path\" \"$fixture\" \"$mode\"\n      if [ ! -s \"$out_path\" ]; then\n        echo \"[verify_backend_uir_stability] failed to produce object: $out_path\" 1>&2\n        exit 1\n      fi\n\n      h=\"$(sha256_f"
        out = out + "ile \"$out_path\")\"\n      if [ \"$h\" = \"\" ]; then\n        echo \"[verify_backend_uir_stability] failed to hash object output\" 1>&2\n        exit 2\n      fi\n      if [ \"$i\" -eq 1 ]; then\n        base_hash=\"$h\"\n      elif [ \"$h\" != \"$base_hash\" ]; then\n        echo \"[verify_backend_uir_stability] non-deterministic output for $mode:$fixture (iter $i/$reps): $base_hash -> $h\" 1>&2\n        exit 1\n      fi\n      i=$((i + 1))\n    done\n\n    echo \"verify_backend_uir_stability: ok ${mode} ${fixture}\"\n  done <<EOF\n$fixture_lines\nEOF\ndone\n\necho \"verify_backend_uir_stability ok\"\n"
        return out
    if id == "verify_backend_x86_64_darwin":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nif [ \"$host_os\" != \"Darwin\" ]; then\n  echo \"verify_backend_x86_64_darwin skip: darwin-only (host_os=$host_os)\" 1>&2\n  exit 2\nfi\nif ! command -v cc >/dev/null 2>&1; then\n  echo \"verify_backend_x86_64_darwin skip: missing cc\" 1>&2\n  exit 2\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n# Keep x86_64 codegen gate independent from closure-level no-pointer policy toggles.\nexport STAGE1_STD_NO_POINTERS=0\nexport STAGE1_STD_NO_POINTERS_STRICT=0\nexport STAGE1_NO_POINTERS_NON_C_ABI=0\nexport STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0\n\nout_dir=\"artifacts/backend_x86_64_darwin\"\nmkdir -p \"$out_dir\"\n\ncheng_rt_obj_base=\"chengcache/system_helpers.backend.cheng.x86_64.darwin.o\"\nfloat_bits_src=\"src/runtime/native/system_helpers_float_bits.c\"\nfloat_bits_obj=\"chengcache/system_helpers_float_bits.x86_64.darwin.min11.o\"\ncheng_rt_obj=\"chengcache/system"
        out = out + "_helpers.backend.combined.x86_64.darwin.o\"\n\ncan_run=\"0\"\nif command -v arch >/dev/null 2>&1; then\n  if arch -x86_64 /usr/bin/true >/dev/null 2>&1; then\n    can_run=\"1\"\n  fi\nfi\n\nrun_x86_64() {\n  exe=\"$1\"\n  shift || true\n  if [ \"$can_run\" != \"1\" ]; then\n    echo \"[Warn] verify_backend_x86_64_darwin: missing Rosetta; skip run: $exe\" 1>&2\n    return 0\n  fi\n  arch -x86_64 \"$exe\" \"$@\"\n}\n\nis_known_system_link_x86_64_blocker() {\n  log_path=\"$1\"\n  if [ ! -f \"$log_path\" ]; then\n    return 1\n  fi\n  if rg -q \"Undefined symbols for architecture x86_64:\" \"$log_path\" && \\\n     rg -q \"_cheng_(bytes_copy|bytes_set|memcpy|memset|seq_get|seq_set|strcmp|strlen|load_ptr|store_ptr)\" \"$log_path\"; then\n    return 0\n  fi\n  if rg -q \"ld: symbol\\\\(s\\\\) not found for architecture x86_64\" \"$log_path\" && \\\n     rg -q \"system_helpers\\\\.backend\\\\.combined\\\\.x86_64\\\\.darwin\\\\.o\" \"$log_path\"; then\n    return 0\n  fi\n  return 1\n}\n\nensure_backend_runtime_obj() {\n  if [ ! -f \"$cheng_rt_obj_base\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$cheng_rt_obj_base\" ]; then\n    env \\\n      BACKEND_VALIDATE=1 \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=x86_64-apple-darwin \\\n      BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n      BACKEND_O"
        out = out + "UTPUT=\"$cheng_rt_obj_base\" \\\n      \"$driver\" >/dev/null\n  fi\n\n  if [ ! -f \"$float_bits_obj\" ] || [ \"$float_bits_src\" -nt \"$float_bits_obj\" ]; then\n    env MACOSX_DEPLOYMENT_TARGET=11.0 \\\n      cc -target x86_64-apple-darwin -mmacosx-version-min=11.0 -O2 -c \"$float_bits_src\" -o \"$float_bits_obj\"\n  fi\n\n  if [ ! -f \"$cheng_rt_obj\" ] || [ \"$cheng_rt_obj_base\" -nt \"$cheng_rt_obj\" ] || [ \"$float_bits_obj\" -nt \"$cheng_rt_obj\" ]; then\n    ld -r -arch x86_64 \"$cheng_rt_obj_base\" \"$float_bits_obj\" -o \"$cheng_rt_obj\"\n  fi\n}\n\nbuild_obj() {\n  fixture=\"$1\"\n  obj_path=\"$2\"\n  rm -f \"$obj_path\"\n  BACKEND_VALIDATE=1 \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_WHOLE_PROGRAM=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=x86_64-apple-darwin \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$obj_path\" \\\n  \"$driver\"\n  if [ ! -s \"$obj_path\" ]; then\n    echo \"[Error] missing object output: $obj_path\" 1>&2\n    exit 1\n  fi\n}\n\nbuild_exe() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  base=\"$(basename \"$fixture\" .cheng)\"\n  compile_log=\"$out_dir/build.${base}.x86_64.system.log\"\n  rm -f \"$exe_path\" \"$compile_log\"\n  ensure_backend_runtime_obj\n  set +e\n  env \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$cheng_rt_obj\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=x86_64-ap"
        out = out + "ple-darwin \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >\"$compile_log\" 2>&1\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ]; then\n    if is_known_system_link_x86_64_blocker \"$compile_log\"; then\n      return 2\n    fi\n    tail -n 200 \"$compile_log\" 1>&2 || true\n    return \"$status\"\n  fi\n  if [ ! -x \"$exe_path\" ]; then\n    echo \"[Error] missing exe output: $exe_path\" 1>&2\n    return 1\n  fi\n  return 0\n}\n\nrequire_build_exe() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  set +e\n  build_exe \"$fixture\" \"$exe_path\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 0 ]; then\n    return 0\n  fi\n  if [ \"$status\" -eq 2 ]; then\n    echo \"verify_backend_x86_64_darwin skip: system-link x86_64 Mach-O unresolved imports on this seed/driver\" 1>&2\n    exit 2\n  fi\n  exit \"$status\"\n}\n\n# Object + exe smoke: importc puts.\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.x86_64.o\"\nexe_path=\"$out_dir/hello_importc_puts.x86_64\"\n\nbuild_obj \"$fixture\" \"$obj_path\"\nif command -v otool >/dev/null 2>&1; then\n  if ! otool -hv \"$obj_path\" | grep -q \"X86_64\"; then\n    echo \"verify_backend_x86_64_darwin skip: seed/driver does not emit x86_64 Mach-O objects\" 1>&2\n    exit 2\n  fi\nfi\nif command -v nm >/dev/null 2>&1; then\n  nm \"$obj_path\" | grep -q \" T _main\"\n  nm \"$obj_path\" | grep -q \" U _puts\"\nfi\n\nrequire_build_exe \"$fixtu"
        out = out + "re\" \"$exe_path\"\nif [ \"$can_run\" = \"1\" ]; then\n  run_x86_64 \"$exe_path\" >\"$out_dir/run.hello_importc_puts.txt\"\n  grep -Fq \"hello importc puts\" \"$out_dir/run.hello_importc_puts.txt\"\nelse\n  echo \"[Warn] verify_backend_x86_64_darwin: missing Rosetta; skip output check\" 1>&2\nfi\n\n# Deeper x86_64 exe coverage (SysV ABI + control flow + concurrency).\nfor fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/${base}.x86_64\"\n  require_build_exe \"$fixture\" \"$exe_path\"\n  run_x86_64 \"$exe_path\"\ndone\n\n# Self linker (no `cc`): x86_64 Mach-O via backend `--linker=self`.\nensure_backend_runtime_obj\n\nbuild_exe_self() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  rm -f \"$exe_path\"\n  set +e\n  env \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_LINKER=self \\\n    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$cheng_rt_obj\" \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=x86_64-apple-darwin \\\n    BACKEND_INPUT=\"$fixture\" \\\n    BACKEND_OUTPUT=\"$exe_path\" \\\n    \"$driver\" >/dev/null\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -ne 0 ] || [ ! -x \"$exe_path\" ]; then\n    return 2\n  fi\n  return 0\n}\n\nexe_self=\"$out_dir/hello_puts.x86_64.self\"\nif"
        out = out + " ! build_exe_self tests/cheng/backend/fixtures/hello_puts.cheng \"$exe_self\"; then\n  echo \"verify_backend_x86_64_darwin skip: self-link x86_64 Mach-O unresolved imports on this seed/driver\" 1>&2\n  exit 2\nfi\nrun_x86_64 \"$exe_self\" >\"$out_dir/run.hello_puts.self.txt\"\nif [ \"$can_run\" = \"1\" ]; then\n  grep -Fq \"hello from cheng backend\" \"$out_dir/run.hello_puts.self.txt\"\nfi\n\nfor fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/${base}.x86_64.self\"\n  if ! build_exe_self \"$fixture\" \"$exe_path\"; then\n    echo \"verify_backend_x86_64_darwin skip: self-link x86_64 Mach-O unresolved imports on this seed/driver\" 1>&2\n    exit 2\n  fi\n  run_x86_64 \"$exe_path\"\ndone\n\necho \"verify_backend_x86_64_darwin ok\"\n"
        return out
    if id == "verify_backend_x86_64_linux":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif [ \"${CLEAN_CHENG_LOCAL:-1}\" = \"1\" ] && [ \"${TOOLING_CLEANUP_DEPTH:-0}\" = \"0\" ]; then\n  export TOOLING_CLEANUP_DEPTH=1\n  cleanup_backend_driver_on_exit() {\n    status=$?\n    set +e\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cleanup_cheng_local\n    exit \"$status\"\n  }\n  trap cleanup_backend_driver_on_exit EXIT\nfi\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\ncase \"$host_os/$host_arch\" in\n  Linux/x86_64)\n    ;;\n  *)\n    echo \"verify_backend_x86_64_linux skip: linux/x86_64 only (host=$host_os/$host_arch)\" >&2\n    exit 2\n    ;;\nesac\n\nif ! command -v cc >/dev/null 2>&1; then\n  echo \"verify_backend_x86_64_linux skip: missing cc\" >&2\n  exit 2\nfi\n\ndriver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nout_dir=\"artifacts/backend_x86_64_linux\"\nmkdir -p \"$out_dir\"\n\nmagic_hex() {\n  od -An -tx1 -N4 \"$1\" 2>/dev/null | tr -d ' \\n'\n}\n\nbuild_obj() {\n  fixture=\"$1\"\n  obj_path=\"$2\"\n  rm -f \"$obj_path\"\n  BACKEND_VALIDATE=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=x86_64-unknown-linux-gnu \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$obj_path\" \\\n  \"$driver\"\n  if [ ! -s \"$obj_path\" ]; then\n    echo \"[Error] missing object output: "
        out = out + "$obj_path\" >&2\n    exit 1\n  fi\n}\n\nbuild_exe() {\n  fixture=\"$1\"\n  exe_path=\"$2\"\n  rm -f \"$exe_path\"\n  BACKEND_VALIDATE=1 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=x86_64-unknown-linux-gnu \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$exe_path\" \\\n  \"$driver\"\n  if [ ! -x \"$exe_path\" ]; then\n    echo \"[Error] missing executable output: $exe_path\" >&2\n    exit 1\n  fi\n}\n\nfixture=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"\nobj_path=\"$out_dir/hello_importc_puts.x86_64.o\"\nexe_path=\"$out_dir/hello_importc_puts.x86_64\"\n\nbuild_obj \"$fixture\" \"$obj_path\"\n[ \"$(magic_hex \"$obj_path\")\" = \"7f454c46\" ]\nif command -v nm >/dev/null 2>&1; then\n  nm \"$obj_path\" | grep -q \" T main\"\n  nm \"$obj_path\" | grep -q \" U puts\"\nfi\n\nbuild_exe \"$fixture\" \"$exe_path\"\n\"$exe_path\" >\"$out_dir/run.hello_importc_puts.txt\"\ngrep -Fq \"hello importc puts\" \"$out_dir/run.hello_importc_puts.txt\"\n\nfor fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng \\\n               tests/cheng/backend/fixtures/return_for_sum.cheng\ndo\n  base=\"$(basename \"$fixture\" .cheng)\"\n  exe_path=\"$out_dir/${base}.x86_64\"\n  build_exe \"$fixture\" \"$exe_path\"\n  \"$exe_path\"\ndone\n\necho \"verify_backend_x86_64_linux ok\"\n"
        return out
    if id == "verify_backend_zero_script_closure":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_backend_zero_script_closure] $1\" 1>&2\n  exit 1\n}\n\nif ! command -v rg >/dev/null 2>&1; then\n  fail \"rg is required\"\nfi\n\nembedded_map=\"src/tooling/cheng_tooling_embedded_inline.cheng\"\ntool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\nfor required in \"$embedded_map\" \"$tool\"; do\n  [ -f \"$required\" ] || fail \"missing required file: $required\"\ndone\n\nleft_tooling=\"$(find src/tooling -maxdepth 1 -type f -name '*.sh' | LC_ALL=C sort || true)\"\nif [ \"$left_tooling\" != \"\" ]; then\n  echo \"[verify_backend_zero_script_closure] unexpected shell wrappers under src/tooling:\" 1>&2\n  printf '%s\\n' \"$left_tooling\" | sed 's/^/  - /' 1>&2\n  exit 1\nfi\n\nleft_scripts=\"$(find scripts -maxdepth 1 -type f -name '*.sh' | LC_ALL=C sort || true)\"\nif [ \"$left_scripts\" != \"\" ]; then\n  echo \"[verify_backend_zero_script_closure] unexpected shell wrappers under scripts/:\" 1>&2\n  printf '%s\\n' \"$left_scripts\" | sed 's/^/  - /' 1>&2\n  exit 1\nfi\n\nout_dir=\"artifacts/backend_zero_script_closure\"\nmkdir -p \"$out_dir\"\nmap_ids=\"$out_dir/map_ids.txt\"\n\"$tool\" embedded-ids | LC_ALL=C sort -u >\"$map_ids\"\n\ntmp_body=\"$out_dir/.tmp.script_body.sh\"\nwhile IFS= read -r sid; do\n  [ \"$sid\" != \"\" ] || continue\n  \"$tool\" embedded-text --id:\"$s"
        out = out + "id\" >\"$tmp_body\"\n  if rg -n '(^|[[:space:]])(sh|bash)[[:space:]]+src/tooling/[A-Za-z0-9_.-]+\\.sh' -P \"$tmp_body\" >/dev/null 2>&1; then\n    echo \"[verify_backend_zero_script_closure] embedded script still contains direct wrapper invocation: $sid\" 1>&2\n    rg -n '(^|[[:space:]])(sh|bash)[[:space:]]+src/tooling/[A-Za-z0-9_.-]+\\.sh' -P \"$tmp_body\" | sed 's/^/  - /' 1>&2\n    exit 1\n  fi\ndone <\"$map_ids\"\nrm -f \"$tmp_body\"\n\nreport=\"$out_dir/backend_zero_script_closure.report.txt\"\n{\n  echo \"status=ok\"\n  echo \"tooling_shell_files=0\"\n  echo \"allowed_tooling_shells=\"\n  echo \"scripts_shell_files=0\"\n  echo \"map_ids=$map_ids\"\n} >\"$report\"\n\necho \"verify_backend_zero_script_closure ok\"\n"
        return out
    if id == "verify_buildmeta":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_buildmeta.sh --buildmeta:<path> [--ledger:<path>]\n\nNotes:\n  - Validate buildmeta lock/pkgmeta/snapshot fields and ensure referenced files exist.\n  - If --ledger is provided, check ledger.jsonl exists and contains events.\nEOF\n}\n\nbuildmeta=\"\"\nledger=\"\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --buildmeta:*)\n      buildmeta=\"${1#--buildmeta:}\"\n      ;;\n    --ledger:*)\n      ledger=\"${1#--ledger:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nif [ \"$buildmeta\" = \"\" ]; then\n  echo \"[Error] missing --buildmeta\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$buildmeta\" ]; then\n  echo \"[Error] buildmeta not found: $buildmeta\" 1>&2\n  exit 2\nfi\n\nsha256_file() {\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$1\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$1\" | awk '{print $1}'\n    return\n  fi\n  echo \"\"\n}\n\ntoml_string_in_section() {\n  section=\"$1\"\n  key=\"$2\"\n  file=\"$3\"\n  awk -v section=\"$section\" -v key=\"$key\" '\n    $0 ~ /^\\[/ {\n      in_section = ($0 == \"[\" section \"]\")\n      next\n    }\n    in_section {\n      pattern = \"^[[:space:]]*\" key \"[[:space:]]*=[[:space:]]*\\\"\"\n      if ($0 ~ pattern)"
        out = out + " {\n        sub(\"^[[:space:]]*\" key \"[[:space:]]*=[[:space:]]*\\\"\", \"\")\n        sub(\"\\\"[[:space:]]*$\", \"\")\n        print\n        exit\n      }\n    }\n  ' \"$file\"\n}\n\ntoml_int_in_section() {\n  section=\"$1\"\n  key=\"$2\"\n  file=\"$3\"\n  awk -v section=\"$section\" -v key=\"$key\" '\n    $0 ~ /^\\[/ {\n      in_section = ($0 == \"[\" section \"]\")\n      next\n    }\n    in_section {\n      pattern = \"^[[:space:]]*\" key \"[[:space:]]*=[[:space:]]*[0-9]\"\n      if ($0 ~ pattern) {\n        sub(\"^[[:space:]]*\" key \"[[:space:]]*=[[:space:]]*\", \"\")\n        sub(\"[[:space:]]*$\", \"\")\n        print\n        exit\n      }\n    }\n  ' \"$file\"\n}\n\nlock_path=\"$(toml_string_in_section lock path \"$buildmeta\")\"\nlock_sha=\"$(toml_string_in_section lock sha256 \"$buildmeta\")\"\nif [ \"$lock_path\" != \"\" ]; then\n  if [ ! -f \"$lock_path\" ]; then\n    echo \"[Error] lock file missing: $lock_path\" 1>&2\n    exit 2\n  fi\n  if [ \"$lock_sha\" != \"\" ]; then\n    actual=\"$(sha256_file \"$lock_path\")\"\n    if [ \"$actual\" != \"$lock_sha\" ]; then\n      echo \"[Error] lock sha256 mismatch\" 1>&2\n      exit 2\n    fi\n  fi\nfi\n\nmeta_path=\"$(toml_string_in_section pkgmeta path \"$buildmeta\")\"\nmeta_sha=\"$(toml_string_in_section pkgmeta sha256 \"$buildmeta\")\"\nif [ \"$meta_path\" != \"\" ]; then\n  if [ ! -f \"$meta_path\" ]; then\n    echo \"[Error] pkgmeta file missing: $meta_path\" 1>&2\n    exit 2\n  fi\n  if [ \"$meta_sha\" != \""
        out = out + "\" ]; then\n    actual=\"$(sha256_file \"$meta_path\")\"\n    if [ \"$actual\" != \"$meta_sha\" ]; then\n      echo \"[Error] pkgmeta sha256 mismatch\" 1>&2\n      exit 2\n    fi\n  fi\nfi\n\nsnap_cid=\"$(toml_string_in_section snapshot cid \"$buildmeta\")\"\nsnap_author=\"$(toml_string_in_section snapshot author_id \"$buildmeta\")\"\nsnap_sig=\"$(toml_string_in_section snapshot signature \"$buildmeta\")\"\nsnap_epoch=\"$(toml_int_in_section snapshot epoch \"$buildmeta\")\"\nif [ \"$snap_cid\" != \"\" ] || [ \"$snap_author\" != \"\" ] || [ \"$snap_sig\" != \"\" ]; then\n  if [ \"$snap_cid\" = \"\" ] || [ \"$snap_author\" = \"\" ]; then\n    echo \"[Error] snapshot fields incomplete\" 1>&2\n    exit 2\n  fi\n  if [ \"$snap_epoch\" = \"\" ]; then\n    echo \"[Error] snapshot epoch missing\" 1>&2\n    exit 2\n  fi\nfi\n\nif [ \"$ledger\" != \"\" ]; then\n  if [ ! -f \"$ledger\" ]; then\n    echo \"[Error] ledger not found: $ledger\" 1>&2\n    exit 2\n  fi\n  if command -v rg >/dev/null 2>&1; then\n    if ! rg -q \"\\\"type\\\"\" \"$ledger\"; then\n      echo \"[Error] ledger has no events\" 1>&2\n      exit 2\n    fi\n  else\n    if ! grep -q \"\\\"type\\\"\" \"$ledger\"; then\n      echo \"[Error] ledger has no events\" 1>&2\n      exit 2\n    fi\n  fi\nfi\n\necho \"verify ok\"\n"
        return out
    if id == "verify_cheng_skill_consistency":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nskill_root=\"${SKILL_ROOT:-docs/cheng-skill}\"\nskill_md=\"$skill_root/SKILL.md\"\ngrammar_md=\"$skill_root/references/grammar.md\"\nownership_md=\"$skill_root/references/ownership.md\"\nstdlib_md=\"$skill_root/references/stdlib.md\"\ntemplate_md=\"$skill_root/assets/hello-cheng/main.cheng\"\nfixture_cheng=\"tests/cheng/skill/hello_cheng_ci_sample.cheng\"\nrun_fixture_cheng=\"tests/cheng/backend/fixtures/return_add.cheng\"\nif [ ! -f \"$run_fixture_cheng\" ]; then\n  run_fixture_cheng=\"tests/cheng/backend/fixtures/return_i64.cheng\"\nfi\nskill_compile=\"${SKILL_COMPILE:-1}\"\nskill_run=\"${SKILL_RUN:-1}\"\nskill_frontend=\"${SKILL_FRONTEND:-stage1}\"\n\nfail() {\n  echo \"[verify_cheng_skill_consistency] $1\" 1>&2\n  exit 1\n}\n\nrequire_file() {\n  f=\"$1\"\n  [ -f \"$f\" ] || fail \"missing file: $f\"\n}\n\ncheck_forbidden() {\n  file=\"$1\"\n  regex=\"$2\"\n  label=\"$3\"\n  if grep -nE \"$regex\" \"$file\" >/dev/null 2>&1; then\n    echo \"[verify_cheng_skill_consistency] forbidden syntax ($label): $file\" 1>&2\n    grep -nE \"$regex\" \"$file\" 1>&2 || true\n    exit 1\n  fi\n}\n\ncheck_forbidden_in_markdown_code() {\n  file=\"$1\"\n  regex=\"$2\"\n  label=\"$3\"\n  if awk '\n    /^```/ { in_code = !in_code; next }\n    in_code { print }\n  ' \"$file\" | grep -nE \"$regex\" >/dev/null 2>&1; then\n    echo \"["
        out = out + "verify_cheng_skill_consistency] forbidden syntax ($label): $file\" 1>&2\n    awk '\n      /^```/ { in_code = !in_code; next }\n      in_code { print }\n    ' \"$file\" | grep -nE \"$regex\" 1>&2 || true\n    exit 1\n  fi\n}\n\ncompare_if_exists() {\n  src_file=\"$1\"\n  dst_file=\"$2\"\n  label=\"$3\"\n  if [ ! -f \"$dst_file\" ]; then\n    fail \"missing synced file for $label: $dst_file\"\n  fi\n  if ! cmp -s \"$src_file\" \"$dst_file\"; then\n    fail \"drift detected for $label: $src_file != $dst_file\"\n  fi\n}\n\nrun_with_timeout() {\n  limit_secs=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$limit_secs\" \"$@\"\n}\n\nrequire_file \"$skill_md\"\nrequire_file \"$grammar_md\"\nrequire_file \"$ownership_md\"\nrequire_file \"$stdlib_md\"\nrequire_file \"$template_md\"\nrequire_file \"$fixture_cheng\"\nif [ \"$skill"
        out = out + "_compile\" = \"1\" ] && [ \"$skill_run\" = \"1\" ]; then\n  require_file \"$run_fixture_cheng\"\nfi\n\ncase \"$skill_frontend\" in\n  stage1)\n    ;;\n  *)\n    fail \"invalid SKILL_FRONTEND=$skill_frontend (expected stage1)\"\n    ;;\nesac\n\nif ! grep -qE '^1\\. .*cheng-formal-spec\\.md' \"$skill_md\"; then\n  fail \"authority order missing formal spec as #1 in $skill_md\"\nfi\nif ! grep -qE ' `?cheng-formal-spec\\.md`? ' \"$skill_md\"; then\n  fail \"missing conflict rule (formal spec wins) in $skill_md\"\nfi\nif ! grep -q 'references/ownership.md' \"$skill_md\"; then\n  fail \"missing ownership reference in $skill_md\"\nfi\nif ! grep -qi 'no-pointer' \"$skill_md\"; then\n  fail \"missing no-pointer policy in $skill_md\"\nfi\nif ! grep -qi 'no-pointer' \"$grammar_md\"; then\n  fail \"missing no-pointer policy note in $grammar_md\"\nfi\n\ncheck_forbidden_in_markdown_code \"$grammar_md\" '^[[:space:]]*import[[:space:]]+std[[:space:]]+/' 'legacy spaced std import'\ncheck_forbidden_in_markdown_code \"$grammar_md\" '^[[:space:]]*import[[:space:]]+\"' 'string import'\ncheck_forbidden_in_markdown_code \"$grammar_md\" '^[[:space:]]*import[[:space:]]+\\.{1,2}/' 'relative import'\ncheck_forbidden_in_markdown_code \"$grammar_md\" '^[[:space:]]*import[[:space:]]+[A-Za-z0-9_/]+[[:space:]]*,[[:space:]]*[A-Za-z0-9_/]+[[:space:]]*$' 'comma import list'\ncheck_forbidden_in_markdown_code \"$grammar_md\" '^[[:space:]]*(method|converter)[[:space:]]+[A-Za-z_]' 'legacy top-level "
        out = out + "routine keyword'\ncheck_forbidden_in_markdown_code \"$grammar_md\" 'TypeExpr[[:space:]]+expr' 'legacy TypeExpr expr conversion'\ncheck_forbidden_in_markdown_code \"$grammar_md\" 'cast\\[[^]]+\\]\\(' 'legacy cast[T](x)'\n\ncheck_forbidden_in_markdown_code \"$stdlib_md\" '^[[:space:]]*import[[:space:]]+std[[:space:]]+/' 'legacy spaced std import'\ncheck_forbidden_in_markdown_code \"$stdlib_md\" '^[[:space:]]*import[[:space:]]+\"' 'string import'\ncheck_forbidden_in_markdown_code \"$stdlib_md\" '^[[:space:]]*import[[:space:]]+\\.{1,2}/' 'relative import'\ncheck_forbidden_in_markdown_code \"$stdlib_md\" '\\.\\./\\.\\./cheng/stdlib/bootstrap' 'legacy relative bootstrap import'\ncheck_forbidden_in_markdown_code \"$ownership_md\" '^[[:space:]]*(method|converter)[[:space:]]+[A-Za-z_]' 'legacy top-level routine keyword'\ncheck_forbidden_in_markdown_code \"$ownership_md\" 'cast\\[[^]]+\\]\\(' 'legacy cast[T](x)'\n\ncheck_forbidden \"$template_md\" '^[[:space:]]*(method|converter)[[:space:]]+[A-Za-z_]' 'legacy top-level routine keyword'\ncheck_forbidden \"$template_md\" 'cast\\[[^]]+\\]\\(' 'legacy cast[T](x)'\ncheck_forbidden \"$template_md\" '^[[:space:]]*import[[:space:]]+\"' 'string import'\ncheck_forbidden \"$template_md\" '^[[:space:]]*import[[:space:]]+\\.{1,2}/' 'relative import'\n\nif ! cmp -s \"$template_md\" \"$fixture_cheng\"; then\n  fail \"template drift: $template_md != $fixture_cheng\"\nfi\n\nif [ \"$skill_compile\" = \"1\" ]; then\n  driver=\"${BACKEND_DRIVER:-}\"\n  al"
        out = out + "low_selfhost=\"${SKILL_DRIVER_ALLOW_SELFHOST:-0}\"\n  if [ \"$driver\" = \"\" ]; then\n    driver=\"${SKILL_DRIVER:-}\"\n  fi\n  if [ \"$driver\" = \"\" ]; then\n    driver=\"$(TOOLING_STAGE0_ALLOW_LEGACY_FALLBACK=0 BACKEND_DRIVER_PATH_ALLOW_SELFHOST=\"$allow_selfhost\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path 2>/dev/null || true)\"\n  fi\n  if [ \"$driver\" = \"\" ]; then\n    if [ -x \"artifacts/backend_driver/cheng\" ]; then\n      driver=\"artifacts/backend_driver/cheng\"\n    elif [ -x \"dist/releases/current/cheng\" ]; then\n      driver=\"dist/releases/current/cheng\"\n    elif [ -x \"artifacts/backend_seed/cheng.stage2\" ]; then\n      driver=\"artifacts/backend_seed/cheng.stage2\"\n    fi\n  fi\n  if [ \"$driver\" = \"\" ] && [ \"$allow_selfhost\" = \"1\" ]; then\n    if [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage2\" ]; then\n      driver=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n    elif [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage1\" ]; then\n      driver=\"artifacts/backend_selfhost_self_obj/cheng.stage1\"\n    fi\n  fi\n  if [ ! -x \"$driver\" ]; then\n    fail \"backend driver not executable: $driver\"\n  fi\n  driver_exec=\"$driver\"\n  driver_real_env=\"\"\n  if [ -x \"src/tooling/backend_driver_exec.sh\" ]; then\n    driver_exec=\"src/tooling/backend_driver_exec.sh\"\n    driver_real_env=\"BACKEND_DRIVER_REAL=$driver\"\n  fi\n  out_dir=\"artifacts/cheng_skill_consistency\"\n  out_obj=\"$out_dir/hello_cheng_ci_sample.o\"\n  out_exe=\"$out_dir/hello_cheng_ci_s"
        out = out + "ample\"\n  out_exe_win=\"$out_dir/hello_cheng_ci_sample.exe\"\n  run_exe=\"$out_dir/return_add_smoke\"\n  run_exe_win=\"$out_dir/return_add_smoke.exe\"\n  compile_timeout=\"${SKILL_COMPILE_TIMEOUT:-60}\"\n  run_timeout=\"${SKILL_RUN_TIMEOUT:-10}\"\n\n  mkdir -p \"$out_dir\"\n  rm -f \"$out_obj\" \"$out_exe\" \"$out_exe_win\" \"$run_exe\" \"$run_exe_win\"\n\n  set +e\n  run_with_timeout \"$compile_timeout\" env \\\n    $driver_real_env \\\n    MM=orc \\\n    BACKEND_MULTI=1 \\\n    BACKEND_MULTI_FORCE=1 \\\n    STAGE1_SKIP_SEM=0 \\\n    GENERIC_MODE=dict \\\n    GENERIC_SPEC_BUDGET=0 \\\n    STAGE1_SKIP_OWNERSHIP=1 \\\n    BACKEND_FRONTEND=\"$skill_frontend\" \\\n    BACKEND_VALIDATE=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    CHENG_BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_INPUT=\"$fixture_cheng\" \\\n    BACKEND_OUTPUT=\"$out_obj\" \\\n    \"$driver_exec\"\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 124 ]; then\n    fail \"compile timeout (${compile_timeout}s) for object sample: $fixture_cheng\"\n  fi\n  [ \"$status\" -eq 0 ] || fail \"compile failed for object sample: $fixture_cheng (status=$status)\"\n\n  [ -s \"$out_obj\" ] || fail \"missing object output after compile: $out_obj\"\n\n  set +e\n  run_with_timeout \"$compile_timeout\" env \\"
        out = out + "\n    TOOLING_STAGE0_ALLOW_LEGACY_FALLBACK=0 \\\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} compile \\\n      --in:$fixture_cheng \\\n      --out:$out_exe \\\n      --stage0:$driver \\\n      --linker:system\n  status=\"$?\"\n  set -e\n  if [ \"$status\" -eq 124 ]; then\n    fail \"compile timeout (${compile_timeout}s) for executable sample: $fixture_cheng\"\n  fi\n  [ \"$status\" -eq 0 ] || fail \"compile failed for executable sample: $fixture_cheng (status=$status)\"\n\n  exe_path=\"\"\n  if [ -x \"$out_exe\" ]; then\n    exe_path=\"$out_exe\"\n  elif [ -x \"$out_exe_win\" ] || [ -f \"$out_exe_win\" ]; then\n    exe_path=\"$out_exe_win\"\n  fi\n  [ \"$exe_path\" != \"\" ] || fail \"missing executable output after compile: $out_exe(.exe)\"\n\n  if [ \"$skill_run\" = \"1\" ]; then\n    set +e\n    run_with_timeout \"$compile_timeout\" env \\\n      TOOLING_STAGE0_ALLOW_LEGACY_FALLBACK=0 \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} compile \\\n        --in:$run_fixture_cheng \\\n        --out:$run_exe \\\n        --stage0:$driver \\\n        --linker:system\n    status=\"$?\"\n    set -e\n    if [ \"$status\" -eq 124 ]; then\n      fail \"compile timeout (${compile_timeout}s) for smoke sample: $run_fixture_cheng\"\n    fi\n    [ \"$status\" -eq 0 ] || fail \"compile failed for smoke sample: $run_fixture_cheng (status=$status)\"\n\n    run_path=\""
        out = out + "\"\n    if [ -x \"$run_exe\" ]; then\n      run_path=\"$run_exe\"\n    elif [ -x \"$run_exe_win\" ] || [ -f \"$run_exe_win\" ]; then\n      run_path=\"$run_exe_win\"\n    fi\n    [ \"$run_path\" != \"\" ] || fail \"missing smoke executable output: $run_exe(.exe)\"\n\n    run_with_timeout \"$run_timeout\" \"$run_path\" >/dev/null\n  fi\nfi\n\nhome_skill_root=\"${SKILL_HOME_ROOT:-$HOME/.codex/skills/cheng}\"\nif [ \"${SKILL_COMPARE_HOME:-1}\" = \"1\" ] && [ -d \"$home_skill_root\" ]; then\n  compare_if_exists \"$skill_md\" \"$home_skill_root/SKILL.md\" 'SKILL.md'\n  compare_if_exists \"$grammar_md\" \"$home_skill_root/references/grammar.md\" 'references/grammar.md'\n  compare_if_exists \"$ownership_md\" \"$home_skill_root/references/ownership.md\" 'references/ownership.md'\n  compare_if_exists \"$stdlib_md\" \"$home_skill_root/references/stdlib.md\" 'references/stdlib.md'\n  compare_if_exists \"$template_md\" \"$home_skill_root/assets/hello-cheng/main.cheng\" 'assets/hello-cheng/main.cheng'\nfi\n\necho \"verify_cheng_skill_consistency ok\"\n"
        return out
    if id == "verify_demo_compute_settle":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"build/cheng_demo_compute_verify\"\nMODE=\"local\"\nEPOCH=\"1\"\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\ncd \"$repo_root\"\n\nresolve_chengc_bin() {\n  local name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$repo_root\" \"$name\"\n}\n\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    --root:*)\n      ROOT=\"${1#--root:}\"\n      ;;\n    --mode:*)\n      MODE=\"${1#--mode:}\"\n      ;;\n    --epoch:*)\n      EPOCH=\"${1#--epoch:}\"\n      ;;\n    *)\n      echo \"unknown arg: $1\" 1>&2\n      exit 1\n      ;;\n  esac\n  shift\ndone\n\nDEMO_ARGS=(--root:\"$ROOT\" --mode:\"$MODE\" --epoch:\"$EPOCH\" --clean --reset-ledger)\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} demo_compute_settle \"${DEMO_ARGS[@]}\" >/dev/null\n\nsettle=\"$(\"$storage_bin\" settle --root:\"$ROOT\" --format:toml --top:1)\"\nprintf '%s' \"$settle\" | grep -Fq \"compute_total\" || { echo \"verify: missing compute_total\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"audit_total\" || { echo \"verify: missing audit_total\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"exec_request\" || { echo \"verify: missing exec_request count\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"exec_receipt\" || { echo \"verify: missing exec_receip"
        out = out + "t count\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"audit_sample_count\" || { echo \"verify: missing audit_sample_count\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"fraud_report_count\" || { echo \"verify: missing fraud_report_count\" 1>&2; exit 1; }\n\nif [ ! -f \"$ROOT/settle_reconcile.csv\" ]; then\n  echo \"verify: missing reconcile csv\" 1>&2\n  exit 1\nfi\n\nif [ ! -f \"$ROOT/rwad_batch.json\" ]; then\n  echo \"verify: missing rwad_batch.json\" 1>&2\n  exit 1\nfi\n\nbatch=\"$(cat \"$ROOT/rwad_batch.json\")\"\nprintf '%s' \"$batch\" | grep -Fq \"\\\"schema_version\\\"\" || { echo \"verify: missing schema_version\" 1>&2; exit 1; }\nprintf '%s' \"$batch\" | grep -Fq \"\\\"settlement\\\"\" || { echo \"verify: missing settlement\" 1>&2; exit 1; }\nprintf '%s' \"$batch\" | grep -Fq \"\\\"batch_id\\\"\" || { echo \"verify: missing batch_id\" 1>&2; exit 1; }\nprintf '%s' \"$batch\" | grep -Fq \"\\\"settlement_sha256\\\"\" || { echo \"verify: missing settlement_sha256\" 1>&2; exit 1; }\n\nif [ ! -f \"$ROOT/rwad_result.json\" ]; then\n  echo \"verify: missing rwad_result.json\" 1>&2\n  exit 1\nfi\nresult=\"$(cat \"$ROOT/rwad_result.json\")\"\nprintf '%s' \"$result\" | grep -Fq \"\\\"schema_version\\\":\\\"rwad-cheng-settlement-result/v1\\\"\" || { echo \"verify: invalid rwad result schema\" 1>&2; exit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"request_schema\\\":\\\"cheng-rwad-settlement/v1\\\"\" || { echo \"verify: invalid rwad request schema\" 1>&2; e"
        out = out + "xit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"status\\\":\\\"finalized\\\"\" || { echo \"verify: invalid rwad status\" 1>&2; exit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"totals\\\"\" || { echo \"verify: missing rwad totals\" 1>&2; exit 1; }\n\nif [ ! -f \"$ROOT/rwad_ack.json\" ]; then\n  echo \"verify: missing rwad_ack.json\" 1>&2\n  exit 1\nfi\nack=\"$(cat \"$ROOT/rwad_ack.json\")\"\nprintf '%s' \"$ack\" | grep -Fq \"\\\"ok\\\"\" || { echo \"verify: missing rwad ack ok\" 1>&2; exit 1; }\nprintf '%s' \"$ack\" | grep -Fq \"\\\"request_schema\\\":\\\"cheng-rwad-settlement/v1\\\"\" || { echo \"verify: invalid rwad ack request schema\" 1>&2; exit 1; }\nprintf '%s' \"$ack\" | grep -Fq \"\\\"totals\\\"\" || { echo \"verify: missing rwad ack totals\" 1>&2; exit 1; }\n\necho \"verify ok\"\n"
        return out
    if id == "verify_demo_io_lease":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"build/cheng_demo_verify\"\nMODE=\"local\"\nLISTEN=\"\"\nPEER=\"\"\nREQUIRE_LEASE=\"0\"\nrepo_root=\"$(CDPATH= cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")/../..\" && pwd)\"\ncd \"$repo_root\"\n\nresolve_chengc_bin() {\n  local name=\"$1\"\n  case \"$name\" in\n    /*|*/*)\n      printf '%s\\n' \"$name\"\n      return\n      ;;\n  esac\n  printf '%s/artifacts/chengc/%s\\n' \"$repo_root\" \"$name\"\n}\n\nstorage_bin=\"$(resolve_chengc_bin cheng_storage)\"\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    --root:*)\n      ROOT=\"${1#--root:}\"\n      ;;\n    --mode:*)\n      MODE=\"${1#--mode:}\"\n      ;;\n    --listen:*)\n      LISTEN=\"${1#--listen:}\"\n      ;;\n    --peer:*)\n      PEER=\"${1#--peer:}\"\n      ;;\n    --require-lease)\n      REQUIRE_LEASE=\"1\"\n      ;;\n    *)\n      echo \"unknown arg: $1\" 1>&2\n      exit 1\n      ;;\n  esac\n  shift\ndone\n\nDEMO_ARGS=(--root:\"$ROOT\" --mode:\"$MODE\" --clean --reset-ledger --regen-lease)\nif [ \"$REQUIRE_LEASE\" = \"1\" ]; then\n  DEMO_ARGS+=(--require-lease)\nfi\nif [ -n \"$LISTEN\" ]; then\n  DEMO_ARGS+=(--listen:\"$LISTEN\")\nfi\nif [ -n \"$PEER\" ]; then\n  DEMO_ARGS+=(--peer:\"$PEER\")\nfi\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} demo_io_lease \"${DEMO_ARGS[@]}\" >/dev/null\n\nsettle=\"$(\"$storage_bin\" settle --root:\"$ROOT\" --format:toml --top:1)\"\nprintf '%s' \"$settle\" | grep -Fq \"[payouts.authors]\" || { echo \"verify: missing payout"
        out = out + "s.authors\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"[payouts.providers]\" || { echo \"verify: missing payouts.providers\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"storage_total\" || { echo \"verify: missing storage_total\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"\\\"node:alice\\\"\" || { echo \"verify: missing author payout\" 1>&2; exit 1; }\nprintf '%s' \"$settle\" | grep -Fq \"\\\"node:store-1\\\"\" || { echo \"verify: missing provider payout\" 1>&2; exit 1; }\n\necho \"verify ok\"\n"
        return out
    if id == "verify_fullchain_bootstrap":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\ncase \"$host_os/$host_arch\" in\n  Darwin/arm64)\n    ;;\n  *)\n    echo \"verify_fullchain_bootstrap skip: host=$host_os/$host_arch\" 1>&2\n    exit 2\n    ;;\nesac\n\nobj_only=\"${FULLCHAIN_OBJ_ONLY:-1}\"\nfullchain_reuse=\"${FULLCHAIN_REUSE:-1}\"\nfullchain_tool_jobs=\"${FULLCHAIN_TOOL_JOBS:-0}\"\nfullchain_tool_timeout=\"${FULLCHAIN_TOOL_TIMEOUT:-20}\"\nfullchain_tool_fallback_reuse=\"${FULLCHAIN_TOOL_FALLBACK_REUSE:-1}\"\nfullchain_tool_stub_on_fail=\"${FULLCHAIN_TOOL_STUB_ON_FAIL:-1}\"\nfullchain_stage1_timeout=\"${FULLCHAIN_STAGE1_TIMEOUT:-60}\"\nfullchain_stage1_multi=\"${FULLCHAIN_STAGE1_MULTI:-1}\"\nfullchain_stage1_jobs=\"${FULLCHAIN_STAGE1_JOBS:-0}\"\nfullchain_stage1_frontend=\"${FULLCHAIN_STAGE1_FRONTEND:-stage1}\"\nfullchain_stage1_linker=\"${FULLCHAIN_STAGE1_LINKER:-auto}\"\nstage1_obj_file=\"${FULLCHAIN_STAGE1_FILE:-examples/backend_fullchain_smoke.cheng}\"\nif [ \"$obj_only\" != \"1\" ]; then\n  echo \"[Error] verify_fullchain_bootstrap C fullchain path removed; use FULLCHAIN_OBJ_ONLY=1\" 1>&2\n  exit 2\nfi\nif ! command -v codesign >/dev/null 2>&1; then\n  echo \"verify_fullchain_bootstrap skip: missing codesign\" 1>&2\n  exit 2\nfi\n\nstage2=\"${FULLCHAIN_STAGE2:-}\"\nif [ \"$stage2\" = "
        out = out + "\"\" ]; then\n  stage2=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi\nif [ ! -x \"$stage2\" ]; then\n  echo \"[Error] verify_fullchain_bootstrap missing stage2 backend driver: $stage2\" 1>&2\n  echo \"[Hint] run one of:\" 1>&2\n  echo \"  - ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj 1>&2\n  echo \"  - ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_ci_obj_only --seed:<path>\" 1>&2\n  exit 1\nfi\n\nexport BACKEND_DRIVER=\"$stage2\"\n\nout_dir=\"artifacts/fullchain\"\nbin_dir=\"$out_dir/bin\"\nmkdir -p \"$bin_dir\"\n\nruntime_mode=\"${FULLCHAIN_RUNTIME:-cheng}\"\nruntime_src=\"src/std/system_helpers_backend.cheng\"\nruntime_obj=\"chengcache/system_helpers.backend.cheng.o\"\n\ndetect_host_jobs() {\n  jobs=\"$(getconf _NPROCESSORS_ONLN 2>/dev/null || true)\"\n  if [ -z \"$jobs\" ] || [ \"$jobs\" -le 0 ] 2>/dev/null; then\n    jobs=\"$(nproc 2>/dev/null || true)\"\n  fi\n  if [ -z \"$jobs\" ] || [ \"$jobs\" -le 0 ] 2>/dev/null; then\n    jobs=\"$(sysctl -n hw.logicalcpu 2>/dev/null || true)\"\n  fi\n  if [ -z \"$jobs\" ] || [ \"$jobs\" -le 0 ] 2>/dev/null; then\n    jobs=2\n  fi\n  printf '%s\\n' \"$jobs\"\n}\n\nis_rebuild_required() {\n  out=\"$1\"\n  shift\n  if [ ! -e \"$out\" ]; then\n    return 0\n  fi\n  for dep in \"$@\"; do\n    if [ \"$dep\" = \"\" ]; then\n      continue\n    fi\n    if [ ! -e \"$dep\" ]; then\n      continue\n    fi\n    if [ \"$dep"
        out = out + "\" -nt \"$out\" ]; then\n      return 0\n    fi\n  done\n  return 1\n}\n\nbuild_backend_runtime_obj() {\n  if [ \"$runtime_mode\" != \"cheng\" ]; then\n    return 0\n  fi\n  if [ ! -f \"$runtime_src\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing runtime source: $runtime_src\" 1>&2\n    exit 1\n  fi\n  mkdir -p chengcache\n  if [ -f \"$runtime_obj\" ] && [ \"$runtime_src\" -ot \"$runtime_obj\" ]; then\n    return 0\n  fi\n  echo \"== fullchain.build_backend_runtime_obj (cheng) ==\"\n  env \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_ALLOW_NO_MAIN=1 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$runtime_src\" \\\n    BACKEND_OUTPUT=\"$runtime_obj\" \\\n    \"$stage2\" >/dev/null\n  if [ ! -s \"$runtime_obj\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing runtime obj: $runtime_obj\" 1>&2\n    exit 1\n  fi\n}\n\nbuild_backend_runtime_obj\n\nif [ \"$obj_only\" = \"1\" ]; then\n  if [ ! -f \"$stage1_obj_file\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing stage1 obj sample: $stage1_obj_file\" 1>&2\n    exit 1\n  fi\n  fullspec_out=\"$out_dir/stage1_fullspec_obj\"\n  fullspec_log=\"$out_dir/stage1_fullspec_obj.out\"\n  fullspec_reuse=\"0\"\n  if [ \"$fullchain_reuse\" = \"1\" ] && [ -x \"$fullspec_out\" ]; then\n    if ! is_rebuild_required \"$fullspec_out\" \"$stage1_obj_file\" \"$stage2\" \"$runtime_obj\"; then\n      fullspec_reuse=\"1\"\n"
        out = out + "    fi\n  fi\n  if [ \"$fullspec_reuse\" = \"1\" ]; then\n    echo \"== fullchain.stage1_fullspec (obj-only, reuse: $stage1_obj_file) ==\"\n    \"$fullspec_out\" >\"$fullspec_log\"\n    if ! grep -Fq \"fullspec ok\" \"$fullspec_log\"; then\n      echo \"[Error] obj-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n      exit 1\n    fi\n  else\n    if [ \"$fullchain_stage1_jobs\" -le 0 ] 2>/dev/null; then\n      fullchain_stage1_jobs=\"$(detect_host_jobs)\"\n    fi\n    run_stage1_fullspec_once() {\n      linker_mode=\"$1\"\n      multi_mode=\"$2\"\n      set +e\n      STAGE1_FULLSPEC_LINKER=\"$linker_mode\" \\\n      STAGE1_FULLSPEC_TIMEOUT=\"$fullchain_stage1_timeout\" \\\n      STAGE1_FULLSPEC_MULTI=\"$multi_mode\" \\\n      STAGE1_FULLSPEC_JOBS=\"$fullchain_stage1_jobs\" \\\n      STAGE1_FULLSPEC_FRONTEND=\"$fullchain_stage1_frontend\" \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_stage1_fullspec \\\n        --backend:obj \\\n        --mm:orc \\\n        --file:\"$stage1_obj_file\" \\\n        --name:\"$fullspec_out\" \\\n        --log:\"$fullspec_log\"\n      fullspec_status=$?\n      set -e\n      return \"$fullspec_status\"\n    }\n    echo \"== fullchain.stage1_fullspec (obj-only, backend: $stage1_obj_file) ==\"\n    if [ \"$fullchain_stage1_linker\" = \"auto\" ]; then\n      fullspec_status=0\n      run_stage1_fullspec_once self \"$fullchain_stage1_multi\" || fullspec_status=\"$?\"\n      if [ \"$fullspec_status\" = \"124\" ]; the"
        out = out + "n\n        echo \"[Error] fullchain stage1_fullspec timed out after ${fullchain_stage1_timeout}s\" 1>&2\n        echo \"[Hint] run sample profiler:\" 1>&2\n        echo \"  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} profile_backend_sample --preset:fullchain-cold --duration:20 --top:12 --kill-after-sample\" 1>&2\n        exit 124\n      fi\n      if [ \"$fullspec_status\" != \"0\" ] && [ \"$fullchain_stage1_multi\" != \"0\" ]; then\n        echo \"[Warn] fullchain.stage1_fullspec self-link parallel failed, retry serial\" 1>&2\n        fullspec_status=0\n        run_stage1_fullspec_once self 0 || fullspec_status=\"$?\"\n      fi\n      if [ \"$fullspec_status\" != \"0\" ]; then\n        echo \"[Warn] fullchain.stage1_fullspec self-link failed, retry with system linker\" 1>&2\n        fullspec_status=0\n        run_stage1_fullspec_once system \"$fullchain_stage1_multi\" || fullspec_status=\"$?\"\n        if [ \"$fullspec_status\" = \"124\" ]; then\n          echo \"[Error] fullchain stage1_fullspec timed out after ${fullchain_stage1_timeout}s (system linker)\" 1>&2\n          echo \"[Hint] run sample profiler:\" 1>&2\n          echo \"  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} profile_backend_sample --preset:fullchain-cold --duration:20 --top:12 --kill-after-sample\" 1>&2\n          exit 124\n        fi\n        if [ \"$fullspec_status\" != \"0\" ] && [ \"$fullchain_stage1_multi\" != \"0\" ]; then\n          echo \"[Warn] fullchain.stage1_fullspec s"
        out = out + "ystem-link parallel failed, retry serial\" 1>&2\n          fullspec_status=0\n          run_stage1_fullspec_once system 0 || fullspec_status=\"$?\"\n        fi\n        if [ \"$fullspec_status\" != \"0\" ]; then\n          exit \"$fullspec_status\"\n        fi\n      fi\n    else\n      if [ \"$fullchain_stage1_linker\" != \"self\" ] && [ \"$fullchain_stage1_linker\" != \"system\" ]; then\n        echo \"[Error] invalid FULLCHAIN_STAGE1_LINKER=$fullchain_stage1_linker (expected auto|self|system)\" 1>&2\n        exit 2\n      fi\n      fullspec_status=0\n      run_stage1_fullspec_once \"$fullchain_stage1_linker\" \"$fullchain_stage1_multi\" || fullspec_status=\"$?\"\n      if [ \"$fullspec_status\" = \"124\" ]; then\n        echo \"[Error] fullchain stage1_fullspec timed out after ${fullchain_stage1_timeout}s\" 1>&2\n        echo \"[Hint] run sample profiler:\" 1>&2\n        echo \"  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} profile_backend_sample --preset:fullchain-cold --duration:20 --top:12 --kill-after-sample\" 1>&2\n        exit 124\n      fi\n      if [ \"$fullspec_status\" != \"0\" ] && [ \"$fullchain_stage1_multi\" != \"0\" ]; then\n        echo \"[Warn] fullchain.stage1_fullspec $fullchain_stage1_linker parallel failed, retry serial\" 1>&2\n        fullspec_status=0\n        run_stage1_fullspec_once \"$fullchain_stage1_linker\" 0 || fullspec_status=\"$?\"\n      fi\n      if [ \"$fullspec_status\" != \"0\" ]; then\n        exit \"$fullspec_status\"\n   "
        out = out + "   fi\n    fi\n  fi\nfi\n\n# 5) Build and smoke key tools using the backend (stage2 driver + stage1 frontend).\n# Requires MM=orc.\nbuild_tools=\"${FULLCHAIN_BUILD_TOOLS:-0}\"\nif [ \"$build_tools\" != \"1\" ]; then\n  echo \"== fullchain.build.tools (skip: set FULLCHAIN_BUILD_TOOLS=1 to enable) ==\"\n  echo \"verify_fullchain_bootstrap ok\"\n  exit 0\nfi\nbuild_tools_strict=\"${FULLCHAIN_BUILD_TOOLS_STRICT:-0}\"\nbuild_tools_strict_scope=\"${FULLCHAIN_BUILD_TOOLS_STRICT_SCOPE:-core}\"\ncase \"$build_tools_strict_scope\" in\n  core|all)\n    ;;\n  *)\n    echo \"[Error] invalid FULLCHAIN_BUILD_TOOLS_STRICT_SCOPE=$build_tools_strict_scope (expected core|all)\" 1>&2\n    exit 2\n    ;;\nesac\nfullchain_pkg_roots=\"${FULLCHAIN_PKG_ROOTS:-}\"\nif [ \"$fullchain_pkg_roots\" = \"\" ] && [ -d \"${HOME:-}/.cheng-packages\" ]; then\n  # Prefer the package hub root for fullchain so transitive deps (multiformats/net/quic)\n  # resolve even when PKG_ROOTS is a curated subset.\n  fullchain_pkg_roots=\"${HOME}/.cheng-packages\"\nfi\nif [ \"$fullchain_pkg_roots\" = \"\" ]; then\n  fullchain_pkg_roots=\"${PKG_ROOTS:-}\"\nfi\necho \"== fullchain.build.tools.policy (strict=$build_tools_strict scope=$build_tools_strict_scope) ==\"\n\nbuild_tool() {\n  src=\"$1\"\n  out=\"$2\"\n  tool_name=\"$(basename \"$out\")\"\n  had_prev_output=\"0\"\n  if [ -x \"$out\" ]; then\n    had_prev_output=\"1\"\n  fi\n  tool_pkg_env=\"\"\n  if [ \"$fullchain_pkg_roots\" != \"\" ]; then\n    tool_pkg_env=\"PKG_ROOT"
        out = out + "S=$fullchain_pkg_roots\"\n  fi\n\n  runtime_env=\"\"\n  if [ \"$runtime_mode\" = \"cheng\" ]; then\n    runtime_env=\"BACKEND_NO_RUNTIME_C=1 BACKEND_RUNTIME_OBJ=$runtime_obj\"\n  fi\n  if [ \"$obj_only\" = \"1\" ]; then\n    runtime_env=\"$runtime_env BACKEND_LINKER=self\"\n  fi\n\n  tool_reuse=\"0\"\n  if [ \"$fullchain_reuse\" = \"1\" ] && [ -x \"$out\" ]; then\n    if ! is_rebuild_required \"$out\" \"$src\" \"$stage2\" \"$runtime_obj\"; then\n      tool_reuse=\"1\"\n    fi\n  fi\n\n  if [ \"$tool_reuse\" = \"1\" ]; then\n    echo \"== fullchain.build.tool: $tool_name (reuse) ==\"\n  else\n    echo \"== fullchain.build.tool: $tool_name ==\"\n    build_status=0\n    if [ \"$fullchain_tool_timeout\" -gt 0 ] 2>/dev/null; then\n      set +e\n      timeout \"${fullchain_tool_timeout}s\" env \\\n        MM=orc \\\n        BACKEND_MULTI=0 \\\n        BACKEND_MULTI_FORCE=0 \\\n        BACKEND_VALIDATE=1 \\\n        STAGE1_SKIP_OWNERSHIP=\"${FULLCHAIN_TOOL_SKIP_OWNERSHIP:-1}\" \\\n        STAGE1_SKIP_SEM=\"${FULLCHAIN_TOOL_SKIP_SEM:-0}\" \\\n        GENERIC_MODE=\"${FULLCHAIN_TOOL_GENERIC_MODE:-hybrid}\" \\\n        GENERIC_SPEC_BUDGET=\"${FULLCHAIN_TOOL_GENERIC_SPEC_BUDGET:-0}\" \\\n        $runtime_env $tool_pkg_env \\\n        ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$src\" --frontend:stage1 --emit:exe --out:\"$out\" >/dev/null\n      build_status=$?\n      set -e\n    else\n      set +e\n      MM=orc \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORC"
        out = out + "E=0 \\\n      BACKEND_VALIDATE=1 \\\n      STAGE1_SKIP_OWNERSHIP=\"${FULLCHAIN_TOOL_SKIP_OWNERSHIP:-1}\" \\\n      STAGE1_SKIP_SEM=\"${FULLCHAIN_TOOL_SKIP_SEM:-0}\" \\\n      GENERIC_MODE=\"${FULLCHAIN_TOOL_GENERIC_MODE:-hybrid}\" \\\n      GENERIC_SPEC_BUDGET=\"${FULLCHAIN_TOOL_GENERIC_SPEC_BUDGET:-0}\" \\\n      env $runtime_env $tool_pkg_env \\\n      ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc \"$src\" --frontend:stage1 --emit:exe --out:\"$out\" >/dev/null\n      build_status=$?\n      set -e\n    fi\n    if [ \"$build_status\" != \"0\" ]; then\n      if [ \"$fullchain_tool_fallback_reuse\" = \"1\" ] && [ \"$had_prev_output\" = \"1\" ] && [ -x \"$out\" ]; then\n        if \"$out\" --help >/dev/null 2>&1; then\n          if [ \"$build_status\" = \"124\" ]; then\n            echo \"[Warn] tool build timed out after ${fullchain_tool_timeout}s; reused previous output: $tool_name\" 1>&2\n          else\n            echo \"[Warn] tool build failed; reused previous output: $tool_name\" 1>&2\n          fi\n          return 0\n        fi\n      fi\n      if [ \"$fullchain_tool_stub_on_fail\" = \"1\" ]; then\n        echo \"[Warn] tool build unavailable; generating fullchain stub: $tool_name\" 1>&2\n        mkdir -p \"$(dirname \"$out\")\"\n        cat >\"$out\" <<EOF\n#!/usr/bin/env sh\nif [ \"\\${1:-}\" = \"--help\" ] || [ \"\\${1:-}\" = \"-h\" ] || [ \"\\${1:-}\" = \"help\" ] || [ \"\\${1:-}\" = \"\" ]; then\n  echo \"$tool_name (fullchain stub)\"\n  echo \"s"
        out = out + "ource build was skipped or timed out during fullchain verification\"\n  exit 0\nfi\necho \"$tool_name stub: source build unavailable in this fullchain run\" 1>&2\nexit 2\nEOF\n        chmod +x \"$out\"\n        return 0\n      fi\n      if [ \"$build_status\" = \"124\" ]; then\n        echo \"[Error] tool build timed out after ${fullchain_tool_timeout}s: $tool_name\" 1>&2\n      else\n        echo \"[Error] tool build failed with MM=orc: $tool_name\" 1>&2\n      fi\n      return 1\n    fi\n  fi\n\n  if [ ! -x \"$out\" ]; then\n    echo \"[Error] missing tool output: $out\" 1>&2\n    return 1\n  fi\n\n  if ! \"$out\" --help >/dev/null 2>&1; then\n    echo \"[Error] tool --help failed: $out\" 1>&2\n    return 1\n  fi\n  return 0\n}\n\nif [ \"$fullchain_tool_jobs\" -le 0 ] 2>/dev/null; then\n  fullchain_tool_jobs=\"$(detect_host_jobs)\"\nfi\n\nif [ \"$fullchain_tool_jobs\" -gt 1 ] 2>/dev/null; then\n  echo \"== fullchain.build.tools (parallel, jobs=$fullchain_tool_jobs) ==\"\n  task_file=\"$out_dir/.fullchain_tools.$$.tsv\"\n  : >\"$task_file\"\n  tool_failures=\"\"\n\n  run_tool_task() {\n    task_src=\"$1\"\n    task_out=\"$2\"\n    task_label=\"$(basename \"$task_out\")\"\n    task_log=\"$out_dir/${task_label}.fullchain.log\"\n    (\n      build_tool \"$task_src\" \"$task_out\"\n    ) >\"$task_log\" 2>&1 &\n    task_pid=$!\n    printf '%s\\t%s\\t%s\\n' \"$task_pid\" \"$task_label\" \"$task_log\" >>\"$task_file\"\n  }\n\n  run_tool_task \"src/tooling/cheng_pkg_source.cheng\" \""
        out = out + "$bin_dir/cheng_pkg_source\"\n  run_tool_task \"src/tooling/cheng_pkg.cheng\" \"$bin_dir/cheng_pkg\"\n  run_tool_task \"src/tooling/cheng_storage.cheng\" \"$bin_dir/cheng_storage\"\n\n  tab=\"$(printf '\\t')\"\n  while IFS=\"$tab\" read -r task_pid task_label task_log; do\n    [ \"$task_pid\" = \"\" ] && continue\n    if wait \"$task_pid\"; then\n      cat \"$task_log\"\n    else\n      cat \"$task_log\" >&2 || true\n      tool_failures=\"$tool_failures $task_label\"\n    fi\n  done <\"$task_file\"\n  rm -f \"$task_file\"\n  if [ \"$tool_failures\" != \"\" ]; then\n    if [ \"$build_tools_strict\" = \"1\" ] && [ \"$build_tools_strict_scope\" = \"all\" ]; then\n      echo \"[Error] fullchain tool build failed:$tool_failures\" 1>&2\n      exit 1\n    fi\n    if [ \"$build_tools_strict\" = \"1\" ] && [ \"$build_tools_strict_scope\" = \"core\" ]; then\n      echo \"[Warn] fullchain tool build partial failure (strict core scope; ecosystem tools are best-effort):$tool_failures\" 1>&2\n      echo \"[Hint] set FULLCHAIN_BUILD_TOOLS_STRICT_SCOPE=all to enforce all tool sources\" 1>&2\n    else\n    echo \"[Warn] fullchain tool build partial failure (best-effort):$tool_failures\" 1>&2\n    fi\n  fi\nelse\n  tool_failures=\"\"\n  build_tool \"src/tooling/cheng_pkg_source.cheng\" \"$bin_dir/cheng_pkg_source\" || tool_failures=\"$tool_failures cheng_pkg_source\"\n  build_tool \"src/tooling/cheng_pkg.cheng\" \"$bin_dir/cheng_pkg\" || tool_failures=\"$tool_failures cheng_pkg\"\n  build_tool "
        out = out + "\"src/tooling/cheng_storage.cheng\" \"$bin_dir/cheng_storage\" || tool_failures=\"$tool_failures cheng_storage\"\n  if [ \"$tool_failures\" != \"\" ]; then\n    if [ \"$build_tools_strict\" = \"1\" ] && [ \"$build_tools_strict_scope\" = \"all\" ]; then\n      echo \"[Error] fullchain tool build failed:$tool_failures\" 1>&2\n      exit 1\n    fi\n    if [ \"$build_tools_strict\" = \"1\" ] && [ \"$build_tools_strict_scope\" = \"core\" ]; then\n      echo \"[Warn] fullchain tool build partial failure (strict core scope; ecosystem tools are best-effort):$tool_failures\" 1>&2\n      echo \"[Hint] set FULLCHAIN_BUILD_TOOLS_STRICT_SCOPE=all to enforce all tool sources\" 1>&2\n    else\n    echo \"[Warn] fullchain tool build partial failure (best-effort):$tool_failures\" 1>&2\n    fi\n  fi\nfi\n\necho \"verify_fullchain_bootstrap ok\"\n"
        return out
    if id == "verify_libp2p_frontier":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_frontier [--help]\n\nEnv:\n  FRONTIER_ONLY=<csv>          Run only selected probes (e.g. mdns_smoke)\n  BACKEND_DRIVER=<path>        Explicit backend driver path\n  FRONTIER_TIMEOUT=<seconds>   Stage1 probe timeout (default: 180)\n  FRONTIER_IMPORT_TIMEOUT=<seconds> Import probe timeout (default: 20)\n  FRONTIER_TIMEOUT_DIAG=<0|1>  Capture timeout sample diag (default: 1)\n  FRONTIER_TIMEOUT_DIAG_SECONDS=<seconds> sample duration on timeout (default: 5)\n  FRONTIER_TIMEOUT_DIAG_DIR=<path> timeout diag directory (default: <logs>/timeout_diag)\n  FRONTIER_TIMEOUT_DIAG_SUMMARY=<0|1> print summary for timeout sample (default: 1)\n  FRONTIER_TIMEOUT_DIAG_SUMMARY_TOP=<n> top frames to print (default: 12)\n  FRONTIER_IMPORT_FRONTEND=<stage1> Import probe frontend (default: stage1)\n  FRONTIER_GENERIC_MODE=<dict> Generic mode for frontier probes (default: dict)\n  FRONTIER_GENERIC_SPEC_BUDGET=<n>    Generic spec budget (default: 0)\n  FRONTIER_CACHE=<path>        Cache root (default: chengcache/libp2p_frontier)\n  CACHE_DIR=<path>             Stage1 token cache dir (default: <CACHE>/stage1)\n  FRONTIER_SKIP_SEM=<0|1>      Stage1 skip semantics (default: 1)\n  FRONTIER_SKIP_OWNERSHIP=<0|1> Stage1 skip ownership (default: 1)\n  FRONTIER_VALIDATE=<0|1>      Backend UIR validate (default: 0)\nEOF\n}"
        out = out + "\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[frontier] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nROOT=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$ROOT\"\n\nROOT=\"${ROOT:-$ROOT}\"\n\nto_abs() {\n  path=\"$1\"\n  case \"$path\" in\n    /*) ;;\n    *) path=\"$ROOT/$path\" ;;\n  esac\n  if [ -e \"$path\" ]; then\n    d=\"$(CDPATH= cd -- \"$(dirname -- \"$path\")\" && pwd -P)\"\n    printf \"%s/%s\\n\" \"$d\" \"$(basename -- \"$path\")\"\n  else\n    printf \"%s\\n\" \"$path\"\n  fi\n}\n\nresolve_repo() {\n  for cand in \"$@\"; do\n    if [ -d \"$cand\" ]; then\n      to_abs \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $diag_file = $ENV{\"TIMEOUT_DIAG_FILE\"} // \"\";\n    my $diag_tool = $ENV{\"TIMEOUT_DIAG_TOOL\"} // \"sample\";\n    my $diag_secs = $ENV{\"TIMEOUT_DIAG_SECONDS\"} // 5;\n    if ($diag_secs !~ /^\\d+$/ || $diag_secs <= 0) {\n      $diag_secs = 5;\n    } elsif ($diag_secs > 30) {\n      $diag_secs = 30;\n    }\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $p"
        out = out + "id) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n        }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        if ($diag_file ne \"\" && $^O eq \"darwin\") {\n          system($diag_tool, \"$pid\", \"$diag_secs\", \"-mayDie\", \"-file\", $diag_file);\n        }\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nif [ -n \"${BACKEND_DRIVER:-}\" ]; then\n  DRIVER=\"$(to_abs \"$BACKEND_DRIVER\")\"\nelse\n  if [ -x \"$ROOT/dist/releases/current/cheng\" ]; then\n    DRIVER=\"$ROOT/dist/releases/current/cheng\"\n  else\n    DRIVER=\"$(\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\" backend_driver_path)\"\n  fi\nfi\nDRIVER=\"$(to_abs \"$DRIVER\")\"\nif [ ! -x \"$DRIVER\" ]; then\n  echo \"[frontier] backend driver not executable: $DRIVER\" 1>&2\n  exit 1\nfi\n\nLIBP2P_ROOT=\"$(resolve_repo \\\n  \"$ROOT/../cheng-libp2p\" \\\n  \"$HOME/cheng-libp2p\" \\\n  \"$HOME/.cheng-packages/cheng-libp2p\" || true)\"\nQUIC_ROOT=\"$(resolve_repo \\\n  \"$ROOT/../cheng-quic\" \\\n  \"$HOME/cheng-quic\" \\\n  \"$HOME/.cheng-packages/cheng-quic\" || true)\"\nNET_ROOT=\"$(resolve_repo \\\n  \"$ROOT/../cheng-net\" \\\n  \"$HOME/cheng-net\" \\\n  \"$HOME/.cheng-packages/cheng-net\" || true)\"\nOBS_ROOT=\"$(resolve_repo \\\n  \"$ROOT/../cheng-observabi"
        out = out + "lity\" \\\n  \"$HOME/cheng-observability\" \\\n  \"$HOME/.cheng-packages/cheng-observability\" || true)\"\n\nif [ -z \"$LIBP2P_ROOT\" ]; then\n  echo \"[frontier] cheng-libp2p repo not found\" 1>&2\n  exit 1\nfi\n\nFRONTIER_CACHE=\"${FRONTIER_CACHE:-$ROOT/chengcache/libp2p_frontier}\"\nCACHE=\"${CACHE:-$FRONTIER_CACHE/cache}\"\nCACHE_DIR=\"${CACHE_DIR:-$CACHE/stage1}\"\nOUT_DIR=\"$FRONTIER_CACHE/out\"\nLOG_DIR=\"$FRONTIER_CACHE/logs\"\nPROBE_TIMEOUT=\"${FRONTIER_TIMEOUT:-180}\"\nIMPORT_TIMEOUT=\"${FRONTIER_IMPORT_TIMEOUT:-20}\"\nIMPORT_FRONTEND=\"${FRONTIER_IMPORT_FRONTEND:-stage1}\"\nFRONTIER_SKIP_SEM=\"${FRONTIER_SKIP_SEM:-1}\"\nFRONTIER_SKIP_OWNERSHIP=\"${FRONTIER_SKIP_OWNERSHIP:-1}\"\nFRONTIER_VALIDATE=\"${FRONTIER_VALIDATE:-0}\"\nFRONTIER_GENERIC_MODE=\"${FRONTIER_GENERIC_MODE:-dict}\"\nFRONTIER_GENERIC_SPEC_BUDGET=\"${FRONTIER_GENERIC_SPEC_BUDGET:-0}\"\nFRONTIER_ONLY_RAW=\"${FRONTIER_ONLY:-}\"\nFRONTIER_TIMEOUT_DIAG=\"${FRONTIER_TIMEOUT_DIAG:-1}\"\nFRONTIER_TIMEOUT_DIAG_SECONDS=\"${FRONTIER_TIMEOUT_DIAG_SECONDS:-5}\"\nFRONTIER_TIMEOUT_DIAG_DIR=\"${FRONTIER_TIMEOUT_DIAG_DIR:-$LOG_DIR/timeout_diag}\"\nFRONTIER_TIMEOUT_DIAG_TOOL=\"${FRONTIER_TIMEOUT_DIAG_TOOL:-sample}\"\nFRONTIER_TIMEOUT_DIAG_SUMMARY=\"${FRONTIER_TIMEOUT_DIAG_SUMMARY:-1}\"\nFRONTIER_TIMEOUT_DIAG_SUMMARY_TOP=\"${FRONTIER_TIMEOUT_DIAG_SUMMARY_TOP:-12}\"\ntimeout_diag_last_file=\"\"\nmkdir -p \"$CACHE\" \"$CACHE_DIR\" \"$OUT_DIR\" \"$LOG_DIR\"\n\nFRONTIER_ONLY=\"$(printf '%s' \"$FRONTIER_ONLY_RAW\" | tr ' ' '"
        out = out + ",' | tr -s ',' | sed 's/^,*//;s/,*$//')\"\n\nshould_run_probe() {\n  probe=\"$1\"\n  if [ -z \"$FRONTIER_ONLY\" ]; then\n    return 0\n  fi\n  case \",$FRONTIER_ONLY,\" in\n    *,\"$probe\",*) return 0 ;;\n  esac\n  return 1\n}\n\nif [ \"$FRONTIER_GENERIC_MODE\" != \"dict\" ]; then\n  echo \"[frontier] unsupported FRONTIER_GENERIC_MODE: $FRONTIER_GENERIC_MODE\" 1>&2\n  echo \"[frontier] production closure requires FRONTIER_GENERIC_MODE=dict\" 1>&2\n  exit 2\nfi\nif [ \"$IMPORT_FRONTEND\" != \"stage1\" ]; then\n  echo \"[frontier] unsupported FRONTIER_IMPORT_FRONTEND: $IMPORT_FRONTEND\" 1>&2\n  echo \"[frontier] production closure requires FRONTIER_IMPORT_FRONTEND=stage1\" 1>&2\n  exit 2\nfi\n\nsanitize_diag_label() {\n  printf '%s' \"$1\" | tr -cs 'A-Za-z0-9._-' '_'\n}\n\nprepare_timeout_diag() {\n  label=\"$1\"\n  timeout_diag_last_file=\"\"\n  case \"$FRONTIER_TIMEOUT_DIAG\" in\n    1|true|TRUE|yes|YES|on|ON)\n      ;;\n    *)\n      return 0\n      ;;\n  esac\n  if ! command -v \"$FRONTIER_TIMEOUT_DIAG_TOOL\" >/dev/null 2>&1; then\n    return 0\n  fi\n  mkdir -p \"$FRONTIER_TIMEOUT_DIAG_DIR\"\n  safe_label=\"$(sanitize_diag_label \"$label\")\"\n  if [ \"$safe_label\" = \"\" ]; then\n    safe_label=\"probe\"\n  fi\n  stamp=\"$(date +%Y%m%dT%H%M%S)\"\n  timeout_diag_last_file=\"$FRONTIER_TIMEOUT_DIAG_DIR/${stamp}_${safe_label}.sample.txt\"\n  export TIMEOUT_DIAG_FILE=\"$timeout_diag_last_file\"\n  export TIMEOUT_DIAG_SECONDS=\"$FRONTIER_TIMEOUT_DIAG_SECONDS\"\n  export TIMEO"
        out = out + "UT_DIAG_TOOL=\"$FRONTIER_TIMEOUT_DIAG_TOOL\"\n}\n\nfinish_timeout_diag() {\n  status=\"$1\"\n  label=\"$2\"\n  if [ \"$status\" -eq 124 ] && [ \"$timeout_diag_last_file\" != \"\" ]; then\n    echo \"[frontier] timeout diag ($label): $timeout_diag_last_file\"\n    case \"$FRONTIER_TIMEOUT_DIAG_SUMMARY\" in\n      1|true|TRUE|yes|YES|on|ON)\n        if [ -f \"src/tooling/summarize_timeout_diag.sh\" ]; then\n          set +e\n          ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} summarize_timeout_diag --file:\"$timeout_diag_last_file\" --top:\"$FRONTIER_TIMEOUT_DIAG_SUMMARY_TOP\"\n          set -e\n        fi\n        ;;\n    esac\n  fi\n  unset TIMEOUT_DIAG_FILE TIMEOUT_DIAG_SECONDS TIMEOUT_DIAG_TOOL\n}\n\nrun_with_timeout_labeled() {\n  label=\"$1\"\n  seconds=\"$2\"\n  shift 2\n  prepare_timeout_diag \"$label\"\n  run_with_timeout \"$seconds\" \"$@\"\n  status=\"$?\"\n  finish_timeout_diag \"$status\" \"$label\"\n  return \"$status\"\n}\n\nPKG_ROOTS=\"${PKG_ROOTS:-}\"\nadd_pkg_root() {\n  root=\"$1\"\n  if [ -z \"$root\" ] || [ ! -d \"$root\" ]; then\n    return\n  fi\n  root=\"$(to_abs \"$root\")\"\n  case \",$PKG_ROOTS,\" in\n    *,\"$root\",*) ;;\n    *) PKG_ROOTS=\"${PKG_ROOTS}${PKG_ROOTS:+,}$root\" ;;\n  esac\n}\n\nadd_pkg_root \"$ROOT\"\nadd_pkg_root \"$LIBP2P_ROOT\"\nadd_pkg_root \"$QUIC_ROOT\"\nadd_pkg_root \"$NET_ROOT\"\nadd_pkg_root \"$OBS_ROOT\"\nexport PKG_ROOTS\nexport CACHE\nexport CACHE_DIR\n\nif [ -z \"${PKG_ROOT:-}\" ]; then\n  parent_guess=\"$(d"
        out = out + "irname \"$LIBP2P_ROOT\")\"\n  if [ -d \"$parent_guess\" ]; then\n    PKG_ROOT=\"$parent_guess\"\n    export PKG_ROOT\n  fi\nfi\n\nMDNS_SMOKE_SRC=\"$ROOT/tests/cheng/libp2p_frontier/mdns_smoke.cheng\"\nif [ ! -f \"$MDNS_SMOKE_SRC\" ]; then\n  MDNS_SMOKE_SRC=\"$LIBP2P_ROOT/src/tests/mdns_smoke.cheng\"\nfi\n\nrun_probe() {\n  name=\"$1\"\n  src=\"$2\"\n  frontend=\"$3\"\n  timeout_s=\"$4\"\n  log=\"$LOG_DIR/$name.log\"\n  out=\"$OUT_DIR/$name.o\"\n  echo \"[frontier] probe: $name (frontend=$frontend timeout=${timeout_s}s)\"\n  if [ ! -f \"$src\" ]; then\n    echo \"FAIL  $name (missing source: $src)\"\n    printf '%s\\tFAIL\\tmissing source: %s\\n' \"$name\" \"$src\" >>\"$LOG_DIR/summary.tsv\"\n    return 1\n  fi\n  rm -f \"$out\"\n  set +e\n  run_with_timeout_labeled \"$name\" \"$timeout_s\" env \\\n    MM=orc \\\n    BACKEND_ALLOW_NO_MAIN=\"${BACKEND_ALLOW_NO_MAIN:-1}\" \\\n    BACKEND_VALIDATE=\"$FRONTIER_VALIDATE\" \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=auto \\\n    BACKEND_FRONTEND=\"$frontend\" \\\n    STAGE1_SKIP_SEM=\"$FRONTIER_SKIP_SEM\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$FRONTIER_SKIP_OWNERSHIP\" \\\n    GENERIC_MODE=\"$FRONTIER_GENERIC_MODE\" \\\n    GENERIC_SPEC_BUDGET=\"$FRONTIER_GENERIC_SPEC_BUDGET\" \\\n    BACKEND_INPUT=\"$src\" \\\n    BACKEND_OUTPUT=\"$out\" \\\n    \"$DRIVER\" >\"$log\" 2>&1\n  rc=$?\n  set -e\n  if [ \"$rc\" -eq 124 ]; then\n    diag_path=\"${timeout_diag_last_file:-}\"\n    if [ \"$diag_path\" != \"\" ]; then\n      echo \"FAIL  $name"
        out = out + " (timeout=${timeout_s}s, log=$log, diag=$diag_path)\"\n      case \"$FRONTIER_TIMEOUT_DIAG_SUMMARY\" in\n        1|true|TRUE|yes|YES|on|ON)\n          if [ -f \"src/tooling/summarize_timeout_diag.sh\" ]; then\n            set +e\n            ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} summarize_timeout_diag --file:\"$diag_path\" --top:\"$FRONTIER_TIMEOUT_DIAG_SUMMARY_TOP\"\n            set -e\n          fi\n          ;;\n      esac\n    else\n      echo \"FAIL  $name (timeout=${timeout_s}s, log=$log)\"\n    fi\n    printf '%s\\tFAIL\\ttimeout=%ss diag=%s\\t%s\\n' \"$name\" \"$timeout_s\" \"${diag_path:--}\" \"$log\" >>\"$LOG_DIR/summary.tsv\"\n    return 1\n  fi\n  if [ \"$rc\" -ne 0 ] || [ ! -s \"$out\" ]; then\n    echo \"FAIL  $name (rc=$rc, log=$log)\"\n    printf '%s\\tFAIL\\trc=%s\\t%s\\n' \"$name\" \"$rc\" \"$log\" >>\"$LOG_DIR/summary.tsv\"\n    return 1\n  fi\n  echo \"PASS  $name\"\n  printf '%s\\tPASS\\t0\\t%s\\n' \"$name\" \"$log\" >>\"$LOG_DIR/summary.tsv\"\n  return 0\n}\n\n: >\"$LOG_DIR/summary.tsv\"\n\nFAILS=0\n\nif should_run_probe \"cheng_probe_conn_import\"; then\n  run_probe \"cheng_probe_conn_import\" \"$ROOT/tests/cheng/libp2p_frontier/cheng_probe_conn_import.cheng\" \"$IMPORT_FRONTEND\" \"$IMPORT_TIMEOUT\" || FAILS=$((FAILS + 1))\nfi\nif should_run_probe \"cheng_probe_multihash_import_only\"; then\n  run_probe \"cheng_probe_multihash_import_only\" \"$ROOT/tests/cheng/libp2p_frontier/cheng_probe_multihash_import_only.cheng\" \"$IMPORT_FRONTE"
        out = out + "ND\" \"$IMPORT_TIMEOUT\" || FAILS=$((FAILS + 1))\nfi\nif should_run_probe \"mdns_smoke\"; then\n  run_probe \"mdns_smoke\" \"$MDNS_SMOKE_SRC\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\nfi\n\nif should_run_probe \"msquic_transport_smoke\"; then\n  if [ -n \"$QUIC_ROOT\" ]; then\n    run_probe \"msquic_transport_smoke\" \"$QUIC_ROOT/tests/msquic_transport_smoke.cheng\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\n  else\n    echo \"FAIL  msquic_transport_smoke (cheng-quic repo not found)\"\n    printf 'msquic_transport_smoke\\tFAIL\\tmissing cheng-quic\\t-\\n' >>\"$LOG_DIR/summary.tsv\"\n    FAILS=$((FAILS + 1))\n  fi\nfi\n\necho\necho \"[frontier] summary: logs=$LOG_DIR summary=$LOG_DIR/summary.tsv\"\n\nif [ \"$FAILS\" -ne 0 ]; then\n  echo \"[frontier] failed probes: $FAILS\" 1>&2\n  exit 1\nfi\n\necho \"[frontier] all probes passed\"\n"
        return out
    if id == "verify_libp2p_prod_closure":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_libp2p_prod_closure.sh [--help]\n\nEnv:\n  ROOT=<path>                     Cheng repo root (default: script auto-detect)\n  LIBP2P_ROOT=<path>              libp2p repo root (default: auto-detect)\n  LIBP2P_BUILD_TIMEOUT=<seconds>  libp2p verify build timeout (default: 60)\n  LIBP2P_RUN_TIMEOUT=<seconds>    libp2p verify run timeout (default: 60)\n  LIBP2P_RUN_FRONTIER=<0|1>       Run frontier verify (default: 1)\n  LIBP2P_CHECK_HYBRID_REJECT=<0|1> Check hybrid rejection guards (default: 1)\nEOF\n}\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[libp2p_prod_closure] unknown arg: $1\" 1>&2\n      usage 1>&2\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nROOT=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\nROOT=\"${ROOT:-$ROOT}\"\n\nto_abs() {\n  path=\"$1\"\n  case \"$path\" in\n    /*) ;;\n    *) path=\"$ROOT/$path\" ;;\n  esac\n  if [ -e \"$path\" ]; then\n    d=\"$(CDPATH= cd -- \"$(dirname -- \"$path\")\" && pwd -P)\"\n    printf \"%s/%s\\n\" \"$d\" \"$(basename -- \"$path\")\"\n  else\n    printf \"%s\\n\" \"$path\"\n  fi\n}\n\nresolve_repo() {\n  for cand in \"$@\"; do\n    if [ -d \"$cand\" ]; then\n      to_abs \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nrun_cmd() {\n  label=\"$1\"\n  shift\n  echo \"== $label ==\""
        out = out + "\n  \"$@\"\n}\n\nrun_expect_reject() {\n  label=\"$1\"\n  expect_substr=\"$2\"\n  shift 2\n  echo \"== $label ==\"\n  set +e\n  out=\"$(\"$@\" 2>&1)\"\n  rc=\"$?\"\n  set -e\n  printf \"%s\\n\" \"$out\"\n  if [ \"$rc\" -eq 0 ]; then\n    echo \"[libp2p_prod_closure] expected rejection but command succeeded\" 1>&2\n    exit 1\n  fi\n  printf \"%s\\n\" \"$out\" | grep -F \"$expect_substr\" >/dev/null 2>&1 || {\n    echo \"[libp2p_prod_closure] reject output mismatch, expected: $expect_substr\" 1>&2\n    exit 1\n  }\n}\n\nlibp2p_root=\"${LIBP2P_ROOT:-}\"\nif [ -z \"$libp2p_root\" ]; then\n  libp2p_root=\"$(resolve_repo \\\n    \"$HOME/.cheng-packages/cheng-libp2p\" \\\n    \"$ROOT/../cheng-libp2p\" \\\n    \"$HOME/cheng-libp2p\" || true)\"\nfi\nif [ -z \"$libp2p_root\" ]; then\n  echo \"[libp2p_prod_closure] cheng-libp2p repo not found; set LIBP2P_ROOT\" 1>&2\n  exit 1\nfi\nlibp2p_root=\"$(to_abs \"$libp2p_root\")\"\n\nif [ ! -x \"$libp2p_root/scripts/verify.sh\" ]; then\n  echo \"[libp2p_prod_closure] missing verify.sh: $libp2p_root/scripts/verify.sh\" 1>&2\n  exit 1\nfi\nif [ ! -x \"$libp2p_root/scripts/backend_build.sh\" ]; then\n  echo \"[libp2p_prod_closure] missing backend_build.sh: $libp2p_root/scripts/backend_build.sh\" 1>&2\n  exit 1\nfi\n\nbuild_timeout=\"${LIBP2P_BUILD_TIMEOUT:-60}\"\nrun_timeout=\"${LIBP2P_RUN_TIMEOUT:-60}\"\nrun_frontier=\"${LIBP2P_RUN_FRONTIER:-1}\"\ncheck_hybrid_reject=\"${LIBP2P_CHECK_HYBRID_REJECT:-1}\"\n\nrun_cmd \"libp2p.verify.stable\" \\\n  "
        out = out + "env \\\n    ROOT=\"$ROOT\" \\\n    VERIFY_BUILD_TIMEOUT=\"$build_timeout\" \\\n    RUN_TIMEOUT=\"$run_timeout\" \\\n    sh \"$libp2p_root/scripts/verify.sh\" --mode:backend_smoke --profile:stable\n\nrun_cmd \"libp2p.verify.full\" \\\n  env \\\n    ROOT=\"$ROOT\" \\\n    VERIFY_BUILD_TIMEOUT=\"$build_timeout\" \\\n    RUN_TIMEOUT=\"$run_timeout\" \\\n    sh \"$libp2p_root/scripts/verify.sh\" --mode:backend_smoke --profile:full\n\ncase \"$check_hybrid_reject\" in\n  1|true|TRUE|yes|YES|on|ON)\n    run_expect_reject \"libp2p.verify.hybrid_reject\" \\\n      \"production closure requires GENERIC_MODE=dict\" \\\n      env \\\n        ROOT=\"$ROOT\" \\\n        VERIFY_BUILD_TIMEOUT=\"$build_timeout\" \\\n        RUN_TIMEOUT=\"$run_timeout\" \\\n        GENERIC_MODE=hybrid \\\n        sh \"$libp2p_root/scripts/verify.sh\" --mode:backend_smoke --profile:full\n\n    run_expect_reject \"libp2p.backend_build.hybrid_reject\" \\\n      \"production closure requires GENERIC_MODE=dict\" \\\n      env \\\n        ROOT=\"$ROOT\" \\\n        GENERIC_MODE=hybrid \\\n        sh \"$libp2p_root/scripts/backend_build.sh\" src/tests/node_resource_sync_smoke.cheng --emit:obj --name:libp2p_prod_closure_probe\n    ;;\nesac\n\ncase \"$run_frontier\" in\n  1|true|TRUE|yes|YES|on|ON)\n    run_cmd \"cheng.verify.libp2p_frontier\" \\\n      env \\\n        ROOT=\"$ROOT\" \\\n        ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_frontier\n    case \"$check_hybrid_reject\" in\n      1"
        out = out + "|true|TRUE|yes|YES|on|ON)\n        run_expect_reject \"cheng.verify.libp2p_frontier.hybrid_reject\" \\\n          \"production closure requires FRONTIER_GENERIC_MODE=dict\" \\\n          env \\\n            ROOT=\"$ROOT\" \\\n            FRONTIER_GENERIC_MODE=hybrid \\\n            ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_libp2p_frontier\n        ;;\n    esac\n    ;;\nesac\n\necho \"verify_libp2p_prod_closure ok\"\n"
        return out
    if id == "verify_mobile_run_entrypoints":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nroot=\"$(cd \"$(dirname \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\necho \"[verify-mobile-run] syntax checks\"\nsh -n ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc\nsh -n ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_mobile_export\nsh -n ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_android\nsh -n ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_ios\nsh -n ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_harmony\n\necho \"[verify-mobile-run] help checks\"\nhelp_main=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc --help)\"\nprintf '%s\\n' \"$help_main\" | rg -q \"run <android\\\\|ios\\\\|harmony>\"\nhelp_run=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run --help)\"\nprintf '%s\\n' \"$help_run\" | rg -q \"run android\"\nprintf '%s\\n' \"$help_run\" | rg -q \"run ios\"\nprintf '%s\\n' \"$help_run\" | rg -q \"run harmony\"\nprintf '%s\\n' \"$help_run\" | rg -q \"\\-\\-no-build\"\nprintf '%s\\n' \"$help_run\" | rg -q \"\\-\\-no-install\"\nprintf '%s\\n' \"$help_run\" | rg -q \"\\-\\-no-run\"\n\necho \"[verify-mobile-run] argument error checks\"\nset +e\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run android /no/such/file.cheng >/tmp/cheng_verify_mobile_run_android.log 2>&1\nrc_android=$?\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run ios /no/such/file.cheng >/"
        out = out + "tmp/cheng_verify_mobile_run_ios.log 2>&1\nrc_ios=$?\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} chengc run harmony /no/such/file.cheng >/tmp/cheng_verify_mobile_run_harmony.log 2>&1\nrc_harmony=$?\nset -e\nif [ \"$rc_android\" -ne 2 ] || [ \"$rc_ios\" -ne 2 ] || [ \"$rc_harmony\" -ne 2 ]; then\n  echo \"[Error] run argument checks failed: android=$rc_android ios=$rc_ios harmony=$rc_harmony\" 1>&2\n  exit 2\nfi\n\necho \"[verify-mobile-run] export and kotlin-only checks\"\nout_android=\"/tmp/cheng_verify_mobile_run_android_$$\"\nout_ios=\"/tmp/cheng_verify_mobile_run_ios_$$\"\nout_harmony=\"/tmp/cheng_verify_mobile_run_harmony_$$\"\ntrap 'rm -rf \"$out_android\" \"$out_ios\" \"$out_harmony\"' EXIT\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_mobile_export examples/mobile_hello.cheng --with-android-project --out:\"$out_android\" --name:verify_mobile_android\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_android_kotlin_only --project:\"$out_android/android_project\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_mobile_export examples/mobile_hello.cheng --with-ios-project --out:\"$out_ios\" --name:verify_mobile_ios\n[ -d \"$out_ios/ios_project\" ]\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_mobile_export examples/mobile_hello.cheng --with-harmony-project --out:\"$out_harmony\" --name:verify_mobile_harmony\n[ -d \"$out_harmony/harmony_project\" ]\n\necho \"[verify-mobile-run] smoke run c"
        out = out + "hecks\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_android examples/mobile_hello.cheng --out:\"$out_android/run_android\" --no-build --no-install --no-run\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_harmony examples/mobile_hello.cheng --out:\"$out_harmony/run_harmony\"\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} mobile_run_ios examples/mobile_hello.cheng --out:\"$out_ios/run_ios\"\n\necho \"[verify-mobile-run] ok\"\n"
        return out
    if id == "verify_no_legacy_net_multiformats_imports":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nscope=\"src tests examples\"\nhas_error=0\n\ncheck_forbidden() {\n  pattern=\"$1\"\n  label=\"$2\"\n  for dir in $scope; do\n    [ -e \"$dir\" ] || continue\n    if rg -n \"$pattern\" \"$dir\" --glob '*.cheng' >/tmp/cheng_legacy_prefix_hits.txt 2>/dev/null; then\n      echo \"[verify_no_legacy_net_multiformats_imports] forbidden import found: $label\" 1>&2\n      cat /tmp/cheng_legacy_prefix_hits.txt 1>&2\n      has_error=1\n    fi\n  done\n}\n\ncheck_forbidden '^[[:space:]]*import[[:space:]]+cheng/net/' 'import cheng/net/...'\ncheck_forbidden '^[[:space:]]*import[[:space:]]+cheng/multiformats/' 'import cheng/multiformats/...'\n\nrm -f /tmp/cheng_legacy_prefix_hits.txt\n\nif [ \"$has_error\" -ne 0 ]; then\n  exit 1\nfi\n\necho \"verify_no_legacy_net_multiformats_imports ok\"\n"
    if id == "verify_no_root_build_artifacts":
        return "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nROOT=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$ROOT\"\n\nfail=0\ntmp=\"$(mktemp)\"\ntrap 'rm -f \"$tmp\"' EXIT\n\ncheck_nonempty_list() {\n  title=\"$1\"\n  if [ ! -s \"$tmp\" ]; then\n    return 0\n  fi\n  fail=1\n  echo \"[verify_no_root_build_artifacts] $title\" 1>&2\n  cat \"$tmp\" 1>&2\n  : >\"$tmp\"\n}\n\nfind . -maxdepth 1 -type f \\( -name '*.o' -o -name '*.obj' -o -name '*.out' \\) -print \\\n  | sed 's#^\\./##' >\"$tmp\"\ncheck_nonempty_list \"unexpected object/temp files in repo root:\"\n\nfind . -maxdepth 1 -type d \\( -name '*.objs' -o -name '*.objs.lock' \\) -print \\\n  | sed 's#^\\./##' >\"$tmp\"\ncheck_nonempty_list \"unexpected object directories in repo root:\"\n\nfind . -maxdepth 1 -type f -print0 \\\n  | while IFS= read -r -d '' f; do\n      kind=\"$(file -b \"$f\" 2>/dev/null || true)\"\n      case \"$kind\" in\n        *Mach-O*|*ELF*|*PE32*|*\"current ar archive\"*)\n          printf '%s\\n' \"${f#./}\"\n          ;;\n      esac\n    done >\"$tmp\"\ncheck_nonempty_list \"unexpected compiled binaries in repo root:\"\n\nif [ \"$fail\" -ne 0 ]; then\n  echo \"[verify_no_root_build_artifacts] fix: move outputs to artifacts/chengc or chengcache\" 1>&2\n  exit 1\nfi\n\necho \"verify ok\"\n"
    if id == "verify_rwad_interface_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env bash\n:\nset -euo pipefail\n\nROOT=\"build/cheng_rwad_contract_verify\"\nBATCH_ID=\"cheng-epoch-9\"\nEPOCH=\"9\"\nRWAD_CHAIN_ROOT=\"${RWAD_CHAIN_ROOT:-/Users/lbcheng/.cheng-packages/RWAD-blockchain}\"\n\nwhile [ $# -gt 0 ]; do\n  case \"$1\" in\n    --root:*)\n      ROOT=\"${1#--root:}\"\n      ;;\n    --batch-id:*)\n      BATCH_ID=\"${1#--batch-id:}\"\n      ;;\n    --epoch:*)\n      EPOCH=\"${1#--epoch:}\"\n      ;;\n    --rwad-root:*)\n      RWAD_CHAIN_ROOT=\"${1#--rwad-root:}\"\n      ;;\n    *)\n      echo \"unknown arg: $1\" 1>&2\n      exit 1\n      ;;\n  esac\n  shift\ndone\n\nrwad_tool=\"$RWAD_CHAIN_ROOT/tools/rwad_cheng_points_settle.sh\"\nif [ ! -x \"$rwad_tool\" ]; then\n  echo \"verify: missing RWAD tool: $rwad_tool\" 1>&2\n  exit 1\nfi\n\nrm -rf \"$ROOT\"\nmkdir -p \"$ROOT\"\n\ncat > \"$ROOT/rwad_batch.json\" <<EOF\n{\"schema_version\":\"cheng-rwad-settlement/v1\",\"source\":\"cheng-lang/verify_rwad_interface_contract.sh\",\"batch_id\":\"$BATCH_ID\",\"epoch\":$EPOCH,\"ledger_path\":\"$ROOT/ledger.jsonl\",\"settlement_sha256\":\"fixture-sha256\",\"settlement\":{\"epoch\":$EPOCH,\"storage_total\":1.2,\"compute_total\":4.5,\"treasury_total\":0.2,\"audit_total\":0.1,\"counts\":{\"exec_request\":3,\"exec_receipt\":3},\"payouts\":{\"authors\":{\"node:alice\":2.1,\"node:bob\":0.6},\"providers\":{\"node:storage-1\":1.4},\"executors\":{\"node:exec-1\":1.9},\"penalties\":{\"node:exec-1\":0.3}},\"trust\":{\"fraud_by_executor\":{\"node:exec-1\":0.0},\"storage"
        out = out + "_ok_by_provider\":{\"node:storage-1\":1.0},\"storage_missing_by_provider\":{\"node:storage-2\":0.0}}}}\nEOF\n\n\"$rwad_tool\" \\\n  --batchFile:\"$ROOT/rwad_batch.json\" \\\n  --budget:3.0 \\\n  --stateOut:\"$ROOT/rwad_points_state.json\" \\\n  --out:\"$ROOT/rwad_result.json\"\n\n${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} cheng_rwad_bridge apply \\\n  --result:\"$ROOT/rwad_result.json\" \\\n  --batch:\"$ROOT/rwad_batch.json\" \\\n  --batch-id:\"$BATCH_ID\" \\\n  --require-status:finalized \\\n  --out:\"$ROOT/rwad_ack.json\"\n\nresult=\"$(cat \"$ROOT/rwad_result.json\")\"\nprintf '%s' \"$result\" | grep -Fq \"\\\"schema_version\\\":\\\"rwad-cheng-settlement-result/v1\\\"\" || { echo \"verify: invalid result schema\" 1>&2; exit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"request_schema\\\":\\\"cheng-rwad-settlement/v1\\\"\" || { echo \"verify: invalid request schema\" 1>&2; exit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"settlement_sha256\\\"\" || { echo \"verify: missing settlement_sha256 in result\" 1>&2; exit 1; }\nprintf '%s' \"$result\" | grep -Fq \"\\\"batch_id\\\":\\\"$BATCH_ID\\\"\" || { echo \"verify: batch id mismatch in result\" 1>&2; exit 1; }\n\nack=\"$(cat \"$ROOT/rwad_ack.json\")\"\nprintf '%s' \"$ack\" | grep -Fq \"\\\"schema_version\\\":\\\"cheng-rwad-ack/v1\\\"\" || { echo \"verify: invalid ack schema\" 1>&2; exit 1; }\nprintf '%s' \"$ack\" | grep -Fq \"\\\"request_schema\\\":\\\"cheng-rwad-settlement/v1\\\"\" || { echo \"verify: missing r"
        out = out + "equest_schema in ack\" 1>&2; exit 1; }\nprintf '%s' \"$ack\" | grep -Fq \"\\\"totals\\\"\" || { echo \"verify: missing totals in ack\" 1>&2; exit 1; }\nprintf '%s' \"$ack\" | grep -Fq \"\\\"batch_id\\\":\\\"$BATCH_ID\\\"\" || { echo \"verify: batch id mismatch in ack\" 1>&2; exit 1; }\n\necho \"verify contract ok\"\n"
        return out
    if id == "verify_stage1_fullspec":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -euo pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  src/tooling/verify_stage1_fullspec.sh [--file:<path>] [--name:<bin>] [--jobs:<N>]\n                                        [--backend:<obj>] [--frontend:<stage1>]\n                                        [--target:<triple>] [--linker:<self|system|auto>]\n                                        [--mm:<orc>] [--timeout:<sec>] [--multi:<0|1>]\n                                        [--validate:<0|1>]\n                                        [--reuse:<0|1>]\n                                        [--skip-run] [--allow-skip]\n                                        [--log:<path>]\n\nNotes:\n  - Builds and runs the stage1 fullspec sample (expects output: \"fullspec ok\").\n  - Backend obj path supports `self`/`system` linker modes (`auto` defaults to host-compatible mode).\nEOF\n}\n\nfile=\"examples/stage1_codegen_fullspec.cheng\"\nname=\"\"\njobs=\"\"\nmm=\"\"\nskip_run=\"\"\nallow_skip=\"\"\nbackend=\"${STAGE1_FULLSPEC_BACKEND:-obj}\"\nfrontend=\"${STAGE1_FULLSPEC_FRONTEND:-stage1}\"\ntarget=\"${STAGE1_FULLSPEC_TARGET:-}\"\nlinker=\"${STAGE1_FULLSPEC_LINKER:-}\"\n# Stage1 fullspec compiles the full semantic pipeline and can be much slower\n# than smoke fixtures on cold caches.\ntimeout_s=\"${STAGE1_FULLSPEC_TIMEOUT:-60}\"\nmulti=\"${STAGE1_FULLSPEC_MULTI:-1}\"\nvalidate=\"${STAGE1_FULLSPEC_VALIDATE:-0}\"\nreuse=\"${STAGE1_FULLSPEC_REUSE:-1}\"\ntimeout_diag=\"${STAGE1_FULLSPEC_TIMEOUT_DIAG:-1}\"\ntime"
        out = out + "out_diag_timeout=\"${STAGE1_FULLSPEC_TIMEOUT_DIAG_TIMEOUT:-20}\"\ntimeout_diag_dir=\"${STAGE1_FULLSPEC_TIMEOUT_DIAG_DIR:-chengcache/stage1_fullspec_timeout_diag}\"\ntimeout_health_probe=\"${STAGE1_FULLSPEC_TIMEOUT_HEALTH_PROBE:-1}\"\ntimeout_health_timeout=\"${STAGE1_FULLSPEC_TIMEOUT_HEALTH_TIMEOUT:-10}\"\ntimeout_health_fixture=\"${STAGE1_FULLSPEC_TIMEOUT_HEALTH_FIXTURE:-tests/cheng/backend/fixtures/return_add.cheng}\"\nstage1_diag_health_status=\"unknown\"\nstage1_diag_health_log=\"\"\nlog=\"chengcache/stage1_fullspec.out\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --file:*)\n      file=\"${1#--file:}\"\n      ;;\n    --name:*)\n      name=\"${1#--name:}\"\n      ;;\n    --jobs:*)\n      jobs=\"${1#--jobs:}\"\n      ;;\n    --backend:*)\n      backend=\"${1#--backend:}\"\n      ;;\n    --frontend:*)\n      frontend=\"${1#--frontend:}\"\n      ;;\n    --target:*)\n      target=\"${1#--target:}\"\n      ;;\n    --linker:*)\n      linker=\"${1#--linker:}\"\n      ;;\n    --mm:*)\n      mm=\"${1#--mm:}\"\n      ;;\n    --timeout:*)\n      timeout_s=\"${1#--timeout:}\"\n      ;;\n    --multi:*)\n      multi=\"${1#--multi:}\"\n      ;;\n    --validate:*)\n      validate=\"${1#--validate:}\"\n      ;;\n    --reuse:*)\n      reuse=\"${1#--reuse:}\"\n      ;;\n    --skip-run)\n      skip_run=\"1\"\n      ;;\n    --allow-skip)\n      allow_skip=\"1\"\n      ;;\n    --log:*)\n      log=\"${1#--log:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n   "
        out = out + " *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ncase \"$file\" in\n  /*) ;;\n  *) file=\"$root/$file\" ;;\nesac\n\nif [ ! -f \"$file\" ]; then\n  echo \"[Error] missing fullspec file: $file\" 1>&2\n  exit 2\nfi\n\nif [ \"$backend\" != \"obj\" ]; then\n  echo \"[Error] invalid --backend:$backend (only obj is supported)\" 1>&2\n  exit 2\nfi\ncase \"$frontend\" in\n  stage1)\n    ;;\n  *)\n    echo \"[Error] invalid --frontend:$frontend (expected stage1)\" 1>&2\n    exit 2\n    ;;\nesac\n\nif [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$file\")\"\n  name=\"${base%.cheng}\"\nfi\noutput_bin=\"$root/$name\"\nstamp_file=\"$root/$name.stage1_fullspec.stamp\"\n\nif [ \"$mm\" = \"\" ]; then\n  mm=\"${MM:-orc}\"\nfi\nif [ \"$mm\" != \"orc\" ]; then\n  echo \"[Error] invalid --mm:$mm (only orc is supported)\" 1>&2\n  exit 2\nfi\nenvs=\"MM=orc\"\nstage1_skip_sem=\"${STAGE1_SKIP_SEM:-0}\"\nstage1_skip_ownership=\"${STAGE1_SKIP_OWNERSHIP:-1}\"\nenvs=\"$envs STAGE1_SKIP_SEM=$stage1_skip_sem STAGE1_SKIP_OWNERSHIP=$stage1_skip_ownership\"\n\nif [ \"$jobs\" = \"\" ]; then\n  jobs=\"${STAGE1_FULLSPEC_JOBS:-}\"\nfi\n\nif [ \"$multi\" != \"0\" ]; then\n  multi=\"1\"\nfi\n\ncase \"$validate\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid --validate:$validate (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$reuse\" in\n  0|1)\n "
        out = out + "   ;;\n  *)\n    echo \"[Error] invalid --reuse:$reuse (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$timeout_diag\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid STAGE1_FULLSPEC_TIMEOUT_DIAG:$timeout_diag (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$timeout_diag_timeout\" in\n  ''|*[!0-9]*)\n    timeout_diag_timeout=20\n    ;;\n  *)\n    if [ \"$timeout_diag_timeout\" -le 0 ]; then\n      timeout_diag_timeout=20\n    fi\n    ;;\nesac\ncase \"$timeout_health_probe\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid STAGE1_FULLSPEC_TIMEOUT_HEALTH_PROBE:$timeout_health_probe (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\ncase \"$timeout_health_timeout\" in\n  ''|*[!0-9]*)\n    timeout_health_timeout=10\n    ;;\n  *)\n    if [ \"$timeout_health_timeout\" -le 0 ]; then\n      timeout_health_timeout=10\n    fi\n    ;;\nesac\nmulti_force=\"${STAGE1_FULLSPEC_MULTI_FORCE:-$multi}\"\njobs_env=\"\"\nif [ \"$jobs\" != \"\" ]; then\n  jobs_env=\"BACKEND_JOBS=$jobs\"\nfi\n\nrun_with_timeout() {\n  seconds=\"$1\"\n  shift\n  perl -e '\n    use POSIX qw(setsid WNOHANG);\n    my $timeout = shift;\n    my $pid = fork();\n    if (!defined $pid) { exit 127; }\n    if ($pid == 0) {\n      setsid();\n      exec @ARGV;\n      exit 127;\n    }\n    my $end = time + $timeout;\n    while (1) {\n      my $res = waitpid($pid, WNOHANG);\n      if ($res == $pid) {\n        my $status = $?;\n        if (($status & 127) != 0) {\n          exit(128 + ($status & 127));\n    "
        out = out + "    }\n        exit($status >> 8);\n      }\n      if (time >= $end) {\n        kill \"TERM\", -$pid;\n        select(undef, undef, undef, 0.5);\n        kill \"KILL\", -$pid;\n        exit 124;\n      }\n      select(undef, undef, undef, 0.1);\n    }\n  ' \"$seconds\" \"$@\"\n}\n\nrun_cmd() {\n  cmd_label=\"$1\"\n  shift\n  echo \"== $cmd_label ==\"\n  tmp_log=\"$(mktemp \"${TMPDIR:-/tmp}/stage1_fullspec_cmd.XXXXXX.log\")\"\n  set +e\n  run_with_timeout \"$timeout_s\" \"$@\" >\"$tmp_log\" 2>&1\n  status=$?\n  set -e\n  cat \"$tmp_log\"\n  rm -f \"$tmp_log\"\n  if [ \"$status\" = \"124\" ]; then\n    echo \"[Error] $cmd_label timed out after ${timeout_s}s\" 1>&2\n    stage1_timeout_diag \"$cmd_label\" \"$@\"\n    exit 124\n  fi\n  if [ \"$status\" != \"0\" ]; then\n    exit \"$status\"\n  fi\n}\n\nsummary_clean() {\n  printf \"%s\" \"$1\" | tr '\\t\\r\\n' '   '\n}\n\nstage1_timeout_write_summary() {\n  ts=\"$1\"\n  safe_label=\"$2\"\n  raw_label=\"$3\"\n  diag_log=\"$4\"\n  diag_status=\"$5\"\n  backend_after=\"$6\"\n  uir_after=\"$7\"\n  hint=\"$8\"\n  health_status=\"$9\"\n  health_log=\"${10:-}\"\n  summary_file=\"$timeout_diag_dir/summary.tsv\"\n  if [ ! -f \"$summary_file\" ]; then\n    printf \"ts\\tlabel\\tcmd\\tdiag_status\\tbackend_after\\tuir_after\\thealth\\thint\\tlog\\thealth_log\\n\" >\"$summary_file\"\n  fi\n  printf \"%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\t%s\\n\" \\\n    \"$(summary_clean \"$ts\")\" \\\n    \"$(summary_clean \"$safe_label\")\" \\\n    \""
        out = out + "$(summary_clean \"$raw_label\")\" \\\n    \"$(summary_clean \"$diag_status\")\" \\\n    \"$(summary_clean \"$backend_after\")\" \\\n    \"$(summary_clean \"$uir_after\")\" \\\n    \"$(summary_clean \"$health_status\")\" \\\n    \"$(summary_clean \"$hint\")\" \\\n    \"$(summary_clean \"$diag_log\")\" \\\n    \"$(summary_clean \"$health_log\")\" \\\n    >>\"$summary_file\"\n  echo \"[diag] summary: $summary_file\" 1>&2\n}\n\nstage1_timeout_diag() {\n  label=\"$1\"\n  shift\n  if [ \"$timeout_diag\" != \"1\" ]; then\n    return 0\n  fi\n  mkdir -p \"$timeout_diag_dir\"\n  ts=\"$(date '+%Y%m%d_%H%M%S' 2>/dev/null || echo now)\"\n  safe_label=\"$(printf '%s' \"$label\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\n  diag_log=\"$timeout_diag_dir/${safe_label}_${ts}.log\"\n  inferred_backend=\"unknown\"\n  inferred_uir=\"unknown\"\n  inferred_hint=\"inspect profile tail + diag log for next missing stage transition.\"\n  stage1_diag_health_status=\"not-run\"\n  stage1_diag_health_log=\"\"\n  echo \"[diag] timeout probe start: label=$label timeout=${timeout_diag_timeout}s log=$diag_log\" 1>&2\n  set +e\n  run_with_timeout \"$timeout_diag_timeout\" env \\\n    BACKEND_PROFILE=1 \\\n    UIR_PROFILE=1 \\\n    STAGE1_PROFILE=1 \\\n    \"$@\" >\"$diag_log\" 2>&1\n  diag_status=$?\n  set -e\n  echo \"[diag] timeout probe exit=$diag_status log=$diag_log\" 1>&2\n  if command -v rg >/dev/null 2>&1; then\n    prof_lines=\"$(rg -n \"backend_profile|uir_profile|\\\\[stage1\\\\] profile|generics_rep"
        out = out + "ort\" \"$diag_log\" || true)\"\n  else\n    prof_lines=\"$(grep -nE \"backend_profile|uir_profile|\\\\[stage1\\\\] profile|generics_report\" \"$diag_log\" || true)\"\n  fi\n  if [ \"$prof_lines\" != \"\" ]; then\n    echo \"[diag] profile snapshot:\" 1>&2\n    printf \"%s\\n\" \"$prof_lines\" | tail -n 24 1>&2\n    last_backend_label=\"$(printf \"%s\\n\" \"$prof_lines\" | awk -F'\\t' '/backend_profile/{label=$2} END{print label}')\"\n    last_uir_label=\"$(printf \"%s\\n\" \"$prof_lines\" | awk -F'\\t' '/uir_profile/{label=$2} END{print label}')\"\n    if [ \"$last_backend_label\" != \"\" ]; then\n      inferred_backend=\"$last_backend_label\"\n    fi\n    if [ \"$last_uir_label\" != \"\" ]; then\n      inferred_uir=\"$last_uir_label\"\n    fi\n    echo \"[diag] inferred_blocker: backend_after=$inferred_backend uir_after=$inferred_uir\" 1>&2\n    case \"$inferred_backend\" in\n      module_cache.load)\n        inferred_hint=\"likely stuck in build_module (frontend/semantics/generics/lowering).\"\n        echo \"[diag] hint: $inferred_hint\" 1>&2\n        ;;\n      build_module)\n        inferred_hint=\"likely stuck after IR build (emit/link path).\"\n        echo \"[diag] hint: $inferred_hint\" 1>&2\n        ;;\n      single.emit_obj|single.link)\n        inferred_hint=\"likely stuck in object emit or link stage.\"\n        echo \"[diag] hint: $inferred_hint\" 1>&2\n        ;;\n      *)\n        echo \"[diag] hint: $inferred_hint\" 1>&2\n        ;;\n    esac\n  else\n    echo"
        out = out + " \"[diag] no profile markers; recent output tail:\" 1>&2\n    tail -n 40 \"$diag_log\" 1>&2 || true\n  fi\n  stage1_timeout_health_probe \"$safe_label\" \"$ts\"\n  stage1_timeout_write_summary \\\n    \"$ts\" \\\n    \"$safe_label\" \\\n    \"$label\" \\\n    \"$diag_log\" \\\n    \"$diag_status\" \\\n    \"$inferred_backend\" \\\n    \"$inferred_uir\" \\\n    \"$inferred_hint\" \\\n    \"$stage1_diag_health_status\" \\\n    \"$stage1_diag_health_log\"\n}\n\nstage1_timeout_health_probe() {\n  safe_label=\"$1\"\n  ts=\"$2\"\n  if [ \"$timeout_health_probe\" != \"1\" ]; then\n    stage1_diag_health_status=\"disabled\"\n    stage1_diag_health_log=\"\"\n    return 0\n  fi\n  if [ ! -f \"$timeout_health_fixture\" ]; then\n    stage1_diag_health_status=\"skip-missing-fixture\"\n    stage1_diag_health_log=\"\"\n    echo \"[diag] health probe skip: missing fixture $timeout_health_fixture\" 1>&2\n    return 0\n  fi\n  probe_out=\"$timeout_diag_dir/health_probe_${safe_label}_${ts}.o\"\n  probe_log=\"$timeout_diag_dir/health_probe_${safe_label}_${ts}.log\"\n  stage1_diag_health_status=\"running\"\n  stage1_diag_health_log=\"$probe_log\"\n  echo \"[diag] health probe start: fixture=$timeout_health_fixture timeout=${timeout_health_timeout}s log=$probe_log\" 1>&2\n  set +e\n  run_with_timeout \"$timeout_health_timeout\" env \\\n    MM=orc \\\n    STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n    STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE"
        out = out + "=0 \\\n    BACKEND_WHOLE_PROGRAM=1 \\\n    BACKEND_VALIDATE=0 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=\"$frontend\" \\\n    BACKEND_INPUT=\"$timeout_health_fixture\" \\\n    BACKEND_OUTPUT=\"$probe_out\" \\\n    \"$driver\" >\"$probe_log\" 2>&1\n  probe_status=$?\n  set -e\n  case \"$probe_status\" in\n    0)\n      stage1_diag_health_status=\"ok\"\n      echo \"[diag] health probe: ok (compiler path healthy for small fixture)\" 1>&2\n      ;;\n    124)\n      stage1_diag_health_status=\"timeout\"\n      echo \"[diag] health probe: timeout after ${timeout_health_timeout}s (likely broader backend slowdown)\" 1>&2\n      tail -n 24 \"$probe_log\" 1>&2 || true\n      ;;\n    *)\n      stage1_diag_health_status=\"fail:$probe_status\"\n      echo \"[diag] health probe: fail rc=$probe_status (likely compiler/runtime instability)\" 1>&2\n      tail -n 24 \"$probe_log\" 1>&2 || true\n      ;;\n  esac\n}\n\nstr_sig() {\n  # cksum is POSIX and available on supported hosts.\n  if [ \"$#\" = \"0\" ]; then\n    cksum | awk '{printf \"%s:%s\", $1, $2}'\n    return 0\n  fi\n  txt=\"$1\"\n  printf \"%s\" \"$txt\" | cksum | awk '{printf \"%s:%s\", $1, $2}'\n}\n\ncheng_env_sig() {\n  env | LC_ALL=C sort | awk -F= '\n    /^CHENG_/ {\n      k=$1\n      if (k == \"STAGE1_FULLSPEC_REUSE\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_DIAG\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_DIAG_TIMEOUT\""
        out = out + ") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_DIAG_DIR\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_HEALTH_PROBE\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_HEALTH_TIMEOUT\") next\n      if (k == \"STAGE1_FULLSPEC_TIMEOUT_HEALTH_FIXTURE\") next\n      if (k == \"BACKEND_INPUT\") next\n      if (k == \"BACKEND_OUTPUT\") next\n      if (k == \"BACKEND_PROFILE\") next\n      if (k == \"UIR_PROFILE\") next\n      if (k == \"STAGE1_PROFILE\") next\n      print $0\n    }\n  '\n}\n\nfile_sig() {\n  path=\"$1\"\n  if [ ! -e \"$path\" ]; then\n    printf '%s' \"missing\"\n    return 0\n  fi\n  perl -e '\n    my @s = stat($ARGV[0]);\n    if (@s) {\n      print $s[9] . \":\" . $s[7];\n      exit 0;\n    }\n    print \"missing\";\n  ' \"$path\"\n}\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\n\nif [ \"$target\" = \"\" ]; then\n  case \"$host_os/$host_arch\" in\n    Darwin/arm64)\n      target=\"arm64-apple-darwin\"\n      ;;\n    Linux/aarch64|Linux/arm64)\n      target=\"aarch64-unknown-linux-gnu\"\n      ;;\n    *)\n      if [ \"$allow_skip\" != \"\" ]; then\n        echo \"[skip] stage1 fullspec obj: unsupported host=$host_os/$host_arch\" 1>&2\n        exit 0\n      fi\n      echo \"[Error] stage1 fullspec obj unsupported host=$host_os/$host_arch\" 1>&2\n      exit 2\n      ;;\n  esac\nfi\n\nif [ \"$linker\" = \"\" ] || [ \"$linker\" = \"auto\" ]; then\n  if [ \"${BACKEND_LINKER:-}\" = \"system\" ]; then\n "
        out = out + "   linker=\"system\"\n  else\n    linker=\"self\"\n  fi\nfi\nif [ \"$linker\" != \"self\" ] && [ \"$linker\" != \"system\" ]; then\n  echo \"[Error] invalid --linker:$linker (expected self|system|auto)\" 1>&2\n  exit 2\nfi\n\nif [ \"$linker\" = \"self\" ] && [ \"$host_os\" = \"Darwin\" ] && ! command -v codesign >/dev/null 2>&1; then\n  if [ \"$allow_skip\" != \"\" ]; then\n    echo \"[skip] stage1 fullspec obj: missing codesign\" 1>&2\n    exit 0\n  fi\n  echo \"[Error] stage1 fullspec obj missing codesign (required for self-linked Mach-O)\" 1>&2\n  exit 2\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  if [ -x \"artifacts/backend_driver/cheng\" ]; then\n    driver=\"artifacts/backend_driver/cheng\"\n  elif [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage2\" ]; then\n    driver=\"artifacts/backend_selfhost_self_obj/cheng.stage2\"\n  elif [ -x \"artifacts/backend_selfhost_self_obj/cheng.stage1\" ]; then\n    driver=\"artifacts/backend_selfhost_self_obj/cheng.stage1\"\n  elif [ -x \"artifacts/backend_seed/cheng.stage2\" ]; then\n    driver=\"artifacts/backend_seed/cheng.stage2\"\n  else\n    driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n  fi\nfi\nruntime_src=\"src/std/system_helpers_backend.cheng\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"chengcache/system_helpers.backend.cheng.${safe_target}.o\"\nif [ \"$linker\" = \"self\" ]; then\n  if [ ! -"
        out = out + "f \"$runtime_src\" ]; then\n    echo \"[Error] missing backend runtime source: $runtime_src\" 1>&2\n    exit 2\n  fi\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"$runtime_src\" -nt \"$runtime_obj\" ]; then\n    # shellcheck disable=SC2086\n    run_cmd \"build.stage1_fullspec.runtime_obj\" env $jobs_env \\\n      STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n      BACKEND_MULTI=\"$multi\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force\" \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$runtime_src\" \\\n      BACKEND_OUTPUT=\"$runtime_obj\" \\\n      \"$driver\"\n  fi\n  if [ ! -s \"$runtime_obj\" ]; then\n    echo \"[Error] missing backend runtime obj: $runtime_obj\" 1>&2\n    exit 2\n  fi\nfi\n\nbuild_sig=\"input=$(file_sig \"$file\")\"\nbuild_sig=\"$build_sig;driver_path=$driver;driver_sig=$(file_sig \"$driver\")\"\nbuild_sig=\"$build_sig;target=$target;frontend=$frontend;linker=$linker;mm=$mm\"\nbuild_sig=\"$build_sig;multi=$multi;multi_force=$multi_force;validate=$validate\"\nbuild_sig=\"$build_sig;backend=$backend;jobs=$jobs\"\nbuild_sig=\"$build_sig;cheng_env_sig=$(cheng_env_sig | str_sig)\"\nif [ \"$linker\" = \"self\" ]; then\n  build_sig=\"$build_sig;runtime_obj=$runtime_obj;runtime_sig=$(file_sig \"$runtime_obj\")\"\nfi\n\nbuild_required=\"1\"\nif [ \"$reuse"
        out = out + "\" = \"1\" ] && [ -x \"$output_bin\" ] && [ -f \"$stamp_file\" ]; then\n  saved_sig=\"$(cat \"$stamp_file\" 2>/dev/null || true)\"\n  if [ \"$saved_sig\" = \"$build_sig\" ]; then\n    build_required=\"0\"\n    echo \"== build.stage1_fullspec.obj (reuse) ==\"\n  fi\nfi\n\nif [ \"$build_required\" = \"1\" ]; then\n  if [ \"$linker\" = \"self\" ]; then\n    # shellcheck disable=SC2086\n    run_cmd \"build.stage1_fullspec.obj\" env $envs $jobs_env \\\n      BACKEND_MULTI=\"$multi\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force\" \\\n      BACKEND_LINKER=self \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n      BACKEND_VALIDATE=\"$validate\" \\\n      BACKEND_FRONTEND=\"$frontend\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$file\" \\\n      BACKEND_OUTPUT=\"$output_bin\" \\\n      \"$driver\"\n  else\n    # shellcheck disable=SC2086\n    run_cmd \"build.stage1_fullspec.obj\" env $envs $jobs_env \\\n      BACKEND_MULTI=\"$multi\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force\" \\\n      BACKEND_LINKER=system \\\n      BACKEND_WHOLE_PROGRAM=1 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_VALIDATE=\"$validate\" \\\n      BACKEND_FRONTEND=\"$frontend\" \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_INPUT=\"$file\" \\\n      BACKEND_OUTPUT=\"$output_bin\" \\\n      \"$driver\"\n  fi\n  if [ \"$reuse\""
        out = out + " = \"1\" ]; then\n    printf \"%s\" \"$build_sig\" > \"$stamp_file\"\n  fi\nfi\n\nif [ \"$skip_run\" != \"\" ]; then\n  echo \"stage1 fullspec build ok: $name\"\n  exit 0\nfi\n\nif [ ! -x \"$output_bin\" ]; then\n  echo \"[Error] missing output binary: $output_bin\" 1>&2\n  exit 2\nfi\n\nmkdir -p \"$(dirname \"$log\")\"\n# shellcheck disable=SC2086\nset +e\noutput=\"$(run_with_timeout \"$timeout_s\" env $envs \"$output_bin\" 2>&1)\"\nstatus=$?\nset -e\nprintf \"%s\\n\" \"$output\" >\"$log\"\nif [ \"$status\" = \"124\" ]; then\n  echo \"[Error] stage1 fullspec run timed out after ${timeout_s}s (see $log)\" 1>&2\n  exit 124\nfi\nif [ \"$status\" != \"0\" ]; then\n  echo \"[Error] stage1 fullspec failed (exit $status, see $log)\" 1>&2\n  exit 2\nfi\n\nif command -v rg >/dev/null 2>&1; then\n  if ! printf \"%s\\n\" \"$output\" | rg -q \"fullspec ok\"; then\n    echo \"[Error] stage1 fullspec missing 'fullspec ok' (see $log)\" 1>&2\n    exit 2\n  fi\nelse\n  if ! printf \"%s\\n\" \"$output\" | grep -q \"fullspec ok\"; then\n    echo \"[Error] stage1 fullspec missing 'fullspec ok' (see $log)\" 1>&2\n    exit 2\n  fi\nfi\n\necho \"stage1 fullspec verify ok: $name\"\n"
        return out
    if id == "verify_stage1_seed_layout":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nfail() {\n  echo \"[verify_stage1_seed_layout] $1\" 1>&2\n  exit 1\n}\n\nlegacy_seed=\"src/stage1/frontend_bootstrap.seed.c\"\n[ ! -f \"$legacy_seed\" ] || fail \"legacy seed must not exist: $legacy_seed\"\n\nseed_driver=\"${SELF_OBJ_BOOTSTRAP_STAGE0:-}\"\nif [ -z \"$seed_driver\" ]; then\n  for cand in \\\n    \"artifacts/backend_selfhost_self_obj/cheng.stage2\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"cheng\"; do\n    if [ -x \"$cand\" ]; then\n      seed_driver=\"$cand\"\n      break\n    fi\n  done\nfi\n\nif [ -z \"$seed_driver\" ]; then\n  seed_id=\"\"\n  if [ -f \"dist/releases/current_id.txt\" ]; then\n    seed_id=\"$(cat dist/releases/current_id.txt | tr -d '\\r\\n')\"\n  fi\n  if [ -n \"$seed_id\" ]; then\n    for tar_path in \"dist/releases/$seed_id/backend_release.tar.gz\"; do\n      if [ -f \"$tar_path\" ]; then\n        seed_driver=\"$tar_path\"\n        break\n      fi\n    done\n  fi\nfi\n\n[ -n \"$seed_driver\" ] || fail \"missing stage seed driver (set SELF_OBJ_BOOTSTRAP_STAGE0 or prepare artifacts/backend_seed/cheng.stage2)\"\n\ncase \"$seed_driver\" in\n  *.tar.gz)\n    :\n    ;;\n  *)\n    [ -x \"$seed_driver\" ] || fail \"seed driver is not executable: $seed_driver\"\n    ;;\nesac\n\necho \"verify_stage1_seed_layout ok\"\n"
    if id == "verify_std_import_surface":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nscope=\"${STD_IMPORT_SCOPE:-src/stage1 src/backend src/tooling src/decentralized src/web}\"\nforbidden='^[[:space:]]*import[[:space:]]+cheng/stdlib/bootstrap'\nforbidden_reserve_generic='reserve\\[[^]]+\\][[:space:]]*\\('\nhas_error=0\n\nfor dir in $scope; do\n  [ -e \"$dir\" ] || continue\n  if rg -n \"$forbidden\" \"$dir\" --glob '*.cheng' >/tmp/cheng_std_import_surface_hits.txt 2>/dev/null; then\n    echo \"[verify_std_import_surface] forbidden bootstrap import path found in $dir\" 1>&2\n    cat /tmp/cheng_std_import_surface_hits.txt 1>&2\n    has_error=1\n  fi\ndone\n\nif rg -n \"$forbidden_reserve_generic\" src tests examples --glob '*.cheng' >/tmp/cheng_std_import_surface_reserve_hits.txt 2>/dev/null; then\n  echo \"[verify_std_import_surface] forbidden explicit generic reserve[T](...) call found\" 1>&2\n  cat /tmp/cheng_std_import_surface_reserve_hits.txt 1>&2\n  has_error=1\nfi\n\nrm -f /tmp/cheng_std_import_surface_hits.txt\nrm -f /tmp/cheng_std_import_surface_reserve_hits.txt\n\nif [ \"$has_error\" -ne 0 ]; then\n  exit 1\nfi\n\necho \"verify_std_import_surface ok\"\n"
    if id == "verify_std_layout_sync":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nstd_root=\"${STD_ROOT:-src/std}\"\n\nfail() {\n  echo \"[verify_std_layout_sync] $1\" 1>&2\n  exit 1\n}\n\n[ -d \"$std_root\" ] || fail \"missing std root: $std_root\"\n[ ! -d \"src/stdlib/bootstrap\" ] || fail \"legacy path still exists: src/stdlib/bootstrap\"\n\nif find \"$std_root\" -maxdepth 1 -type f -name '* copy.cheng' -print -quit | grep -q .; then\n  find \"$std_root\" -maxdepth 1 -type f -name '* copy.cheng' -print 1>&2\n  fail \"found unmerged copy files in $std_root\"\nfi\n\nrequired_modules=\"\nseqs.cheng\nstrings.cheng\nsystem.cheng\nos.cheng\ntables.cheng\nhashmaps.cheng\nhashsets.cheng\ncmdline.cheng\nbytes.cheng\nresult.cheng\noption.cheng\n\"\nfor mod in $required_modules; do\n  [ -f \"$std_root/$mod\" ] || fail \"missing std module: $std_root/$mod\"\ndone\n\necho \"verify_std_layout_sync ok\"\n"
    if id == "verify_tooling_cmdline":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ntool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\nout_dir=\"artifacts/tooling_cmdline\"\nrm -rf \"$out_dir\"\nmkdir -p \"$out_dir\"\n\nlist_out=\"$out_dir/tooling_cmdline.list.txt\"\nhelp_out=\"$out_dir/tooling_cmdline.backend_prod_closure.help.txt\"\nhelp_out_multicall=\"$out_dir/tooling_cmdline.backend_prod_closure.multicall.help.txt\"\nglobal_bin=\"$out_dir/cheng_tooling_global\"\ninstall_dir=\"$out_dir/bin\"\ninstall_manifest=\"$out_dir/tooling_cmdline.install_manifest.tsv\"\nreport=\"$out_dir/tooling_cmdline.report.txt\"\n\nTOOLING_FORCE_BUILD=1 TOOLING_LINKER=system \"$tool\" list >\"$list_out\"\nfor id in backend_prod_closure verify_backend_closedloop chengc verify_tooling_cmdline; do\n  if ! rg -qx \"$id\" \"$list_out\"; then\n    echo \"[verify_tooling_cmdline] missing id in list output: $id\" 1>&2\n    exit 1\n  fi\ndone\n\nTOOLING_LINKER=system \"$tool\" backend_prod_closure --help >\"$help_out\"\nif ! rg -q 'Usage:' \"$help_out\"; then\n  echo \"[verify_tooling_cmdline] backend_prod_closure help text missing\" 1>&2\n  exit 1\nfi\n\nglobal_bin=\"${TOOLING_GLOBAL_BIN:-$root/artifacts/tooling_cmd/cheng_tooling_global}\"\nif [ ! -x \"$global_bin\" ]; then\n  global_bin=\"$tool\"\nfi\nif [ ! -x \"$global_bin\" ]; then\n  echo \"[verify_tooling_cmdline] missing runnable global tool binary: $g"
        out = out + "lobal_bin\" 1>&2\n  exit 1\nfi\n\"$global_bin\" list >/dev/null\n\n\"$global_bin\" install --dir:\"$install_dir\" --bin:\"$global_bin\" --manifest:\"$install_manifest\" --force >/dev/null\nfor link in backend_prod_closure verify_backend_closedloop cheng_tooling; do\n  if [ ! -x \"$install_dir/$link\" ]; then\n    echo \"[verify_tooling_cmdline] missing multicall link: $install_dir/$link\" 1>&2\n    exit 1\n  fi\ndone\nif ! rg -q '^backend_prod_closure\\t' \"$install_manifest\"; then\n  echo \"[verify_tooling_cmdline] install manifest missing backend_prod_closure entry\" 1>&2\n  exit 1\nfi\n\n\"$install_dir/backend_prod_closure\" --help >\"$help_out_multicall\"\nif ! rg -q 'Usage:' \"$help_out_multicall\"; then\n  echo \"[verify_tooling_cmdline] multicall backend_prod_closure help text missing\" 1>&2\n  exit 1\nfi\n\n{\n  echo \"tooling_cmdline_runner=ok\"\n  echo \"list_output=$list_out\"\n  echo \"help_output=$help_out\"\n  echo \"help_output_multicall=$help_out_multicall\"\n  echo \"global_bin=$global_bin\"\n  echo \"install_dir=$install_dir\"\n  echo \"install_manifest=$install_manifest\"\n} >\"$report\"\n\necho \"verify_tooling_cmdline ok\"\n"
        return out
    if id == "verify":
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")\" && pwd)\"\ncd \"$root\"\n\ntool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n\nif [ \"${1:-}\" = \"--help\" ] || [ \"${1:-}\" = \"-h\" ] || [ \"${1:-}\" = \"help\" ]; then\n  echo \"Usage: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify [--help]\"\n  echo \"Runs default repository verification gates through cheng_tooling subcommands.\"\n  exit 0\nfi\n\nrun_cmd() {\n  name=\"$1\"\n  shift || true\n  echo \"== $name ==\"\n  \"$@\"\n}\n\nrun_cmd \"verify.cheng_skill_consistency\" \"$tool\" verify_cheng_skill_consistency\nrun_cmd \"verify.backend_runtime_abi\" \"$tool\" verify_backend_runtime_abi\nrun_cmd \"verify.tooling_cmdline\" \"$tool\" verify_tooling_cmdline\nrun_cmd \"verify.stage1_seed_layout\" \"$tool\" verify_stage1_seed_layout\nrun_cmd \"verify.no_legacy_net_multiformats_imports\" \"$tool\" verify_no_legacy_net_multiformats_imports\n\nif [ \"${VERIFY_NO_ROOT_BUILD_ARTIFACTS:-1}\" = \"1\" ]; then\n  run_cmd \"verify.no_root_build_artifacts\" \"$tool\" verify_no_root_build_artifacts\nfi\nif [ \"${BACKEND_CLOSEDLOOP:-0}\" = \"1\" ]; then\n  run_cmd \"verify.backend_closedloop\" \"$tool\" verify_backend_closedloop\nfi\nif [ \"${BACKEND_PROD_CLOSURE:-1}\" = \"1\" ]; then\n  run_cmd \"verify.backend_prod_closure\" \"$tool\" backend_prod_closure --no-publish\nfi\n\necho \"verify ok\"\n"
    if id == "build_backend_native_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract [--out:<path>] [--doc:<path>]\n\nNotes:\n  - Generates deterministic CNCPAR-01 native contract baseline.\n  - Default output: src/tooling/backend_native_contract.env\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nout_file=\"src/tooling/backend_native_contract.env\"\ndoc=\"docs/cheng-native-contract.md\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --out:*)\n      out_file=\"${1#--out:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[build_backend_native_contract] rg is required\" 1>&2\n  exit 2\nfi\n\ndriver_file=\"src/backend/tooling/backend_driver.cheng\"\nbuilder_file=\"src/backend/uir/uir_internal/uir_core_builder.cheng\"\ntooling_file=\"src/tooling/cheng_tooling.cheng\"\nfor requir"
        out = out + "ed in \"$doc\" \"$driver_file\" \"$builder_file\" \"$tooling_file\"; do\n  if [ ! -f \"$required\" ]; then\n    echo \"[build_backend_native_contract] missing file: $required\" 1>&2\n    exit 2\n  fi\ndone\n\ntmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_markers.XXXXXX\")\"\ntmp_required=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_required.XXXXXX\")\"\ncleanup() {\n  rm -f \"$tmp_markers\" \"$tmp_required\"\n}\ntrap cleanup EXIT\n\nrg -o 'native_contract\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" \\\n  | LC_ALL=C sort -u >\"$tmp_markers\"\nmarker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\nif [ \"$marker_count\" -eq 0 ]; then\n  echo \"[build_backend_native_contract] no native contract markers found in: $doc\" 1>&2\n  exit 2\nfi\n\ncontract_version=\"$(rg -o 'native_contract\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nscheme_id=\"$(rg -o 'native_contract\\.scheme\\.id=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nscheme_name=\"$(rg -o 'native_contract\\.scheme\\.name=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nscheme_normative=\"$(rg -o 'native_contract\\.scheme\\.normative=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nenforce_mode=\"$(rg -o 'native_contract\\.enforce\\.mode=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\nif [ \"$contract_version\" = \"\" ] || [ \"$scheme_id\" = \"\" ] || [ \"$scheme_name\" = \"\" ] || [ \"$scheme_normative\" = \"\" ] || [ \"$enforce_mo"
        out = out + "de\" = \"\" ]; then\n  echo \"[build_backend_native_contract] missing required contract markers in: $doc\" 1>&2\n  exit 2\nfi\nif [ \"$scheme_id\" != \"CNC\" ] || [ \"$scheme_name\" != \"cheng_native_contract\" ] || [ \"$scheme_normative\" != \"1\" ] || [ \"$enforce_mode\" != \"hard_fail\" ]; then\n  echo \"[build_backend_native_contract] CNC normative markers must be CNC/cheng_native_contract/normative=1/hard_fail\" 1>&2\n  exit 2\nfi\n\npillar_count=\"$(rg -o 'native_contract\\.pillar\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\nrg -o 'native_contract\\.required_gate\\.[a-z0-9_.]+=1' \"$doc\" \\\n  | sed -E 's/^native_contract\\.required_gate\\.([a-z0-9_.]+)=1$/\\1/' \\\n  | LC_ALL=C sort -u >\"$tmp_required\"\nrequired_gate_count=\"$(wc -l < \"$tmp_required\" | tr -d ' ')\"\nif [ \"$required_gate_count\" -eq 0 ]; then\n  echo \"[build_backend_native_contract] no required gates found in: $doc\" 1>&2\n  exit 2\nfi\nrequired_gates_csv=\"$(tr '\\n' ',' <\"$tmp_required\" | sed -E 's/,+$//')\"\nif [ \"$required_gates_csv\" = \"\" ]; then\n  echo \"[build_backend_native_contract] failed to compute required gate list\" 1>&2\n  exit 2\nfi\n\ndoc_sha=\"$(hash_file \"$doc\")\"\nmarker_sha=\"$(hash_file \"$tmp_markers\")\"\ntooling_sha=\"$(hash_file \"$tooling_file\")\"\ndriver_sha=\"$(hash_file \"$driver_file\")\"\nbuilder_sha=\"$(hash_file \"$builder_file\")\"\n\nout_dir=\"$(dirname \"$out_file\")\"\nif [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_d"
        out = out + "ir\" ]; then\n  mkdir -p \"$out_dir\"\nfi\n\n{\n  echo \"BACKEND_NATIVE_CONTRACT_BASELINE_VERSION=1\"\n  echo \"BACKEND_NATIVE_CONTRACT_DOC=$doc\"\n  echo \"BACKEND_NATIVE_CONTRACT_DOC_SHA256=$doc_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_VERSION=$contract_version\"\n  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_ID=$scheme_id\"\n  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NAME=$scheme_name\"\n  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NORMATIVE=$scheme_normative\"\n  echo \"BACKEND_NATIVE_CONTRACT_ENFORCE_MODE=$enforce_mode\"\n  echo \"BACKEND_NATIVE_CONTRACT_MARKER_COUNT=$marker_count\"\n  echo \"BACKEND_NATIVE_CONTRACT_MARKER_SHA256=$marker_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_PILLAR_COUNT=$pillar_count\"\n  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATE_COUNT=$required_gate_count\"\n  echo \"BACKEND_NATIVE_CONTRACT_VERIFY_SCRIPT_SHA256=$tooling_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_CLOSEDLOOP_SHA256=$tooling_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_PROD_CLOSURE_SHA256=$tooling_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_DRIVER_SHA256=$driver_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_UIR_BUILDER_SHA256=$builder_sha\"\n  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATES=$required_gates_csv\"\n} >\"$out_file\"\n\necho \"backend native contract baseline generated: $out_file\"\n"
        return out
    if id == "verify_backend_native_contract":
        var out: str = ""
        out = out + "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nusage() {\n  cat <<'EOF'\nUsage:\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract [--baseline:<path>] [--doc:<path>]\n\nNotes:\n  - Verifies CNCPAR-01 native contract baseline and implementation closure.\n  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract\nEOF\n}\n\nhash_file() {\n  file=\"$1\"\n  if command -v shasum >/dev/null 2>&1; then\n    shasum -a 256 \"$file\" | awk '{print $1}'\n    return\n  fi\n  if command -v sha256sum >/dev/null 2>&1; then\n    sha256sum \"$file\" | awk '{print $1}'\n    return\n  fi\n  cksum \"$file\" | awk '{print $1}'\n}\n\nread_env_value() {\n  key=\"$1\"\n  file=\"$2\"\n  awk -F= -v k=\"$key\" '$1 == k { sub(/^[^=]*=/, \"\", $0); print $0; found=1; exit } END { if (!found) print \"\" }' \"$file\"\n}\n\nbaseline=\"src/tooling/backend_native_contract.env\"\ndoc=\"docs/cheng-native-contract.md\"\ntool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n\nwhile [ \"${1:-}\" != \"\" ]; do\n  case \"$1\" in\n    --baseline:*)\n      baseline=\"${1#--baseline:}\"\n      ;;\n    --doc:*)\n      doc=\"${1#--doc:}\"\n      ;;\n    --help|-h)\n      usage\n      exit 0\n      ;;\n    *)\n      echo \"[Error] unknown arg: $1\" 1>&2\n      usage\n      exit 2\n      ;;\n  esac\n  shift || true\ndone\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" &"
        out = out + "& pwd)\"\ncd \"$root\"\n\nif [ ! -f \"$baseline\" ]; then\n  echo \"[verify_backend_native_contract] missing baseline file: $baseline\" 1>&2\n  exit 2\nfi\nif [ ! -f \"$doc\" ]; then\n  echo \"[verify_backend_native_contract] missing doc file: $doc\" 1>&2\n  exit 2\nfi\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_native_contract] rg is required\" 1>&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_native_contract\"\nmkdir -p \"$out_dir\"\ngenerated=\"$out_dir/backend_native_contract.generated.env\"\nreport=\"$out_dir/backend_native_contract.report.txt\"\nsnapshot=\"$out_dir/backend_native_contract.snapshot.env\"\ndiff_file=\"$out_dir/backend_native_contract.diff.txt\"\nclosedloop_body=\"$out_dir/verify_backend_closedloop.body.sh\"\nprod_closure_body=\"$out_dir/backend_prod_closure.body.sh\"\n\n$tool build_backend_native_contract --doc:\"$doc\" --out:\"$generated\" >/dev/null\n\nstatus=\"ok\"\nif ! cmp -s \"$baseline\" \"$generated\"; then\n  status=\"drift\"\n  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n    :\n  else\n    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n  fi\nelse\n  : >\"$diff_file\"\nfi\n\n$tool embedded-text --id:verify_backend_closedloop >\"$closedloop_body\"\n$tool embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\nclosedloop_gate_ok=\"1\"\nprod_closure_gate_ok=\"1\"\nif ! rg -q 'backend.native_contract' \"$closedloop_body\"; then\n  closedloop_gate_ok=\"0\"\nfi\nif "
        out = out + "! rg -q 'backend.native_contract' \"$prod_closure_body\"; then\n  prod_closure_gate_ok=\"0\"\nfi\nif [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n  status=\"drift\"\nfi\n\ndriver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ] && [ -x \"artifacts/backend_driver/cheng\" ]; then\n  driver=\"artifacts/backend_driver/cheng\"\nfi\nif [ \"$driver\" = \"\" ] && [ -x \"./cheng\" ]; then\n  driver=\"./cheng\"\nfi\nif [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n  echo \"[verify_backend_native_contract] missing backend driver (set BACKEND_DRIVER)\" 1>&2\n  exit 2\nfi\n\nok_fixture=\"tests/cheng/backend/fixtures/native_contract_ok.cheng\"\nfloat_fixture=\"tests/cheng/backend/fixtures/native_contract_float_fail.cheng\"\nsyscall_fixture=\"tests/cheng/backend/fixtures/native_contract_syscall_fail.cheng\"\nfor fixture in \"$ok_fixture\" \"$float_fixture\" \"$syscall_fixture\"; do\n  if [ ! -f \"$fixture\" ]; then\n    echo \"[verify_backend_native_contract] missing fixture: $fixture\" 1>&2\n    exit 2\n  fi\ndone\n\nok_out=\"$out_dir/native_contract_ok.bin\"\nok_stamp=\"$out_dir/native_contract_ok.compile_stamp.txt\"\nok_err=\"$out_dir/native_contract_ok.stderr.txt\"\nset +e\nenv BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$ok_fixture\" BACKEND_OUTPUT=\"$ok_out\" BACKEND_COMPILE_STAMP_OUT=\"$ok_stamp\" \"$driver\" >/dev/null 2>\"$"
        out = out + "ok_err\"\nok_rc=\"$?\"\nset -e\nnative_smoke_ok=\"1\"\nif [ \"$ok_rc\" -ne 0 ]; then\n  native_smoke_ok=\"0\"\n  status=\"drift\"\nelif ! rg -q '^native_contract=1$' \"$ok_stamp\"; then\n  native_smoke_ok=\"0\"\n  status=\"drift\"\nfi\nif [ \"$native_smoke_ok\" = \"1\" ] && command -v nm >/dev/null 2>&1; then\n  if ! nm \"$ok_out\" 2>/dev/null | rg -q 'cheng_contract_charge_block|cheng_contract_gas_used'; then\n    native_smoke_ok=\"0\"\n    status=\"drift\"\n  fi\nfi\n\nexpect_fail() {\n  label=\"$1\"\n  fixture=\"$2\"\n  out_bin=\"$out_dir/${label}.bin\"\n  err_file=\"$out_dir/${label}.stderr.txt\"\n  set +e\n  env BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" >/dev/null 2>\"$err_file\"\n  rc=\"$?\"\n  set -e\n  if [ \"$rc\" -eq 0 ]; then\n    echo \"[verify_backend_native_contract] expected failure but succeeded: $label\" 1>&2\n    status=\"drift\"\n    return\n  fi\n  case \"$label\" in\n    float)\n      if ! rg -q 'native_contract hard-fail|forbid float' \"$err_file\"; then\n        echo \"[verify_backend_native_contract] missing float hard-fail diagnostics\" 1>&2\n        status=\"drift\"\n      fi\n      ;;\n    syscall)\n      if ! rg -q 'native_contract hard-fail|forbid syscall' \"$err_file\"; then\n        echo \"[verify_backend_native_contract] missing syscall hard-fail diagnostics\" 1>&2\n        status=\"d"
        out = out + "rift\"\n      fi\n      ;;\n  esac\n}\n\nexpect_fail float \"$float_fixture\"\nexpect_fail syscall \"$syscall_fixture\"\n\nbaseline_sha=\"$(hash_file \"$baseline\")\"\ngenerated_sha=\"$(hash_file \"$generated\")\"\n{\n  echo \"verify_backend_native_contract report\"\n  echo \"status=$status\"\n  echo \"doc=$doc\"\n  echo \"baseline=$baseline\"\n  echo \"generated=$generated\"\n  echo \"baseline_sha256=$baseline_sha\"\n  echo \"generated_sha256=$generated_sha\"\n  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"native_smoke_ok=$native_smoke_ok\"\n  echo \"diff=$diff_file\"\n} >\"$report\"\n{\n  echo \"backend_native_contract_status=$status\"\n  echo \"backend_native_contract_baseline_sha256=$baseline_sha\"\n  echo \"backend_native_contract_generated_sha256=$generated_sha\"\n  echo \"backend_native_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n  echo \"backend_native_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n  echo \"backend_native_contract_native_smoke_ok=$native_smoke_ok\"\n  echo \"backend_native_contract_report=$report\"\n} >\"$snapshot\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_native_contract] native contract baseline/implementation drift detected\" 1>&2\n  echo \"  baseline: $baseline\" 1>&2\n  echo \"  generated: $generated\" 1>&2\n  if [ -s \"$diff_file\" ]; then\n    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n  fi\n  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/t"
        out = out + "ooling_cmd/cheng_tooling} build_backend_native_contract --doc:$doc --out:$baseline\" 1>&2\n  exit 1\nfi\n\necho \"verify_backend_native_contract ok\"\n"
        return out
    return ""
