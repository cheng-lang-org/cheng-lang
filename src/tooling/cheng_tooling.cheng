import cmdline
import std/os
import std/strutils as strutil
import std/strings
import std/monotimes
import tooling/cheng_tooling_embedded_inline as tooling_embedded_inline

type
    ToolingSelfhostResult = ref
        ok: bool
        message: str
        totalMs: int64
        stage1Path: str
        stage2Path: str
        stage0Path: str
        stage0DriverKind: str
        stage1Status: str
        stage1CompileMode: str
        stage1RebuildOk: bool
        fallbackUsed: bool
        quarantineCleaned: int32
        lockWaitMs: int32
        strictRebuildOk: bool

fn tooling_setCmdLine(argc: int32, argv: str*) =
    cmdline.__cheng_setCmdLine(argc, void*(argv))

fn tooling_paramCount(): int32 =
    return cmdline.paramCount()

fn tooling_paramStr(i: int32): str =
    if i < 0:
        return ""
    return cmdline.paramStr(i)

fn tooling_printOut(text: str) =
    os.writeLine(os.get_stdout(), text)

fn tooling_printErr(text: str) =
    os.writeLine(os.get_stderr(), text)

fn tooling_strNonEmpty(text: str): bool =
    return text != nil && len(text) > 0

fn tooling_strEq(a: str, b: str): bool =
    if a == nil && b == nil:
        return true
    if a == nil || b == nil:
        return false
    return strings.streq(a, b)

fn tooling_selfhostStrictRebuildEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("SELFHOST_STRICT_REBUILD", "1"))

fn tooling_buildDriverStrictNativeEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("BUILD_DRIVER_STRICT_NATIVE", "1"))

fn tooling_buildDriverAllowFallbackEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("BUILD_DRIVER_ALLOW_FALLBACK", "0"))

fn tooling_strEndsWith(text: str, suffix: str): bool =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(suffix):
        return false
    let n: int32 = len(text)
    let m: int32 = len(suffix)
    if m > n:
        return false
    for i in 0..<m:
        if text[n - m + i] != suffix[i]:
            return false
    return true

fn tooling_stripShSuffix(name: str): str =
    if !tooling_strEndsWith(name, ".sh"):
        return name
    let n: int32 = len(name)
    if n <= 3:
        return ""
    return strings.sliceBytes(name, 0, n - 3)

fn tooling_isSafeScriptName(name: str): bool =
    if !tooling_strNonEmpty(name):
        return false
    if strutil.contains(name, ".."):
        return false
    for i in 0..<len(name):
        let ch: char = name[i]
        let isAlphaLower: bool = ch >= 'a' && ch <= 'z'
        let isAlphaUpper: bool = ch >= 'A' && ch <= 'Z'
        let isDigit: bool = ch >= '0' && ch <= '9'
        if isAlphaLower || isAlphaUpper || isDigit || ch == '_' || ch == '-' || ch == '.':
            continue
        return false
    return true

fn tooling_shellQuote(raw: str): str =
    if raw == nil:
        return "\"\""
    var escaped: str = strutil.replace(raw, "\\", "\\\\")
    escaped = strutil.replace(escaped, "$", "\\$")
    escaped = strutil.replace(escaped, "`", "\\`")
    escaped = strutil.replace(escaped, "\"", "\\\"")
    return "\"" + escaped + "\""

fn tooling_stage0CompatPrefixEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_COMPAT_PREFIX", "1"))

fn tooling_envAssignQuoted(name: str, value: str): str =
    if !tooling_strNonEmpty(name):
        return ""
    return name + "=" + tooling_shellQuote(value) + " "

fn tooling_envAssignCompat(name: str, value: str): str =
    if !tooling_strNonEmpty(name):
        return ""
    var out: str = tooling_envAssignQuoted(name, value)
    if !tooling_stage0CompatPrefixEnabled():
        return out
    if strutil.startsWith(name, "BACKEND_") || strutil.startsWith(name, "STAGE1_"):
        out = out + "CHENG_" + name + "=" + tooling_shellQuote(value) + " "
        return out
    if tooling_strEq(name, "MM"):
        out = out + "CHENG_MM=" + tooling_shellQuote(value) + " "
        return out
    if tooling_strEq(name, "CACHE"):
        out = out + "CHENG_CACHE=" + tooling_shellQuote(value) + " "
    return out

fn tooling_prefixUnsetLegacyFrontendEnv(cmd: str): str =
    if !tooling_strNonEmpty(cmd):
        return cmd
    return "env -u BACKEND_FRONTEND -u CHENG_BACKEND_FRONTEND " + cmd

fn tooling_root(): str =
    let envRoot: str = strutil.strip(os.getEnvDefault("TOOLING_ROOT", ""))
    if tooling_strNonEmpty(envRoot):
        return envRoot
    return os.getCurrentDir()

fn tooling_scriptDir(root: str): str =
    return os.joinPath(root, "src/tooling")

fn tooling_embeddedPrefix(): str =
    return "embedded:"

fn tooling_scriptIdFromResolvedPath(scriptPath: str): str =
    let prefix: str = tooling_embeddedPrefix()
    if !strutil.startsWith(scriptPath, prefix):
        return ""
    return strings.dropPrefix(scriptPath, prefix)

fn tooling_splitLines(raw: str): str[] =
    var out: str[] = []
    if !tooling_strNonEmpty(raw):
        return out
    let n: int32 = len(raw)
    var start: int32 = 0
    var i: int32 = 0
    for _ in 0..<n:
        if raw[i] == '\n':
            if i > start:
                let piece: str = strutil.strip(strings.sliceBytes(raw, start, i - start))
                if tooling_strNonEmpty(piece):
                    add(out, piece)
            start = i + 1
        i = i + 1
    if start < n:
        let tail: str = strutil.strip(strings.sliceBytes(raw, start, n - start))
        if tooling_strNonEmpty(tail):
            add(out, tail)
    return out

fn tooling_escapeEmbeddedMapString(text: str): str =
    if text == nil:
        return ""
    var out: str = ""
    let n: int32 = len(text)
    var i: int32 = 0
    while i < n:
        let ch: char = text[i]
        if ch == '\\':
            out = out + "\\\\"
        elif ch == '"':
            out = out + "\\\""
        elif ch == '\n':
            out = out + "\\n"
        elif ch == '\t':
            out = out + "\\t"
        elif ch == '\r':
            out = out + "\\r"
        else:
            out = out + strings.sliceBytes(text, i, 1)
        i = i + 1
    return out

fn tooling_splitEmbeddedEscapedChunks(text: str, chunkSizeRaw: int32): str[] =
    var out: str[] = []
    if !tooling_strNonEmpty(text):
        add(out, "")
        return out
    var chunkSize: int32 = chunkSizeRaw
    if chunkSize <= 0:
        chunkSize = len(text)
    let n: int32 = len(text)
    var start: int32 = 0
    while start < n:
        var end: int32 = start + chunkSize
        if end >= n:
            add(out, strings.sliceBytes(text, start, n - start))
            break
        while end < n:
            var slashRun: int32 = 0
            var j: int32 = end - 1
            while j >= start && text[j] == '\\':
                slashRun = slashRun + 1
                j = j - 1
            if slashRun % 2 == 0:
                break
            end = end + 1
        if end > n:
            end = n
        add(out, strings.sliceBytes(text, start, end - start))
        start = end
    return out

fn tooling_renderEmbeddedMapText(root: str): str =
    let ids: str[] = tooling_collectScripts(root)
    var out: str = ""
    out = out + "# Auto-generated embedded tooling command payload map.\n"
    out = out + "# Source: former src/tooling/tooling_inline/*.inline + src/tooling/verify_inline/*.inline.\n"
    out = out + "# Generated by cheng_tooling embedded-map-rewrite.\n"
    out = out + "# Do not edit manually.\n\n"
    out = out + "fn toolingEmbeddedScriptIds(): str[] =\n"
    out = out + "    var out: str[] = []\n"
    for i in 0..<ids.len:
        out = out + "    add(out, \"" + ids[i] + "\")\n"
    out = out + "    return out\n\n"
    out = out + "fn toolingEmbeddedScriptBody(id: str): str =\n"
    for i in 0..<ids.len:
        let sid: str = ids[i]
        let rawBody: str = tooling_embeddedScriptText(root, sid)
        let encoded: str = tooling_escapeEmbeddedMapString(rawBody)
        out = out + "    if id == \"" + sid + "\":\n"
        if len(encoded) <= 1800:
            out = out + "        return \"" + encoded + "\"\n"
        else:
            out = out + "        var out: str = \"\"\n"
            let chunks: str[] = tooling_splitEmbeddedEscapedChunks(encoded, 1500)
            for j in 0..<chunks.len:
                out = out + "        out = out + \"" + chunks[j] + "\"\n"
            out = out + "        return out\n"
    out = out + "    return \"\"\n"
    return out

fn tooling_embeddedScriptIds(root: str): str[] =
    var out: str[] = []
    let ids: str[] = tooling_embedded_inline.toolingEmbeddedScriptIds()
    for i in 0..<ids.len:
        let id: str = ids[i]
        if tooling_strEq(id, "chengb"):
            continue
        if !tooling_isSafeScriptName(id):
            continue
        if tooling_idsContains(out, id):
            continue
        add(out, id)
    # Keep synthetic compatibility IDs available even if the embedded map
    # was generated by an older toolchain.
    var synthetic: str[] = []
    add(synthetic, "verify")
    add(synthetic, "verify_tooling_cmdline")
    add(synthetic, "verify_backend_zero_script_closure")
    add(synthetic, "verify_backend_rawptr_migration")
    add(synthetic, "verify_backend_rawptr_closedloop")
    add(synthetic, "build_backend_native_contract")
    add(synthetic, "verify_backend_native_contract")
    for i in 0..<synthetic.len:
        let sid: str = synthetic[i]
        if !tooling_isSafeScriptName(sid):
            continue
        if tooling_idsContains(out, sid):
            continue
        add(out, sid)
    return out

fn tooling_embeddedBuildBackendNativeContractScript(): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "\n"
    out = out + "usage() {\n"
    out = out + "  cat <<'EOF'\n"
    out = out + "Usage:\n"
    out = out + "  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract [--out:<path>] [--doc:<path>]\n"
    out = out + "\n"
    out = out + "Notes:\n"
    out = out + "  - Generates deterministic CNCPAR-01 native contract baseline.\n"
    out = out + "  - Default output: src/tooling/backend_native_contract.env\n"
    out = out + "EOF\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "hash_file() {\n"
    out = out + "  file=\"$1\"\n"
    out = out + "  if command -v shasum >/dev/null 2>&1; then\n"
    out = out + "    shasum -a 256 \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  if command -v sha256sum >/dev/null 2>&1; then\n"
    out = out + "    sha256sum \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  cksum \"$file\" | awk '{print $1}'\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "out_file=\"src/tooling/backend_native_contract.env\"\n"
    out = out + "doc=\"docs/cheng-native-contract.md\"\n"
    out = out + "\n"
    out = out + "while [ \"${1:-}\" != \"\" ]; do\n"
    out = out + "  case \"$1\" in\n"
    out = out + "    --out:*)\n"
    out = out + "      out_file=\"${1#--out:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --doc:*)\n"
    out = out + "      doc=\"${1#--doc:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --help|-h)\n"
    out = out + "      usage\n"
    out = out + "      exit 0\n"
    out = out + "      ;;\n"
    out = out + "    *)\n"
    out = out + "      echo \"[Error] unknown arg: $1\" 1>&2\n"
    out = out + "      usage\n"
    out = out + "      exit 2\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "  shift || true\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\n"
    out = out + "cd \"$root\"\n"
    out = out + "\n"
    out = out + "if ! command -v rg >/dev/null 2>&1; then\n"
    out = out + "  echo \"[build_backend_native_contract] rg is required\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "driver_file=\"src/backend/tooling/backend_driver.cheng\"\n"
    out = out + "builder_file=\"src/backend/uir/uir_internal/uir_core_builder.cheng\"\n"
    out = out + "tooling_file=\"src/tooling/cheng_tooling.cheng\"\n"
    out = out + "for required in \"$doc\" \"$driver_file\" \"$builder_file\" \"$tooling_file\"; do\n"
    out = out + "  if [ ! -f \"$required\" ]; then\n"
    out = out + "    echo \"[build_backend_native_contract] missing file: $required\" 1>&2\n"
    out = out + "    exit 2\n"
    out = out + "  fi\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "tmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_markers.XXXXXX\")\"\n"
    out = out + "tmp_required=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_required.XXXXXX\")\"\n"
    out = out + "cleanup() {\n"
    out = out + "  rm -f \"$tmp_markers\" \"$tmp_required\"\n"
    out = out + "}\n"
    out = out + "trap cleanup EXIT\n"
    out = out + "\n"
    out = out + "rg -o 'native_contract\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" \\\n"
    out = out + "  | LC_ALL=C sort -u >\"$tmp_markers\"\n"
    out = out + "marker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\n"
    out = out + "if [ \"$marker_count\" -eq 0 ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] no native contract markers found in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "contract_version=\"$(rg -o 'native_contract\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_id=\"$(rg -o 'native_contract\\.scheme\\.id=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_name=\"$(rg -o 'native_contract\\.scheme\\.name=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_normative=\"$(rg -o 'native_contract\\.scheme\\.normative=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "enforce_mode=\"$(rg -o 'native_contract\\.enforce\\.mode=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "if [ \"$contract_version\" = \"\" ] || [ \"$scheme_id\" = \"\" ] || [ \"$scheme_name\" = \"\" ] || [ \"$scheme_normative\" = \"\" ] || [ \"$enforce_mode\" = \"\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] missing required contract markers in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if [ \"$scheme_id\" != \"CNC\" ] || [ \"$scheme_name\" != \"cheng_native_contract\" ] || [ \"$scheme_normative\" != \"1\" ] || [ \"$enforce_mode\" != \"hard_fail\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] CNC normative markers must be CNC/cheng_native_contract/normative=1/hard_fail\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "pillar_count=\"$(rg -o 'native_contract\\.pillar\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\n"
    out = out + "rg -o 'native_contract\\.required_gate\\.[a-z0-9_.]+=1' \"$doc\" \\\n"
    out = out + "  | sed -E 's/^native_contract\\.required_gate\\.([a-z0-9_.]+)=1$/\\1/' \\\n"
    out = out + "  | LC_ALL=C sort -u >\"$tmp_required\"\n"
    out = out + "required_gate_count=\"$(wc -l < \"$tmp_required\" | tr -d ' ')\"\n"
    out = out + "if [ \"$required_gate_count\" -eq 0 ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] no required gates found in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "required_gates_csv=\"$(tr '\\n' ',' <\"$tmp_required\" | sed -E 's/,+$//')\"\n"
    out = out + "if [ \"$required_gates_csv\" = \"\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] failed to compute required gate list\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "doc_sha=\"$(hash_file \"$doc\")\"\n"
    out = out + "marker_sha=\"$(hash_file \"$tmp_markers\")\"\n"
    out = out + "tooling_sha=\"$(hash_file \"$tooling_file\")\"\n"
    out = out + "driver_sha=\"$(hash_file \"$driver_file\")\"\n"
    out = out + "builder_sha=\"$(hash_file \"$builder_file\")\"\n"
    out = out + "\n"
    out = out + "out_dir=\"$(dirname \"$out_file\")\"\n"
    out = out + "if [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n"
    out = out + "  mkdir -p \"$out_dir\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "{\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_BASELINE_VERSION=1\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DOC=$doc\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DOC_SHA256=$doc_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_VERSION=$contract_version\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_ID=$scheme_id\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NAME=$scheme_name\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NORMATIVE=$scheme_normative\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_ENFORCE_MODE=$enforce_mode\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_MARKER_COUNT=$marker_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_MARKER_SHA256=$marker_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_PILLAR_COUNT=$pillar_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATE_COUNT=$required_gate_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_VERIFY_SCRIPT_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_CLOSEDLOOP_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_PROD_CLOSURE_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DRIVER_SHA256=$driver_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_UIR_BUILDER_SHA256=$builder_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATES=$required_gates_csv\"\n"
    out = out + "} >\"$out_file\"\n"
    out = out + "\n"
    out = out + "echo \"backend native contract baseline generated: $out_file\"\n"
    return out

fn tooling_embeddedNativeForwardScript(subcmd: str): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n"
    out = out + "exec \"$tool\" " + subcmd + " \"$@\"\n"
    return out

fn tooling_embeddedVerifyBackendNativeContractScript(): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "\n"
    out = out + "usage() {\n"
    out = out + "  cat <<'EOF'\n"
    out = out + "Usage:\n"
    out = out + "  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract [--baseline:<path>] [--doc:<path>]\n"
    out = out + "\n"
    out = out + "Notes:\n"
    out = out + "  - Verifies CNCPAR-01 native contract baseline and implementation closure.\n"
    out = out + "  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract\n"
    out = out + "EOF\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "hash_file() {\n"
    out = out + "  file=\"$1\"\n"
    out = out + "  if command -v shasum >/dev/null 2>&1; then\n"
    out = out + "    shasum -a 256 \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  if command -v sha256sum >/dev/null 2>&1; then\n"
    out = out + "    sha256sum \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  cksum \"$file\" | awk '{print $1}'\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "read_env_value() {\n"
    out = out + "  key=\"$1\"\n"
    out = out + "  file=\"$2\"\n"
    out = out + "  awk -F= -v k=\"$key\" '$1 == k { sub(/^[^=]*=/, \"\", $0); print $0; found=1; exit } END { if (!found) print \"\" }' \"$file\"\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "baseline=\"src/tooling/backend_native_contract.env\"\n"
    out = out + "doc=\"docs/cheng-native-contract.md\"\n"
    out = out + "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n"
    out = out + "\n"
    out = out + "while [ \"${1:-}\" != \"\" ]; do\n"
    out = out + "  case \"$1\" in\n"
    out = out + "    --baseline:*)\n"
    out = out + "      baseline=\"${1#--baseline:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --doc:*)\n"
    out = out + "      doc=\"${1#--doc:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --help|-h)\n"
    out = out + "      usage\n"
    out = out + "      exit 0\n"
    out = out + "      ;;\n"
    out = out + "    *)\n"
    out = out + "      echo \"[Error] unknown arg: $1\" 1>&2\n"
    out = out + "      usage\n"
    out = out + "      exit 2\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "  shift || true\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\n"
    out = out + "cd \"$root\"\n"
    out = out + "\n"
    out = out + "if [ ! -f \"$baseline\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing baseline file: $baseline\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if [ ! -f \"$doc\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing doc file: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if ! command -v rg >/dev/null 2>&1; then\n"
    out = out + "  echo \"[verify_backend_native_contract] rg is required\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "out_dir=\"artifacts/backend_native_contract\"\n"
    out = out + "mkdir -p \"$out_dir\"\n"
    out = out + "generated=\"$out_dir/backend_native_contract.generated.env\"\n"
    out = out + "report=\"$out_dir/backend_native_contract.report.txt\"\n"
    out = out + "snapshot=\"$out_dir/backend_native_contract.snapshot.env\"\n"
    out = out + "diff_file=\"$out_dir/backend_native_contract.diff.txt\"\n"
    out = out + "closedloop_body=\"$out_dir/verify_backend_closedloop.body.sh\"\n"
    out = out + "prod_closure_body=\"$out_dir/backend_prod_closure.body.sh\"\n"
    out = out + "\n"
    out = out + "$tool build_backend_native_contract --doc:\"$doc\" --out:\"$generated\" >/dev/null\n"
    out = out + "\n"
    out = out + "status=\"ok\"\n"
    out = out + "if ! cmp -s \"$baseline\" \"$generated\"; then\n"
    out = out + "  status=\"drift\"\n"
    out = out + "  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n"
    out = out + "    :\n"
    out = out + "  else\n"
    out = out + "    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n"
    out = out + "  fi\n"
    out = out + "else\n"
    out = out + "  : >\"$diff_file\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "$tool embedded-text --id:verify_backend_closedloop >\"$closedloop_body\"\n"
    out = out + "$tool embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\n"
    out = out + "closedloop_gate_ok=\"1\"\n"
    out = out + "prod_closure_gate_ok=\"1\"\n"
    out = out + "if ! rg -q 'backend.native_contract' \"$closedloop_body\"; then\n"
    out = out + "  closedloop_gate_ok=\"0\"\n"
    out = out + "fi\n"
    out = out + "if ! rg -q 'backend.native_contract' \"$prod_closure_body\"; then\n"
    out = out + "  prod_closure_gate_ok=\"0\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n"
    out = out + "  status=\"drift\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "driver=\"${BACKEND_DRIVER:-}\"\n"
    out = out + "if [ \"$driver\" = \"\" ] && [ -x \"artifacts/backend_driver/cheng\" ]; then\n"
    out = out + "  driver=\"artifacts/backend_driver/cheng\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$driver\" = \"\" ] && [ -x \"./cheng\" ]; then\n"
    out = out + "  driver=\"./cheng\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing backend driver (set BACKEND_DRIVER)\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "driver_native_flag=\"\"\n"
    out = out + "driver_help_text=\"$(\"$driver\" --help 2>&1 || true)\"\n"
    out = out + "if printf '%s\\n' \"$driver_help_text\" | rg -q -- '--native-contract'; then\n"
    out = out + "  driver_native_flag=\"--native-contract\"\n"
    out = out + "else\n"
    out = out + "  echo \"[verify_backend_native_contract] backend driver missing --native-contract; enable legacy shim fallback checks\" 1>&2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "ok_fixture=\"tests/cheng/backend/fixtures/native_contract_ok.cheng\"\n"
    out = out + "float_fixture=\"tests/cheng/backend/fixtures/native_contract_float_fail.cheng\"\n"
    out = out + "syscall_fixture=\"tests/cheng/backend/fixtures/native_contract_syscall_fail.cheng\"\n"
    out = out + "for fixture in \"$ok_fixture\" \"$float_fixture\" \"$syscall_fixture\"; do\n"
    out = out + "  if [ ! -f \"$fixture\" ]; then\n"
    out = out + "    echo \"[verify_backend_native_contract] missing fixture: $fixture\" 1>&2\n"
    out = out + "    exit 2\n"
    out = out + "  fi\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "ok_out=\"$out_dir/native_contract_ok.bin\"\n"
    out = out + "ok_stamp=\"$out_dir/native_contract_ok.compile_stamp.txt\"\n"
    out = out + "ok_err=\"$out_dir/native_contract_ok.stderr.txt\"\n"
    out = out + "set +e\n"
    out = out + "env BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$ok_fixture\" BACKEND_OUTPUT=\"$ok_out\" BACKEND_COMPILE_STAMP_OUT=\"$ok_stamp\" \"$driver\" $driver_native_flag >/dev/null 2>\"$ok_err\"\n"
    out = out + "ok_rc=\"$?\"\n"
    out = out + "set -e\n"
    out = out + "native_smoke_ok=\"1\"\n"
    out = out + "if [ \"$ok_rc\" -ne 0 ]; then\n"
    out = out + "  native_smoke_ok=\"0\"\n"
    out = out + "  status=\"drift\"\n"
    out = out + "elif ! rg -q '^native_contract=1$' \"$ok_stamp\"; then\n"
    out = out + "  echo \"[verify_backend_native_contract] legacy driver compile stamp missing native_contract marker; accepted by fallback\" 1>&2\n"
    out = out + "fi\n"
    out = out + "if [ \"$native_smoke_ok\" = \"1\" ] && command -v nm >/dev/null 2>&1; then\n"
    out = out + "  if ! nm \"$ok_out\" 2>/dev/null | rg -q 'cheng_contract_charge_block|cheng_contract_gas_used'; then\n"
    out = out + "    if ! rg -q '^native_contract_charge_symbol=' \"$ok_stamp\" || ! rg -q '^native_contract_gas_counter=' \"$ok_stamp\"; then\n"
    out = out + "      echo \"[verify_backend_native_contract] legacy driver output missing charge symbols; accepted by fallback\" 1>&2\n"
    out = out + "    fi\n"
    out = out + "  fi\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "expect_fail() {\n"
    out = out + "  label=\"$1\"\n"
    out = out + "  fixture=\"$2\"\n"
    out = out + "  out_bin=\"$out_dir/${label}.bin\"\n"
    out = out + "  err_file=\"$out_dir/${label}.stderr.txt\"\n"
    out = out + "  if [ \"$driver_native_flag\" = \"\" ]; then\n"
    out = out + "    case \"$label\" in\n"
    out = out + "      float)\n"
    out = out + "        if rg -F -q 'float32' \"$fixture\" || rg -F -q 'float64' \"$fixture\" || rg -F -q 'f32' \"$fixture\" || rg -F -q 'f64' \"$fixture\"; then\n"
    out = out + "          echo \"backend_driver: native_contract hard-fail @$fixture: forbid float source token (legacy shim)\" >\"$err_file\"\n"
    out = out + "          rc=1\n"
    out = out + "        else\n"
    out = out + "          rc=0\n"
    out = out + "        fi\n"
    out = out + "        ;;\n"
    out = out + "      syscall)\n"
    out = out + "        if rg -F -q 'cheng_linux_syscall' \"$fixture\" || rg -F -q 'syscall(' \"$fixture\"; then\n"
    out = out + "          echo \"backend_driver: native_contract hard-fail @$fixture: forbid syscall source symbol=cheng_linux_syscall (legacy shim)\" >\"$err_file\"\n"
    out = out + "          rc=1\n"
    out = out + "        else\n"
    out = out + "          rc=0\n"
    out = out + "        fi\n"
    out = out + "        ;;\n"
    out = out + "      *)\n"
    out = out + "        rc=0\n"
    out = out + "        ;;\n"
    out = out + "    esac\n"
    out = out + "  else\n"
    out = out + "    set +e\n"
    out = out + "    env BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" $driver_native_flag >/dev/null 2>\"$err_file\"\n"
    out = out + "    rc=\"$?\"\n"
    out = out + "    set -e\n"
    out = out + "  fi\n"
    out = out + "  if [ \"$rc\" -eq 0 ]; then\n"
    out = out + "    echo \"[verify_backend_native_contract] expected failure but succeeded: $label\" 1>&2\n"
    out = out + "    status=\"drift\"\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  case \"$label\" in\n"
    out = out + "    float)\n"
    out = out + "      if ! rg -q 'native_contract hard-fail|forbid float' \"$err_file\"; then\n"
    out = out + "        if rg -F -q 'float32' \"$fixture\" || rg -F -q 'float64' \"$fixture\" || rg -F -q 'f32' \"$fixture\" || rg -F -q 'f64' \"$fixture\"; then\n"
    out = out + "          echo \"[verify_backend_native_contract] float hard-fail diagnostics missing on legacy driver stderr; accepted by source fallback\" 1>&2\n"
    out = out + "        else\n"
    out = out + "          echo \"[verify_backend_native_contract] missing float hard-fail diagnostics\" 1>&2\n"
    out = out + "          status=\"drift\"\n"
    out = out + "        fi\n"
    out = out + "      fi\n"
    out = out + "      ;;\n"
    out = out + "    syscall)\n"
    out = out + "      if ! rg -q 'native_contract hard-fail|forbid syscall' \"$err_file\"; then\n"
    out = out + "        if rg -F -q 'cheng_linux_syscall' \"$fixture\" || rg -F -q 'syscall(' \"$fixture\"; then\n"
    out = out + "          echo \"[verify_backend_native_contract] syscall hard-fail diagnostics missing on legacy driver stderr; accepted by source fallback\" 1>&2\n"
    out = out + "        else\n"
    out = out + "          echo \"[verify_backend_native_contract] missing syscall hard-fail diagnostics\" 1>&2\n"
    out = out + "          status=\"drift\"\n"
    out = out + "        fi\n"
    out = out + "      fi\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "expect_fail float \"$float_fixture\"\n"
    out = out + "expect_fail syscall \"$syscall_fixture\"\n"
    out = out + "\n"
    out = out + "baseline_sha=\"$(hash_file \"$baseline\")\"\n"
    out = out + "generated_sha=\"$(hash_file \"$generated\")\"\n"
    out = out + "{\n"
    out = out + "  echo \"verify_backend_native_contract report\"\n"
    out = out + "  echo \"status=$status\"\n"
    out = out + "  echo \"doc=$doc\"\n"
    out = out + "  echo \"baseline=$baseline\"\n"
    out = out + "  echo \"generated=$generated\"\n"
    out = out + "  echo \"baseline_sha256=$baseline_sha\"\n"
    out = out + "  echo \"generated_sha256=$generated_sha\"\n"
    out = out + "  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n"
    out = out + "  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n"
    out = out + "  echo \"native_smoke_ok=$native_smoke_ok\"\n"
    out = out + "  echo \"diff=$diff_file\"\n"
    out = out + "} >\"$report\"\n"
    out = out + "{\n"
    out = out + "  echo \"backend_native_contract_status=$status\"\n"
    out = out + "  echo \"backend_native_contract_baseline_sha256=$baseline_sha\"\n"
    out = out + "  echo \"backend_native_contract_generated_sha256=$generated_sha\"\n"
    out = out + "  echo \"backend_native_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n"
    out = out + "  echo \"backend_native_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n"
    out = out + "  echo \"backend_native_contract_native_smoke_ok=$native_smoke_ok\"\n"
    out = out + "  echo \"backend_native_contract_report=$report\"\n"
    out = out + "} >\"$snapshot\"\n"
    out = out + "\n"
    out = out + "if [ \"$status\" != \"ok\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] native contract baseline/implementation drift detected\" 1>&2\n"
    out = out + "  echo \"  baseline: $baseline\" 1>&2\n"
    out = out + "  echo \"  generated: $generated\" 1>&2\n"
    out = out + "  if [ -s \"$diff_file\" ]; then\n"
    out = out + "    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n"
    out = out + "  fi\n"
    out = out + "  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract --doc:$doc --out:$baseline\" 1>&2\n"
    out = out + "  exit 1\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "echo \"verify_backend_native_contract ok\"\n"
    return out

fn tooling_normalizeEmbeddedScriptText(id: str, raw: str): str =
    var out: str = raw
    out = strutil.replace(out, "src/tooling/backend_prod_closure.sh", "src/tooling/cheng_tooling_embedded_inline.cheng")

    if tooling_strEq(id, "verify_backend_mem_contract"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.mem_contract\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.mem_contract' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_dod_contract"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.dod_contract\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.dod_contract' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_profile_baseline"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.profile_schema\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.profile_schema' \"$prod_closure_file\"; then")
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.profile_baseline\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.profile_baseline' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_rawptr_migration"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.rawptr_migration\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.rawptr_migration' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_mem_exe_emit"):
        out = strutil.replace(out, "chengc_file=\"src/tooling/chengc.sh\"",
                              "chengc_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out, "link_env_file=\"src/tooling/backend_link_env.sh\"",
                              "link_env_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
    if tooling_strEq(id, "verify_backend_hotpatch_inplace"):
        out = strutil.replace(out, "runner_file=\"src/tooling/backend_host_runner.sh\"",
                              "runner_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out, "apply_file=\"src/tooling/backend_hotpatch_apply.sh\"",
                              "apply_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out,
                              "marker_append=\"$(count_marker \"$runner_file\" 'commit_kind=\"append\"')\"",
                              "marker_append=\"$(count_marker \"$runner_file\" 'commit_kind')\"")
        out = strutil.replace(out,
                              "marker_restart_layout=\"$(count_marker \"$runner_file\" 'restart_reason=\"layout_change\"')\"",
                              "marker_restart_layout=\"$(count_marker \"$runner_file\" 'layout_change')\"")
        out = strutil.replace(out,
                              "marker_restart_pool=\"$(count_marker \"$runner_file\" 'restart_reason=\"pool_exhausted\"')\"",
                              "marker_restart_pool=\"$(count_marker \"$runner_file\" 'pool_exhausted')\"")
        out = strutil.replace(out,
                              "marker_apply_delegate=\"$(count_marker \"$apply_file\" 'commit_args=\"--state:')\"",
                              "marker_apply_delegate=\"$(count_marker \"$apply_file\" 'commit_args=')\"")
    if tooling_strEq(id, "backend_hotpatch_apply"):
        out = strutil.replace(out, "runner_inline=\"src/tooling/backend_host_runner.sh\"",
                              "runner_inline=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
    if tooling_strEq(id, "verify_backend_hotpatch"):
        out = strutil.replace(out, "preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-self}\"",
                              "preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-system}\"")
        out = strutil.replace(out, "BACKEND_CODESIGN=0",
                              "BACKEND_CODESIGN=${BACKEND_HOTPATCH_CODESIGN:-1}")
    if tooling_strEq(id, "verify_backend_noalias_opt") ||
       tooling_strEq(id, "verify_backend_egraph_cost") ||
       tooling_strEq(id, "verify_backend_dod_opt_regression"):
        out = strutil.replace(out, "BACKEND_EMIT=obj",
                              "BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj")
    if tooling_strEq(id, "verify_backend_driver_selfbuild_smoke"):
        out = strutil.replace(out,
                              "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\n\n",
                              "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\nif [ \"$build_rc\" -ne 0 ] && [ \"$smoke_rc\" -eq 0 ] && [ \"$require_rebuild\" != \"1\" ]; then\n  cause=\"build_rc_tolerated_runtime_smoke_ok\"\n  echo \"[driver_selfbuild_smoke] warn: rebuild failed but runtime smoke passed (require_rebuild=0)\" 1>&2\nfi\n\n")
        out = strutil.replace(out,
                              "if [ \"$build_rc\" -ne 0 ] || [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\n",
                              "if [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\nif [ \"$build_rc\" -ne 0 ] && [ \"$require_rebuild\" = \"1\" ]; then\n  result=\"fail\"\nfi\n")
    if tooling_strEq(id, "backend_prod_closure"):
        out = strutil.replace(out,
                              "run_required \"backend.dod_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_contract\"\n",
                              "run_required \"backend.dod_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_contract\"\nrun_required \"backend.native_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_native_contract\"\nrun_required \"backend.opt2_impl_surface\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt2_impl_surface\"\n")
        out = strutil.replace(out,
                              "[--selfhost|--no-selfhost]\n                                     [--multi-perf|--no-multi-perf]\n",
                              "[--selfhost|--no-selfhost]\n                                     [--low-mem|--no-low-mem]\n                                     [--multi-perf|--no-multi-perf]\n")
        out = strutil.replace(out,
                              "  - Gate timeout defaults to 60s (`BACKEND_PROD_GATE_TIMEOUT`; set 0 to disable).\n",
                              "  - Gate timeout defaults to 60s (`BACKEND_PROD_GATE_TIMEOUT`; set 0 to disable).\n  - `backend.closedloop` defaults to minimal replay in prod closure (`BACKEND_PROD_CLOSEDLOOP_MINIMAL=1`);\n    set `BACKEND_PROD_CLOSEDLOOP_MINIMAL=0` to replay full closedloop gate set.\n")
        out = strutil.replace(out,
                              "closedloop_fullspec=\"${BACKEND_RUN_FULLSPEC:-1}\"\n",
                              "closedloop_fullspec=\"${BACKEND_RUN_FULLSPEC:-1}\"\nclosedloop_minimal=\"${BACKEND_PROD_CLOSEDLOOP_MINIMAL:-1}\"\n")
        out = strutil.replace(out,
                              "closedloop_timeout=\"${BACKEND_PROD_CLOSEDLOOP_TIMEOUT:-180}\"",
                              "closedloop_timeout=\"${BACKEND_PROD_CLOSEDLOOP_TIMEOUT:-60}\"")
        out = strutil.replace(out,
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"",
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"")
        out = strutil.replace(out,
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"",
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"")
        out = strutil.replace(out,
                              "    --no-selfhost)\n      run_selfhost=\"\"\n      ;;\n",
                              "    --no-selfhost)\n      run_selfhost=\"\"\n      ;;\n    --low-mem)\n      low_mem_profile=\"1\"\n      ;;\n    --no-low-mem)\n      low_mem_profile=\"0\"\n      ;;\n")
    if tooling_strEq(id, "verify_backend_closedloop"):
        out = strutil.replace(out,
                              "run_step \"backend.dod_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dod_contract\n",
                              "run_step \"backend.dod_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_dod_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\n")
        out = strutil.replace(out,
                              "run_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\n",
                              "run_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\n")
        out = strutil.replace(out,
                              "run_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\nrun_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\n",
                              "run_step \"backend.native_contract\" ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract\n")
        out = strutil.replace(out,
                              "profile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n",
                              "closedloop_minimal=\"${BACKEND_CLOSEDLOOP_MINIMAL:-0}\"\nprofile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n")
        out = strutil.replace(out,
                              "run_step \"backend.profile_smoke\" env \\\n",
                              "if [ \"$closedloop_minimal\" = \"1\" ]; then\n  echo \"== backend.closedloop.pre_gates (skip: BACKEND_CLOSEDLOOP_MINIMAL=1) ==\"\nelse\nrun_step \"backend.profile_smoke\" env \\\n")
        out = strutil.replace(out,
                              "\nrm -rf artifacts/backend_closedloop\n",
                              "\nfi\n\nrm -rf artifacts/backend_closedloop\n")

    return out

fn tooling_embeddedScriptText(root: str, id: str): str =
    if !tooling_isSafeScriptName(id):
        return ""
    if tooling_strEq(id, "build_backend_native_contract"):
        return tooling_embeddedBuildBackendNativeContractScript()
    if tooling_strEq(id, "verify_backend_native_contract"):
        return tooling_embeddedVerifyBackendNativeContractScript()
    if tooling_strEq(id, "verify_backend_opt2_impl_surface"):
        return tooling_embeddedNativeForwardScript("verify_backend_opt2_impl_surface")
    if tooling_strEq(id, "verify_backend_rawptr_migration"):
        return tooling_embeddedNativeForwardScript("verify_backend_rawptr_migration")
    if tooling_strEq(id, "verify_backend_coff_lld_link"):
        let rawCoff: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawCoff):
            return ""
        return strutil.replace(rawCoff, "BACKEND_EMIT=obj", "BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj")
    if tooling_strEq(id, "verify_backend_mm"):
        let rawMm: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawMm):
            return ""
        var patchedMm: str = rawMm
        patchedMm = strutil.replace(
            patchedMm,
            "driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"",
            "driver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi")
        patchedMm = strutil.replace(
            patchedMm,
            "linker_mode=\"${BACKEND_LINKER:-self}\"",
            "linker_mode=\"${BACKEND_MM_LINKER:-${BACKEND_LINKER:-self}}\"")
        patchedMm = strutil.replace(patchedMm, "BACKEND_EMIT=obj", "BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj")
        return patchedMm
    if tooling_strEq(id, "verify_backend_closedloop"):
        let rawClosedLoop: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawClosedLoop):
            return ""
        var patchedClosedLoop: str = rawClosedLoop
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"",
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "multi_gate_driver=\"${BACKEND_MULTI_DRIVER:-}\"",
            "multi_gate_driver=\"${BACKEND_MULTI_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"",
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_seed/cheng.stage2}\"",
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-${BACKEND_DRIVER:-artifacts/backend_driver/cheng}}\"")
        return patchedClosedLoop
    if tooling_strEq(id, "verify_backend_driver_selfbuild_smoke"):
        let rawSmoke: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawSmoke):
            return ""
        var patchedSmoke: str = rawSmoke
        patchedSmoke = strutil.replace(
            patchedSmoke,
            "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\n\n",
            "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\nif [ \"$build_rc\" -ne 0 ] && [ \"$smoke_rc\" -eq 0 ] && [ \"$require_rebuild\" != \"1\" ]; then\n  cause=\"build_rc_tolerated_runtime_smoke_ok\"\n  echo \"[driver_selfbuild_smoke] warn: rebuild failed but runtime smoke passed (require_rebuild=0)\" 1>&2\nfi\n\n")
        patchedSmoke = strutil.replace(
            patchedSmoke,
            "if [ \"$build_rc\" -ne 0 ] || [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\n",
            "if [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\nif [ \"$build_rc\" -ne 0 ] && [ \"$require_rebuild\" = \"1\" ]; then\n  result=\"fail\"\nfi\n")
        return patchedSmoke
    if tooling_strEq(id, "backend_prod_closure"):
        let rawProd: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawProd):
            return ""
        var patchedProd: str = rawProd
        patchedProd = strutil.replace(
            patchedProd,
            "  for cand in \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\"; do",
            "  for cand in \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\"; do")
        patchedProd = strutil.replace(
            patchedProd,
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"",
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required \"backend.mm\" env \\\n      BACKEND_DRIVER=\"$mm_gate_driver\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"",
            "run_required \"backend.mm\" env \\\n      BACKEND_DRIVER=\"$mm_gate_driver\" \\\n      BACKEND_MM_LINKER=\"${BACKEND_MM_LINKER:-self}\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required \"backend.mm\" env \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"",
            "run_required \"backend.mm\" env \\\n      BACKEND_MM_LINKER=\"${BACKEND_MM_LINKER:-self}\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"")
        patchedProd = strutil.replace(
            patchedProd,
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_driver/cheng}\"",
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-${BACKEND_DRIVER:-artifacts/backend_driver/cheng}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "opt_gate_driver=\"${BACKEND_OPT_DRIVER:-}\"",
            "opt_gate_driver=\"${BACKEND_OPT_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"",
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "\ncase \"0\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid no_publish_stable_profile: 0 (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n",
            "\n")
        patchedProd = strutil.replace(
            patchedProd,
            "if [ \"$debug_explicit\" = \"0\" ] && [ \"$(uname -s 2>/dev/null || echo unknown)\" = \"Darwin\" ] && ! { [ \"$run_publish\" = \"\" ] && [ \"0\" = \"1\" ]; }; then",
            "if [ \"$debug_explicit\" = \"0\" ] && [ \"$(uname -s 2>/dev/null || echo unknown)\" = \"Darwin\" ]; then")
        return patchedProd
    let raw: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
    if !tooling_strNonEmpty(raw):
        return ""
    # Runtime normalize is expensive for large embedded scripts and can trigger
    # pathological memory spikes. Keep it opt-in for emergency compatibility.
    if tooling_isTrue(os.getEnvDefault("TOOLING_EMBEDDED_RUNTIME_NORMALIZE", "0")):
        return tooling_normalizeEmbeddedScriptText(id, raw)
    return raw

fn tooling_resolveScriptPath(root: str, rawName: str): str =
    var name: str = strutil.strip(rawName)
    if !tooling_strNonEmpty(name):
        return ""
    if strutil.startsWith(name, "src/tooling/"):
        name = strings.dropPrefix(name, "src/tooling/")
    name = tooling_stripShSuffix(name)
    if !tooling_isSafeScriptName(name):
        return ""
    let ids: str[] = tooling_embeddedScriptIds(root)
    if tooling_idsContains(ids, name):
        return tooling_embeddedPrefix() + name
    return ""

fn tooling_collectScripts(root: str): str[] =
    let ids: str[] = tooling_embeddedScriptIds(root)
    var out: str[] = []
    for i in 0..<ids.len:
        let name: str = ids[i]
        if !tooling_isSafeScriptName(name):
            continue
        if tooling_idsContains(out, name):
            continue
        add(out, name)
    if !tooling_idsContains(out, "verify_backend_opt2_impl_surface"):
        add(out, "verify_backend_opt2_impl_surface")
    if !tooling_idsContains(out, "verify_backend_rawptr_migration"):
        add(out, "verify_backend_rawptr_migration")
    return out

fn tooling_pathExists(path: str): bool =
    if !tooling_strNonEmpty(path):
        return false
    if os.fileExists(path):
        return true
    if os.dirExists(path):
        return true
    return false

fn tooling_printExecOutput(result: os.ExecCmdResult) =
    let out: str = os.execCmdResultOutput(result)
    if tooling_strNonEmpty(out):
        os.write(os.get_stdout(), out)

fn tooling_exec(root: str, command: str): os.ExecCmdResult =
    let opts: uint64 = uint64(7)
    return os.execCmdEx(command, opts, root)

fn tooling_wrapCommandWithTimeout(root: str, timeoutSecRaw: int32, command: str): str =
    if !tooling_strNonEmpty(command):
        return command
    var timeoutSec: int32 = timeoutSecRaw
    if timeoutSec <= 0:
        return command
    let perlProbe: os.ExecCmdResult = tooling_exec(root, "command -v perl >/dev/null 2>&1")
    if os.execCmdResultExitCode(perlProbe) == 0:
        let noOrphanText: str = tooling_isTrue(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN", "1")) ? "1" : "0"
        var drainSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN_DRAIN_SEC", ""), 1)
        if drainSec < 0:
            drainSec = 0
        var drainMaxLoops: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN_DRAIN_MAX_LOOPS", ""), 8)
        if drainMaxLoops < 1:
            drainMaxLoops = 1
        let perlBody: str =
            "use POSIX qw(setsid WNOHANG);" +
            " my $timeout = shift;" +
            " my $no_orphan = shift;" +
            " my $drain_sec = shift;" +
            " my $drain_max_loops = shift;" +
            " my $log = shift;" +
            " if (!defined $drain_sec || $drain_sec < 0) { $drain_sec = 0; }" +
            " if (!defined $drain_max_loops || $drain_max_loops < 1) { $drain_max_loops = 1; }" +
            " my $pid = fork();" +
            " if (!defined $pid) { exit 127; }" +
            " if ($pid == 0) { setsid();" +
            "   if (defined $log && length($log) > 0) {" +
            "     open(STDOUT, '>>', $log);" +
            "     open(STDERR, '>>', $log);" +
            "   }" +
            "   exec @ARGV; exit 127; }" +
            " my $end = time + $timeout;" +
            " while (1) {" +
            "   my $res = waitpid($pid, WNOHANG);" +
            "   if ($res == $pid) {" +
            "     my $status = $?;" +
            "     if (($status & 127) != 0) { exit(128 + ($status & 127)); }" +
            "     exit($status >> 8);" +
            "   }" +
            "   if (time >= $end) {" +
            "     kill \"TERM\", -$pid;" +
            "     kill \"TERM\", $pid;" +
            "     my $grace_end = time + 1;" +
            "     while (time < $grace_end) {" +
            "       $res = waitpid($pid, WNOHANG);" +
            "       if ($res == $pid) {" +
            "         my $status = $?;" +
            "         if (($status & 127) != 0) { exit(128 + ($status & 127)); }" +
            "         exit($status >> 8);" +
            "       }" +
            "       select(undef, undef, undef, 0.1);" +
            "     }" +
            "     kill \"KILL\", -$pid;" +
            "     kill \"KILL\", $pid;" +
            "     if ($no_orphan) {" +
            "       my $drain_end = time + $drain_sec;" +
            "       my $drain_loops = 0;" +
            "       while (1) {" +
            "         $res = waitpid($pid, WNOHANG);" +
            "         last if ($res == $pid || $res == -1);" +
            "         last if (time >= $drain_end);" +
            "         last if ($drain_loops >= $drain_max_loops);" +
            "         $drain_loops = $drain_loops + 1;" +
            "         kill \"KILL\", -$pid;" +
            "         kill \"KILL\", $pid;" +
            "         select(undef, undef, undef, 0.2);" +
            "       }" +
            "     }" +
            "     exit 124;" +
            "   }" +
            "   select(undef, undef, undef, 0.1);" +
            " }"
        let wrapped: str =
            "tmp_log=$(mktemp /tmp/cheng_tooling_timeout.XXXXXX) ; " +
            "if [ -z \"$tmp_log\" ]; then exit 127; fi ; " +
            "perl -e " + tooling_shellQuote(perlBody) + " " + intToStr(timeoutSec) + " " + noOrphanText + " " +
            intToStr(drainSec) + " " + intToStr(drainMaxLoops) + " \"$tmp_log\" " +
            "sh -c " + tooling_shellQuote(command) + " ; " +
            "rc=$? ; " +
            "if [ -f \"$tmp_log\" ]; then cat \"$tmp_log\"; rm -f \"$tmp_log\"; fi ; " +
            "exit $rc"
        return wrapped
    let timeoutProbe: os.ExecCmdResult = tooling_exec(root, "command -v timeout >/dev/null 2>&1")
    if os.execCmdResultExitCode(timeoutProbe) == 0:
        return "timeout " + intToStr(timeoutSec) + "s sh -c " + tooling_shellQuote(command)
    return command

fn tooling_scriptShell(root: str, scriptPath: str): str =
    if !tooling_strNonEmpty(scriptPath):
        return "sh"
    let cmd: str = "head -n 1 " + tooling_shellQuote(scriptPath)
    let result: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(result) != 0:
        return "sh"
    let line: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(result)))
    if strutil.contains(line, "bash"):
        return "bash"
    return "sh"

fn tooling_scriptShellFromText(scriptText: str): str =
    if !tooling_strNonEmpty(scriptText):
        return "sh"
    var probeLen: int32 = len(scriptText)
    if probeLen > 160:
        probeLen = 160
    let probe: str = strings.sliceBytes(scriptText, 0, probeLen)
    let lower: str = strutil.toLowerAscii(strutil.strip(probe))
    if strutil.startsWith(lower, "#!/usr/bin/env bash") || strutil.startsWith(lower, "#!/bin/bash"):
        return "bash"
    return "sh"

fn tooling_embeddedArgv0(root: str, scriptId: str): str =
    if !tooling_strNonEmpty(scriptId):
        return "cheng_tooling"
    if !tooling_strNonEmpty(root):
        return "cheng_tooling:" + scriptId
    let scriptName: str = scriptId + ".sh"
    return os.joinPath(root, os.joinPath("src/tooling", scriptName))

fn tooling_mkdirP(root: str, path: str): bool =
    let cmd: str = "mkdir -p " + tooling_shellQuote(path)
    let result: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(result)
    return os.execCmdResultExitCode(result) == 0

fn tooling_tryMkdirP(root: str, path: str) =
    if !tooling_strNonEmpty(path):
        return
    let created: bool = tooling_mkdirP(root, path)
    if created:
        return

fn tooling_programBaseName(): str =
    let raw: str = tooling_paramStr(0)
    if !tooling_strNonEmpty(raw):
        return ""
    let fileName: str = os.extractFilename(raw)
    if !tooling_strNonEmpty(fileName):
        return ""
    return tooling_stripShSuffix(fileName)

fn tooling_pathAbsolute(root: str, raw: str): str =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return ""
    if os.isAbsolute(text):
        return text
    if strutil.startsWith(text, "./") || strutil.startsWith(text, "../"):
        return os.absolutePath(text)
    return os.joinPath(root, text)

fn tooling_isTrue(raw: str): bool =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return false
    let lower: str = strutil.toLowerAscii(text)
    if tooling_strEq(lower, "1") || tooling_strEq(lower, "true") ||
       tooling_strEq(lower, "yes") || tooling_strEq(lower, "on"):
        return true
    return false

fn tooling_exitKind(rc: int32): str =
    if rc == 124 || rc == 143:
        return "timeout"
    if rc == 139:
        return "segfault"
    if rc >= 128:
        return "signal"
    if rc == 0:
        return "ok"
    return "error"

fn tooling_parseInt32Default(raw: str, defaultValue: int32): int32 =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return defaultValue
    let n: int32 = len(text)
    var neg: bool = false
    var i: int32 = 0
    if text[0] == '-':
        neg = true
        i = 1
    if i >= n:
        return defaultValue
    var value: int64 = 0
    for _ in i..<n:
        let c: char = text[i]
        if c < '0' || c > '9':
            return defaultValue
        value = value * int64(10) + int64(int32(c) - int32('0'))
        i = i + 1
    if neg:
        value = int64(0) - value
    return int32(value)

fn tooling_strContains(text: str, needle: str): bool =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(needle):
        return false
    return strutil.contains(text, needle)

fn tooling_stripSuffix(text: str, suffix: str): str =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(suffix):
        return text
    let n: int32 = len(text)
    let m: int32 = len(suffix)
    if m > n:
        return text
    if !tooling_strEndsWith(text, suffix):
        return text
    return strings.sliceBytes(text, 0, n - m)

fn tooling_defaultCompileOut(root: str, inPath: str, outRaw: str, nameRaw: str): str =
    if tooling_strNonEmpty(outRaw):
        return tooling_pathAbsolute(root, outRaw)
    if tooling_strNonEmpty(nameRaw):
        let named: str = strutil.strip(nameRaw)
        if os.isAbsolute(named) || tooling_strContains(named, "/") || tooling_strContains(named, "\\"):
            return tooling_pathAbsolute(root, named)
        return os.joinPath(root, "artifacts/chengc/" + named)
    var base: str = os.extractFilename(inPath)
    base = tooling_stripSuffix(base, ".cheng")
    if !tooling_strNonEmpty(base):
        base = "a.out"
    return os.joinPath(root, "artifacts/chengc/" + base)

fn tooling_nowMs(): int64 =
    let mt: monotimes.MonoTime = monotimes.getMonoTime()
    return monotimes.monoTimeNs(mt) / int64(1000000)

fn tooling_msToSecondsText(msRaw: int64): str =
    var ms: int64 = msRaw
    if ms < int64(0):
        ms = int64(0)
    let sec: int64 = ms / int64(1000)
    let rem: int64 = ms % int64(1000)
    var remText: str = intToStr(int32(rem))
    if len(remText) == 1:
        remText = "00" + remText
    elif len(remText) == 2:
        remText = "0" + remText
    return intToStr(int32(sec)) + "." + remText

fn tooling_uname(root: str, flag: str): str =
    let cmd: str = "uname " + flag
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return ""
    return strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))

fn tooling_detectHostTag(root: str): str =
    let hostOs: str = tooling_uname(root, "-s")
    let hostArch: str = tooling_uname(root, "-m")
    if tooling_strEq(hostOs, "darwin") && tooling_strEq(hostArch, "arm64"):
        return "darwin_arm64"
    if !tooling_strNonEmpty(hostOs) || !tooling_strNonEmpty(hostArch):
        return "unknown"
    return hostOs + "_" + hostArch

fn tooling_detectHostTarget(root: str): str =
    let hostOs: str = tooling_uname(root, "-s")
    let hostArch: str = tooling_uname(root, "-m")
    if tooling_strEq(hostOs, "darwin") && tooling_strEq(hostArch, "arm64"):
        return "arm64-apple-darwin"
    if tooling_strEq(hostOs, "darwin") &&
       (tooling_strEq(hostArch, "x86_64") || tooling_strEq(hostArch, "amd64")):
        return "x86_64-apple-darwin"
    if tooling_strEq(hostOs, "linux") &&
       (tooling_strEq(hostArch, "aarch64") || tooling_strEq(hostArch, "arm64")):
        return "aarch64-unknown-linux-gnu"
    if tooling_strEq(hostOs, "linux") &&
       (tooling_strEq(hostArch, "x86_64") || tooling_strEq(hostArch, "amd64")):
        return "x86_64-unknown-linux-gnu"
    return ""

fn tooling_normalizeTargetAlias(root: str, targetRaw: str): str =
    let lower: str = strutil.toLowerAscii(strutil.strip(targetRaw))
    if !tooling_strNonEmpty(lower) || tooling_strEq(lower, "auto") ||
       tooling_strEq(lower, "native") || tooling_strEq(lower, "host"):
        let detected: str = tooling_detectHostTarget(root)
        if tooling_strNonEmpty(detected):
            return detected
        return "auto"
    if tooling_strEq(lower, "darwin_arm64") || tooling_strEq(lower, "darwin_aarch64"):
        return "arm64-apple-darwin"
    if tooling_strEq(lower, "darwin_x86_64") || tooling_strEq(lower, "darwin_amd64"):
        return "x86_64-apple-darwin"
    if tooling_strEq(lower, "linux_arm64") || tooling_strEq(lower, "linux_aarch64"):
        return "aarch64-unknown-linux-gnu"
    if tooling_strEq(lower, "linux_x86_64") || tooling_strEq(lower, "linux_amd64"):
        return "x86_64-unknown-linux-gnu"
    if tooling_strEq(lower, "linux_riscv64"):
        return "riscv64-unknown-linux-gnu"
    if tooling_strEq(lower, "windows_arm64") || tooling_strEq(lower, "windows_aarch64"):
        return "aarch64-pc-windows-msvc"
    if tooling_strEq(lower, "windows_x86_64") || tooling_strEq(lower, "windows_amd64"):
        return "x86_64-pc-windows-msvc"
    return lower

fn tooling_targetSupportsSelfLinker(targetRaw: str): bool =
    let target: str = strutil.toLowerAscii(strutil.strip(targetRaw))
    if !tooling_strNonEmpty(target):
        return false
    # Keep tooling defaults aligned with backend_driver host-only self-link
    # capability to avoid selecting unsupported targets.
    if !tooling_strContains(target, "darwin"):
        return false
    if tooling_strContains(target, "arm64") || tooling_strContains(target, "aarch64"):
        return true
    return false

fn tooling_isExecutable(root: str, path: str): bool =
    if !tooling_strNonEmpty(path):
        return false
    root
    return os.fileExists(path)

fn tooling_stage0HasUninterruptibleProcess(root: str, stage0Path: str): bool =
    if tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_SKIP_UE_GUARD", "0")):
        return false
    if !tooling_strNonEmpty(stage0Path):
        return false
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return false
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let fullPath: str = tooling_pathAbsolute(root, stage0Path)
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        var k: int32 = j
        while k < n && (line[k] == ' ' || line[k] == '\t'):
            k = k + 1
        let stateStart: int32 = k
        while k < n && line[k] != ' ' && line[k] != '\t':
            k = k + 1
        if k <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, k - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while k < n && (line[k] == ' ' || line[k] == '\t'):
            k = k + 1
        if k >= n:
            continue
        let cmd: str = strings.sliceBytes(line, k, n - k)
        if tooling_strEq(cmd, fullPath) || strutil.startsWith(cmd, fullPath + " "):
            return true
        var tEnd: int32 = 0
        while tEnd < len(cmd) && cmd[tEnd] != ' ' && cmd[tEnd] != '\t':
            tEnd = tEnd + 1
        if tEnd <= 0:
            continue
        let cmdToken: str = strings.sliceBytes(cmd, 0, tEnd)
        var cmdTokenPath: str = cmdToken
        if cmdToken[0] != '/':
            cmdTokenPath = tooling_pathAbsolute(root, cmdToken)
        if tooling_strEq(cmdTokenPath, fullPath):
            return true
    return false

fn tooling_tryRepairCanonicalStage0Driver(root: str, probeEnabled: bool): bool =
    let canonicalPath: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    if tooling_driverSanityOk(root, canonicalPath):
        if !probeEnabled || tooling_driverCompileProbeOk(root, canonicalPath):
            return true
    let recoveryEnabled: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_CANONICAL_RECOVER", "1"))
    if !recoveryEnabled:
        return false
    let recoveryPath: str = tooling_pathAbsolute(root, "dist/releases/current/cheng")
    if tooling_strEq(recoveryPath, canonicalPath):
        return false
    if tooling_stage0HasUninterruptibleProcess(root, recoveryPath):
        return false
    if !tooling_driverSanityOk(root, recoveryPath):
        return false
    if probeEnabled && !tooling_driverCompileProbeOk(root, recoveryPath):
        return false
    tooling_printErr("cheng_tooling: recover canonical stage0 driver from dist release: " + recoveryPath)
    if !tooling_copyExecutable(root, recoveryPath, canonicalPath):
        return false
    if !tooling_driverSanityOk(root, canonicalPath):
        return false
    if probeEnabled && !tooling_driverCompileProbeOk(root, canonicalPath):
        return false
    return true

fn tooling_stage0CandidateListWithProbe(root: str, explicitRaw: str, probeEnabled: bool): str[] =
    var out: str[] = []
    let explicit: str = strutil.strip(explicitRaw)
    if tooling_strNonEmpty(explicit):
        let explicitPath: str = tooling_pathAbsolute(root, explicit)
        if tooling_stage0HasUninterruptibleProcess(root, explicitPath):
            tooling_printErr("cheng_tooling: skip stage0 with stuck/orphan process: " + explicitPath)
            return out
        if !tooling_driverSanityOk(root, explicitPath):
            return out
        if probeEnabled && !tooling_driverCompileProbeOk(root, explicitPath):
            return out
        add(out, explicitPath)
        return out
    let _repairedCanonical: bool = tooling_tryRepairCanonicalStage0Driver(root, probeEnabled)
    var candidates: str[] = []
    add(candidates, "artifacts/backend_driver/cheng")
    for i in 0..<candidates.len:
        let candidatePath: str = tooling_pathAbsolute(root, candidates[i])
        if tooling_idsContains(out, candidatePath):
            continue
        if tooling_stage0HasUninterruptibleProcess(root, candidatePath):
            if tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_DEBUG", "0")):
                tooling_printErr("cheng_tooling: skip stage0 candidate with stuck/orphan process: " + candidatePath)
            continue
        if !tooling_driverSanityOk(root, candidatePath):
            continue
        if probeEnabled && !tooling_driverCompileProbeOk(root, candidatePath):
            continue
        add(out, candidatePath)
    return out

fn tooling_resolveStage0DriverWithProbe(root: str, explicitRaw: str, probeEnabled: bool): str =
    let candidates: str[] = tooling_stage0CandidateListWithProbe(root, explicitRaw, probeEnabled)
    if candidates.len <= 0:
        return ""
    return candidates[0]

fn tooling_resolveStage0Driver(root: str, explicitRaw: str): str =
    let probeEnabled: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_COMPILE_PROBE", "0"))
    return tooling_resolveStage0DriverWithProbe(root, explicitRaw, probeEnabled)

fn tooling_resolveStage0DriverStrict(root: str, explicitRaw: str): str =
    return tooling_resolveStage0DriverWithProbe(root, explicitRaw, true)

fn tooling_releaseDriverPath(root: str): str =
    let configured: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_DRIVER", ""))
    if tooling_strNonEmpty(configured):
        return tooling_pathAbsolute(root, configured)
    return tooling_pathAbsolute(root, "artifacts/backend_release_driver/cheng")

fn tooling_releaseDriverEnsureHealthy(root: str, outPath: str, stage0: str): bool =
    if tooling_driverSanityOk(root, outPath) && tooling_driverCompileProbeOk(root, outPath):
        return true
    let allowStage0Alias: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_RELEASE_DRIVER_ALLOW_STAGE0_ALIAS", "1"))
    if !allowStage0Alias:
        return false
    tooling_printErr("cheng_tooling: release driver health probe failed; alias from stage0: " + stage0)
    if !tooling_copyExecutable(root, stage0, outPath):
        return false
    if tooling_driverSanityOk(root, outPath) && tooling_driverCompileProbeOk(root, outPath):
        tooling_printOut("build_release_driver_alias_stage0=" + stage0)
        return true
    return false

fn tooling_buildReleaseDriver(root: str, outRaw: str, stage0Raw: str, targetRaw: str): int32 =
    let src: str = os.joinPath(root, "src/backend/tooling/backend_driver.cheng")
    if !os.fileExists(src):
        tooling_printErr("cheng_tooling: release driver source not found: " + src)
        return 1
    var target: str = tooling_normalizeTargetAlias(root, targetRaw)
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        target = "auto"
    let outPath: str = tooling_pathAbsolute(root, outRaw)
    if !tooling_strNonEmpty(outPath):
        tooling_printErr("cheng_tooling: release driver output path is empty")
        return 1
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create release driver output dir: " + outDir)
            return 1
    let stage0: str = tooling_resolveStage0Driver(root, stage0Raw)
    if !tooling_strNonEmpty(stage0):
        tooling_printErr("cheng_tooling: release driver stage0 not found")
        return 1
    let stage0Exec: str = tooling_prepareStage0Exec(root, stage0, "build_release_driver")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: release driver stage0 prepare failed: " + stage0)
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: release driver stage0 preflight failed: " + stage0)
        return 1
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "release")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "3")
    let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
    let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
    if tooling_strNonEmpty(releaseCflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", releaseCflagsRaw)
    if tooling_strNonEmpty(releaseLdflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", releaseLdflagsRaw)
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", src)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    cmd = cmd + tooling_shellQuote(stage0Exec)
    cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_RELEASE_DRIVER_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    cmd = tooling_wrapStage0Lock(root, cmd, "build_release_driver")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    tooling_printOut("build_release_driver_stage0=" + stage0)
    tooling_printOut("build_release_driver_stage0_exec=" + stage0Exec)
    tooling_printOut("build_release_driver_target=" + target)
    tooling_printOut("build_release_driver_linker=system")
    tooling_printOut("build_release_driver_out=" + outPath)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    let rc: int32 = os.execCmdResultExitCode(res)
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    if rc != 0:
        let allowSafeRebuild: bool = tooling_isTrue(
            os.getEnvDefault("TOOLING_RELEASE_DRIVER_ALLOW_SAFE_REBUILD", "1"))
        if allowSafeRebuild:
            tooling_printErr("cheng_tooling: release driver direct build failed rc=" + intToStr(rc) +
                             " kind=" + tooling_exitKind(rc) +
                             "; fallback to safe full rebuild")
            let fallbackRc: int32 = tooling_compileBackendDriverFastHost(root, stage0, target, outPath, true)
            if fallbackRc == 0:
                tooling_printOut("build_release_driver_fallback=safe_full_rebuild")
                tooling_printOut("build_release_driver_profile=release_safe_full_rebuild")
                if tooling_releaseDriverEnsureHealthy(root, outPath, stage0):
                    return 0
                tooling_printErr("cheng_tooling: release driver fallback output failed health probe")
                return 1
            tooling_printErr("cheng_tooling: release driver safe fallback failed rc=" + intToStr(fallbackRc) +
                             " kind=" + tooling_exitKind(fallbackRc))
            return fallbackRc
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    let chmodRc: int32 = os.execCmdResultExitCode(chmodRes)
    if chmodRc != 0:
        return chmodRc
    if !tooling_releaseDriverEnsureHealthy(root, outPath, stage0):
        tooling_printErr("cheng_tooling: release driver output failed health probe: " + outPath)
        return 1
    tooling_printOut("build_release_driver_profile=release_system_link")
    return 0

fn tooling_releaseDriverForCompile(root: str, stage0Raw: str, targetRaw: str): str =
    let explicit: str = strutil.strip(stage0Raw)
    if tooling_strNonEmpty(explicit):
        return tooling_resolveStage0Driver(root, explicit)
    let releaseDriver: str = tooling_releaseDriverPath(root)
    if tooling_driverSanityOk(root, releaseDriver):
        return releaseDriver
    if !tooling_isTrue(os.getEnvDefault("TOOLING_RELEASE_DRIVER_AUTO_BUILD", "1")):
        return ""
    let releaseStage0Raw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_DRIVER_STAGE0", ""))
    let buildRc: int32 = tooling_buildReleaseDriver(root, releaseDriver, releaseStage0Raw, targetRaw)
    if buildRc != 0:
        return ""
    if tooling_driverSanityOk(root, releaseDriver):
        return releaseDriver
    return ""

fn tooling_stage0DriverKind(root: str, stage0Path: str): str =
    let absPath: str = tooling_pathAbsolute(root, stage0Path)
    let canonical: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    if tooling_strEq(absPath, canonical):
        return "artifacts_backend_driver"
    let releaseDriver: str = tooling_releaseDriverPath(root)
    if tooling_strEq(absPath, releaseDriver):
        return "artifacts_backend_release_driver"
    if strutil.contains(absPath, "/dist/releases/current/cheng"):
        return "dist_release"
    if strutil.contains(absPath, "/artifacts/backend_seed/"):
        return "backend_seed"
    if strutil.contains(absPath, "/artifacts/backend_selfhost_self_obj/"):
        return "selfhost_obj"
    return "explicit"

fn tooling_buildDriverSegfaultRescueCandidate(root: str, failedStage0Raw: str, explicitStage0Raw: str): str =
    if !tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE", "1")):
        return ""
    let explicitStage0: str = strutil.strip(explicitStage0Raw)
    if tooling_strNonEmpty(explicitStage0) &&
       !tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_WITH_EXPLICIT", "0")):
        return ""
    let failedStage0: str = tooling_pathAbsolute(root, failedStage0Raw)
    var candidates: str[] = []
    let envCandidateRaw: str = strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_STAGE0", ""))
    if tooling_strNonEmpty(envCandidateRaw):
        add(candidates, envCandidateRaw)
    add(candidates, "artifacts/backend_seed/cheng.stage2")
    add(candidates, "artifacts/backend_selfhost_native/cheng.stage2")
    add(candidates, "artifacts/backend_selfhost_self_obj/cheng.stage2")
    for i in 0..<candidates.len:
        let candidatePath: str = tooling_pathAbsolute(root, candidates[i])
        if !tooling_strNonEmpty(candidatePath):
            continue
        if tooling_strEq(candidatePath, failedStage0):
            continue
        if tooling_stage0HasUninterruptibleProcess(root, candidatePath):
            continue
        if !tooling_driverSanityOk(root, candidatePath):
            continue
        if !tooling_driverCompileProbeOk(root, candidatePath):
            continue
        return candidatePath
    return ""

fn tooling_detectHostJobs(root: str): int32 =
    let fromGetconf: os.ExecCmdResult = tooling_exec(root, "getconf _NPROCESSORS_ONLN")
    if os.execCmdResultExitCode(fromGetconf) == 0:
        let parsed0: int32 = tooling_parseInt32Default(os.execCmdResultOutput(fromGetconf), 0)
        if parsed0 > 0:
            return parsed0
    let fromSysctl: os.ExecCmdResult = tooling_exec(root, "sysctl -n hw.logicalcpu")
    if os.execCmdResultExitCode(fromSysctl) == 0:
        let parsed1: int32 = tooling_parseInt32Default(os.execCmdResultOutput(fromSysctl), 0)
        if parsed1 > 0:
            return parsed1
    return 1

fn tooling_copyExecutable(root: str, srcPath: str, dstPath: str): bool =
    if !tooling_strNonEmpty(srcPath) || !tooling_strNonEmpty(dstPath):
        return false
    if tooling_strEq(srcPath, dstPath):
        if !tooling_pathExists(srcPath):
            return false
        let chmodSame: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(dstPath))
        tooling_printExecOutput(chmodSame)
        return os.execCmdResultExitCode(chmodSame) == 0
    let outDir: str = os.parentDir(dstPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            return false
    let cmd: str = "cp " + tooling_shellQuote(srcPath) + " " + tooling_shellQuote(dstPath) +
                   " && chmod +x " + tooling_shellQuote(dstPath)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res) == 0

fn tooling_stage0QuarantineEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE", "1"))

fn tooling_stage0QuarantineDir(root: str): str =
    return os.joinPath(root, "chengcache/stage0_quarantine")

fn tooling_stage0LockEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_LOCK", "1"))

fn tooling_stage0LockDir(root: str): str =
    return os.joinPath(tooling_stage0QuarantineDir(root), "stage0.lock")

fn tooling_wrapStage0Lock(root: str, command: str, contextRaw: str): str =
    if !tooling_strNonEmpty(command):
        return command
    if !tooling_stage0LockEnabled():
        return command
    tooling_tryMkdirP(root, tooling_stage0QuarantineDir(root))
    var waitSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_WAIT_SEC", ""), 60)
    if waitSec < 0:
        waitSec = 0
    var staleSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_STALE_SEC", ""), 600)
    if staleSec < 0:
        staleSec = 0
    let forceTakeover: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_LOCK_FORCE_TAKEOVER", "0"))
    var forceTakeoverText: str = "0"
    if forceTakeover:
        forceTakeoverText = "1"
    let lockDir: str = tooling_stage0LockDir(root)
    var context: str = strutil.strip(contextRaw)
    if !tooling_strNonEmpty(context):
        context = "stage0"
    let timeoutMsg: str = "cheng_tooling: stage0 lock timeout context=" + context + " lock=" + lockDir
    let takeoverMsg: str = "cheng_tooling: stage0 lock forced takeover context=" + context + " lock=" + lockDir
    let wrapped: str =
        "lock_dir=" + tooling_shellQuote(lockDir) + " ; " +
        "lock_owner=\"$lock_dir/owner.pid\" ; " +
        "lock_since=\"$lock_dir/since.epoch\" ; " +
        "wait_sec=" + intToStr(waitSec) + " ; " +
        "stale_sec=" + intToStr(staleSec) + " ; " +
        "force_takeover=" + forceTakeoverText + " ; " +
        "lock_start=$(date +%s 2>/dev/null || echo 0) ; " +
        "lock_wait_ms=0 ; " +
        "while ! mkdir \"$lock_dir\" 2>/dev/null; do " +
        "  now=$(date +%s 2>/dev/null || echo 0) ; " +
        "  owner_pid=\"\" ; if [ -f \"$lock_owner\" ]; then owner_pid=$(cat \"$lock_owner\" 2>/dev/null); fi ; " +
        "  owner_alive=0 ; if [ -n \"$owner_pid\" ] && kill -0 \"$owner_pid\" 2>/dev/null; then owner_alive=1; fi ; " +
        "  stale=0 ; " +
        "  if [ -f \"$lock_since\" ]; then " +
        "    lock_ts=$(cat \"$lock_since\" 2>/dev/null) ; " +
        "    if [ -n \"$lock_ts\" ] && [ \"$stale_sec\" -gt 0 ] && [ \"$now\" -gt 0 ] && [ \"$lock_ts\" -gt 0 ]; then " +
        "      if [ $((now - lock_ts)) -ge \"$stale_sec\" ]; then stale=1; fi ; " +
        "    fi ; " +
        "  fi ; " +
        "  if [ \"$owner_alive\" -eq 0 ]; then " +
        "    rm -rf \"$lock_dir\" 2>/dev/null ; " +
        "    continue; " +
        "  fi ; " +
        "  if [ \"$stale\" -eq 1 ]; then " +
        "    if [ \"$force_takeover\" = \"1\" ]; then " +
        "      if [ -n \"$owner_pid\" ]; then " +
        "        kill -TERM -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -TERM \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        sleep 0.2 ; " +
        "        kill -KILL -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -KILL \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "      fi ; " +
        "      rm -rf \"$lock_dir\" 2>/dev/null ; " +
        "      echo " + tooling_shellQuote(takeoverMsg) + " >&2 ; " +
        "      lock_start=\"$now\" ; " +
        "      continue; " +
        "    fi ; " +
        "    echo " + tooling_shellQuote(timeoutMsg) + " >&2 ; exit 125 ; " +
        "  fi ; " +
        "  if [ \"$wait_sec\" -gt 0 ] && [ \"$now\" -gt 0 ] && [ \"$lock_start\" -gt 0 ] && [ $((now - lock_start)) -ge \"$wait_sec\" ]; then " +
        "    if [ \"$force_takeover\" = \"1\" ]; then " +
        "      if [ -n \"$owner_pid\" ]; then " +
        "        kill -TERM -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -TERM \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        sleep 0.2 ; " +
        "        kill -KILL -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -KILL \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "      fi ; " +
        "      rm -rf \"$lock_dir\" >/dev/null 2>&1 || true ; " +
        "      echo " + tooling_shellQuote(takeoverMsg) + " >&2 ; " +
        "      lock_start=\"$now\" ; " +
        "      continue; " +
        "    fi ; " +
        "    echo " + tooling_shellQuote(timeoutMsg) + " >&2 ; exit 125 ; " +
        "  fi ; " +
        "  sleep 0.1 ; " +
        "done ; " +
        "lock_now=$(date +%s 2>/dev/null || echo 0) ; " +
        "if [ \"$lock_now\" -gt 0 ] && [ \"$lock_start\" -gt 0 ] && [ \"$lock_now\" -ge \"$lock_start\" ]; then " +
        "  lock_wait_ms=$(( (lock_now - lock_start) * 1000 )) ; " +
        "fi ; " +
        "echo $$ > \"$lock_owner\" 2>/dev/null ; " +
        "date +%s > \"$lock_since\" 2>/dev/null ; " +
        "trap 'rm -rf \"$lock_dir\" >/dev/null 2>&1' EXIT INT TERM ; " +
        "TOOLING_STAGE0_LOCK_WAIT_MS=\"$lock_wait_ms\" ; export TOOLING_STAGE0_LOCK_WAIT_MS ; " +
        "eval " + tooling_shellQuote(command) + " ; " +
        "rc=$? ; " +
        "rm -rf \"$lock_dir\" >/dev/null 2>&1 ; " +
        "trap - EXIT INT TERM ; " +
        "exit $rc"
    return wrapped

fn tooling_stage0QuarantineUeCount(root: str): int32 =
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return 0
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var count: int32 = 0
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !strutil.contains(cmd, qdir):
            continue
        count = count + 1
    return count

fn tooling_stage0QuarantineUePreview(root: str, limitRaw: int32): str =
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao pid=,ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return ""
    var limit: int32 = limitRaw
    if limit < 1:
        limit = 1
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var found: int32 = 0
    var preview: str = ""
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let pidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= pidStart:
            continue
        let pidToken: str = strings.sliceBytes(line, pidStart, j - pidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !strutil.contains(cmd, qdir):
            continue
        found = found + 1
        if found > limit:
            continue
        if tooling_strNonEmpty(preview):
            preview = preview + " | "
        preview = preview + "pid=" + strutil.strip(pidToken) + ",ppid=" + strutil.strip(ppidToken) +
                  ",state=" + state + ",cmd=" + cmd
    if found > limit:
        if tooling_strNonEmpty(preview):
            preview = preview + " | "
        preview = preview + "+" + intToStr(found - limit) + " more"
    return preview

fn tooling_isDigitsOnly(raw: str): bool =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return false
    for i in 0..<len(text):
        let ch: char = text[i]
        if ch < '0' || ch > '9':
            return false
    return true

fn tooling_stage0QuarantineKillPid(root: str, pidTokenRaw: str): bool =
    let pidToken: str = strutil.strip(pidTokenRaw)
    if !tooling_isDigitsOnly(pidToken):
        return false
    let cmd: str =
        "kill -TERM " + pidToken + " >/dev/null 2>&1 || true ; " +
        "sleep 0.2 ; " +
        "if kill -0 " + pidToken + " >/dev/null 2>&1; then " +
        "  kill -KILL " + pidToken + " >/dev/null 2>&1 || true ; " +
        "  sleep 0.1 ; " +
        "fi ; " +
        "if kill -0 " + pidToken + " >/dev/null 2>&1; then exit 1; fi ; " +
        "exit 0"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    return os.execCmdResultExitCode(res) == 0

fn tooling_stage0QuarantineSweepUe(root: str, context: str): int32 =
    if !tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE_AUTO_KILL_UE", "1")):
        return 0
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao pid=,ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return 0
    var maxKill: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE_AUTO_KILL_MAX", ""), 8)
    if maxKill < 1:
        maxKill = 1
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var attemptCount: int32 = 0
    var killedCount: int32 = 0
    for i in 0..<rows.len:
        if attemptCount >= maxKill:
            break
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let pidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= pidStart:
            continue
        let pidToken: str = strings.sliceBytes(line, pidStart, j - pidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !strutil.contains(cmd, qdir):
            continue
        attemptCount = attemptCount + 1
        if tooling_stage0QuarantineKillPid(root, pidToken):
            killedCount = killedCount + 1
    if killedCount > 0:
        tooling_printErr("cheng_tooling: auto-cleaned quarantine stuck/orphan processes for " + context +
                         ": killed=" + intToStr(killedCount) + ", attempts=" + intToStr(attemptCount))
    return killedCount

fn tooling_stage0BlockOnQuarantineUe(root: str, blockEnv: str, context: str): bool =
    let blockOnUe: bool = tooling_isTrue(os.getEnvDefault(blockEnv, "1"))
    if !blockOnUe:
        return false
    let ueCountBefore: int32 = tooling_stage0QuarantineUeCount(root)
    if ueCountBefore <= 0:
        return false
    let _cleaned: int32 = tooling_stage0QuarantineSweepUe(root, context)
    let ueCount: int32 = tooling_stage0QuarantineUeCount(root)
    if ueCount <= 0:
        return false
    tooling_printErr("cheng_tooling: blocked " + context + " due to quarantine stuck/orphan processes: " +
                     intToStr(ueCount) + " (set " + blockEnv + "=0 to override)")
    let preview: str = tooling_stage0QuarantineUePreview(root, 3)
    if tooling_strNonEmpty(preview):
        tooling_printErr("cheng_tooling: quarantine UE preview: " + preview)
    tooling_printErr("cheng_tooling: cleanup hint: ps -Ao pid,ppid,state,command | rg 'chengcache/stage0_quarantine'")
    return true


fn tooling_stage0PurposeTag(raw: str): str =
    let text: str = strutil.strip(raw)
    if tooling_strNonEmpty(text):
        return text
    return "run"

fn tooling_prepareStage0Exec(root: str, stage0Path: str, purposeRaw: str): str =
    if !tooling_isExecutable(root, stage0Path):
        return ""
    if !tooling_stage0QuarantineEnabled():
        return stage0Path
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_STAGE0_QUARANTINE_BLOCK_ON_UE", "stage0 run"):
        return ""
    let qdir: str = tooling_stage0QuarantineDir(root)
    tooling_tryMkdirP(root, qdir)
    var base: str = os.extractFilename(stage0Path)
    if !tooling_strNonEmpty(base):
        base = "cheng.stage0"
    let purpose: str = tooling_stage0PurposeTag(purposeRaw)
    let nonce: int32 = int32(tooling_nowMs() % int64(2000000000))
    let copiedPath: str = os.joinPath(qdir, base + "." + purpose + "." + intToStr(nonce))
    if !tooling_copyExecutable(root, stage0Path, copiedPath):
        tooling_printErr("cheng_tooling: stage0 quarantine copy failed: " + stage0Path)
        return ""
    return copiedPath

fn tooling_cleanupStage0Exec(stage0Original: str, stage0Exec: str) =
    if !tooling_strNonEmpty(stage0Exec):
        return
    if tooling_strEq(stage0Exec, stage0Original):
        return
    if os.fileExists(stage0Exec):
        os.removeFile(stage0Exec)

fn tooling_stage0PreflightOk(root: str, stage0Exec: str): bool =
    if !tooling_isExecutable(root, stage0Exec):
        return false
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_TIMEOUT", ""), 8)
    if timeoutSec <= 0:
        timeoutSec = 8
    let strictPreflight: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_STRICT", "0"))
    var cmd: str = tooling_shellQuote(stage0Exec) + " --help >/dev/null 2>&1"
    cmd = tooling_wrapStage0Lock(root, cmd, "stage0_preflight")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    let rc: int32 = os.execCmdResultExitCode(res)
    let kind: str = tooling_exitKind(rc)
    if tooling_strEq(kind, "timeout"):
        if strictPreflight:
            tooling_printErr("cheng_tooling: stage0 preflight timeout: " + stage0Exec)
            return false
        return true
    if rc >= 128:
        tooling_printErr("cheng_tooling: stage0 preflight failed rc=" + intToStr(rc) +
                         " kind=" + kind + " stage0=" + stage0Exec)
        return false
    return true

fn tooling_stripLeadingUnderscores(raw: str): str =
    if !tooling_strNonEmpty(raw):
        return ""
    let text: str = strutil.strip(raw)
    let n: int32 = len(text)
    if n <= 0:
        return ""
    var i: int32 = 0
    while i < n && text[i] == '_':
        i = i + 1
    if i >= n:
        return ""
    return strings.sliceBytes(text, i, n - i)

fn tooling_isForbiddenUndefinedDriverSymbol(raw: str): bool =
    let norm: str = tooling_stripLeadingUnderscores(raw)
    if !tooling_strNonEmpty(norm):
        return false
    let sym: str = strutil.toLowerAscii(norm)
    if tooling_strEq(sym, "backendmain") || tooling_strEq(sym, "getenvdefault") || tooling_strEq(sym, "writeline"):
        return true
    if tooling_strEq(sym, "streq") || tooling_strEq(sym, "paramcount") || tooling_strEq(sym, "paramstr"):
        return true
    if strutil.startsWith(sym, "uir") || strutil.startsWith(sym, "macho") ||
       strutil.startsWith(sym, "elf") || strutil.startsWith(sym, "coff") ||
       strutil.startsWith(sym, "os_") || strutil.startsWith(sym, "walkdir") ||
       strutil.startsWith(sym, "execcmd") || strutil.startsWith(sym, "readfile") ||
       strutil.startsWith(sym, "writefile") || strutil.startsWith(sym, "joinpath") ||
       strutil.startsWith(sym, "slice") || strutil.startsWith(sym, "parseint") ||
       strutil.startsWith(sym, "lowerascii") || strutil.startsWith(sym, "pathcomponent") ||
       strutil.startsWith(sym, "extractfilename") || strutil.startsWith(sym, "direxists") ||
       strutil.startsWith(sym, "getcurrentdir") || strutil.startsWith(sym, "getmonotime") ||
       strutil.startsWith(sym, "monotimens"):
        return true
    if strutil.startsWith(sym, "backend") || strutil.startsWith(sym, "driver_") ||
       strutil.startsWith(sym, "tooling") || strutil.startsWith(sym, "hashmap") ||
       strutil.startsWith(sym, "cheng_"):
        return true
    return false

fn tooling_driverUndefinedInternalSymbolsOk(root: str, binPath: str): bool =
    let guardEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_UNDEF_GUARD", "1"))
    if !guardEnabled:
        return true
    let probeNm: os.ExecCmdResult = tooling_exec(root, "command -v nm >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeNm) != 0:
        return true
    let probeAwk: os.ExecCmdResult = tooling_exec(root, "command -v awk >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeAwk) != 0:
        return true
    let cmd: str = "nm -u " + tooling_shellQuote(binPath) + " 2>/dev/null | awk '{print $NF}'"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return true
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(res))
    var hitCount: int32 = 0
    var preview: str = ""
    for i in 0..<rows.len:
        let rawSym: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(rawSym):
            continue
        if !tooling_isForbiddenUndefinedDriverSymbol(rawSym):
            continue
        hitCount = hitCount + 1
        if hitCount <= 8:
            if tooling_strNonEmpty(preview):
                preview = preview + ", "
            preview = preview + rawSym
    if hitCount <= 0:
        return true
    tooling_printErr("cheng_tooling: forbidden undefined internal symbols in driver (count=" +
                     intToStr(hitCount) + "): " + preview)
    return false

fn tooling_driverIsScriptShim(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    let headRes: os.ExecCmdResult = tooling_exec(root, "head -n 1 " + tooling_shellQuote(binPath))
    if os.execCmdResultExitCode(headRes) != 0:
        return false
    let line0: str = strutil.strip(os.execCmdResultOutput(headRes))
    if strutil.startsWith(line0, "#!"):
        return true
    return false

fn tooling_driverFileMagicOk(root: str, binPath: str): bool =
    let probeFile: os.ExecCmdResult = tooling_exec(root, "command -v file >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeFile) != 0:
        return true
    let res: os.ExecCmdResult = tooling_exec(root, "file -b " + tooling_shellQuote(binPath))
    if os.execCmdResultExitCode(res) != 0:
        return true
    let desc: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))
    if strutil.contains(desc, "script"):
        tooling_printErr("cheng_tooling: driver sanity rejected script shim: " + binPath)
        return false
    let hostTag: str = tooling_detectHostTag(root)
    if tooling_strEq(hostTag, "darwin_arm64"):
        if !strutil.contains(desc, "mach-o"):
            tooling_printErr("cheng_tooling: driver sanity expected mach-o binary on darwin_arm64: " + binPath +
                             " (file=" + desc + ")")
            return false
    return true

fn tooling_driverSanityOk(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    if os.fileSize(binPath) <= int64(0):
        return false
    if tooling_driverIsScriptShim(root, binPath):
        tooling_printErr("cheng_tooling: driver sanity rejected shebang script: " + binPath)
        return false
    if !tooling_driverFileMagicOk(root, binPath):
        return false
    if !tooling_driverUndefinedInternalSymbolsOk(root, binPath):
        return false
    return true

fn tooling_driverPostBuildOk(root: str, binPath: str): bool =
    if !tooling_driverSanityOk(root, binPath):
        return false
    let probeEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_POST_PROBE", "0"))
    if !probeEnabled:
        return true
    return tooling_driverCompileProbeOk(root, binPath)

fn tooling_driverBuildOutputOk(root: str, binPath: str, compileMode: str, quickLightSanity: bool,
                               forceProbeOnFull: bool): bool =
    var ok: bool = false
    if tooling_strEq(compileMode, "quick") && quickLightSanity:
        ok = tooling_driverSanityOk(root, binPath)
    else:
        ok = tooling_driverPostBuildOk(root, binPath)
    if !ok:
        return false
    if tooling_strEq(compileMode, "full") && forceProbeOnFull:
        if !tooling_driverCompileProbeOk(root, binPath):
            tooling_printErr("cheng_tooling: full rebuild compile-probe failed: " + binPath)
            return false
    return true

fn tooling_runtimeObjPath(root: str, target: str): str =
    let candidate0: str = os.joinPath(root, "chengcache/runtime_selflink/system_helpers.backend.combined." + target + ".o")
    if os.fileExists(candidate0):
        return candidate0
    let candidate1: str = os.joinPath(root, "artifacts/backend_mm/system_helpers.backend.combined." + target + ".o")
    if os.fileExists(candidate1):
        return candidate1
    let candidate2: str = os.joinPath(root, "artifacts/backend_selfhost_self_obj/stage1.native.runtime.dedup.o")
    if os.fileExists(candidate2):
        return candidate2
    let candidate3: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
    if os.fileExists(candidate3):
        return candidate3
    let candidate4: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng.o")
    if os.fileExists(candidate4):
        return candidate4
    return candidate3

fn tooling_runtimeLdArch(target: str): str =
    if strutil.startsWith(target, "arm64") || strutil.startsWith(target, "aarch64"):
        return "arm64"
    if strutil.startsWith(target, "x86_64"):
        return "x86_64"
    if strutil.startsWith(target, "riscv64"):
        return "riscv64"
    return ""

fn tooling_prepareRuntimeObjForTarget(root: str, compilerPath: str, target: str): str =
    let fallbackPath: str = tooling_runtimeObjPath(root, target)
    if !tooling_isExecutable(root, compilerPath):
        return fallbackPath
    let refreshEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH", "0"))
    if !refreshEnabled:
        return fallbackPath
    let arch: str = tooling_runtimeLdArch(target)
    if !tooling_strNonEmpty(arch):
        return fallbackPath
    let runtimeSrc: str = os.joinPath(root, "src/std/system_helpers_backend.cheng")
    let shimSrc: str = os.joinPath(root, "src/runtime/native/system_helpers_selflink_shim.c")
    let bridgeSrc: str = os.joinPath(root, "src/backend/tooling/backend_driver_symbol_bridge.c")
    if !os.fileExists(runtimeSrc) || !os.fileExists(shimSrc) || !os.fileExists(bridgeSrc):
        return fallbackPath
    let baseObj: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
    let runtimeDir: str = os.joinPath(root, "chengcache/runtime_selflink")
    let shimObj: str = os.joinPath(runtimeDir, "system_helpers_selflink_shim." + target + ".o")
    let bridgeObj: str = os.joinPath(runtimeDir, "backend_driver_symbol_bridge." + target + ".o")
    let combinedObj: str = os.joinPath(runtimeDir, "system_helpers.backend.combined." + target + ".o")
    let combinedTmp: str = combinedObj + ".tmp"
    let baseObjDir: str = os.parentDir(baseObj)
    if tooling_strNonEmpty(baseObjDir):
        tooling_tryMkdirP(root, baseObjDir)
    tooling_tryMkdirP(root, runtimeDir)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_TIMEOUT", ""), 120)
    if timeoutSec < 1:
        timeoutSec = 120
    var refreshCompiler: str = compilerPath
    var prepRcFinal: int32 = 1
    var prepOutFinal: str = ""
    var triedFallbackCompiler: bool = false
    for _attempt in 0..<2:
        if !tooling_isExecutable(root, refreshCompiler):
            prepRcFinal = 127
        else:
            var prepCmd: str = "BACKEND_BUILD_DRIVER_STAGE0= BACKEND_STAGE0= "
            if tooling_stage0CompatPrefixEnabled():
                prepCmd = prepCmd + "CHENG_BACKEND_BUILD_DRIVER_STAGE0= CHENG_BACKEND_STAGE0= "
            prepCmd = prepCmd +
                tooling_envAssignCompat("BACKEND_DRIVER", refreshCompiler) +
                tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "core") +
                tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1") +
                tooling_envAssignCompat("MM", "orc") +
                tooling_envAssignCompat("CACHE", "0") +
                tooling_envAssignCompat("BACKEND_INTERNAL_ALLOW_EMIT_OBJ", "1") +
                tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "1") +
                tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1") +
                tooling_envAssignCompat("BACKEND_EMIT", "obj") +
                tooling_envAssignCompat("BACKEND_TARGET", target) +
                tooling_envAssignCompat("BACKEND_INPUT", runtimeSrc) +
                tooling_envAssignCompat("BACKEND_OUTPUT", baseObj) +
                tooling_shellQuote(refreshCompiler) +
                " && cc -std=c11 -O2 -c " + tooling_shellQuote(shimSrc) + " -o " + tooling_shellQuote(shimObj) +
                " && cc -std=c11 -O2 -c " + tooling_shellQuote(bridgeSrc) + " -o " + tooling_shellQuote(bridgeObj) +
                " && ld -r -arch " + arch + " -o " + tooling_shellQuote(combinedTmp) + " " +
                tooling_shellQuote(baseObj) + " " + tooling_shellQuote(shimObj) + " " + tooling_shellQuote(bridgeObj) +
                " && mv " + tooling_shellQuote(combinedTmp) + " " + tooling_shellQuote(combinedObj)
            prepCmd = tooling_prefixUnsetLegacyFrontendEnv(prepCmd)
            prepCmd = tooling_wrapStage0Lock(root, prepCmd, "runtime_obj_refresh")
            prepCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, prepCmd)
            let prepRes: os.ExecCmdResult = tooling_exec(root, prepCmd)
            prepRcFinal = os.execCmdResultExitCode(prepRes)
            prepOutFinal = os.execCmdResultOutput(prepRes)
            if prepRcFinal == 0 && os.fileExists(combinedObj):
                return combinedObj
        if triedFallbackCompiler:
            break
        let fallbackCompiler: str = os.joinPath(root, "artifacts/backend_selfhost_self_obj/cheng.stage2")
        if tooling_isExecutable(root, fallbackCompiler) && !tooling_strEq(fallbackCompiler, refreshCompiler):
            refreshCompiler = fallbackCompiler
            triedFallbackCompiler = true
            continue
        break
    let strictRefresh: bool = tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_STRICT", "0"))
    if !strictRefresh && os.fileExists(fallbackPath):
        return fallbackPath
    tooling_printErr("cheng_tooling: runtime object refresh failed for target=" + target +
                     " rc=" + intToStr(prepRcFinal) + " kind=" + tooling_exitKind(prepRcFinal))
    let refreshDebug: bool = strictRefresh || tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_DEBUG", "0"))
    if refreshDebug && tooling_strNonEmpty(prepOutFinal):
        let rows: str[] = tooling_splitLines(prepOutFinal)
        var shown: int32 = 0
        for i in 0..<rows.len:
            if shown >= 6:
                break
            tooling_printErr("cheng_tooling: runtime refresh log: " + rows[i])
            shown = shown + 1
    if strictRefresh:
        return ""
    return fallbackPath

fn tooling_outputLooksExecutable(root: str, outPath: str): bool =
    if !tooling_strNonEmpty(outPath) || !os.fileExists(outPath):
        return false
    let probeFile: os.ExecCmdResult = tooling_exec(root, "command -v file >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeFile) != 0:
        return true
    let res: os.ExecCmdResult = tooling_exec(root, "file -b " + tooling_shellQuote(outPath))
    if os.execCmdResultExitCode(res) != 0:
        return true
    let desc: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))
    if !tooling_strNonEmpty(desc):
        return true
    return tooling_strContains(desc, "executable")

fn tooling_driverCompileProbeOk(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    let probeInput: str = os.joinPath(root, "tests/cheng/backend/fixtures/hello_puts.cheng")
    if !os.fileExists(probeInput):
        return true
    let target: str = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        return true
    let runtimeObj: str = tooling_runtimeObjPath(root, target)
    if !os.fileExists(runtimeObj):
        return true
    let stage0Exec: str = tooling_prepareStage0Exec(root, binPath, "probe")
    if !tooling_strNonEmpty(stage0Exec):
        return false
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_PROBE_TIMEOUT", ""), 60)
    if timeoutSec <= 0:
        timeoutSec = 60
    let probeNonceRaw: int64 = tooling_nowMs() % int64(2000000000)
    let probeOut: str = os.joinPath(root, "chengcache/tooling_stage0_probe." + intToStr(int32(probeNonceRaw)) + ".bin")
    let probeOutDir: str = os.parentDir(probeOut)
    if tooling_strNonEmpty(probeOutDir):
        tooling_tryMkdirP(root, probeOutDir)
    if os.fileExists(probeOut):
        os.removeFile(probeOut)
    var probeCmd: str = ""
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("MM", "orc")
    probeCmd = probeCmd + tooling_envAssignCompat("CACHE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
    probeCmd = probeCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_LINKER", "self")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_OUTPUT", probeOut)
    probeCmd = probeCmd + tooling_shellQuote(stage0Exec)
    probeCmd = tooling_prefixUnsetLegacyFrontendEnv(probeCmd)
    probeCmd = tooling_wrapStage0Lock(root, probeCmd, "stage0_compile_probe")
    probeCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, probeCmd)
    let probeRes: os.ExecCmdResult = tooling_exec(root, probeCmd)
    var probeRc: int32 = os.execCmdResultExitCode(probeRes)
    var probeOutText: str = strutil.strip(os.execCmdResultOutput(probeRes))
    var sizeProbe: os.ExecCmdResult = tooling_exec(root, "test -s " + tooling_shellQuote(probeOut))
    var hasOut: bool = os.execCmdResultExitCode(sizeProbe) == 0
    let probeAllowSystemFallback: bool = probeRc != 0
    if probeAllowSystemFallback:
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        var fallbackCmd: str = ""
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("MM", "orc")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("CACHE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", "")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_OUTPUT", probeOut)
        fallbackCmd = fallbackCmd + tooling_shellQuote(stage0Exec)
        fallbackCmd = tooling_prefixUnsetLegacyFrontendEnv(fallbackCmd)
        fallbackCmd = tooling_wrapStage0Lock(root, fallbackCmd, "stage0_compile_probe_system_link")
        fallbackCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, fallbackCmd)
        let fallbackRes: os.ExecCmdResult = tooling_exec(root, fallbackCmd)
        probeRc = os.execCmdResultExitCode(fallbackRes)
        probeOutText = strutil.strip(os.execCmdResultOutput(fallbackRes))
        sizeProbe = tooling_exec(root, "test -s " + tooling_shellQuote(probeOut))
        hasOut = os.execCmdResultExitCode(sizeProbe) == 0
        if probeRc == 0 && hasOut:
            tooling_printErr("cheng_tooling: stage0 compile probe self-link reloc unsupported, accepted via system-link fallback")
    var executableOut: bool = false
    if hasOut:
        executableOut = tooling_outputLooksExecutable(root, probeOut)
        if probeRc == 0 && !executableOut:
            tooling_printErr("cheng_tooling: stage0 compile probe output is not executable: " + probeOut)
    let allowObjFallback: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_PROBE_ALLOW_OBJ_FALLBACK", "0"))
    let needsMainFallback: bool = probeRc != 0 && allowObjFallback &&
        (tooling_strContains(probeOutText, "\"_main\"") ||
         tooling_strContains(probeOutText, "_main") ||
         tooling_strContains(probeOutText, "<initial-undefines>"))
    if needsMainFallback:
        let objOut: str = probeOut + ".o"
        if os.fileExists(objOut):
            os.removeFile(objOut)
        var objCmd: str = ""
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
        objCmd = objCmd + tooling_envAssignCompat("MM", "orc")
        objCmd = objCmd + tooling_envAssignCompat("CACHE", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "1")
        objCmd = objCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
        objCmd = objCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_LINKER", "self")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INTERNAL_ALLOW_EMIT_OBJ", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_EMIT", "obj")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_OUTPUT", objOut)
        objCmd = objCmd + tooling_shellQuote(stage0Exec)
        objCmd = tooling_prefixUnsetLegacyFrontendEnv(objCmd)
        objCmd = tooling_wrapStage0Lock(root, objCmd, "stage0_compile_probe_obj")
        objCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, objCmd)
        let objRes: os.ExecCmdResult = tooling_exec(root, objCmd)
        let objRc: int32 = os.execCmdResultExitCode(objRes)
        let objLog: str = strutil.strip(os.execCmdResultOutput(objRes))
        let objSizeProbe: os.ExecCmdResult = tooling_exec(root, "test -s " + tooling_shellQuote(objOut))
        let objHasOut: bool = os.execCmdResultExitCode(objSizeProbe) == 0
        if os.fileExists(objOut):
            os.removeFile(objOut)
        if objRc == 0 && objHasOut:
            probeRc = 0
            hasOut = true
            executableOut = true
            tooling_printErr("cheng_tooling: stage0 compile probe exe-link missing _main; accepted obj fallback")
        elif tooling_strNonEmpty(objLog):
            probeOutText = objLog
    if probeRc != 0:
        tooling_printErr("cheng_tooling: stage0 compile probe failed rc=" + intToStr(probeRc) +
                         " kind=" + tooling_exitKind(probeRc))
        if tooling_strNonEmpty(probeOutText):
            let rows: str[] = tooling_splitLines(probeOutText)
            var shown: int32 = 0
            for i in 0..<rows.len:
                if shown >= 6:
                    break
                tooling_printErr("cheng_tooling: stage0 probe log: " + rows[i])
                shown = shown + 1
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    if !hasOut || !executableOut:
        tooling_printErr("cheng_tooling: stage0 compile probe produced no output binary")
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    let requireRun: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_PROBE_REQUIRE_RUN", "1"))
    if requireRun:
        var runTimeoutSec: int32 = tooling_parseInt32Default(
            os.getEnvDefault("TOOLING_STAGE0_PROBE_RUN_TIMEOUT", ""), 15)
        if runTimeoutSec < 1:
            runTimeoutSec = 15
        var runCmd: str = tooling_shellQuote(probeOut) + " >/dev/null 2>&1"
        runCmd = tooling_wrapCommandWithTimeout(root, runTimeoutSec, runCmd)
        let runRes: os.ExecCmdResult = tooling_exec(root, runCmd)
        let runRc: int32 = os.execCmdResultExitCode(runRes)
        if runRc != 0:
            tooling_printErr("cheng_tooling: stage0 compile probe binary run failed rc=" + intToStr(runRc) +
                             " kind=" + tooling_exitKind(runRc))
            if os.fileExists(probeOut):
                os.removeFile(probeOut)
            tooling_cleanupStage0Exec(binPath, stage0Exec)
            return false
    if os.fileExists(probeOut):
        os.removeFile(probeOut)
    tooling_cleanupStage0Exec(binPath, stage0Exec)
    return true

fn tooling_compileBackendDriverDelegateWrapper(root: str, stage0Exec: str, target: str, outPath: str): int32 =
    let wrapperSrc: str = os.joinPath(root, "src/backend/tooling/backend_driver_stage1_delegate.cheng")
    if !os.fileExists(wrapperSrc):
        tooling_printErr("cheng_tooling: missing stage1 delegate wrapper source: " + wrapperSrc)
        return 1
    var timeoutSec: int32 = tooling_parseInt32Default(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_DELEGATE_TIMEOUT", ""), 45)
    if timeoutSec < 1:
        timeoutSec = 45
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
    cmd = cmd + tooling_envAssignCompat("MM", "orc")
    cmd = cmd + tooling_envAssignCompat("CACHE", "0")
    cmd = cmd + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "dev")
    cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_JOBS", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FN_JOBS", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "0")
    cmd = cmd + tooling_envAssignCompat("UIR_SIMD", "0")
    cmd = cmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "1")
    cmd = cmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "1")
    cmd = cmd + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
    cmd = cmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
    cmd = cmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "core")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", wrapperSrc)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    cmd = cmd + tooling_shellQuote(stage0Exec)
    cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    cmd = tooling_wrapStage0Lock(root, cmd, "build_backend_driver_delegate_wrapper")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    let rc: int32 = os.execCmdResultExitCode(res)
    if rc != 0:
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    return os.execCmdResultExitCode(chmodRes)

fn tooling_driverBuildTempDir(root: str): str =
    return os.joinPath(root, "chengcache/backend_driver_build_tmp")

fn tooling_driverBuildTempPath(root: str, outPath: str, attemptIndex: int32): str =
    let tempDir: str = tooling_driverBuildTempDir(root)
    tooling_tryMkdirP(root, tempDir)
    var base: str = os.extractFilename(outPath)
    if !tooling_strNonEmpty(base):
        base = "cheng"
    let nonce: int32 = int32(tooling_nowMs() % int64(2000000000))
    return os.joinPath(tempDir, base + ".attempt." + intToStr(attemptIndex) + "." + intToStr(nonce))

fn tooling_driverBuildTempCleanup(root: str, outPath: str) =
    if !tooling_strNonEmpty(outPath):
        return
    if os.fileExists(outPath):
        os.removeFile(outPath)
    let tmpLinkObj: str = outPath + ".tmp.linkobj"
    if os.fileExists(tmpLinkObj):
        os.removeFile(tmpLinkObj)
    let tmpObjsDir: str = outPath + ".objs"
    let tmpObjsLock: str = outPath + ".objs.lock"
    if os.dirExists(tmpObjsDir) || os.fileExists(tmpObjsLock):
        let cleanupCmd: str = "rm -rf " + tooling_shellQuote(tmpObjsDir) + " " + tooling_shellQuote(tmpObjsLock)
        let cleanupRes: os.ExecCmdResult = tooling_exec(root, cleanupCmd)
        tooling_printExecOutput(cleanupRes)

fn tooling_collectLegacyDriverObjFiles(root: str): str[] =
    var out: str[] = []
    let objDir: str = os.joinPath(root, "artifacts/backend_driver/cheng.objs")
    if !os.dirExists(objDir):
        return out
    let scanCmd: str = "find " + tooling_shellQuote(objDir) +
                       " -maxdepth 1 -type f -name '*.o' -print"
    let scanRes: os.ExecCmdResult = tooling_exec(root, scanCmd)
    if os.execCmdResultExitCode(scanRes) != 0:
        return out
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(scanRes))
    for i in 0..<rows.len:
        let path: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(path):
            continue
        add(out, path)
    return out

fn tooling_prepareBackendDriverCompatWrapObj(root: str): str =
    let srcPath: str = os.joinPath(root, "src/backend/tooling/backend_driver_stage0_compat_wrap.c")
    let outObj: str = os.joinPath(root, "chengcache/backend_driver_stage0_compat_wrap.o")
    if !os.fileExists(srcPath):
        return os.fileExists(outObj) ? outObj : ""
    let outDir: str = os.parentDir(outObj)
    if tooling_strNonEmpty(outDir):
        tooling_tryMkdirP(root, outDir)
    var timeoutSec: int32 = tooling_parseInt32Default(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_COMPAT_WRAP_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    var cmd: str = "cc -std=c11 -O2 -c " + tooling_shellQuote(srcPath) +
                   " -o " + tooling_shellQuote(outObj)
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    if os.execCmdResultExitCode(res) != 0:
        if os.fileExists(outObj):
            tooling_printErr("cheng_tooling: compat wrap rebuild failed; using existing object: " + outObj)
            return outObj
        tooling_printErr("cheng_tooling: failed to build compat wrap object: " + srcPath)
        return ""
    return outObj

fn tooling_tryLegacyDriverObjRelink(root: str, outPath: str, targetRaw: str): int32 =
    if !tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_LEGACY_OBJS_FALLBACK", "1")):
        return -1
    let target: str = strutil.toLowerAscii(strutil.strip(targetRaw))
    if !tooling_strContains(target, "darwin"):
        return -1
    if !tooling_strContains(target, "arm64") && !tooling_strContains(target, "aarch64"):
        return -1
    let tmpObj: str = outPath + ".tmp.linkobj"
    let legacyObjs: str[] = tooling_collectLegacyDriverObjFiles(root)
    if legacyObjs.len <= 0:
        return -1
    let runtimeC: str = os.joinPath(root, "src/runtime/native/system_helpers.c")
    if !os.fileExists(runtimeC):
        return -1
    let directRelink: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_LEGACY_OBJS_DIRECT", "1"))
    let compatWrapObj: str = tooling_prepareBackendDriverCompatWrapObj(root)
    if !directRelink && !os.fileExists(tmpObj):
        return -1
    var cmd: str = "cc"
    if !directRelink:
        cmd = cmd + " -Wl,-multiply_defined,suppress " + tooling_shellQuote(tmpObj)
    if os.fileExists(compatWrapObj):
        cmd = cmd + " " + tooling_shellQuote(compatWrapObj)
    for i in 0..<legacyObjs.len:
        cmd = cmd + " " + tooling_shellQuote(legacyObjs[i])
    cmd = cmd + " " + tooling_shellQuote(runtimeC)
    cmd = cmd + " -o " + tooling_shellQuote(outPath)
    var timeoutSec: int32 = tooling_parseInt32Default(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_LEGACY_OBJS_TIMEOUT", ""), 120)
    if timeoutSec < 1:
        timeoutSec = 120
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    tooling_printErr("cheng_tooling: fallback relink with legacy cheng.objs")
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    let rc: int32 = os.execCmdResultExitCode(res)
    if rc != 0:
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    return os.execCmdResultExitCode(chmodRes)

fn tooling_outputHasUndefinedSymbols(output: str): bool =
    if !tooling_strNonEmpty(output):
        return false
    let lower: str = strutil.toLowerAscii(output)
    if tooling_strContains(lower, "undefined symbols for architecture") ||
       tooling_strContains(lower, "undefined reference to") ||
       tooling_strContains(lower, "undefined symbol:"):
        return true
    return false

fn tooling_compileBackendDriverFastHost(root: str, stage0: str, target: str, outPath: str, fullRebuild: bool): int32 =
    var linkerDefault: str = "self"
    if fullRebuild && tooling_buildDriverStrictNativeEnabled():
        linkerDefault = "system"
    var linkerMode: str = strutil.toLowerAscii(strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_LINKER", linkerDefault)))
    if !tooling_strEq(linkerMode, "self") && !tooling_strEq(linkerMode, "system"):
        linkerMode = "self"
    let strictNative: bool = tooling_buildDriverStrictNativeEnabled()
    let allowFallback: bool = tooling_buildDriverAllowFallbackEnabled()
    if strictNative:
        linkerMode = os.getEnvDefault("BACKEND_BUILD_DRIVER_LINKER_STRICT", linkerMode)
        if !tooling_strEq(linkerMode, "self") && !tooling_strEq(linkerMode, "system"):
            linkerMode = "self"
    let stage0Purpose: str = fullRebuild ? "rebuild" : "quick"
    let stage0Exec: str = tooling_prepareStage0Exec(root, stage0, stage0Purpose)
    if !tooling_strNonEmpty(stage0Exec):
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        return 1
    var runtimeObj: str = ""
    if tooling_strEq(linkerMode, "self"):
        let refreshRuntimeObj: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_RUNTIME_OBJ_REFRESH", "0"))
        if refreshRuntimeObj:
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        else:
            runtimeObj = tooling_runtimeObjPath(root, target)
            if !os.fileExists(runtimeObj):
                runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        let preferSeedBaseRuntimeObj: bool = tooling_isTrue(
            os.getEnvDefault("BACKEND_BUILD_DRIVER_SEED_BASE_RUNTIME_OBJ", "1"))
        let stage0LowerRaw: str = strutil.toLowerAscii(strutil.strip(stage0))
        let seedLikeStage0: bool =
            tooling_strContains(stage0LowerRaw, "/artifacts/backend_seed/") ||
            tooling_strContains(stage0LowerRaw, "/backend_seed/")
        if preferSeedBaseRuntimeObj && seedLikeStage0:
            let baseRuntimeObj: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
            if os.fileExists(baseRuntimeObj):
                runtimeObj = baseRuntimeObj
        if !os.fileExists(runtimeObj):
            tooling_printErr("cheng_tooling: missing runtime object: " + runtimeObj)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
    var jobs: int32 = tooling_detectHostJobs(root)
    if jobs < 1:
        jobs = 1
    if jobs > 8:
        jobs = 8
    var jobsText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_JOBS", "")
    if fullRebuild:
        jobsText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_JOBS", jobsText)
        if !tooling_strNonEmpty(jobsText):
            jobsText = "1"
    if tooling_strNonEmpty(jobsText):
        jobs = tooling_parseInt32Default(jobsText, jobs)
    if jobs < 1:
        jobs = 1
    if jobs > 8:
        jobs = 8
    var timeoutEnv: str = "BACKEND_BUILD_DRIVER_TIMEOUT"
    var timeoutDefault: int32 = 60
    var parseMode: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_PARSE_MODE", "outline")
    var fnSchedText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_FN_SCHED", "ws")
    var directExeText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_DIRECT_EXE", "1")
    var incrementalText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_INCREMENTAL", "1")
    var multiText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_MULTI", "0")
    var multiForceText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_MULTI_FORCE", "0")
    var stage1BuilderText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_STAGE1_BUILDER", "stage1")
    # Stage1 semantic/ownership skip knobs are fixed by mode:
    # quick=1/1, full=0/0. Remove env overrides to keep behavior deterministic.
    var skipSemText: str = "1"
    var skipOwnershipText: str = "1"
    var genericModeText: str = "dict"
    var genericSpecBudgetText: str = "0"
    if fullRebuild:
        timeoutEnv = "BACKEND_BUILD_DRIVER_REBUILD_TIMEOUT"
        timeoutDefault = 60
        parseMode = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_PARSE_MODE", "full")
        fnSchedText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_FN_SCHED", "serial")
        directExeText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_DIRECT_EXE", "0")
        incrementalText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_INCREMENTAL", "0")
        # Full rebuild on unstable drivers can crash under multi worker mode.
        # Default to serial full rebuild; callers can opt in via env for diagnostics.
        multiText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_MULTI", "0")
        multiForceText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_MULTI_FORCE", "0")
        stage1BuilderText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_STAGE1_BUILDER", stage1BuilderText)
        skipSemText = "0"
        skipOwnershipText = "0"
        genericModeText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_GENERIC_MODE", "dict")
        genericSpecBudgetText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_GENERIC_SPEC_BUDGET", "0")
    if !tooling_strNonEmpty(parseMode):
        parseMode = fullRebuild ? "full" : "outline"
    if !tooling_strNonEmpty(fnSchedText):
        fnSchedText = fullRebuild ? "serial" : "ws"
    if !tooling_strNonEmpty(directExeText):
        directExeText = fullRebuild ? "0" : "1"
    if !tooling_strNonEmpty(incrementalText):
        incrementalText = fullRebuild ? "0" : "1"
    if !tooling_strNonEmpty(multiText):
        multiText = fullRebuild ? "1" : "0"
    if !tooling_strNonEmpty(multiForceText):
        multiForceText = fullRebuild ? "1" : "0"
    if !tooling_strNonEmpty(stage1BuilderText):
        stage1BuilderText = "stage1"
    if !tooling_strNonEmpty(genericModeText):
        genericModeText = "dict"
    if !tooling_strNonEmpty(genericSpecBudgetText):
        genericSpecBudgetText = "0"
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault(timeoutEnv, ""), timeoutDefault)
    if timeoutSec < 1:
        timeoutSec = timeoutDefault
    let profileEnabledFromEnv: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE", "0"))
    let profileOutRaw: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE_OUT", "")
    var profileOutPath: str = ""
    if tooling_strNonEmpty(profileOutRaw):
        profileOutPath = tooling_pathAbsolute(root, profileOutRaw)
    let profileEnabled: bool = profileEnabledFromEnv || tooling_strNonEmpty(profileOutPath)
    let crashRetrySafe: bool = fullRebuild &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_CRASH_RETRY_SAFE", "1"))
    var usedCrashRetry: bool = false
    var finalRes: os.ExecCmdResult = tooling_exec(root, "true")
    var finalRc: int32 = 1
    var lastCompileCmdBase: str = ""
    for attempt in 0..<2:
        if attempt > 0 && (!crashRetrySafe || !usedCrashRetry):
            break
        var compileCmd: str = ""
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
        compileCmd = compileCmd + tooling_envAssignCompat("MM", "orc")
        compileCmd = compileCmd + tooling_envAssignCompat("CACHE", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "dev")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", parseMode)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_FN_SCHED", fnSchedText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", directExeText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_MULTI", multiText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", multiForceText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", incrementalText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_JOBS", intToStr(jobs))
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_FN_JOBS", intToStr(jobs))
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_WHOLE_PROGRAM", "1")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_OPT", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_OPT2", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("UIR_SIMD", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", skipSemText)
        compileCmd = compileCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", skipOwnershipText)
        compileCmd = compileCmd + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
        compileCmd = compileCmd + tooling_envAssignCompat("GENERIC_MODE", genericModeText)
        compileCmd = compileCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", genericSpecBudgetText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", stage1BuilderText)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_LINKER", linkerMode)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        if tooling_strEq(linkerMode, "self"):
            compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
            compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
        else:
            compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_INPUT", os.joinPath(root, "src/backend/tooling/backend_driver.cheng"))
        compileCmd = compileCmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
        compileCmd = compileCmd + tooling_shellQuote(stage0Exec)
        compileCmd = tooling_prefixUnsetLegacyFrontendEnv(compileCmd)
        lastCompileCmdBase = compileCmd
        if profileEnabled:
            compileCmd = tooling_envAssignCompat("BACKEND_PROFILE", "1") +
                         tooling_envAssignCompat("STAGE1_PROFILE", "1") +
                         tooling_envAssignCompat("UIR_PROFILE", "1") + compileCmd
        compileCmd = tooling_wrapStage0Lock(root, compileCmd, "build_backend_driver_compile")
        compileCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, compileCmd)
        let res: os.ExecCmdResult = tooling_exec(root, compileCmd)
        tooling_printExecOutput(res)
        finalRes = res
        finalRc = os.execCmdResultExitCode(res)
        if finalRc != 139 || !crashRetrySafe || usedCrashRetry:
            break
        usedCrashRetry = true
        tooling_printErr("cheng_tooling: full rebuild crashed with segfault; retrying safe serial stage1 builder")
        jobs = 1
        multiText = "0"
        multiForceText = "0"
        incrementalText = "0"
        fnSchedText = "serial"
        directExeText = "0"
        stage1BuilderText = "stage1"
    let finalOutTrim: str = strutil.strip(os.execCmdResultOutput(finalRes))
    let diagOnEmptyFail: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_EMPTY_FAIL_DIAG", "1"))
    if fullRebuild && finalRc != 0 && !tooling_strNonEmpty(finalOutTrim) &&
       diagOnEmptyFail && tooling_strNonEmpty(lastCompileCmdBase):
        let diagName: str = "build_backend_driver.empty_fail." +
                            intToStr(int32(tooling_nowMs() % int64(2000000000))) + ".log"
        let diagPath: str = os.joinPath(tooling_driverBuildTempDir(root), diagName)
        var diagCmd: str = ""
        diagCmd = diagCmd + tooling_envAssignCompat("BACKEND_PROFILE", "1")
        diagCmd = diagCmd + tooling_envAssignCompat("STAGE1_PROFILE", "1")
        diagCmd = diagCmd + tooling_envAssignCompat("UIR_PROFILE", "1")
        diagCmd = diagCmd + tooling_envAssignCompat("BACKEND_DEBUG_STAGE1_PIPE", "1")
        diagCmd = diagCmd + lastCompileCmdBase
        diagCmd = tooling_wrapStage0Lock(root, diagCmd, "build_backend_driver_diag")
        diagCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, diagCmd)
        let diagRes: os.ExecCmdResult = tooling_exec(root, diagCmd)
        let diagOut: str = os.execCmdResultOutput(diagRes)
        os.writeFile(diagPath, diagOut)
        tooling_printErr("cheng_tooling: full rebuild failed with empty output; diagnostic log: " + diagPath)
        if tooling_strNonEmpty(strutil.strip(diagOut)):
            let rows: str[] = tooling_splitLines(diagOut)
            var maxLines: int32 = 24
            if rows.len < maxLines:
                maxLines = rows.len
            for i in 0..<maxLines:
                tooling_printErr("cheng_tooling: full rebuild diag: " + rows[i])
    if tooling_strNonEmpty(profileOutPath):
        let profileOutDir: str = os.parentDir(profileOutPath)
        if tooling_strNonEmpty(profileOutDir):
            tooling_tryMkdirP(root, profileOutDir)
        os.writeFile(profileOutPath, os.execCmdResultOutput(finalRes))
        tooling_printOut("build_backend_driver_profile_log=" + profileOutPath)
    let strictRelinkOnUndef: bool = fullRebuild && strictNative &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_STRICT_LEGACY_RELINK_ON_UNDEF", "1"))
    if finalRc != 0 && strictRelinkOnUndef && tooling_outputHasUndefinedSymbols(os.execCmdResultOutput(finalRes)):
        let strictRelinkRc: int32 = tooling_tryLegacyDriverObjRelink(root, outPath, target)
        if strictRelinkRc == 0 && tooling_driverSanityOk(root, outPath):
            tooling_printOut("build_backend_driver_strict_legacy_obj_relink=1")
            finalRc = 0
        elif strictRelinkRc > 0:
            tooling_printErr("cheng_tooling: strict legacy relink failed rc=" + intToStr(strictRelinkRc) +
                             " kind=" + tooling_exitKind(strictRelinkRc))
            finalRc = strictRelinkRc
    let legacyRelinkFallback: bool = fullRebuild && allowFallback &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_LEGACY_RELINK", "0"))
    let delegateWrapperEnabled: bool = fullRebuild &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_DELEGATE_WRAPPER",
                                        "0"))
    let delegateWrapperAllowByPolicy: bool = allowFallback
    let delegateWrapperAnyFail: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_DELEGATE_ON_ANY_FAIL",
                         "0"))
    let delegateWrapperFallback: bool = delegateWrapperEnabled && delegateWrapperAllowByPolicy &&
        (finalRc == 139 || delegateWrapperAnyFail)
    if finalRc != 0:
        if legacyRelinkFallback:
            let legacyRelinkRc: int32 = tooling_tryLegacyDriverObjRelink(root, outPath, target)
            if legacyRelinkRc == 0 && tooling_driverSanityOk(root, outPath):
                tooling_printOut("build_backend_driver_legacy_obj_relink=1")
                finalRc = 0
            elif legacyRelinkRc > 0:
                tooling_printErr("cheng_tooling: legacy cheng.objs relink failed rc=" + intToStr(legacyRelinkRc) +
                                 " kind=" + tooling_exitKind(legacyRelinkRc))
                finalRc = legacyRelinkRc
    if finalRc != 0 && delegateWrapperFallback:
        tooling_printErr("cheng_tooling: full rebuild failed rc=" + intToStr(finalRc) +
                         " kind=" + tooling_exitKind(finalRc) +
                         "; retrying with stage1 delegate wrapper")
        let delegateRc: int32 = tooling_compileBackendDriverDelegateWrapper(root, stage0Exec, target, outPath)
        if delegateRc == 0 && tooling_driverSanityOk(root, outPath):
            tooling_printOut("build_backend_driver_delegate_wrapper=1")
            finalRc = 0
        elif delegateRc != 0:
            tooling_printErr("cheng_tooling: delegate wrapper compile failed rc=" + intToStr(delegateRc) +
                             " kind=" + tooling_exitKind(delegateRc))
            finalRc = delegateRc
        else:
            tooling_printErr("cheng_tooling: delegate wrapper output sanity failed")
            finalRc = 1
    if finalRc != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        return finalRc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    let chmodRc: int32 = os.execCmdResultExitCode(chmodRes)
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    return chmodRc

fn tooling_selfhostBootstrapFastHost(root: str, compileStage1: bool, outDirRaw: str, timingOutRaw: str, stage0Raw: str): ToolingSelfhostResult =
    var result: ToolingSelfhostResult
    new result
    result.ok = false
    result.message = ""
    result.totalMs = int64(0)
    result.stage1Path = ""
    result.stage2Path = ""
    result.stage0Path = ""
    result.stage0DriverKind = "unknown"
    result.stage1Status = "init"
    result.stage1CompileMode = "alias"
    result.stage1RebuildOk = false
    result.fallbackUsed = false
    result.quarantineCleaned = 0
    result.lockWaitMs = 0
    result.strictRebuildOk = false

    let hostTag: str = tooling_detectHostTag(root)
    if !tooling_strEq(hostTag, "darwin_arm64"):
        result.message = "selfhost_fast_host unsupported host: " + hostTag
        return result
    let target: str = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        result.message = "selfhost_fast_host failed to resolve host target"
        return result
    result.quarantineCleaned = tooling_stage0QuarantineSweepUe(root, "selfhost_fast_host")
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_SELFHOST_BLOCK_ON_UE", "selfhost_fast_host"):
        result.message = "selfhost_fast_host blocked by quarantine stuck/orphan processes"
        return result

    let explicitStage0Raw: str = strutil.strip(stage0Raw)
    var stage0: str = tooling_resolveStage0DriverStrict(root, stage0Raw)
    if !tooling_strNonEmpty(stage0) && tooling_strNonEmpty(explicitStage0Raw):
        result.message = "selfhost_fast_host explicit stage0 failed strict probe: " + explicitStage0Raw
        return result
    if !tooling_strNonEmpty(stage0):
        result.message = "selfhost_fast_host missing stage0 driver"
        return result
    result.stage0Path = stage0
    result.stage0DriverKind = tooling_stage0DriverKind(root, stage0)

    var outDir: str = outDirRaw
    if !tooling_strNonEmpty(outDir):
        outDir = "artifacts/backend_selfhost_self_obj"
    outDir = tooling_pathAbsolute(root, outDir)
    if !tooling_mkdirP(root, outDir):
        result.message = "selfhost_fast_host failed to create out dir: " + outDir
        return result
    let stage1Path: str = os.joinPath(outDir, "cheng.stage1")
    let stage2Path: str = os.joinPath(outDir, "cheng.stage2")
    result.stage1Path = stage1Path
    result.stage2Path = stage2Path

    let startedMs: int64 = tooling_nowMs()
    let stage1StartedMs: int64 = tooling_nowMs()
    var stage1Status: str = "alias"
    var stage1CompileMode: str = "alias"
    let strictRebuild: bool = tooling_selfhostStrictRebuildEnabled()
    let requireStage1Rebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_REQUIRE_REBUILD", "0")))
    let stage1FullRebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FULL_REBUILD", "0")))
    let stage1ForceProbeOnFull: bool = compileStage1 &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FORCE_PROBE_ON_FULL", "1"))
    let stage1AutoFullOnRequire: bool = compileStage1 && !stage1FullRebuild && requireStage1Rebuild &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_AUTO_FULL_ON_REQUIRE", "1"))
    let stage1QuickLightSanity: bool = compileStage1 && !stage1FullRebuild &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_QUICK_LIGHT_SANITY", "1"))
    var compileStage1TextBase: str = "0"
    if compileStage1:
        compileStage1TextBase = "1"
        if stage1FullRebuild:
            stage1CompileMode = "full"
        else:
            stage1CompileMode = "quick"
    result.stage1CompileMode = stage1CompileMode
    if compileStage1:
        var rcBuild: int32 = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, stage1FullRebuild)
        var stage1BuildOk: bool = false
        if rcBuild == 0:
            stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                        stage1ForceProbeOnFull)
        if stage1AutoFullOnRequire && (!stage1BuildOk || rcBuild != 0):
            tooling_printErr("cheng_tooling: selfhost fast stage1 quick rebuild failed or not runnable; retrying full-rebuild because require-rebuild is enabled")
            stage1CompileMode = "full"
            rcBuild = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, true)
            if rcBuild == 0:
                stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                            stage1ForceProbeOnFull)
            else:
                stage1BuildOk = false
        if !stage1BuildOk && rcBuild != 0 && tooling_strEq(tooling_exitKind(rcBuild), "segfault"):
            let rescueStage0: str = tooling_buildDriverSegfaultRescueCandidate(root, stage0, explicitStage0Raw)
            if tooling_strNonEmpty(rescueStage0):
                tooling_printErr("cheng_tooling: selfhost fast stage1 segfault; retrying with rescue stage0: " + rescueStage0)
                stage0 = rescueStage0
                result.stage0Path = stage0
                result.stage0DriverKind = tooling_stage0DriverKind(root, stage0)
                let retryFull: bool = tooling_strEq(stage1CompileMode, "full")
                rcBuild = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, retryFull)
                if rcBuild == 0:
                    stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                                stage1ForceProbeOnFull)
                else:
                    stage1BuildOk = false
        if stage1BuildOk:
            stage1Status = "rebuild"
            result.stage1RebuildOk = true
            result.fallbackUsed = false
        else:
            if requireStage1Rebuild:
                if rcBuild != 0:
                    result.message = "selfhost_fast_host stage1 compile failed rc=" + intToStr(rcBuild) +
                                     " kind=" + tooling_exitKind(rcBuild)
                else:
                    result.message = "selfhost_fast_host stage1 compile output sanity failed"
                return result
            if !tooling_copyExecutable(root, stage0, stage1Path):
                if rcBuild != 0:
                    result.message = "selfhost_fast_host stage1 compile failed rc=" + intToStr(rcBuild) +
                                     " kind=" + tooling_exitKind(rcBuild)
                else:
                    result.message = "selfhost_fast_host stage1 compile output sanity failed and stage0 reuse copy failed"
                return result
            stage1Status = "reused_stage0"
            result.stage1RebuildOk = false
            result.fallbackUsed = true
    else:
        if !tooling_copyExecutable(root, stage0, stage1Path):
            result.message = "selfhost_fast_host stage1 alias copy failed"
            return result
        stage1Status = "alias"
        result.stage1RebuildOk = false
        result.fallbackUsed = true
    let stage1Ms: int64 = tooling_nowMs() - stage1StartedMs
    result.stage1Status = stage1Status
    result.stage1CompileMode = stage1CompileMode
    result.strictRebuildOk = !compileStage1 || !strictRebuild || result.stage1RebuildOk

    let stage2StartedMs: int64 = tooling_nowMs()
    if !tooling_copyExecutable(root, stage1Path, stage2Path):
        result.message = "selfhost_fast_host stage2 alias copy failed"
        return result
    let stage2Ms: int64 = tooling_nowMs() - stage2StartedMs

    let totalMs: int64 = tooling_nowMs() - startedMs
    result.totalMs = totalMs
    result.ok = true
    result.message = "ok"

    var timingOut: str = timingOutRaw
    if !tooling_strNonEmpty(timingOut):
        timingOut = os.joinPath(outDir, "selfhost_timing_native.tsv")
    timingOut = tooling_pathAbsolute(root, timingOut)
    let timingDir: str = os.parentDir(timingOut)
    tooling_tryMkdirP(root, timingDir)
    let timingText: str =
        "stage1\t" + stage1Status + "\t" + tooling_msToSecondsText(stage1Ms) + "\n" +
        "stage2\talias\t" + tooling_msToSecondsText(stage2Ms) + "\n" +
        "total\tok\t" + tooling_msToSecondsText(totalMs) + "\n"
    os.writeFile(timingOut, timingText)
    result.lockWaitMs = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_WAIT_MS", ""), 0)
    return result

fn tooling_sortInt32Asc(values: int32[]): int32[] =
    var out: int32[] = []
    for i in 0..<values.len:
        add(out, values[i])
    for i in 1..<out.len:
        let key: int32 = out[i]
        var j: int32 = i - 1
        while j >= 0 && out[j] > key:
            out[j + 1] = out[j]
            j = j - 1
        out[j + 1] = key
    return out

fn tooling_pickPercentile(sorted: int32[], pct: int32): int32 =
    if sorted.len <= 0:
        return -1
    var k: int32 = (pct * sorted.len + 99) / 100
    if k < 1:
        k = 1
    if k > sorted.len:
        k = sorted.len
    return sorted[k - 1]

fn tooling_backendDriverHistoryKeep(name: str): bool =
    if tooling_strEq(name, "cheng"):
        return true
    if tooling_strEq(name, "cheng.objs"):
        return true
    if tooling_strEq(name, "cheng.objs.lock"):
        return true
    return false

fn tooling_cmdCleanupBackendDriverHistory(root: str, dryRun: bool): int32 =
    let backendDir: str = os.joinPath(root, "artifacts/backend_driver")
    if !os.dirExists(backendDir):
        tooling_printOut("cleanup_backend_driver_history_status=noop")
        tooling_printOut("cleanup_backend_driver_history_dir_missing=" + backendDir)
        return 0
    let scanCmd: str = "find " + tooling_shellQuote(backendDir) + " -maxdepth 1 -mindepth 1 -name 'cheng*' -print"
    let scanRes: os.ExecCmdResult = tooling_exec(root, scanCmd)
    let scanRc: int32 = os.execCmdResultExitCode(scanRes)
    if scanRc != 0:
        tooling_printErr("cheng_tooling: cleanup_backend_driver_history scan failed")
        tooling_printExecOutput(scanRes)
        return scanRc
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(scanRes))
    var removedCount: int32 = 0
    var keepCount: int32 = 0
    var scannedCount: int32 = 0
    for i in 0..<rows.len:
        let path: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(path):
            continue
        scannedCount = scannedCount + 1
        let base: str = os.extractFilename(path)
        if tooling_backendDriverHistoryKeep(base):
            keepCount = keepCount + 1
            continue
        removedCount = removedCount + 1
        if dryRun:
            tooling_printOut("cleanup_backend_driver_history_plan_remove=" + path)
            continue
        let rmCmd: str = "rm -rf " + tooling_shellQuote(path)
        let rmRes: os.ExecCmdResult = tooling_exec(root, rmCmd)
        let rmRc: int32 = os.execCmdResultExitCode(rmRes)
        if rmRc != 0:
            tooling_printErr("cheng_tooling: cleanup_backend_driver_history remove failed: " + path)
            tooling_printExecOutput(rmRes)
            return rmRc
    tooling_printOut("cleanup_backend_driver_history_scanned=" + intToStr(scannedCount))
    tooling_printOut("cleanup_backend_driver_history_kept=" + intToStr(keepCount))
    tooling_printOut("cleanup_backend_driver_history_removed=" + intToStr(removedCount))
    if dryRun:
        tooling_printOut("cleanup_backend_driver_history_dry_run=1")
    else:
        tooling_printOut("cleanup_backend_driver_history_dry_run=0")
    return 0

fn tooling_cmdDriverPath(root: str, explicitRaw: str): int32 =
    let stage0: str = tooling_resolveStage0Driver(root, explicitRaw)
    if !tooling_strNonEmpty(stage0):
        tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    tooling_printOut(stage0)
    return 0

fn tooling_writeBackendDriverNativeContractShim(root: str, outPathRaw: str, delegateRaw: str): bool =
    if !tooling_strNonEmpty(outPathRaw) || !tooling_strNonEmpty(delegateRaw):
        return false
    let outPath: str = tooling_pathAbsolute(root, outPathRaw)
    let delegatePath: str = tooling_pathAbsolute(root, delegateRaw)
    if !tooling_isExecutable(root, delegatePath):
        return false
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            return false
    var script: str = ""
    script = script + "#!/usr/bin/env sh\n"
    script = script + "set -e\n"
    script = script + "delegate=" + tooling_shellQuote(delegatePath) + "\n"
    script = script + "if [ ! -x \"$delegate\" ]; then\n"
    script = script + "  echo \"backend_driver shim: missing delegate: $delegate\" 1>&2\n"
    script = script + "  exit 1\n"
    script = script + "fi\n"
    script = script + "native_raw=\"${BACKEND_NATIVE_CONTRACT:-}\"\n"
    script = script + "native_on=0\n"
    script = script + "case \"$native_raw\" in\n"
    script = script + "  1|true|TRUE|yes|YES|on|ON) native_on=1 ;;\n"
    script = script + "esac\n"
    script = script + "if [ \"$native_on\" = \"1\" ]; then\n"
    script = script + "  input=\"${BACKEND_INPUT:-}\"\n"
    script = script + "  if [ -n \"$input\" ] && [ -f \"$input\" ]; then\n"
    script = script + "    if command -v rg >/dev/null 2>&1; then\n"
    script = script + "      if rg -q 'cheng_linux_syscall|\\bsyscall\\(' \"$input\"; then\n"
    script = script + "        echo \"backend_driver: native_contract hard-fail @$input: forbid syscall\" 1>&2\n"
    script = script + "        exit 1\n"
    script = script + "      fi\n"
    script = script + "      if rg -q '\\b(float32|float64|f32|f64)\\b' \"$input\"; then\n"
    script = script + "        echo \"backend_driver: native_contract hard-fail @$input: forbid float\" 1>&2\n"
    script = script + "        exit 1\n"
    script = script + "      fi\n"
    script = script + "    fi\n"
    script = script + "  fi\n"
    script = script + "fi\n"
    script = script + "set +e\n"
    script = script + "\"$delegate\" \"$@\"\n"
    script = script + "rc=\"$?\"\n"
    script = script + "set -e\n"
    script = script + "if [ \"$native_on\" = \"1\" ] && [ \"$rc\" -eq 0 ]; then\n"
    script = script + "  stamp=\"${BACKEND_COMPILE_STAMP_OUT:-}\"\n"
    script = script + "  if [ -n \"$stamp\" ]; then\n"
    script = script + "    {\n"
    script = script + "      echo \"native_contract=1\"\n"
    script = script + "      echo \"native_contract_charge_symbol=${BACKEND_NATIVE_CONTRACT_CHARGE_SYMBOL:-__cheng_contract_charge_block}\"\n"
    script = script + "      echo \"native_contract_gas_counter=${BACKEND_NATIVE_CONTRACT_GAS_COUNTER:-__cheng_contract_gas_used}\"\n"
    script = script + "    } >> \"$stamp\" 2>/dev/null || true\n"
    script = script + "  fi\n"
    script = script + "fi\n"
    script = script + "exit \"$rc\"\n"
    os.writeFile(outPath, script)
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    return os.execCmdResultExitCode(chmodRes) == 0

fn tooling_cmdCleanupBackendDriverHistoryFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var dryRun: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("cleanup-backend-driver-history options:")
            tooling_printOut("  --dry-run                   print files to remove, no write")
            return 0
        if tooling_strEq(arg, "--dry-run"):
            dryRun = true
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown cleanup-backend-driver-history arg: " + arg)
        return 1
    return tooling_cmdCleanupBackendDriverHistory(root, dryRun)

fn tooling_cmdBuildBackendDriver(root: str, outRaw: str, stage0Raw: str, targetRaw: str, requireRebuild: bool): int32 =
    var target: str = strutil.strip(targetRaw)
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        tooling_printErr("cheng_tooling: failed to detect target")
        return 1
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_BUILD_DRIVER_BLOCK_ON_UE", "build_backend_driver"):
        return 1
    let explicitStage0Raw: str = strutil.strip(stage0Raw)
    let stage0Candidates: str[] = tooling_stage0CandidateListWithProbe(root, stage0Raw, true)
    if stage0Candidates.len <= 0 && tooling_strNonEmpty(explicitStage0Raw):
        tooling_printErr("cheng_tooling: explicit stage0 failed strict probe: " + explicitStage0Raw)
        return 1
    if stage0Candidates.len <= 0:
        tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    var outPath: str = outRaw
    if !tooling_strNonEmpty(outPath):
        outPath = "artifacts/backend_driver/cheng"
    outPath = tooling_pathAbsolute(root, outPath)
    let canonicalDriverPath: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    let autoCleanHistory: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_AUTO_CLEAN_HISTORY", "1"))
    let strictNative: bool = tooling_buildDriverStrictNativeEnabled()
    let allowFallback: bool = tooling_buildDriverAllowFallbackEnabled()
    let quickLightSanity: bool = false
    let forceProbeOnFull: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_FULL_FORCE_PROBE", "1"))
    let noRecover: bool = !allowFallback || tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_NO_RECOVER", "1"))
    var maxStage0Attempts: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_BUILD_DRIVER_MAX_STAGE0_ATTEMPTS", ""), 0)
    if maxStage0Attempts < 0:
        maxStage0Attempts = 0
    let compileMode: str = "full"
    var stage0AttemptCandidates: str[] = stage0Candidates
    var attemptCount: int32 = stage0AttemptCandidates.len
    if maxStage0Attempts > 0 && maxStage0Attempts < attemptCount:
        attemptCount = maxStage0Attempts
    var lastRc: int32 = 1
    var lastCompileMode: str = compileMode
    var lastStage0: str = ""
    var fallbackStage0: str = ""
    let legacyRelinkOnSanityFail: bool = allowFallback &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_LEGACY_RELINK", "0"))
    let delegateOnSanityFail: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_DELEGATE_ON_SANITY_FAIL", "0"))
    var i: int32 = 0
    while i < attemptCount:
        let stage0: str = stage0AttemptCandidates[i]
        var stage0ReusePath: str = stage0
        var attemptFallbackUsed: bool = false
        if !tooling_strNonEmpty(fallbackStage0):
            fallbackStage0 = stage0
        let attemptIndex: int32 = i + 1
        tooling_printErr("cheng_tooling: build_backend_driver stage0 attempt " + intToStr(attemptIndex) +
                         "/" + intToStr(attemptCount) + " driver=" + stage0)
        let attemptOutPath: str = tooling_driverBuildTempPath(root, outPath, attemptIndex)
        tooling_driverBuildTempCleanup(root, attemptOutPath)
        var attemptCompileMode: str = compileMode
        var rc: int32 = tooling_compileBackendDriverFastHost(root, stage0ReusePath, target, attemptOutPath, true)
        var postBuildOk: bool = false
        if rc == 0:
            postBuildOk = tooling_driverBuildOutputOk(root, attemptOutPath, attemptCompileMode, quickLightSanity, forceProbeOnFull)
        if rc == 0 && !postBuildOk && legacyRelinkOnSanityFail:
            let relinkRc: int32 = tooling_tryLegacyDriverObjRelink(root, attemptOutPath, target)
            if relinkRc == 0:
                postBuildOk = tooling_driverBuildOutputOk(root, attemptOutPath, attemptCompileMode, quickLightSanity, forceProbeOnFull)
                if postBuildOk:
                    tooling_printOut("build_backend_driver_legacy_obj_relink=1")
            elif relinkRc > 0:
                rc = relinkRc
        if rc == 0 && !postBuildOk && delegateOnSanityFail:
            tooling_printErr("cheng_tooling: stage0 attempt output sanity failed; retrying delegate wrapper")
            let delegateRc: int32 = tooling_compileBackendDriverDelegateWrapper(root, stage0ReusePath, target, attemptOutPath)
            if delegateRc == 0:
                if tooling_driverSanityOk(root, attemptOutPath) && tooling_driverCompileProbeOk(root, attemptOutPath):
                    postBuildOk = true
                    attemptFallbackUsed = true
                    attemptCompileMode = attemptCompileMode + "_delegate"
                    tooling_printOut("build_backend_driver_delegate_wrapper=1")
                else:
                    postBuildOk = false
            elif delegateRc > 0:
                rc = delegateRc
        lastRc = rc
        lastCompileMode = attemptCompileMode
        if rc == 0 && postBuildOk:
            if !tooling_copyExecutable(root, attemptOutPath, outPath):
                tooling_printErr("cheng_tooling: stage0 attempt output install failed: " + attemptOutPath)
                postBuildOk = false
            tooling_driverBuildTempCleanup(root, attemptOutPath)
        if rc == 0 && postBuildOk:
            tooling_printOut("build_backend_driver_compile_mode=" + attemptCompileMode)
            tooling_printOut("build_backend_driver_rebuilt=1")
            tooling_printOut("build_backend_driver_fallback_used=" + (attemptFallbackUsed ? "1" : "0"))
            tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
            tooling_printOut("build_backend_driver_ok=" + outPath)
            if autoCleanHistory && tooling_strEq(outPath, canonicalDriverPath):
                let cleanRc: int32 = tooling_cmdCleanupBackendDriverHistory(root, false)
                if cleanRc != 0:
                    return cleanRc
            return 0
        tooling_driverBuildTempCleanup(root, attemptOutPath)
        if rc != 0:
            tooling_printErr("cheng_tooling: stage0 attempt failed rc=" + intToStr(rc) +
                             " kind=" + tooling_exitKind(rc) + " driver=" + stage0)
            if tooling_strEq(tooling_exitKind(rc), "segfault"):
                let canQueueRescue: bool = (maxStage0Attempts <= 0) || (stage0AttemptCandidates.len < maxStage0Attempts)
                if canQueueRescue:
                    let rescueStage0: str = tooling_buildDriverSegfaultRescueCandidate(root, stage0, explicitStage0Raw)
                    if tooling_strNonEmpty(rescueStage0) && !tooling_idsContains(stage0AttemptCandidates, rescueStage0):
                        add(stage0AttemptCandidates, rescueStage0)
                        attemptCount = stage0AttemptCandidates.len
                        tooling_printErr("cheng_tooling: stage0 segfault detected; queued rescue stage0 candidate: " + rescueStage0)
        else:
            tooling_printErr("cheng_tooling: stage0 attempt output sanity failed: " + stage0)
        lastStage0 = stage0
        i = i + 1
    let shimFallbackDefault: str = allowFallback ? "1" : "0"
    let shimFallbackEnabled: bool = !strictNative &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_SHIM_FALLBACK", shimFallbackDefault))
    if shimFallbackEnabled:
        var shimDelegate: str = fallbackStage0
        if !tooling_strNonEmpty(shimDelegate):
            shimDelegate = os.joinPath(root, "dist/releases/current/cheng")
        let outAbs: str = tooling_pathAbsolute(root, outPath)
        let shimAbs: str = tooling_pathAbsolute(root, shimDelegate)
        if tooling_strEq(shimAbs, outAbs):
            let distFallback: str = os.joinPath(root, "dist/releases/current/cheng")
            if tooling_isExecutable(root, distFallback):
                shimDelegate = distFallback
        if tooling_writeBackendDriverNativeContractShim(root, outPath, shimDelegate):
            tooling_printErr("cheng_tooling: build backend driver compile failed; installed shim fallback delegate=" + shimDelegate)
            tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
            tooling_printOut("build_backend_driver_shim_fallback=1")
            tooling_printOut("build_backend_driver_rebuilt=0")
            tooling_printOut("build_backend_driver_fallback_used=1")
            tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
            tooling_printOut("build_backend_driver_ok=" + outPath)
            if autoCleanHistory && tooling_strEq(outPath, canonicalDriverPath):
                let cleanRc: int32 = tooling_cmdCleanupBackendDriverHistory(root, false)
                if cleanRc != 0:
                    return cleanRc
            return 0
    if requireRebuild:
        tooling_printErr("cheng_tooling: require-rebuild enabled; all stage0 attempts failed, stage0 reuse disabled")
        tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
        tooling_printOut("build_backend_driver_rebuilt=0")
        tooling_printOut("build_backend_driver_fallback_used=0")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printOut("build_backend_driver_ok=" + outPath)
        if lastRc != 0:
            return lastRc
        return 1
    if noRecover:
        let strictReuseOnFail: bool = strictNative && !requireRebuild &&
            tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_STRICT_REUSE_STAGE0_ON_FAIL", "1"))
        if strictReuseOnFail:
            var strictReuseStage0: str = fallbackStage0
            if !tooling_strNonEmpty(strictReuseStage0):
                strictReuseStage0 = lastStage0
            if tooling_strNonEmpty(strictReuseStage0) &&
               tooling_copyExecutable(root, strictReuseStage0, outPath) &&
               tooling_driverPostBuildOk(root, outPath):
                tooling_printErr("cheng_tooling: strict rebuild failed rc=" + intToStr(lastRc) +
                                 " kind=" + tooling_exitKind(lastRc) +
                                 "; reused healthy stage0 driver")
                tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
                tooling_printOut("build_backend_driver_reused_stage0=" + strictReuseStage0)
                tooling_printOut("build_backend_driver_rebuilt=0")
                tooling_printOut("build_backend_driver_fallback_used=0")
                tooling_printOut("build_backend_driver_strict_native=1")
                tooling_printOut("build_backend_driver_ok=" + outPath)
                if autoCleanHistory && tooling_strEq(outPath, canonicalDriverPath):
                    let cleanRc: int32 = tooling_cmdCleanupBackendDriverHistory(root, false)
                    if cleanRc != 0:
                        return cleanRc
                return 0
        tooling_printErr("cheng_tooling: build backend driver compile failed rc=" + intToStr(lastRc) +
                         " kind=" + tooling_exitKind(lastRc) + "; no-recover enabled, stage0 reuse disabled")
        tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
        tooling_printOut("build_backend_driver_rebuilt=0")
        tooling_printOut("build_backend_driver_fallback_used=0")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printOut("build_backend_driver_ok=" + outPath)
        if lastRc != 0:
            return lastRc
        return 1
    if allowFallback && tooling_copyExecutable(root, fallbackStage0, outPath) && tooling_driverPostBuildOk(root, outPath):
        tooling_printErr("cheng_tooling: build backend driver compile failed rc=" + intToStr(lastRc) +
                         " kind=" + tooling_exitKind(lastRc) + "; reused stage0 driver")
        tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
        tooling_printOut("build_backend_driver_reused_stage0=" + fallbackStage0)
        tooling_printOut("build_backend_driver_rebuilt=0")
        tooling_printOut("build_backend_driver_fallback_used=1")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
        tooling_printOut("build_backend_driver_ok=" + outPath)
        if autoCleanHistory && tooling_strEq(outPath, canonicalDriverPath):
            let cleanRc: int32 = tooling_cmdCleanupBackendDriverHistory(root, false)
            if cleanRc != 0:
                return cleanRc
        return 0
    if !allowFallback:
        tooling_printOut("build_backend_driver_fallback_used=0")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
    if lastRc != 0:
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printErr("cheng_tooling: build backend driver failed rc=" + intToStr(lastRc))
        return lastRc
    tooling_printErr("cheng_tooling: build backend driver output sanity failed: " + outPath)
    return 1

fn tooling_cmdSelfhostBootstrapFastHost(root: str, compileStage1: bool, outDirRaw: str, timingOutRaw: str, stage0Raw: str): int32 =
    let res: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, outDirRaw, timingOutRaw, stage0Raw)
    if res == nil || !res.ok:
        var msg: str = "unknown failure"
        if res != nil:
            msg = res.message
        tooling_printErr("cheng_tooling: selfhost bootstrap fast host failed: " + msg)
        return 1
    tooling_printOut("selfhost_fast_stage1=" + res.stage1Path)
    tooling_printOut("selfhost_fast_stage2=" + res.stage2Path)
    tooling_printOut("selfhost_fast_stage0=" + res.stage0Path)
    tooling_printOut("selfhost_fast_stage0_driver_kind=" + res.stage0DriverKind)
    tooling_printOut("selfhost_fast_stage1_status=" + res.stage1Status)
    tooling_printOut("selfhost_fast_stage1_compile_mode=" + res.stage1CompileMode)
    var stage1RebuildOkText: str = "0"
    if res.stage1RebuildOk:
        stage1RebuildOkText = "1"
    var fallbackUsedText: str = "0"
    if res.fallbackUsed:
        fallbackUsedText = "1"
    var strictRebuildOkText: str = "0"
    if res.strictRebuildOk:
        strictRebuildOkText = "1"
    tooling_printOut("selfhost_fast_stage1_rebuild_ok=" + stage1RebuildOkText)
    tooling_printOut("selfhost_fast_fallback_used=" + fallbackUsedText)
    tooling_printOut("selfhost_fast_quarantine_cleaned=" + intToStr(res.quarantineCleaned))
    tooling_printOut("selfhost_fast_lock_wait_ms=" + intToStr(res.lockWaitMs))
    tooling_printOut("selfhost_fast_strict_rebuild_ok=" + strictRebuildOkText)
    tooling_printOut("selfhost_fast_total_ms=" + intToStr(int32(res.totalMs)))
    return 0

fn tooling_cmdSelfhost100msHost(root: str, hostOnlyRaw: str, itersRaw: str, p95Raw: str, p99Raw: str, enforceRaw: str, reportRaw: str, compileStage1: bool, outDirRaw: str, stage0Raw: str): int32 =
    var hostOnly: str = strutil.strip(hostOnlyRaw)
    if !tooling_strNonEmpty(hostOnly):
        hostOnly = "darwin_arm64"
    var iters: int32 = tooling_parseInt32Default(itersRaw, 5)
    if iters <= 0:
        iters = 5
    var p95Limit: int32 = tooling_parseInt32Default(p95Raw, 100)
    if p95Limit <= 0:
        p95Limit = 100
    var p99Limit: int32 = tooling_parseInt32Default(p99Raw, 120)
    if p99Limit <= 0:
        p99Limit = 120
    let enforce: bool = tooling_isTrue(enforceRaw)
    let strictRebuild: bool = tooling_selfhostStrictRebuildEnabled()
    let requireStage1Rebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_REQUIRE_REBUILD", "0")))
    let stage1FullRebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FULL_REBUILD", "0")))
    var stage1CompileModeBase: str = "alias"
    if compileStage1:
        if stage1FullRebuild:
            stage1CompileModeBase = "full"
        else:
            stage1CompileModeBase = "quick"
    var compileStage1TextBase: str = "0"
    if compileStage1:
        compileStage1TextBase = "1"

    let hostTag: str = tooling_detectHostTag(root)
    var reportPath: str = reportRaw
    if !tooling_strNonEmpty(reportPath):
        reportPath = "artifacts/backend_selfhost_100ms_host/report.tsv"
    reportPath = tooling_pathAbsolute(root, reportPath)
    let reportDir: str = os.parentDir(reportPath)
    tooling_tryMkdirP(root, reportDir)

    if hostTag != hostOnly:
        let reportSkip: str =
            "host=" + hostTag + "\n" +
            "host_only=" + hostOnly + "\n" +
            "compile_stage1=" + compileStage1TextBase + "\n" +
            "stage1_compile_mode=" + stage1CompileModeBase + "\n" +
            "strict_rebuild_ok=0\n" +
            "fallback_used=0\n" +
            "quarantine_cleaned=0\n" +
            "lock_wait_ms=0\n" +
            "status=skip_non_target_host\n"
        os.writeFile(reportPath, reportSkip)
        tooling_printOut("[selfhost_100ms_native] skip on non-target host: host=" + hostTag + " target=" + hostOnly)
        return 0
    var totalsMs: int32[] = []
    var stage1RebuildCount: int32 = 0
    var stage1ReuseCount: int32 = 0
    var stage1AliasCount: int32 = 0
    var stage1CompileModeFullCount: int32 = 0
    var stage1CompileModeQuickCount: int32 = 0
    var stage1CompileModeAliasCount: int32 = 0
    var fallbackUsedCount: int32 = 0
    var quarantineCleanedTotal: int32 = 0
    var lockWaitMsMax: int32 = 0
    var strictRebuildOkCount: int32 = 0
    var stage0DriverKindSummary: str = ""
    var outDirInput: str = outDirRaw
    if !tooling_strNonEmpty(outDirInput):
        outDirInput = "artifacts/backend_selfhost_100ms_host"
    let outDir: str = tooling_pathAbsolute(root, outDirInput)
    tooling_tryMkdirP(root, outDir)
    for i in 1..iters:
        let timingPath: str = os.joinPath(outDir, "selfhost_timing_native." + intToStr(i) + ".tsv")
        let res: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, "", timingPath, stage0Raw)
        if res == nil || !res.ok:
            var msg: str = "unknown failure"
            var stage0DriverKindFail: str = "unknown"
            var fallbackUsedFail: str = "0"
            var quarantineCleanedFail: str = "0"
            var lockWaitMsFail: str = "0"
            var strictRebuildOkFail: str = "0"
            if res != nil:
                msg = res.message
                stage0DriverKindFail = res.stage0DriverKind
                if res.fallbackUsed:
                    fallbackUsedFail = "1"
                quarantineCleanedFail = intToStr(res.quarantineCleaned)
                lockWaitMsFail = intToStr(res.lockWaitMs)
                if res.strictRebuildOk:
                    strictRebuildOkFail = "1"
            let reportFail: str =
                "host=" + hostTag + "\n" +
                "iters=" + intToStr(iters) + "\n" +
                "failed_iter=" + intToStr(i) + "\n" +
                "status=bootstrap_fail\n" +
                "reason=" + msg + "\n" +
                "compile_stage1=" + compileStage1TextBase + "\n" +
                "stage1_compile_mode=" + stage1CompileModeBase + "\n" +
                "stage0_driver_kind=" + stage0DriverKindFail + "\n" +
                "fallback_used=" + fallbackUsedFail + "\n" +
                "quarantine_cleaned=" + quarantineCleanedFail + "\n" +
                "lock_wait_ms=" + lockWaitMsFail + "\n" +
                "strict_rebuild_ok=" + strictRebuildOkFail + "\n" +
                "limit_p95_ms=" + intToStr(p95Limit) + "\n" +
                "limit_p99_ms=" + intToStr(p99Limit) + "\n"
            os.writeFile(reportPath, reportFail)
            tooling_printErr("[selfhost_100ms_native] bootstrap failed: iter=" + intToStr(i) + " reason=" + msg)
            if enforce:
                return 1
            return 0
        add(totalsMs, int32(res.totalMs))
        if res.fallbackUsed:
            fallbackUsedCount = fallbackUsedCount + 1
        quarantineCleanedTotal = quarantineCleanedTotal + res.quarantineCleaned
        if res.lockWaitMs > lockWaitMsMax:
            lockWaitMsMax = res.lockWaitMs
        if res.strictRebuildOk:
            strictRebuildOkCount = strictRebuildOkCount + 1
        if !tooling_strNonEmpty(stage0DriverKindSummary):
            stage0DriverKindSummary = res.stage0DriverKind
        elif !tooling_strEq(stage0DriverKindSummary, res.stage0DriverKind):
            stage0DriverKindSummary = "mixed"
        if tooling_strEq(res.stage1Status, "rebuild") && res.stage1RebuildOk:
            stage1RebuildCount = stage1RebuildCount + 1
        elif tooling_strEq(res.stage1Status, "reused_stage0"):
            stage1ReuseCount = stage1ReuseCount + 1
        elif tooling_strEq(res.stage1Status, "alias"):
            stage1AliasCount = stage1AliasCount + 1
        if tooling_strEq(res.stage1CompileMode, "full"):
            stage1CompileModeFullCount = stage1CompileModeFullCount + 1
        elif tooling_strEq(res.stage1CompileMode, "quick"):
            stage1CompileModeQuickCount = stage1CompileModeQuickCount + 1
        else:
            stage1CompileModeAliasCount = stage1CompileModeAliasCount + 1
    if totalsMs.len <= 0:
        tooling_printErr("[selfhost_100ms_native] empty totals")
        return 1
    let sorted: int32[] = tooling_sortInt32Asc(totalsMs)
    let p95Ms: int32 = tooling_pickPercentile(sorted, 95)
    let p99Ms: int32 = tooling_pickPercentile(sorted, 99)
    var maxMs: int32 = 0
    for i in 0..<sorted.len:
        if sorted[i] > maxMs:
            maxMs = sorted[i]
    var status: str = "ok"
    if p95Ms > p95Limit || p99Ms > p99Limit:
        status = "regression"
    var stage1StatusSummary: str = "alias"
    var stage1CompileModeSummary: str = "alias"
    var stage1RebuildOk: bool = false
    if compileStage1:
        if stage1CompileModeFullCount == iters:
            stage1CompileModeSummary = "full"
        elif stage1CompileModeQuickCount == iters:
            stage1CompileModeSummary = "quick"
        elif stage1CompileModeFullCount > 0 && stage1CompileModeQuickCount > 0:
            stage1CompileModeSummary = "mixed_full_quick"
        elif stage1CompileModeAliasCount == iters:
            stage1CompileModeSummary = "alias"
        else:
            stage1CompileModeSummary = "mixed"
        if stage1RebuildCount == iters:
            stage1StatusSummary = "rebuild"
            stage1RebuildOk = true
        elif stage1RebuildCount > 0 && stage1ReuseCount > 0:
            stage1StatusSummary = "mixed_rebuild_reuse"
            stage1RebuildOk = false
        elif stage1ReuseCount > 0:
            stage1StatusSummary = "reused_stage0"
            stage1RebuildOk = false
        else:
            stage1StatusSummary = "unknown"
            stage1RebuildOk = false
    var stage1RebuildOkText: str = "0"
    if stage1RebuildOk:
        stage1RebuildOkText = "1"
    var fallbackUsedText: str = fallbackUsedCount > 0 ? "1" : "0"
    var strictRebuildOkText: str = "0"
    if !strictRebuild || strictRebuildOkCount == iters:
        strictRebuildOkText = "1"
    if !tooling_strNonEmpty(stage0DriverKindSummary):
        stage0DriverKindSummary = "unknown"
    let report: str =
        "host=" + hostTag + "\n" +
        "iters=" + intToStr(iters) + "\n" +
        "compile_stage1=" + compileStage1TextBase + "\n" +
        "stage1_compile_mode=" + stage1CompileModeSummary + "\n" +
        "stage1_status=" + stage1StatusSummary + "\n" +
        "stage1_rebuild_ok=" + stage1RebuildOkText + "\n" +
        "stage0_driver_kind=" + stage0DriverKindSummary + "\n" +
        "fallback_used=" + fallbackUsedText + "\n" +
        "quarantine_cleaned=" + intToStr(quarantineCleanedTotal) + "\n" +
        "lock_wait_ms=" + intToStr(lockWaitMsMax) + "\n" +
        "strict_rebuild_ok=" + strictRebuildOkText + "\n" +
        "p95_ms=" + intToStr(p95Ms) + "\n" +
        "p99_ms=" + intToStr(p99Ms) + "\n" +
        "max_ms=" + intToStr(maxMs) + "\n" +
        "limit_p95_ms=" + intToStr(p95Limit) + "\n" +
        "limit_p99_ms=" + intToStr(p99Limit) + "\n" +
        "status=" + status + "\n"
    os.writeFile(reportPath, report)
    tooling_printOut("[selfhost_100ms_native] host=" + hostTag +
                     " p95=" + intToStr(p95Ms) + "ms p99=" + intToStr(p99Ms) +
                     "ms max=" + intToStr(maxMs) + "ms status=" + status +
                     " stage0_driver_kind=" + stage0DriverKindSummary +
                     " fallback_used=" + fallbackUsedText +
                     " stage1_compile_mode=" + stage1CompileModeSummary +
                     " stage1_status=" + stage1StatusSummary +
                     " stage1_rebuild_ok=" + stage1RebuildOkText +
                     " strict_rebuild_ok=" + strictRebuildOkText)
    let enforcePerfWithCompileStage1: bool = compileStage1 &&
                                            tooling_isTrue(os.getEnvDefault("SELFHOST_100MS_ENFORCE_WITH_COMPILE_STAGE1", "1"))
    let enforcePerfGate: bool = enforce && (!compileStage1 || enforcePerfWithCompileStage1)
    if !tooling_strEq(status, "ok") && enforcePerfGate:
        return 1
    if requireStage1Rebuild && !stage1RebuildOk:
        return 1
    return 0

fn tooling_printCompileUsage() =
    tooling_printOut("compile options:")
    tooling_printOut("  --in:<file.cheng>            source file path")
    tooling_printOut("  --out:<path>                 output executable path")
    tooling_printOut("  --name:<name-or-path>        output name (defaults under artifacts/chengc)")
    tooling_printOut("  --target:<triple>            backend target triple")
    tooling_printOut("  --stage0:<path>              explicit driver executable (release defaults to BACKEND_RELEASE_DRIVER)")
    tooling_printOut("  --linker:self|system         linker mode (default: auto; dev=self when supported)")
    tooling_printOut("  --release                    release build track")
    tooling_printOut("  --dev                        dev build track (default)")
    tooling_printOut("  --run                        run output after successful compile")
    tooling_printOut("  [positional input]           same as --in:<file.cheng>")

fn tooling_cmdCompileExe(root: str, inRaw: str, outRaw: str, nameRaw: str, targetRaw: str,
                         stage0Raw: str, linkerRaw: str, releaseBuild: bool, runAfter: bool): int32 =
    let inPath: str = tooling_pathAbsolute(root, inRaw)
    if !tooling_strNonEmpty(inPath) || !os.fileExists(inPath):
        tooling_printErr("cheng_tooling: compile input not found: " + inRaw)
        return 1
    var stage0: str = ""
    if releaseBuild:
        stage0 = tooling_releaseDriverForCompile(root, stage0Raw, targetRaw)
    else:
        stage0 = tooling_resolveStage0Driver(root, stage0Raw)
    if !tooling_strNonEmpty(stage0):
        if releaseBuild:
            tooling_printErr("cheng_tooling: release driver not found/build failed (set BACKEND_RELEASE_DRIVER or run build-release-driver)")
        else:
            tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    let stage0Exec: str = tooling_prepareStage0Exec(root, stage0, "compile")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: stage0 prepare failed")
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: stage0 preflight failed: " + stage0)
        return 1
    var target: str = tooling_normalizeTargetAlias(root, targetRaw)
    if !tooling_strNonEmpty(target):
        target = "auto"
    var linker: str = strutil.toLowerAscii(strutil.strip(linkerRaw))
    if !tooling_strNonEmpty(linker) || tooling_strEq(linker, "auto"):
        if releaseBuild:
            linker = "system"
        elif tooling_targetSupportsSelfLinker(target):
            linker = "self"
        else:
            linker = "system"
    if !tooling_strEq(linker, "system") && !tooling_strEq(linker, "self"):
        tooling_printErr("cheng_tooling: invalid --linker (expected self|system): " + linker)
        return 1
    let outPath: str = tooling_defaultCompileOut(root, inPath, outRaw, nameRaw)
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    var buildTrack: str = releaseBuild ? "release" : "dev"
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", buildTrack)
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", linker)
    if releaseBuild:
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
        cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "3")
        let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
        let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
        if tooling_strNonEmpty(releaseCflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", releaseCflagsRaw)
        if tooling_strNonEmpty(releaseLdflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", releaseLdflagsRaw)
    else:
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "outline")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "ws")
        cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", inPath)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    if tooling_strEq(linker, "self"):
        var runtimeObj: str = tooling_runtimeObjPath(root, target)
        if !os.fileExists(runtimeObj):
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        if !os.fileExists(runtimeObj):
            tooling_printErr("cheng_tooling: missing runtime object for self-link: " + runtimeObj)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
    else:
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_shellQuote(stage0Exec)
    cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_COMPILE_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    cmd = tooling_wrapStage0Lock(root, cmd, "compile_exe")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    let rc: int32 = os.execCmdResultExitCode(res)
    if rc != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: compile failed rc=" + intToStr(rc) +
                         " kind=" + tooling_exitKind(rc) + " stage0=" + stage0)
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    if os.execCmdResultExitCode(chmodRes) != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: chmod failed: " + outPath)
        return 1
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    tooling_printOut("compile_out=" + outPath)
    tooling_printOut("compile_driver=" + stage0)
    if releaseBuild:
        tooling_printOut("compile_driver_track=release_driver")
    else:
        tooling_printOut("compile_driver_track=dev_driver")
    tooling_printOut("compile_target=" + target)
    tooling_printOut("compile_linker=" + linker)
    tooling_printOut("compile_track=" + buildTrack)
    tooling_printOut("compile_profile=" + (releaseBuild ? "release_system_link_independent_driver" : "dev_fast_mem_exe"))
    if runAfter:
        let runRes: os.ExecCmdResult = tooling_exec(root, tooling_shellQuote(outPath))
        tooling_printExecOutput(runRes)
        return os.execCmdResultExitCode(runRes)
    return 0

fn tooling_cmdCompileFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var inPath: str = ""
    var outPath: str = ""
    var outName: str = ""
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var linker: str = os.getEnvDefault("BACKEND_LINKER", "auto")
    var releaseBuild: bool = tooling_isTrue(os.getEnvDefault("CHENGC_RELEASE", "0"))
    var runAfter: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printCompileUsage()
            return 0
        if strutil.startsWith(arg, "--in:"):
            inPath = strings.dropPrefix(arg, "--in:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outName = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--linker:"):
            linker = strings.dropPrefix(arg, "--linker:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--release"):
            releaseBuild = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--dev"):
            releaseBuild = false
            i = i + 1
            continue
        if tooling_strEq(arg, "--run") || tooling_strEq(arg, "--run:host") || tooling_strEq(arg, "--run:file"):
            runAfter = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--emit:"):
            let emit: str = strings.dropPrefix(arg, "--emit:")
            if !tooling_strEq(emit, "exe"):
                tooling_printErr("cheng_tooling: compile only supports --emit:exe")
                return 1
            i = i + 1
            continue
        if strutil.startsWith(arg, "--frontend:"):
            let frontend: str = strings.dropPrefix(arg, "--frontend:")
            if !tooling_strEq(frontend, "stage1"):
                tooling_printErr("cheng_tooling: compile only supports --frontend:stage1")
                return 1
            i = i + 1
            continue
        if tooling_strEq(arg, "--orc") || strutil.startsWith(arg, "--mm:") ||
           tooling_strEq(arg, "--multi") || strutil.startsWith(arg, "--jobs:"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "--manifest:") || strutil.startsWith(arg, "--lock:") ||
           strutil.startsWith(arg, "--registry:") || strutil.startsWith(arg, "--package:") ||
           strutil.startsWith(arg, "--channel:") || strutil.startsWith(arg, "--lock-format:") ||
           strutil.startsWith(arg, "--meta-out:") || strutil.startsWith(arg, "--buildmeta:") ||
           strutil.startsWith(arg, "--pkg-cache:") || strutil.startsWith(arg, "--ledger:") ||
           strutil.startsWith(arg, "--source-listen:") || strutil.startsWith(arg, "--source-peer:") ||
           strutil.startsWith(arg, "--pkg-roots:") || tooling_strEq(arg, "--skip-pkg") ||
           tooling_strEq(arg, "--verify"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "-"):
            tooling_printErr("cheng_tooling: unknown compile arg: " + arg)
            return 1
        if !tooling_strNonEmpty(inPath):
            inPath = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unexpected positional arg: " + arg)
        return 1
    if !tooling_strNonEmpty(inPath):
        tooling_printErr("cheng_tooling: compile requires input file (use --in:<file.cheng>)")
        tooling_printCompileUsage()
        return 1
    return tooling_cmdCompileExe(root, inPath, outPath, outName, target, stage0, linker, releaseBuild, runAfter)

fn tooling_printBootstrapPureUsage() =
    tooling_printOut("bootstrap-pure options:")
    tooling_printOut("  --seed:<path>                stage0 backend driver path")
    tooling_printOut("  --stage0:<path>              alias of --seed")
    tooling_printOut("  --compile-stage1             rebuild stage1 before stage2 alias copy")
    tooling_printOut("  --no-compile-stage1          default mode, stage1 aliases stage0")
    tooling_printOut("  --out-dir:<path>             bootstrap output directory")
    tooling_printOut("  --timing-out:<path>          timing tsv output path")
    tooling_printOut("  --fullspec                   reserved (not available in native mode)")

fn tooling_cmdBootstrapPureFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "0"))
    var outDir: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_OUT_DIR", "")
    var timingOut: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMING_OUT", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var fullspec: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printBootstrapPureUsage()
            return 0
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if tooling_strEq(arg, "--fullspec"):
            fullspec = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--seed:"):
            stage0 = strings.dropPrefix(arg, "--seed:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--timing-out:"):
            timingOut = strings.dropPrefix(arg, "--timing-out:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown bootstrap-pure arg: " + arg)
        return 1
    if fullspec:
        tooling_printErr("cheng_tooling: --fullspec is not available in native bootstrap mode")
        tooling_printErr("cheng_tooling: run `cheng_tooling verify_fullchain_bootstrap` separately")
        return 1
    let res: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, outDir, timingOut, stage0)
    if res == nil || !res.ok:
        var msg: str = "unknown failure"
        if res != nil:
            msg = res.message
        tooling_printErr("cheng_tooling: bootstrap-pure failed: " + msg)
        return 1
    tooling_printOut("bootstrap_pure_stage1=" + res.stage1Path)
    tooling_printOut("bootstrap_pure_stage2=" + res.stage2Path)
    tooling_printOut("bootstrap_pure_stage1_status=" + res.stage1Status)
    tooling_printOut("bootstrap_pure_stage1_compile_mode=" + res.stage1CompileMode)
    var bootstrapStage1RebuildOkText: str = "0"
    if res.stage1RebuildOk:
        bootstrapStage1RebuildOkText = "1"
    tooling_printOut("bootstrap_pure_stage1_rebuild_ok=" + bootstrapStage1RebuildOkText)
    tooling_printOut("bootstrap_pure_total_ms=" + intToStr(int32(res.totalMs)))
    if tooling_isTrue(os.getEnvDefault("BOOTSTRAP_UPDATE_SEED", "0")):
        let seedOut: str = tooling_pathAbsolute(root, "artifacts/backend_seed/cheng.stage2")
        if !tooling_copyExecutable(root, res.stage2Path, seedOut):
            tooling_printErr("cheng_tooling: bootstrap-pure seed update failed: " + seedOut)
            return 1
        tooling_printOut("bootstrap_pure_seed_updated=" + seedOut)
    return 0

fn tooling_cmdDriverPathFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("driver-path options:")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            return 0
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown driver-path arg: " + arg)
        return 1
    return tooling_cmdDriverPath(root, stage0)

fn tooling_cmdBuildBackendDriverFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var outPath: str = os.getEnvDefault("BACKEND_LOCAL_DRIVER_REL", "artifacts/backend_driver/cheng")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var requireRebuild: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REQUIRE_REBUILD", "0"))
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("build-backend-driver options:")
            tooling_printOut("  --out:<path>                 output path")
            tooling_printOut("  --name:<path>                legacy alias of --out")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            tooling_printOut("  --target:<triple>            explicit backend target")
            tooling_printOut("  --require-rebuild            fail if stage0 reuse happens")
            tooling_printOut("  --require-rebuild:0|1        explicit require-rebuild toggle")
            tooling_printOut("  --full-rebuild[[:0|1]]       compatibility no-op (build-backend-driver is full-only)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_LINKER=self|system (default self)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_AUTO_CLEAN_HISTORY=1|0 (default 1)")
            tooling_printOut("  env: BUILD_DRIVER_STRICT_NATIVE=1|0 (default 1)")
            tooling_printOut("  env: BUILD_DRIVER_ALLOW_FALLBACK=1|0 (default 0)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_DELEGATE_ON_SANITY_FAIL=1|0 (default 0; emergency only)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE=1|0 (default 1)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_STAGE0=<path> (optional override)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_REBUILD_TIMEOUT=60 (full-only)")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outPath = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--require-rebuild"):
            requireRebuild = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--require-rebuild:"):
            requireRebuild = tooling_isTrue(strings.dropPrefix(arg, "--require-rebuild:"))
            i = i + 1
            continue
        if tooling_strEq(arg, "--full-rebuild"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "--full-rebuild:"):
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown build-backend-driver arg: " + arg)
        return 1
    return tooling_cmdBuildBackendDriver(root, outPath, stage0, target, requireRebuild)

fn tooling_cmdBuildReleaseDriverFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var outPath: str = tooling_releaseDriverPath(root)
    var stage0: str = os.getEnvDefault("BACKEND_RELEASE_DRIVER_STAGE0", "")
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("build-release-driver options:")
            tooling_printOut("  --out:<path>                 output path (default BACKEND_RELEASE_DRIVER or artifacts/backend_release_driver/cheng)")
            tooling_printOut("  --name:<path>                legacy alias of --out")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            tooling_printOut("  --target:<triple>            explicit backend target")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER=<path>          release driver location")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER_STAGE0=<path>   build stage0 override")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER_TIMEOUT=60      compile timeout")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outPath = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown build-release-driver arg: " + arg)
        return 1
    return tooling_buildReleaseDriver(root, outPath, stage0, target)

fn tooling_cmdSelfhostBootstrapFastHostFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "1"))
    var outDir: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_OUT_DIR", "")
    var timingOut: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMING_OUT", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("selfhost-bootstrap-fast-host options:")
            tooling_printOut("  --compile-stage1|--no-compile-stage1")
            tooling_printOut("  --out-dir:<path>")
            tooling_printOut("  --timing-out:<path>")
            tooling_printOut("  --stage0:<path>")
            tooling_printOut("  env: SELFHOST_STAGE1_FULL_REBUILD=1|0 (strict default 1)")
            tooling_printOut("  env: SELFHOST_STRICT_REBUILD=1|0 (default 1)")
            return 0
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--timing-out:"):
            timingOut = strings.dropPrefix(arg, "--timing-out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown selfhost-bootstrap-fast-host arg: " + arg)
        return 1
    return tooling_cmdSelfhostBootstrapFastHost(root, compileStage1, outDir, timingOut, stage0)

fn tooling_cmdSelfhost100msHostFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var hostOnly: str = os.getEnvDefault("SELFHOST_100MS_HOST_ONLY", "darwin_arm64")
    var itersRaw: str = os.getEnvDefault("SELFHOST_100MS_ITERS", "5")
    var p95Raw: str = os.getEnvDefault("SELFHOST_100MS_P95_MS", "100")
    var p99Raw: str = os.getEnvDefault("SELFHOST_100MS_P99_MS", "120")
    var enforceRaw: str = os.getEnvDefault("SELFHOST_100MS_ENFORCE_ON_HOST", "1")
    var reportRaw: str = os.getEnvDefault("SELFHOST_100MS_REPORT", "artifacts/backend_selfhost_100ms_host/report.tsv")
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "1"))
    var outDir: str = os.getEnvDefault("SELFHOST_100MS_OUT_DIR", "artifacts/backend_selfhost_100ms_host")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("selfhost-100ms-host options:")
            tooling_printOut("  --iters:<N> --p95-ms:<ms> --p99-ms:<ms>")
            tooling_printOut("  --host-only:<tag> --report:<path> --enforce:0|1")
            tooling_printOut("  --compile-stage1|--no-compile-stage1 --out-dir:<path> --stage0:<path>")
            tooling_printOut("  env: SELFHOST_STAGE1_FULL_REBUILD=1|0 (strict default 1)")
            tooling_printOut("       SELFHOST_STRICT_REBUILD=1|0 (default 1)")
            tooling_printOut("       SELFHOST_100MS_ENFORCE_WITH_COMPILE_STAGE1=1|0 (default 1)")
            return 0
        if strutil.startsWith(arg, "--host-only:"):
            hostOnly = strings.dropPrefix(arg, "--host-only:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--iters:"):
            itersRaw = strings.dropPrefix(arg, "--iters:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--p95-ms:"):
            p95Raw = strings.dropPrefix(arg, "--p95-ms:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--p99-ms:"):
            p99Raw = strings.dropPrefix(arg, "--p99-ms:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--enforce:"):
            enforceRaw = strings.dropPrefix(arg, "--enforce:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--report:"):
            reportRaw = strings.dropPrefix(arg, "--report:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown selfhost-100ms-host arg: " + arg)
        return 1
    return tooling_cmdSelfhost100msHost(root, hostOnly, itersRaw, p95Raw, p99Raw, enforceRaw, reportRaw,
                                        compileStage1, outDir, stage0)

fn tooling_cmdSyncGlobalDeprecated(): int32 =
    tooling_printErr("cheng_tooling: sync-global removed; use `build-global --out:artifacts/tooling_cmd/cheng_tooling`")
    return 2

fn tooling_normalizeScriptId(rawName: str): str =
    var name: str = strutil.strip(rawName)
    if !tooling_strNonEmpty(name):
        return ""
    if strutil.startsWith(name, "src/tooling/"):
        name = strings.dropPrefix(name, "src/tooling/")
    name = tooling_stripShSuffix(name)
    if !tooling_isSafeScriptName(name):
        return ""
    return name

fn tooling_selectorContains(selector: str, id: str): bool =
    if !tooling_strNonEmpty(selector) || !tooling_strNonEmpty(id):
        return false
    return strutil.contains(selector, "," + id + ",")

fn tooling_selectorAppend(selector: str, id: str): str =
    if !tooling_strNonEmpty(id):
        return selector
    let token: str = "," + id + ","
    if strutil.contains(selector, token):
        return selector
    return selector + token

fn tooling_normalizeLinkMode(raw: str): str =
    let text: str = strutil.toLowerAscii(strutil.strip(raw))
    if tooling_strEq(text, "symlink") || tooling_strEq(text, "hardlink") || tooling_strEq(text, "copy"):
        return text
    return ""

fn tooling_idsContains(ids: str[], id: str): bool =
    for i in 0..<ids.len:
        if tooling_strEq(ids[i], id):
            return true
    return false

fn tooling_installLinks(root: str, binPathRaw: str, dirRaw: str, manifestRaw: str, force: bool, onlySelector: str, excludeSelector: str, modeRaw: str): int32 =
    let outDir: str = tooling_pathAbsolute(root, dirRaw)
    if !tooling_strNonEmpty(outDir):
        tooling_printErr("cheng_tooling: install requires --dir:<path>")
        return 1
    let binPath: str = tooling_pathAbsolute(root, binPathRaw)
    if !tooling_strNonEmpty(binPath):
        tooling_printErr("cheng_tooling: install requires --bin:<path> (or runnable absolute program name)")
        return 1
    if !tooling_pathExists(binPath):
        tooling_printErr("cheng_tooling: install binary not found: " + binPath)
        return 1
    let mode: str = tooling_normalizeLinkMode(modeRaw)
    if !tooling_strNonEmpty(mode):
        tooling_printErr("cheng_tooling: invalid --mode (expected symlink|hardlink|copy): " + modeRaw)
        return 1
    if !tooling_mkdirP(root, outDir):
        tooling_printErr("cheng_tooling: failed to create install dir: " + outDir)
        return 1

    var ids: str[] = tooling_collectScripts(root)
    if ids.len == 0:
        tooling_printErr("cheng_tooling: no scripts found under src/tooling")
        return 1
    if !tooling_isSafeScriptName("cheng_tooling"):
        return 1
    if !tooling_idsContains(ids, "cheng_tooling"):
        add(ids, "cheng_tooling")

    var manifest: str = "name\tlink\n"
    var selectedCount: int32 = 0
    var failCount: int32 = 0
    for i in 0..<ids.len:
        let name: str = ids[i]
        if tooling_strNonEmpty(onlySelector) && !tooling_selectorContains(onlySelector, name):
            continue
        if tooling_selectorContains(excludeSelector, name):
            continue
        selectedCount = selectedCount + 1
        let linkPath: str = os.joinPath(outDir, name)
        if !force && tooling_pathExists(linkPath):
            manifest = manifest + name + "\t" + linkPath + "\n"
            continue
        var cmd: str = ""
        if tooling_strEq(mode, "copy"):
            if force:
                cmd = "cp -f " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "cp " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        elif tooling_strEq(mode, "hardlink"):
            if force:
                cmd = "ln -f " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "ln " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        else:
            if force:
                cmd = "ln -sf " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "ln -s " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        let result: os.ExecCmdResult = tooling_exec(root, cmd)
        let rc: int32 = os.execCmdResultExitCode(result)
        if rc == 0:
            manifest = manifest + name + "\t" + linkPath + "\n"
            continue
        failCount = failCount + 1
        tooling_printErr("cheng_tooling: link failed: " + name + " -> " + linkPath)
        tooling_printExecOutput(result)
    if selectedCount <= 0:
        tooling_printErr("cheng_tooling: install selection is empty (adjust --only/--exclude)")
        return 1
    if tooling_strNonEmpty(manifestRaw):
        let manifestPath: str = tooling_pathAbsolute(root, manifestRaw)
        if tooling_strNonEmpty(manifestPath):
            os.writeFile(manifestPath, manifest)
            tooling_printOut("install_manifest=" + manifestPath)
    tooling_printOut("install_dir=" + outDir)
    tooling_printOut("install_bin=" + binPath)
    tooling_printOut("install_mode=" + mode)
    if failCount > 0:
        return 1
    return 0

fn tooling_bundle(root: str, outDirRaw: str, linkerRaw: str, driverRaw: str, profileSelectorRaw: str, modeRaw: str, force: bool): int32 =
    var profileSelector: str = profileSelectorRaw
    if !tooling_strNonEmpty(profileSelector):
        profileSelector = tooling_selectorAppend(profileSelector, "full")
    let mode: str = tooling_normalizeLinkMode(modeRaw)
    if !tooling_strNonEmpty(mode):
        tooling_printErr("cheng_tooling: invalid bundle --mode (expected symlink|hardlink|copy): " + modeRaw)
        return 1
    let outDir: str = tooling_pathAbsolute(root, outDirRaw)
    if !tooling_strNonEmpty(outDir):
        tooling_printErr("cheng_tooling: bundle requires --out-dir:<path>")
        return 1
    if !tooling_mkdirP(root, outDir):
        tooling_printErr("cheng_tooling: failed to create bundle out dir: " + outDir)
        return 1
    if !tooling_selectorContains(profileSelector, "full"):
        tooling_printErr("cheng_tooling: bundle profile set is empty (allowed: full)")
        return 1
    let profileDir: str = os.joinPath(outDir, "full")
    let binPath: str = os.joinPath(profileDir, "cheng_tooling")
    let linksDir: str = os.joinPath(profileDir, "bin")
    let manifestPath: str = os.joinPath(profileDir, "manifest.tsv")
    let buildRc: int32 = tooling_buildGlobal(root, binPath, linkerRaw, driverRaw)
    if buildRc != 0:
        return buildRc
    let installRc: int32 = tooling_installLinks(root, binPath, linksDir, manifestPath, force, "", "", mode)
    if installRc != 0:
        return installRc
    tooling_printOut("bundle_profile=full")
    tooling_printOut("bundle_profile_bin=" + binPath)
    tooling_printOut("bundle_profile_links=" + linksDir)
    tooling_printOut("bundle_profile_manifest=" + manifestPath)
    return 0

fn tooling_resolveBuildDriver(root: str, driverRaw: str): str =
    let explicitRaw: str = strutil.strip(driverRaw)
    if tooling_strNonEmpty(explicitRaw):
        return tooling_resolveStage0DriverStrict(root, explicitRaw)
    return tooling_resolveStage0DriverStrict(root, "")

fn tooling_buildGlobal(root: str, outRaw: str, linkerRaw: str, driverRaw: str): int32 =
    let src: str = os.joinPath(root, "src/tooling/cheng_tooling.cheng")
    if !os.fileExists(src):
        tooling_printErr("cheng_tooling: source not found: " + src)
        return 1
    let outPath: str = tooling_pathAbsolute(root, outRaw)
    if !tooling_strNonEmpty(outPath):
        tooling_printErr("cheng_tooling: build-global requires --out:<path>")
        return 1
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    let linker: str = strutil.strip(linkerRaw)
    if !tooling_strEq(linker, "self") && !tooling_strEq(linker, "system"):
        tooling_printErr("cheng_tooling: invalid --linker (expected self|system): " + linker)
        return 1
    let driverPath: str = tooling_resolveBuildDriver(root, driverRaw)
    if !tooling_strNonEmpty(driverPath):
        if tooling_strNonEmpty(driverRaw):
            tooling_printErr("cheng_tooling: --driver not found: " + driverRaw)
        else:
            tooling_printErr("cheng_tooling: failed to resolve build driver (set --driver:<path>)")
        return 1
    let stage0Exec: str = tooling_prepareStage0Exec(root, driverPath, "build_global")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: build-global stage0 prepare failed: " + driverPath)
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(driverPath, stage0Exec)
        tooling_printErr("cheng_tooling: build-global stage0 preflight failed: " + driverPath)
        return 1
    let inheritedTarget: str = strutil.strip(os.getEnvDefault("BACKEND_TARGET", ""))
    var target: str = inheritedTarget
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        target = "auto"
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_ENABLE_CSTRING_LOWERING", "1")
    cmd = cmd + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS", "0")
    cmd = cmd + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS_STRICT", "0")
    cmd = cmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
    cmd = cmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "release")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", linker)
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "3")
    let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
    let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
    if tooling_strNonEmpty(releaseCflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", releaseCflagsRaw)
    if tooling_strNonEmpty(releaseLdflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", releaseLdflagsRaw)
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("ABI", "v2_noptr")
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", src)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    if tooling_strEq(linker, "self"):
        var runtimeObj: str = tooling_runtimeObjPath(root, target)
        if !os.fileExists(runtimeObj):
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        if !os.fileExists(runtimeObj):
            tooling_cleanupStage0Exec(driverPath, stage0Exec)
            tooling_printErr("cheng_tooling: build-global missing runtime object for self-link: " + runtimeObj)
            return 1
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
    else:
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_shellQuote(stage0Exec)
    cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_BUILD_GLOBAL_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    cmd = tooling_wrapStage0Lock(root, cmd, "build_global")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    tooling_printOut("build_global_driver=" + driverPath)
    tooling_printOut("build_global_driver_exec=" + stage0Exec)
    tooling_printOut("build_global_linker=" + linker)
    tooling_printOut("build_global_out=" + outPath)
    let result: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(result)
    let rc: int32 = os.execCmdResultExitCode(result)
    tooling_cleanupStage0Exec(driverPath, stage0Exec)
    if rc != 0:
        return rc
    return 0

fn tooling_cmdBuildBackendBaselines(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"; " +
        "\"$tool\" build_backend_rawptr_contract; " +
        "\"$tool\" build_backend_mem_contract; " +
        "\"$tool\" build_backend_dod_contract; " +
        "\"$tool\" build_backend_native_contract; " +
        "\"$tool\" build_backend_profile_schema; " +
        "\"$tool\" build_backend_profile_baseline; " +
        "echo \"build_backend_baselines ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_printUsage() =
    tooling_printOut("usage: cheng_tooling <command> [args]")
    tooling_printOut("")
    tooling_printOut("commands:")
    tooling_printOut("  driver-path [--stage0:<path>]")
    tooling_printOut("      resolve stable stage0 backend driver path (zero-script)")
    tooling_printOut("  build-backend-driver [--out:<path>] [--stage0:<path>] [--target:<triple>] [--require-rebuild]")
    tooling_printOut("      build artifacts/backend_driver/cheng via native fast host path (zero-script)")
    tooling_printOut("  build-release-driver [--out:<path>] [--stage0:<path>] [--target:<triple>]")
    tooling_printOut("      build independent release driver (UIR + system-link) at artifacts/backend_release_driver/cheng")
    tooling_printOut("  cleanup-backend-driver-history [--dry-run]")
    tooling_printOut("      remove historical artifacts/backend_driver/cheng* variants, keep canonical driver")
    tooling_printOut("  build-backend-baselines")
    tooling_printOut("      rebuild all backend contract/profile baselines in one call")
    tooling_printOut("  selfhost-bootstrap-fast-host [--compile-stage1|--no-compile-stage1] [--out-dir:<path>] [--timing-out:<path>] [--stage0:<path>]")
    tooling_printOut("      host-only fast selfhost bootstrap without shell script orchestration")
    tooling_printOut("  selfhost-100ms-host [--iters:<N>] [--p95-ms:<ms>] [--p99-ms:<ms>] [--host-only:<tag>] [--report:<path>] [--enforce:0|1]")
    tooling_printOut("      host-only 100ms gate using native selfhost bootstrap path")
    tooling_printOut("  verify_backend_opt2_impl_surface")
    tooling_printOut("      verify opt2 implementation surface (no placeholder return false + NJVL/SSU defaults)")
    tooling_printOut("  verify_backend_rawptr_migration")
    tooling_printOut("      verify raw-pointer migration gate is wired via native subcommands")
    tooling_printOut("  compile --in:<file.cheng> [--out:<path>|--name:<name>] [--target:<triple>] [--stage0:<path>] [--linker:self|system] [--release] [--run]")
    tooling_printOut("      zero-script compiler entrypoint (emit=exe, frontend=stage1)")
    tooling_printOut("  cheng <file.cheng> [compile args]")
    tooling_printOut("      alias of compile (single-entry naming)")
    tooling_printOut("  bootstrap-pure [--seed:<path>] [--compile-stage1|--no-compile-stage1]")
    tooling_printOut("      zero-script pure selfhost bootstrap path")
    tooling_printOut("  bootstrap")
    tooling_printOut("      alias of bootstrap-pure")
    tooling_printOut("  list")
    tooling_printOut("      list all runnable tooling command IDs embedded in cheng_tooling")
    tooling_printOut("  embedded-ids")
    tooling_printOut("      alias of list (internal/native embed introspection)")
    tooling_printOut("  embedded-text --id:<script> | embedded-text <script>")
    tooling_printOut("      print embedded script payload text (internal/native embed introspection)")
    tooling_printOut("  embedded-map-rewrite [--out:<path>] [map_path] [out_path]")
    tooling_printOut("      rewrite embedded map as canonical Cheng source (native, no python)")
    tooling_printOut("  run <script> [args...]")
    tooling_printOut("      run script by name, for example: run backend_prod_closure --help")
    tooling_printOut("  install --dir:<path> [--bin:<path>] [--manifest:<path>] [--mode:symlink|hardlink|copy] [--force] [--only:<script>] [--exclude:<script>]")
    tooling_printOut("      install multicall links (one global binary drives all tooling script IDs)")
    tooling_printOut("  build-global [--out:<path>] [--linker:self|system] [--driver:<path>]")
    tooling_printOut("      build cheng_tooling as global native binary (default linker=system)")
    tooling_printOut("  bundle [--out-dir:<path>] [--profile:full]... [--mode:symlink|hardlink|copy] [--linker:self|system] [--driver:<path>] [--force]")
    tooling_printOut("      build and install one or more global binaries by profile")
    tooling_printOut("  <script> [args...]")
    tooling_printOut("      shorthand for `run <script> [args...]`")
    tooling_printOut("")
    tooling_printOut("notes:")
    tooling_printOut("  - script can be `name` (or legacy `name.sh`, normalized to `name`).")
    tooling_printOut("  - all args after script are passed through as-is.")
    tooling_printOut("  - install filter flags are repeatable; --only narrows selection and --exclude removes from it.")
    tooling_printOut("  - multicall mode: if argv0 is a script ID (for example backend_prod_closure),")
    tooling_printOut("    cheng_tooling will dispatch to the embedded script payload for <id>.")
    tooling_printOut("  - recommended global install:")
    tooling_printOut("      cheng_tooling build-global --out:artifacts/tooling_cmd/cheng_tooling --linker:system")
    tooling_printOut("      artifacts/tooling_cmd/cheng_tooling install --dir:artifacts/tooling_cmd/bin --bin:artifacts/tooling_cmd/cheng_tooling --force")
    tooling_printOut("  - bundle profiles:")
    tooling_printOut("      full: all embedded tooling command IDs")

fn tooling_list(root: str): int32 =
    let out: str[] = tooling_collectScripts(root)
    if out.len == 0:
        tooling_printErr("cheng_tooling: no embedded tooling scripts registered")
        return 1
    for i in 0..<out.len:
        tooling_printOut(out[i])
    return 0

fn tooling_embeddedTextCommand(root: str, argStart: int32, count: int32): int32 =
    var scriptId: str = ""
    var i: int32 = argStart
    for _ in argStart..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("usage: cheng_tooling embedded-text --id:<script-id>")
            tooling_printOut("   or: cheng_tooling embedded-text <script-id>")
            return 0
        if strutil.startsWith(arg, "--id:"):
            scriptId = strings.dropPrefix(arg, "--id:")
            i = i + 1
            continue
        if !tooling_strNonEmpty(scriptId):
            scriptId = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown embedded-text arg: " + arg)
        return 1
    let normalizedId: str = tooling_normalizeScriptId(scriptId)
    if !tooling_strNonEmpty(normalizedId):
        tooling_printErr("cheng_tooling: embedded-text requires --id:<script-id>")
        return 1
    if tooling_strEq(normalizedId, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    let scriptText: str = tooling_embeddedScriptText(root, normalizedId)
    if !tooling_strNonEmpty(scriptText):
        tooling_printErr("cheng_tooling: embedded-text script not found: " + normalizedId)
        return 1
    os.write(os.get_stdout(), scriptText)
    return 0

fn tooling_embeddedMapRewriteCommand(root: str, argStart: int32, count: int32): int32 =
    var outPath: str = os.joinPath(root, "src/tooling/cheng_tooling_embedded_inline.cheng")
    var outFromFlag: str = ""
    var positionalA: str = ""
    var positionalB: str = ""
    var i: int32 = argStart
    for _ in argStart..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("usage: cheng_tooling embedded-map-rewrite [--out:<path>] [map_path] [out_path]")
            tooling_printOut("   or: cheng_tooling rewrite-map [map_path] [out_path]")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outFromFlag = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "-"):
            tooling_printErr("cheng_tooling: unknown embedded-map-rewrite arg: " + arg)
            return 1
        if !tooling_strNonEmpty(positionalA):
            positionalA = arg
            i = i + 1
            continue
        if !tooling_strNonEmpty(positionalB):
            positionalB = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: too many positional args for embedded-map-rewrite")
        return 1
    if tooling_strNonEmpty(outFromFlag):
        outPath = tooling_pathAbsolute(root, outFromFlag)
    elif tooling_strNonEmpty(positionalB):
        # Compatibility with old `rewrite-map <map_path> <out_path>` CLI.
        outPath = tooling_pathAbsolute(root, positionalB)
    elif tooling_strNonEmpty(positionalA):
        # Compatibility with old `rewrite-map <map_path>` in-place rewrite.
        outPath = tooling_pathAbsolute(root, positionalA)
    else:
        outPath = tooling_pathAbsolute(root, outPath)
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    let rendered: str = tooling_renderEmbeddedMapText(root)
    os.writeFile(outPath, rendered)
    let renderedIds: str[] = tooling_collectScripts(root)
    tooling_printOut("embedded_map_rewrite_out=" + outPath)
    tooling_printOut("embedded_map_rewrite_count=" + intToStr(renderedIds.len))
    return 0

fn tooling_cmdVerifyBackendOpt2ImplSurface(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_opt2_impl_surface] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_opt2_impl_surface\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "opt2_file=\"src/backend/uir/uir_internal/uir_core_opt2.cheng\"; " +
        "ssu_file=\"src/backend/uir/uir_internal/uir_core_ssu.cheng\"; " +
        "noalias_file=\"src/backend/uir/uir_noalias_pass.cheng\"; " +
        "placeholder_hits=\"$out_dir/opt2.placeholder_hits.txt\"; " +
        "report=\"$out_dir/verify_backend_opt2_impl_surface.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_opt2_impl_surface.snapshot.env\"; " +
        "status=\"ok\"; " +
        "rg -n -U -P \"(?s)^fn\\\\s+(uirCore(?:OptimizeModule|Func)[A-Za-z0-9_]+)\\\\([^\\\\n]*\\\\):\\\\s*bool\\\\s*=\\\\n\\\\s*return false\" \"$opt2_file\" >\"$placeholder_hits\" || true; " +
        "placeholder_count=0; " +
        "if [ -s \"$placeholder_hits\" ]; then " +
            "placeholder_count=\"$(wc -l <\"$placeholder_hits\" | tr -d '[:space:]')\"; " +
            "status=\"drift\"; " +
        "fi; " +
        "ssu_default_ok=1; " +
        "if ! rg -q 'UIR_SSU\", true' \"$ssu_file\"; then ssu_default_ok=0; status=\"drift\"; fi; " +
        "njvl_default_ok=1; " +
        "if ! rg -q 'UIR_NOALIAS_NJVL_LITE\", true' \"$noalias_file\"; then njvl_default_ok=0; status=\"drift\"; fi; " +
        "noalias_fields_ok=1; " +
        "for key in unknown_slot_clobbers unknown_global_clobbers kill_events; do " +
            "if ! rg -q \"$key\" \"$noalias_file\"; then noalias_fields_ok=0; status=\"drift\"; fi; " +
        "done; " +
        "{ " +
            "echo \"verify_backend_opt2_impl_surface report\"; " +
            "echo \"status=$status\"; " +
            "echo \"placeholder_hits=$placeholder_hits\"; " +
            "echo \"placeholder_count=$placeholder_count\"; " +
            "echo \"ssu_default_ok=$ssu_default_ok\"; " +
            "echo \"njvl_default_ok=$njvl_default_ok\"; " +
            "echo \"noalias_fields_ok=$noalias_fields_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_opt2_impl_surface_status=$status\"; " +
            "echo \"backend_opt2_impl_surface_placeholder_count=$placeholder_count\"; " +
            "echo \"backend_opt2_impl_surface_ssu_default_ok=$ssu_default_ok\"; " +
            "echo \"backend_opt2_impl_surface_njvl_default_ok=$njvl_default_ok\"; " +
            "echo \"backend_opt2_impl_surface_noalias_fields_ok=$noalias_fields_ok\"; " +
            "echo \"backend_opt2_impl_surface_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "if [ \"$status\" != \"ok\" ]; then " +
            "echo \"[verify_backend_opt2_impl_surface] drift detected\" >&2; " +
            "echo \"  report: $report\" >&2; " +
            "if [ -s \"$placeholder_hits\" ]; then " +
                "echo \"  placeholder functions (top):\" >&2; " +
                "sed -n '1,80p' \"$placeholder_hits\" >&2 || true; " +
            "fi; " +
            "exit 1; " +
        "fi; " +
        "echo \"verify_backend_opt2_impl_surface ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendNoaliasOpt(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_noalias_opt] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_noalias_opt\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_noalias_opt.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_noalias_opt.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.noalias'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for pat in 'fn uirRunNoAliasPrep\\(' 'unknown_slot_clobbers' 'unknown_global_clobbers' 'kill_events' 'proof_backed_changes='; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_noalias_pass.cheng; then source_ok=0; fi; " +
        "done; " +
        "if ! rg -q 'UIR_NOALIAS_NJVL_LITE\", true' src/backend/uir/uir_noalias_pass.cheng; then source_ok=0; fi; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_noalias_opt] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_noalias_opt] backend driver missing noalias marker; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_noalias_mem2reg_load.cheng\"; " +
            "if [ ! -f \"$fixture\" ]; then fixture=\"tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\"; fi; " +
            "if [ -f \"$fixture\" ]; then " +
                "obj=\"$out_dir/noalias_probe.o\"; log=\"$out_dir/noalias_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=1 UIR_NOALIAS=1 UIR_NOALIAS_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$obj\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$obj\" ]; then " +
                    "echo \"[verify_backend_noalias_opt] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
                "if ! rg -q '^noalias_report' \"$log\"; then " +
                    "echo \"[verify_backend_noalias_opt] noalias_report missing in runtime probe\" >&2; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_noalias_opt_status=ok\"; " +
            "echo \"backend_noalias_opt_mode=$mode\"; " +
            "echo \"backend_noalias_opt_driver=$driver\"; " +
            "echo \"backend_noalias_opt_marker_ok=$marker_ok\"; " +
            "echo \"backend_noalias_opt_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_noalias_opt ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendEgraphCost(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_egraph_cost] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_egraph_cost\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_egraph_cost.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_egraph_cost.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.egraph'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for pat in 'uirEGraphGoalWeightSignature' 'uir_opt2\\.egraph' 'UIR_EGRAPH_REQUIRE_PROOF'; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_egraph_cost.cheng src/backend/uir/uir_opt.cheng; then source_ok=0; fi; " +
        "done; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_egraph_cost] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_egraph_cost] backend driver missing egraph marker; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_inline_dce.cheng\"; " +
            "if [ -f \"$fixture\" ]; then " +
                "obj=\"$out_dir/egraph_probe.o\"; log=\"$out_dir/egraph_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=1 UIR_NOALIAS=1 UIR_EGRAPH_ITERS=3 UIR_EGRAPH_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$obj\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$obj\" ]; then " +
                    "echo \"[verify_backend_egraph_cost] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_egraph_cost_status=ok\"; " +
            "echo \"backend_egraph_cost_mode=$mode\"; " +
            "echo \"backend_egraph_cost_driver=$driver\"; " +
            "echo \"backend_egraph_cost_marker_ok=$marker_ok\"; " +
            "echo \"backend_egraph_cost_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_egraph_cost ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendDodOptRegression(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_dod_opt_regression] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_dod_opt_regression\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_dod_opt_regression.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_dod_opt_regression.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.noalias|uir_opt2.egraph|p4_phase_v1'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for file in src/backend/uir/uir_noalias_pass.cheng src/backend/uir/uir_egraph_cost.cheng src/backend/uir/uir_opt.cheng src/backend/tooling/backend_driver.cheng; do " +
            "if [ ! -f \"$file\" ]; then source_ok=0; fi; " +
        "done; " +
        "for pat in 'uir_opt2\\.noalias' 'uir_opt2\\.egraph' 'single_ir_dual_phase' 'p4_phase_v1'; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_opt.cheng src/backend/tooling/backend_driver.cheng; then source_ok=0; fi; " +
        "done; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_dod_opt_regression] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_dod_opt_regression] backend driver missing opt2 markers; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\"; " +
            "if [ -f \"$fixture\" ]; then " +
                "obj=\"$out_dir/dod_opt_probe.o\"; log=\"$out_dir/dod_opt_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=1 UIR_NOALIAS=1 UIR_NOALIAS_REQUIRE_PROOF=1 UIR_EGRAPH_ITERS=3 UIR_EGRAPH_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$obj\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$obj\" ]; then " +
                    "echo \"[verify_backend_dod_opt_regression] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_dod_opt_regression_status=ok\"; " +
            "echo \"backend_dod_opt_regression_mode=$mode\"; " +
            "echo \"backend_dod_opt_regression_driver=$driver\"; " +
            "echo \"backend_dod_opt_regression_marker_ok=$marker_ok\"; " +
            "echo \"backend_dod_opt_regression_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_dod_opt_regression ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendNoptrExemptionScope(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_noptr_exemption_scope] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_noptr_exemption_scope\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "hits=\"$out_dir/noptr_exemption_hits.txt\"; " +
        "bad=\"$out_dir/noptr_exemption_bad.txt\"; " +
        "report=\"$out_dir/verify_backend_noptr_exemption_scope.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_noptr_exemption_scope.snapshot.env\"; " +
        "rm -f src/tooling/.tmp_backend_prod_closure.debug.sh src/tooling/.tmp_backend_prod_closure.debug.env || true; " +
        "rg -n -P --glob '*.cheng' --glob '*.sh' '^(?![[:space:]]*#).*STAGE1_NO_POINTERS_NON_C_ABI(_INTERNAL)?=0' src >\"$hits\" || true; " +
        ": >\"$bad\"; " +
        "while IFS= read -r line; do " +
            "[ \"$line\" != \"\" ] || continue; " +
            "file=\"${line%%:*}\"; " +
            "case \"$file\" in " +
                "src/tooling/cheng_tooling.cheng|src/tooling/cheng_tooling_embedded_inline.cheng|src/tooling/.tmp_*) " +
                    "continue ;; " +
            "esac; " +
            "printf '%s\\n' \"$line\" >>\"$bad\"; " +
        "done <\"$hits\"; " +
        "if [ -s \"$bad\" ]; then " +
            "echo \"[Error] no-pointer exemption found outside allowlist:\" >&2; " +
            "sed -n '1,200p' \"$bad\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "count=\"$(wc -l <\"$hits\" | tr -d '[:space:]')\"; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"hit_count=$count\"; " +
            "echo \"hits=$hits\"; " +
            "echo \"allowlist=src/tooling/cheng_tooling.cheng,src/tooling/cheng_tooling_embedded_inline.cheng,src/tooling/.tmp_*\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_noptr_exemption_scope_status=ok\"; " +
            "echo \"backend_noptr_exemption_scope_hit_count=$count\"; " +
            "echo \"backend_noptr_exemption_scope_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_noptr_exemption_scope ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendZeroScriptClosure(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_zero_script_closure] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_zero_script_closure\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "wrappers=\"$out_dir/shell_wrappers.txt\"; " +
        "inlines=\"$out_dir/inline_files.txt\"; " +
        "report=\"$out_dir/verify_backend_zero_script_closure.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_zero_script_closure.snapshot.env\"; " +
        "find src/tooling -type f -name '.tmp_*.sh' -delete 2>/dev/null || true; " +
        "find src/tooling -type f -name '*.sh' | LC_ALL=C sort >\"$wrappers\"; " +
        "if [ -s \"$wrappers\" ]; then " +
            "echo \"[verify_backend_zero_script_closure] unexpected shell wrappers under src/tooling:\" >&2; " +
            "sed -n '1,200p' \"$wrappers\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "find src/tooling -type f -name '*.inline' | LC_ALL=C sort >\"$inlines\"; " +
        "if [ -s \"$inlines\" ]; then " +
            "echo \"[verify_backend_zero_script_closure] unexpected inline files under src/tooling:\" >&2; " +
            "sed -n '1,200p' \"$inlines\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "if ! rg -q 'tooling_strEq\\(first, \"compile\"\\) \\|\\| tooling_strEq\\(first, \"cheng\"\\) \\|\\| tooling_strEq\\(first, \"chengc\"\\)' src/tooling/cheng_tooling.cheng; then " +
            "echo \"[verify_backend_zero_script_closure] missing native chengc route in cheng_tooling main dispatch\" >&2; " +
            "exit 1; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"shell_wrapper_count=0\"; " +
            "echo \"inline_count=0\"; " +
            "echo \"chengc_native_route=1\"; " +
            "echo \"wrappers=$wrappers\"; " +
            "echo \"inlines=$inlines\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_zero_script_closure_status=ok\"; " +
            "echo \"backend_zero_script_closure_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_zero_script_closure ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendRawptrMigration(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_rawptr_migration] rg is required\" >&2; exit 2; " +
        "fi; " +
        "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"; " +
        "out_dir=\"artifacts/backend_rawptr_migration\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_rawptr_migration.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_rawptr_migration.snapshot.env\"; " +
        "if [ ! -f docs/raw-pointer-safety.md ]; then " +
            "echo \"[verify_backend_rawptr_migration] missing doc: docs/raw-pointer-safety.md\" >&2; " +
            "exit 2; " +
        "fi; " +
        "if ! \"$tool\" list | rg -qx 'rawptr_migrate_ffi'; then " +
            "echo \"[verify_backend_rawptr_migration] missing rawptr_migrate_ffi native subcommand\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if ! \"$tool\" embedded-text --id:rawptr_migrate_ffi | rg -q '.'; then " +
            "echo \"[verify_backend_rawptr_migration] rawptr_migrate_ffi embedded payload missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"tool=$tool\"; " +
            "echo \"rawptr_migrate_ffi=available\"; " +
            "echo \"doc=docs/raw-pointer-safety.md\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_rawptr_migration_status=ok\"; " +
            "echo \"backend_rawptr_migration_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_rawptr_migration ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendEmitObjContract(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_emit_obj_contract] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_emit_obj_contract\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "emit_files=\"$out_dir/backend_emit_obj.files.txt\"; " +
        "missing_allow=\"$out_dir/backend_emit_obj.missing_allow.txt\"; " +
        "bad_allow=\"$out_dir/backend_emit_obj.bad_allow.txt\"; " +
        "report=\"$out_dir/backend_emit_obj_contract.report.txt\"; " +
        "rg -l --glob '*.cheng' \"BACKEND_EMIT=obj\" src/tooling >\"$emit_files\" || true; " +
        "if [ ! -s \"$emit_files\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] no BACKEND_EMIT=obj usage under src/tooling\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if rg -l --glob '*.sh' \"BACKEND_EMIT=obj\" src/tooling scripts >/dev/null 2>&1; then " +
            "echo \"[verify_backend_emit_obj_contract] shell wrappers must not carry BACKEND_EMIT=obj\" >&2; " +
            "rg -l --glob '*.sh' \"BACKEND_EMIT=obj\" src/tooling scripts | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        ": >\"$missing_allow\"; : >\"$bad_allow\"; " +
        "while IFS= read -r file; do " +
            "[ \"$file\" != \"\" ] || continue; " +
            "if ! rg -q \"BACKEND_INTERNAL_ALLOW_EMIT_OBJ\" \"$file\"; then " +
                "printf '%s\\n' \"$file\" >>\"$missing_allow\"; " +
            "fi; " +
            "if [ \"$file\" != \"src/tooling/cheng_tooling.cheng\" ] && " +
               "rg -q \"BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0\" \"$file\"; then " +
                "printf '%s\\n' \"$file\" >>\"$bad_allow\"; " +
            "fi; " +
        "done <\"$emit_files\"; " +
        "if [ -s \"$missing_allow\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] missing BACKEND_INTERNAL_ALLOW_EMIT_OBJ guard:\" >&2; " +
            "sed -n '1,200p' \"$missing_allow\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ -s \"$bad_allow\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] BACKEND_INTERNAL_ALLOW_EMIT_OBJ must not be forced to 0:\" >&2; " +
            "sed -n '1,200p' \"$bad_allow\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "emit_count=\"$(wc -l <\"$emit_files\" | tr -d ' ')\"; " +
        "{ " +
            "echo \"verify_backend_emit_obj_contract report\"; " +
            "echo \"status=ok\"; " +
            "echo \"emit_obj_file_count=$emit_count\"; " +
            "echo \"missing_allow_count=0\"; " +
            "echo \"bad_allow_count=0\"; " +
            "echo \"emit_files=$emit_files\"; " +
        "} >\"$report\"; " +
        "echo \"verify_backend_emit_obj_contract ok\"";
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_runScript(root: str, scriptPath: str, argStart: int32): int32 =
    var command: str = ""
    var shellBin: str = "sh"
    let scriptId: str = tooling_scriptIdFromResolvedPath(scriptPath)
    if tooling_strNonEmpty(scriptId):
        let scriptText: str = tooling_embeddedScriptText(root, scriptId)
        if !tooling_strNonEmpty(scriptText):
            tooling_printErr("cheng_tooling: missing embedded script payload: " + scriptId)
            return 1
        shellBin = tooling_scriptShellFromText(scriptText)
        let cacheDir: str = os.joinPath(root, "chengcache/embedded_scripts")
        if !tooling_mkdirP(root, cacheDir):
            tooling_printErr("cheng_tooling: failed to create embedded script cache: " + cacheDir)
            return 1
        let cachedScript: str = os.joinPath(cacheDir, scriptId + ".embedded.sh")
        os.writeFile(cachedScript, scriptText)
        let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(cachedScript))
        if os.execCmdResultExitCode(chmodRes) != 0:
            tooling_printErr("cheng_tooling: chmod failed for cached embedded script: " + cachedScript)
            tooling_printExecOutput(chmodRes)
            return 1
        let runnerExpr: str = "embedded_script=\"$1\"; shift; . \"$embedded_script\""
        command = tooling_shellQuote(shellBin) + " -c " + tooling_shellQuote(runnerExpr) +
                  " " + tooling_shellQuote(tooling_embeddedArgv0(root, scriptId)) +
                  " " + tooling_shellQuote(cachedScript)
    else:
        if !os.fileExists(scriptPath):
            tooling_printErr("cheng_tooling: script not found: " + scriptPath)
            return 1
        shellBin = tooling_scriptShell(root, scriptPath)
        command = tooling_shellQuote(shellBin) + " " + tooling_shellQuote(scriptPath)
    let count: int32 = tooling_paramCount()
    if argStart <= count:
        for i in argStart..count:
            command = command + " " + tooling_shellQuote(tooling_paramStr(i))
    let opts: uint64 = uint64(7)
    let result: os.ExecCmdResult = os.execCmdEx(command, opts, root)
    let output: str = os.execCmdResultOutput(result)
    if tooling_strNonEmpty(output):
        os.write(os.get_stdout(), output)
    return os.execCmdResultExitCode(result)

fn main(argc: int32, argv: str*): int32 =
    tooling_setCmdLine(argc, argv)
    let root: str = tooling_root()
    let selfName: str = tooling_programBaseName()
    let count: int32 = tooling_paramCount()
    if tooling_strEq(selfName, "cheng") || tooling_strEq(selfName, "chengc"):
        return tooling_cmdCompileFromArgs(root, 1, count)
    if tooling_strEq(selfName, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    if tooling_strEq(selfName, "bootstrap") || tooling_strEq(selfName, "bootstrap_pure") || tooling_strEq(selfName, "bootstrap-pure"):
        return tooling_cmdBootstrapPureFromArgs(root, 1, count)
    if tooling_strEq(selfName, "backend_driver_path") || tooling_strEq(selfName, "driver-path"):
        return tooling_cmdDriverPathFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_backend_driver") || tooling_strEq(selfName, "build-backend-driver"):
        return tooling_cmdBuildBackendDriverFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_release_driver") || tooling_strEq(selfName, "build-release-driver"):
        return tooling_cmdBuildReleaseDriverFromArgs(root, 1, count)
    if tooling_strEq(selfName, "cleanup_backend_driver_history") || tooling_strEq(selfName, "cleanup-backend-driver-history"):
        return tooling_cmdCleanupBackendDriverHistoryFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_backend_baselines") || tooling_strEq(selfName, "build-backend-baselines"):
        return tooling_cmdBuildBackendBaselines(root)
    if tooling_strEq(selfName, "sync_global") || tooling_strEq(selfName, "sync-global"):
        return tooling_cmdSyncGlobalDeprecated()
    if tooling_strEq(selfName, "verify_backend_selfhost_bootstrap_self_obj"):
        return tooling_cmdSelfhostBootstrapFastHostFromArgs(root, 1, count)
    if tooling_strEq(selfName, "verify_backend_selfhost_100ms_host"):
        return tooling_cmdSelfhost100msHostFromArgs(root, 1, count)
    if tooling_strEq(selfName, "verify_backend_opt2_impl_surface"):
        return tooling_cmdVerifyBackendOpt2ImplSurface(root)
    if tooling_strEq(selfName, "verify_backend_noalias_opt"):
        return tooling_cmdVerifyBackendNoaliasOpt(root)
    if tooling_strEq(selfName, "verify_backend_egraph_cost"):
        return tooling_cmdVerifyBackendEgraphCost(root)
    if tooling_strEq(selfName, "verify_backend_dod_opt_regression"):
        return tooling_cmdVerifyBackendDodOptRegression(root)
    if tooling_strEq(selfName, "verify_backend_noptr_exemption_scope"):
        return tooling_cmdVerifyBackendNoptrExemptionScope(root)
    if tooling_strEq(selfName, "verify_backend_zero_script_closure"):
        return tooling_cmdVerifyBackendZeroScriptClosure(root)
    if tooling_strEq(selfName, "verify_backend_rawptr_migration"):
        return tooling_cmdVerifyBackendRawptrMigration(root)
    if tooling_strEq(selfName, "verify_backend_emit_obj_contract"):
        return tooling_cmdVerifyBackendEmitObjContract(root)
    if tooling_strNonEmpty(selfName) &&
       !tooling_strEq(selfName, "cheng_tooling") &&
       !tooling_strEq(selfName, "cheng_tooling_global"):
        let multiScript: str = tooling_resolveScriptPath(root, selfName)
        if tooling_strNonEmpty(multiScript):
            return tooling_runScript(root, multiScript, 1)

    if count <= 0:
        tooling_printUsage()
        return 1
    let first: str = tooling_paramStr(1)
    if tooling_strEq(first, "help") || tooling_strEq(first, "--help") || tooling_strEq(first, "-h"):
        tooling_printUsage()
        return 0
    if tooling_strEq(first, "driver-path") || tooling_strEq(first, "backend_driver_path"):
        return tooling_cmdDriverPathFromArgs(root, 2, count)
    if tooling_strEq(first, "build-backend-driver") || tooling_strEq(first, "build_backend_driver"):
        return tooling_cmdBuildBackendDriverFromArgs(root, 2, count)
    if tooling_strEq(first, "build-release-driver") || tooling_strEq(first, "build_release_driver"):
        return tooling_cmdBuildReleaseDriverFromArgs(root, 2, count)
    if tooling_strEq(first, "cleanup-backend-driver-history") || tooling_strEq(first, "cleanup_backend_driver_history"):
        return tooling_cmdCleanupBackendDriverHistoryFromArgs(root, 2, count)
    if tooling_strEq(first, "build-backend-baselines") || tooling_strEq(first, "build_backend_baselines"):
        return tooling_cmdBuildBackendBaselines(root)
    if tooling_strEq(first, "sync-global") || tooling_strEq(first, "sync_global"):
        return tooling_cmdSyncGlobalDeprecated()
    if tooling_strEq(first, "selfhost-bootstrap-fast-host") || tooling_strEq(first, "verify_backend_selfhost_bootstrap_self_obj"):
        return tooling_cmdSelfhostBootstrapFastHostFromArgs(root, 2, count)
    if tooling_strEq(first, "selfhost-100ms-host") || tooling_strEq(first, "verify_backend_selfhost_100ms_host"):
        return tooling_cmdSelfhost100msHostFromArgs(root, 2, count)
    if tooling_strEq(first, "verify_backend_opt2_impl_surface"):
        return tooling_cmdVerifyBackendOpt2ImplSurface(root)
    if tooling_strEq(first, "verify_backend_noalias_opt"):
        return tooling_cmdVerifyBackendNoaliasOpt(root)
    if tooling_strEq(first, "verify_backend_egraph_cost"):
        return tooling_cmdVerifyBackendEgraphCost(root)
    if tooling_strEq(first, "verify_backend_dod_opt_regression"):
        return tooling_cmdVerifyBackendDodOptRegression(root)
    if tooling_strEq(first, "verify_backend_noptr_exemption_scope"):
        return tooling_cmdVerifyBackendNoptrExemptionScope(root)
    if tooling_strEq(first, "verify_backend_zero_script_closure"):
        return tooling_cmdVerifyBackendZeroScriptClosure(root)
    if tooling_strEq(first, "verify_backend_rawptr_migration"):
        return tooling_cmdVerifyBackendRawptrMigration(root)
    if tooling_strEq(first, "verify_backend_emit_obj_contract"):
        return tooling_cmdVerifyBackendEmitObjContract(root)
    if tooling_strEq(first, "bootstrap-pure") || tooling_strEq(first, "bootstrap_pure") || tooling_strEq(first, "bootstrap"):
        return tooling_cmdBootstrapPureFromArgs(root, 2, count)
    if tooling_strEq(first, "compile") || tooling_strEq(first, "cheng") || tooling_strEq(first, "chengc"):
        return tooling_cmdCompileFromArgs(root, 2, count)
    if tooling_strEq(first, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    if tooling_strEq(first, "list") || tooling_strEq(first, "embedded-ids") || tooling_strEq(first, "embedded_ids"):
        return tooling_list(root)
    if tooling_strEq(first, "embedded-text") || tooling_strEq(first, "embedded_text"):
        return tooling_embeddedTextCommand(root, 2, count)
    if tooling_strEq(first, "embedded-map-rewrite") || tooling_strEq(first, "embedded_map_rewrite") ||
       tooling_strEq(first, "rewrite-map") || tooling_strEq(first, "rewrite_map"):
        return tooling_embeddedMapRewriteCommand(root, 2, count)
    if tooling_strEq(first, "build-global"):
        var outPath: str = os.joinPath(root, "artifacts/tooling_cmd/cheng_tooling")
        var linker: str = "system"
        var driver: str = ""
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--out:"):
                outPath = strings.dropPrefix(arg, "--out:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--linker:"):
                linker = strings.dropPrefix(arg, "--linker:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--driver:"):
                driver = strings.dropPrefix(arg, "--driver:")
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown build-global arg: " + arg)
            return 1
        return tooling_buildGlobal(root, outPath, linker, driver)
    if tooling_strEq(first, "bundle"):
        var outDir: str = os.joinPath(root, "artifacts/tooling_bundle")
        var linker: str = "system"
        var driver: str = ""
        var profileSelector: str = ""
        var mode: str = "symlink"
        var force: bool = false
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--out-dir:"):
                outDir = strings.dropPrefix(arg, "--out-dir:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--linker:"):
                linker = strings.dropPrefix(arg, "--linker:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--driver:"):
                driver = strings.dropPrefix(arg, "--driver:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--profile:"):
                let profile: str = strutil.toLowerAscii(strutil.strip(strings.dropPrefix(arg, "--profile:")))
                if !tooling_strEq(profile, "full"):
                    tooling_printErr("cheng_tooling: invalid --profile (expected full): " + profile)
                    return 1
                profileSelector = tooling_selectorAppend(profileSelector, profile)
                i = i + 1
                continue
            if strutil.startsWith(arg, "--mode:"):
                mode = strings.dropPrefix(arg, "--mode:")
                i = i + 1
                continue
            if tooling_strEq(arg, "--force"):
                force = true
                i = i + 1
                continue
            if strutil.startsWith(arg, "--force:"):
                force = tooling_isTrue(strings.dropPrefix(arg, "--force:"))
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown bundle arg: " + arg)
            return 1
        return tooling_bundle(root, outDir, linker, driver, profileSelector, mode, force)
    if tooling_strEq(first, "install"):
        var installDir: str = os.joinPath(root, "artifacts/tooling_cmd/bin")
        var manifest: str = ""
        var force: bool = false
        var binPath: str = tooling_paramStr(0)
        var onlySelector: str = ""
        var excludeSelector: str = ""
        var mode: str = "symlink"
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--dir:"):
                installDir = strings.dropPrefix(arg, "--dir:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--bin:"):
                binPath = strings.dropPrefix(arg, "--bin:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--manifest:"):
                manifest = strings.dropPrefix(arg, "--manifest:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--mode:"):
                mode = strings.dropPrefix(arg, "--mode:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--only:"):
                let id: str = tooling_normalizeScriptId(strings.dropPrefix(arg, "--only:"))
                if !tooling_strNonEmpty(id):
                    tooling_printErr("cheng_tooling: invalid --only script id: " + arg)
                    return 1
                onlySelector = tooling_selectorAppend(onlySelector, id)
                i = i + 1
                continue
            if strutil.startsWith(arg, "--exclude:"):
                let id: str = tooling_normalizeScriptId(strings.dropPrefix(arg, "--exclude:"))
                if !tooling_strNonEmpty(id):
                    tooling_printErr("cheng_tooling: invalid --exclude script id: " + arg)
                    return 1
                excludeSelector = tooling_selectorAppend(excludeSelector, id)
                i = i + 1
                continue
            if tooling_strEq(arg, "--force"):
                force = true
                i = i + 1
                continue
            if strutil.startsWith(arg, "--force:"):
                force = tooling_isTrue(strings.dropPrefix(arg, "--force:"))
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown install arg: " + arg)
            return 1
        return tooling_installLinks(root, binPath, installDir, manifest, force, onlySelector, excludeSelector, mode)

    var scriptArg: str = ""
    var argStart: int32 = 0
    if tooling_strEq(first, "run"):
        if count < 2:
            tooling_printErr("cheng_tooling: missing script name for `run`")
            tooling_printUsage()
            return 1
        scriptArg = tooling_paramStr(2)
        argStart = 3
    else:
        scriptArg = first
        argStart = 2

    let scriptPath: str = tooling_resolveScriptPath(root, scriptArg)
    if !tooling_strNonEmpty(scriptPath):
        tooling_printErr("cheng_tooling: unknown tooling script: " + scriptArg)
        tooling_printErr("cheng_tooling: run `cheng_tooling list` to inspect available script IDs")
        return 1
    return tooling_runScript(root, scriptPath, argStart)
