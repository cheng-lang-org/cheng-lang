import cmdline
import std/os
import std/strutils as strutil
import std/strings
import std/monotimes
import tooling/cheng_tooling_embedded_inline as tooling_embedded_inline

type
    ToolingSelfhostResult = ref
        ok: bool
        message: str
        totalMs: int64
        mode: str
        stage1Path: str
        stage2Path: str
        stage3Path: str
        stage0Path: str
        stage0DriverKind: str
        stage1Status: str
        stage1CompileMode: str
        stage1RebuildOk: bool
        fallbackUsed: bool
        quarantineCleaned: int32
        lockWaitMs: int32
        strictRebuildOk: bool
        stage2Sha256: str
        stage3Sha256: str
        fixedPointOk: bool
        stage1CompileMs: int64
        stage1SanityMs: int64
        stage1CompileAttempts: int32
        stage1CompileSegfaults: int32

var
    tooling_buildDriverLastStampHit: bool = false
    tooling_buildDriverTightProfileLogShown: bool = false

fn tooling_setCmdLine(argc: int32, argv: str*) =
    cmdline.__cheng_setCmdLine(argc, void*(argv))

fn tooling_paramCount(): int32 =
    return cmdline.paramCount()

fn tooling_paramStr(i: int32): str =
    if i < 0:
        return ""
    return cmdline.paramStr(i)

fn tooling_printOut(text: str) =
    os.writeLine(os.get_stdout(), text)

fn tooling_printErr(text: str) =
    os.writeLine(os.get_stderr(), text)

fn tooling_strNonEmpty(text: str): bool =
    return len(text) > 0

fn tooling_strEq(a: str, b: str): bool =
    if a == b:
        return true
    if len(a) == 0 || len(b) == 0:
        return false
    return strings.streq(a, b)

fn tooling_selfhostStrictRebuildEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("SELFHOST_STRICT_REBUILD", "1"))

fn tooling_buildDriverStrictNativeEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("BUILD_DRIVER_STRICT_NATIVE", "1"))

fn tooling_buildDriverAllowFallbackEnabled(): bool =
    # Fallback path has been removed from production closure.
    # Keep env read only for compatibility diagnostics.
    return false

fn tooling_buildDriverProfileMode(): str =
    let raw: str = strutil.toLowerAscii(strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE_MODE", "backend")))
    if tooling_strEq(raw, "full"):
        return "full"
    if tooling_strEq(raw, "backend") || tooling_strEq(raw, "backend_only"):
        return "backend"
    if tooling_strEq(raw, "stage1") || tooling_strEq(raw, "stage1_uir"):
        return "stage1_uir"
    return "safe"

fn tooling_prefixBuildDriverProfile(cmd: str, profileMode: str): str =
    var out: str = cmd
    if tooling_strEq(profileMode, "full"):
        out = tooling_envAssignCompat("UIR_PROFILE", "1") + out
        out = tooling_envAssignCompat("STAGE1_PROFILE", "1") + out
        out = tooling_envAssignCompat("BACKEND_PROFILE", "1") + out
        return out
    if tooling_strEq(profileMode, "backend"):
        out = tooling_envAssignCompat("BACKEND_PROFILE", "1") + out
        return out
    if tooling_strEq(profileMode, "stage1_uir"):
        out = tooling_envAssignCompat("UIR_PROFILE", "1") + out
        return out
    return out

fn tooling_strEndsWith(text: str, suffix: str): bool =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(suffix):
        return false
    let n: int32 = len(text)
    let m: int32 = len(suffix)
    if m > n:
        return false
    for i in 0..<m:
        if text[n - m + i] != suffix[i]:
            return false
    return true

fn tooling_stripShSuffix(name: str): str =
    if !tooling_strEndsWith(name, ".sh"):
        return name
    let n: int32 = len(name)
    if n <= 3:
        return ""
    return strings.sliceBytes(name, 0, n - 3)

fn tooling_isSafeScriptName(name: str): bool =
    if !tooling_strNonEmpty(name):
        return false
    if strutil.contains(name, ".."):
        return false
    for i in 0..<len(name):
        let ch: char = name[i]
        let isAlphaLower: bool = ch >= 'a' && ch <= 'z'
        let isAlphaUpper: bool = ch >= 'A' && ch <= 'Z'
        let isDigit: bool = ch >= '0' && ch <= '9'
        if isAlphaLower || isAlphaUpper || isDigit || ch == '_' || ch == '-' || ch == '.':
            continue
        return false
    return true

fn tooling_shellQuote(raw: str): str =
    if len(raw) == 0:
        return "\"\""
    var escaped: str = strutil.replace(raw, "\\", "\\\\")
    escaped = strutil.replace(escaped, "$", "\\$")
    escaped = strutil.replace(escaped, "`", "\\`")
    escaped = strutil.replace(escaped, "\"", "\\\"")
    return "\"" + escaped + "\""

fn tooling_stage0CompatPrefixEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_COMPAT_PREFIX", "1"))

fn tooling_envAssignQuoted(name: str, value: str): str =
    if !tooling_strNonEmpty(name):
        return ""
    return name + "=" + tooling_shellQuote(value) + " "

fn tooling_envAssignCompat(name: str, value: str): str =
    if !tooling_strNonEmpty(name):
        return ""
    var out: str = tooling_envAssignQuoted(name, value)
    if !tooling_stage0CompatPrefixEnabled():
        return out
    if strutil.startsWith(name, "BACKEND_") || strutil.startsWith(name, "STAGE1_"):
        out = out + "CHENG_" + name + "=" + tooling_shellQuote(value) + " "
        return out
    if tooling_strEq(name, "MM"):
        out = out + "CHENG_MM=" + tooling_shellQuote(value) + " "
        return out
    if tooling_strEq(name, "CACHE"):
        out = out + "CHENG_CACHE=" + tooling_shellQuote(value) + " "
    return out

fn tooling_prefixUnsetLegacyFrontendEnv(cmd: str): str =
    if !tooling_strNonEmpty(cmd):
        return cmd
    return "env -u BACKEND_FRONTEND -u CHENG_BACKEND_FRONTEND " + cmd

fn tooling_root(): str =
    let envRoot: str = strutil.strip(os.getEnvDefault("TOOLING_ROOT", ""))
    if tooling_strNonEmpty(envRoot):
        return envRoot
    return os.getCurrentDir()

fn tooling_scriptDir(root: str): str =
    return os.joinPath(root, "src/tooling")

fn tooling_embeddedPrefix(): str =
    return "embedded:"

fn tooling_scriptIdFromResolvedPath(scriptPath: str): str =
    let prefix: str = tooling_embeddedPrefix()
    if !strutil.startsWith(scriptPath, prefix):
        return ""
    return strings.dropPrefix(scriptPath, prefix)

fn tooling_splitLines(raw: str): str[] =
    var out: str[] = []
    if !tooling_strNonEmpty(raw):
        return out
    let n: int32 = len(raw)
    var start: int32 = 0
    var i: int32 = 0
    for _ in 0..<n:
        if raw[i] == '\n':
            if i > start:
                let piece: str = strutil.strip(strings.sliceBytes(raw, start, i - start))
                if tooling_strNonEmpty(piece):
                    add(out, piece)
            start = i + 1
        i = i + 1
    if start < n:
        let tail: str = strutil.strip(strings.sliceBytes(raw, start, n - start))
        if tooling_strNonEmpty(tail):
            add(out, tail)
    return out

fn tooling_readTextFile(root: str, pathRaw: str): str =
    let path: str = tooling_pathAbsolute(root, pathRaw)
    if !tooling_strNonEmpty(path) || !os.fileExists(path):
        return ""
    let res: os.ExecCmdResult = tooling_exec(root, "cat " + tooling_shellQuote(path))
    if os.execCmdResultExitCode(res) != 0:
        return ""
    return os.execCmdResultOutput(res)

fn tooling_kvGet(raw: str, key: str): str =
    if !tooling_strNonEmpty(raw) || !tooling_strNonEmpty(key):
        return ""
    let rows: str[] = tooling_splitLines(raw)
    let prefix: str = key + "="
    for i in 0..<rows.len:
        let line: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(line):
            continue
        if strutil.startsWith(line, prefix):
            return strings.dropPrefix(line, prefix)
    return ""

fn tooling_buildGlobalCrashMemoPath(root: str): str =
    return os.joinPath(root, "chengcache/tooling_cmd/build_global.crash_pref.env")

fn tooling_buildGlobalSafeFromMemo(root: str, memoPathRaw: str, driverPath: str, srcPath: str,
                                   target: str, linker: str, driverSha: str, srcSha: str): bool =
    let memoPath: str = tooling_pathAbsolute(root, memoPathRaw)
    if !tooling_strNonEmpty(memoPath) || !os.fileExists(memoPath):
        return false
    if !tooling_strNonEmpty(driverSha) || !tooling_strNonEmpty(srcSha):
        return false
    let raw: str = tooling_readTextFile(root, memoPath)
    if !tooling_strEq(tooling_kvGet(raw, "version"), "1"):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "prefer_safe"), "1"):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "driver_path"), tooling_pathAbsolute(root, driverPath)):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "driver_sha"), driverSha):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "src_path"), tooling_pathAbsolute(root, srcPath)):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "src_sha"), srcSha):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "target"), target):
        return false
    if !tooling_strEq(tooling_kvGet(raw, "linker"), linker):
        return false
    return true

fn tooling_buildGlobalWriteCrashMemo(root: str, memoPathRaw: str, driverPath: str, srcPath: str,
                                     target: str, linker: str, driverSha: str, srcSha: str,
                                     preferSafe: bool) =
    let memoPath: str = tooling_pathAbsolute(root, memoPathRaw)
    if !tooling_strNonEmpty(memoPath):
        return
    let memoDir: str = os.parentDir(memoPath)
    if tooling_strNonEmpty(memoDir):
        tooling_tryMkdirP(root, memoDir)
    let preferSafeText: str = preferSafe ? "1" : "0"
    var text: str = ""
    text = text + "version=1\n"
    text = text + "prefer_safe=" + preferSafeText + "\n"
    text = text + "driver_path=" + tooling_pathAbsolute(root, driverPath) + "\n"
    text = text + "driver_sha=" + driverSha + "\n"
    text = text + "src_path=" + tooling_pathAbsolute(root, srcPath) + "\n"
    text = text + "src_sha=" + srcSha + "\n"
    text = text + "target=" + target + "\n"
    text = text + "linker=" + linker + "\n"
    os.writeFile(memoPath, text)

fn tooling_escapeEmbeddedMapString(text: str): str =
    if len(text) == 0:
        return ""
    var out: str = ""
    let n: int32 = len(text)
    var i: int32 = 0
    while i < n:
        let ch: char = text[i]
        if ch == '\\':
            out = out + "\\\\"
        elif ch == '"':
            out = out + "\\\""
        elif ch == '\n':
            out = out + "\\n"
        elif ch == '\t':
            out = out + "\\t"
        elif ch == '\r':
            out = out + "\\r"
        else:
            out = out + strings.sliceBytes(text, i, 1)
        i = i + 1
    return out

fn tooling_splitEmbeddedEscapedChunks(text: str, chunkSizeRaw: int32): str[] =
    var out: str[] = []
    if !tooling_strNonEmpty(text):
        add(out, "")
        return out
    var chunkSize: int32 = chunkSizeRaw
    if chunkSize <= 0:
        chunkSize = len(text)
    let n: int32 = len(text)
    var start: int32 = 0
    while start < n:
        var end: int32 = start + chunkSize
        if end >= n:
            add(out, strings.sliceBytes(text, start, n - start))
            break
        while end < n:
            var slashRun: int32 = 0
            var j: int32 = end - 1
            while j >= start && text[j] == '\\':
                slashRun = slashRun + 1
                j = j - 1
            if slashRun % 2 == 0:
                break
            end = end + 1
        if end > n:
            end = n
        add(out, strings.sliceBytes(text, start, end - start))
        start = end
    return out

fn tooling_renderEmbeddedMapText(root: str): str =
    let ids: str[] = tooling_collectScripts(root)
    var out: str = ""
    out = out + "# Auto-generated embedded tooling command payload map.\n"
    out = out + "# Source: former src/tooling/tooling_inline/*.inline + src/tooling/verify_inline/*.inline.\n"
    out = out + "# Generated by cheng_tooling embedded-map-rewrite.\n"
    out = out + "# Do not edit manually.\n\n"
    out = out + "fn toolingEmbeddedScriptIds(): str[] =\n"
    out = out + "    var out: str[] = []\n"
    for i in 0..<ids.len:
        out = out + "    add(out, \"" + ids[i] + "\")\n"
    out = out + "    return out\n\n"
    out = out + "fn toolingEmbeddedScriptBody(id: str): str =\n"
    for i in 0..<ids.len:
        let sid: str = ids[i]
        let rawBody: str = tooling_embeddedScriptText(root, sid)
        let encoded: str = tooling_escapeEmbeddedMapString(rawBody)
        out = out + "    if id == \"" + sid + "\":\n"
        if len(encoded) <= 1800:
            out = out + "        return \"" + encoded + "\"\n"
        else:
            out = out + "        var out: str = \"\"\n"
            let chunks: str[] = tooling_splitEmbeddedEscapedChunks(encoded, 1500)
            for j in 0..<chunks.len:
                out = out + "        out = out + \"" + chunks[j] + "\"\n"
            out = out + "        return out\n"
    out = out + "    return \"\"\n"
    return out

fn tooling_embeddedScriptIds(root: str): str[] =
    var out: str[] = []
    let ids: str[] = tooling_embedded_inline.toolingEmbeddedScriptIds()
    for i in 0..<ids.len:
        let id: str = ids[i]
        if tooling_strEq(id, "chengb"):
            continue
        if !tooling_isSafeScriptName(id):
            continue
        if tooling_idsContains(out, id):
            continue
        add(out, id)
    # Keep synthetic compatibility IDs available even if the embedded map
    # was generated by an older toolchain.
    var synthetic: str[] = []
    add(synthetic, "verify")
    add(synthetic, "verify_tooling_cmdline")
    add(synthetic, "verify_backend_zero_script_closure")
    add(synthetic, "verify_backend_rawptr_migration")
    add(synthetic, "verify_backend_rawptr_closedloop")
    add(synthetic, "build_backend_native_contract")
    add(synthetic, "verify_backend_native_contract")
    for i in 0..<synthetic.len:
        let sid: str = synthetic[i]
        if !tooling_isSafeScriptName(sid):
            continue
        if tooling_idsContains(out, sid):
            continue
        add(out, sid)
    return out

fn tooling_embeddedBuildBackendNativeContractScript(): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "\n"
    out = out + "usage() {\n"
    out = out + "  cat <<'EOF'\n"
    out = out + "Usage:\n"
    out = out + "  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract [--out:<path>] [--doc:<path>]\n"
    out = out + "\n"
    out = out + "Notes:\n"
    out = out + "  - Generates deterministic CNCPAR-01 native contract baseline.\n"
    out = out + "  - Default output: src/tooling/backend_native_contract.env\n"
    out = out + "EOF\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "hash_file() {\n"
    out = out + "  file=\"$1\"\n"
    out = out + "  if command -v shasum >/dev/null 2>&1; then\n"
    out = out + "    shasum -a 256 \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  if command -v sha256sum >/dev/null 2>&1; then\n"
    out = out + "    sha256sum \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  cksum \"$file\" | awk '{print $1}'\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "out_file=\"src/tooling/backend_native_contract.env\"\n"
    out = out + "doc=\"docs/cheng-native-contract.md\"\n"
    out = out + "\n"
    out = out + "while [ \"${1:-}\" != \"\" ]; do\n"
    out = out + "  case \"$1\" in\n"
    out = out + "    --out:*)\n"
    out = out + "      out_file=\"${1#--out:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --doc:*)\n"
    out = out + "      doc=\"${1#--doc:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --help|-h)\n"
    out = out + "      usage\n"
    out = out + "      exit 0\n"
    out = out + "      ;;\n"
    out = out + "    *)\n"
    out = out + "      echo \"[Error] unknown arg: $1\" 1>&2\n"
    out = out + "      usage\n"
    out = out + "      exit 2\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "  shift || true\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\n"
    out = out + "cd \"$root\"\n"
    out = out + "\n"
    out = out + "if ! command -v rg >/dev/null 2>&1; then\n"
    out = out + "  echo \"[build_backend_native_contract] rg is required\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "driver_file=\"src/backend/tooling/backend_driver.cheng\"\n"
    out = out + "builder_file=\"src/backend/uir/uir_internal/uir_core_builder.cheng\"\n"
    out = out + "tooling_file=\"src/tooling/cheng_tooling.cheng\"\n"
    out = out + "for required in \"$doc\" \"$driver_file\" \"$builder_file\" \"$tooling_file\"; do\n"
    out = out + "  if [ ! -f \"$required\" ]; then\n"
    out = out + "    echo \"[build_backend_native_contract] missing file: $required\" 1>&2\n"
    out = out + "    exit 2\n"
    out = out + "  fi\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "tmp_markers=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_markers.XXXXXX\")\"\n"
    out = out + "tmp_required=\"$(mktemp \"${TMPDIR:-/tmp}/backend_native_contract_required.XXXXXX\")\"\n"
    out = out + "cleanup() {\n"
    out = out + "  rm -f \"$tmp_markers\" \"$tmp_required\"\n"
    out = out + "}\n"
    out = out + "trap cleanup EXIT\n"
    out = out + "\n"
    out = out + "rg -o 'native_contract\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" \\\n"
    out = out + "  | LC_ALL=C sort -u >\"$tmp_markers\"\n"
    out = out + "marker_count=\"$(wc -l < \"$tmp_markers\" | tr -d ' ')\"\n"
    out = out + "if [ \"$marker_count\" -eq 0 ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] no native contract markers found in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "contract_version=\"$(rg -o 'native_contract\\.version=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_id=\"$(rg -o 'native_contract\\.scheme\\.id=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_name=\"$(rg -o 'native_contract\\.scheme\\.name=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "scheme_normative=\"$(rg -o 'native_contract\\.scheme\\.normative=[0-9]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "enforce_mode=\"$(rg -o 'native_contract\\.enforce\\.mode=[A-Za-z0-9_]+' \"$doc\" | head -n 1 | cut -d= -f2 || true)\"\n"
    out = out + "if [ \"$contract_version\" = \"\" ] || [ \"$scheme_id\" = \"\" ] || [ \"$scheme_name\" = \"\" ] || [ \"$scheme_normative\" = \"\" ] || [ \"$enforce_mode\" = \"\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] missing required contract markers in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if [ \"$scheme_id\" != \"CNC\" ] || [ \"$scheme_name\" != \"cheng_native_contract\" ] || [ \"$scheme_normative\" != \"1\" ] || [ \"$enforce_mode\" != \"hard_fail\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] CNC normative markers must be CNC/cheng_native_contract/normative=1/hard_fail\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "pillar_count=\"$(rg -o 'native_contract\\.pillar\\.[a-z0-9_.]+=[A-Za-z0-9_]+' \"$doc\" | LC_ALL=C sort -u | wc -l | tr -d ' ')\"\n"
    out = out + "rg -o 'native_contract\\.required_gate\\.[a-z0-9_.]+=1' \"$doc\" \\\n"
    out = out + "  | sed -E 's/^native_contract\\.required_gate\\.([a-z0-9_.]+)=1$/\\1/' \\\n"
    out = out + "  | LC_ALL=C sort -u >\"$tmp_required\"\n"
    out = out + "required_gate_count=\"$(wc -l < \"$tmp_required\" | tr -d ' ')\"\n"
    out = out + "if [ \"$required_gate_count\" -eq 0 ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] no required gates found in: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "required_gates_csv=\"$(tr '\\n' ',' <\"$tmp_required\" | sed -E 's/,+$//')\"\n"
    out = out + "if [ \"$required_gates_csv\" = \"\" ]; then\n"
    out = out + "  echo \"[build_backend_native_contract] failed to compute required gate list\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "doc_sha=\"$(hash_file \"$doc\")\"\n"
    out = out + "marker_sha=\"$(hash_file \"$tmp_markers\")\"\n"
    out = out + "tooling_sha=\"$(hash_file \"$tooling_file\")\"\n"
    out = out + "driver_sha=\"$(hash_file \"$driver_file\")\"\n"
    out = out + "builder_sha=\"$(hash_file \"$builder_file\")\"\n"
    out = out + "\n"
    out = out + "out_dir=\"$(dirname \"$out_file\")\"\n"
    out = out + "if [ \"$out_dir\" != \"\" ] && [ ! -d \"$out_dir\" ]; then\n"
    out = out + "  mkdir -p \"$out_dir\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "{\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_BASELINE_VERSION=1\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DOC=$doc\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DOC_SHA256=$doc_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_VERSION=$contract_version\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_ID=$scheme_id\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NAME=$scheme_name\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_SCHEME_NORMATIVE=$scheme_normative\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_ENFORCE_MODE=$enforce_mode\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_MARKER_COUNT=$marker_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_MARKER_SHA256=$marker_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_PILLAR_COUNT=$pillar_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATE_COUNT=$required_gate_count\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_VERIFY_SCRIPT_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_CLOSEDLOOP_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_PROD_CLOSURE_SHA256=$tooling_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_DRIVER_SHA256=$driver_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_UIR_BUILDER_SHA256=$builder_sha\"\n"
    out = out + "  echo \"BACKEND_NATIVE_CONTRACT_REQUIRED_GATES=$required_gates_csv\"\n"
    out = out + "} >\"$out_file\"\n"
    out = out + "\n"
    out = out + "echo \"backend native contract baseline generated: $out_file\"\n"
    return out

fn tooling_embeddedNativeForwardScript(subcmd: str): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n"
    out = out + "exec \"$tool\" " + subcmd + " \"$@\"\n"
    return out

fn tooling_embeddedVerifyBackendNativeContractScript(): str =
    var out: str = ""
    out = out + "#!/usr/bin/env sh\n"
    out = out + ":\n"
    out = out + "set -eu\n"
    out = out + "(set -o pipefail) 2>/dev/null && set -o pipefail\n"
    out = out + "\n"
    out = out + "usage() {\n"
    out = out + "  cat <<'EOF'\n"
    out = out + "Usage:\n"
    out = out + "  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_native_contract [--baseline:<path>] [--doc:<path>]\n"
    out = out + "\n"
    out = out + "Notes:\n"
    out = out + "  - Verifies CNCPAR-01 native contract baseline and implementation closure.\n"
    out = out + "  - Regenerate baseline with: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract\n"
    out = out + "EOF\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "hash_file() {\n"
    out = out + "  file=\"$1\"\n"
    out = out + "  if command -v shasum >/dev/null 2>&1; then\n"
    out = out + "    shasum -a 256 \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  if command -v sha256sum >/dev/null 2>&1; then\n"
    out = out + "    sha256sum \"$file\" | awk '{print $1}'\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  cksum \"$file\" | awk '{print $1}'\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "read_env_value() {\n"
    out = out + "  key=\"$1\"\n"
    out = out + "  file=\"$2\"\n"
    out = out + "  awk -F= -v k=\"$key\" '$1 == k { sub(/^[^=]*=/, \"\", $0); print $0; found=1; exit } END { if (!found) print \"\" }' \"$file\"\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "baseline=\"src/tooling/backend_native_contract.env\"\n"
    out = out + "doc=\"docs/cheng-native-contract.md\"\n"
    out = out + "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"\n"
    out = out + "\n"
    out = out + "while [ \"${1:-}\" != \"\" ]; do\n"
    out = out + "  case \"$1\" in\n"
    out = out + "    --baseline:*)\n"
    out = out + "      baseline=\"${1#--baseline:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --doc:*)\n"
    out = out + "      doc=\"${1#--doc:}\"\n"
    out = out + "      ;;\n"
    out = out + "    --help|-h)\n"
    out = out + "      usage\n"
    out = out + "      exit 0\n"
    out = out + "      ;;\n"
    out = out + "    *)\n"
    out = out + "      echo \"[Error] unknown arg: $1\" 1>&2\n"
    out = out + "      usage\n"
    out = out + "      exit 2\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "  shift || true\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\n"
    out = out + "cd \"$root\"\n"
    out = out + "\n"
    out = out + "if [ ! -f \"$baseline\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing baseline file: $baseline\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if [ ! -f \"$doc\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing doc file: $doc\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "if ! command -v rg >/dev/null 2>&1; then\n"
    out = out + "  echo \"[verify_backend_native_contract] rg is required\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "out_dir=\"artifacts/backend_native_contract\"\n"
    out = out + "mkdir -p \"$out_dir\"\n"
    out = out + "generated=\"$out_dir/backend_native_contract.generated.env\"\n"
    out = out + "report=\"$out_dir/backend_native_contract.report.txt\"\n"
    out = out + "snapshot=\"$out_dir/backend_native_contract.snapshot.env\"\n"
    out = out + "diff_file=\"$out_dir/backend_native_contract.diff.txt\"\n"
    out = out + "closedloop_body=\"$out_dir/verify_backend_closedloop.body.sh\"\n"
    out = out + "prod_closure_body=\"$out_dir/backend_prod_closure.body.sh\"\n"
    out = out + "\n"
    out = out + "$tool build_backend_native_contract --doc:\"$doc\" --out:\"$generated\" >/dev/null\n"
    out = out + "\n"
    out = out + "status=\"ok\"\n"
    out = out + "if ! cmp -s \"$baseline\" \"$generated\"; then\n"
    out = out + "  status=\"drift\"\n"
    out = out + "  if diff -u \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null; then\n"
    out = out + "    :\n"
    out = out + "  else\n"
    out = out + "    diff \"$baseline\" \"$generated\" >\"$diff_file\" 2>/dev/null || true\n"
    out = out + "  fi\n"
    out = out + "else\n"
    out = out + "  : >\"$diff_file\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "closedloop_cache=\"chengcache/embedded_scripts/verify_backend_closedloop.embedded.sh\"\n"
    out = out + "prod_closure_cache=\"chengcache/embedded_scripts/backend_prod_closure.embedded.sh\"\n"
    out = out + "if [ -s \"$closedloop_cache\" ]; then\n"
    out = out + "  cp \"$closedloop_cache\" \"$closedloop_body\"\n"
    out = out + "else\n"
    out = out + "  $tool verify_backend_closedloop --help >/dev/null 2>&1 || true\n"
    out = out + "  if [ -s \"$closedloop_cache\" ]; then\n"
    out = out + "    cp \"$closedloop_cache\" \"$closedloop_body\"\n"
    out = out + "  else\n"
    out = out + "    $tool embedded-text --id:verify_backend_closedloop >\"$closedloop_body\"\n"
    out = out + "  fi\n"
    out = out + "fi\n"
    out = out + "if [ -s \"$prod_closure_cache\" ]; then\n"
    out = out + "  cp \"$prod_closure_cache\" \"$prod_closure_body\"\n"
    out = out + "else\n"
    out = out + "  $tool backend_prod_closure --help >/dev/null 2>&1 || true\n"
    out = out + "  if [ -s \"$prod_closure_cache\" ]; then\n"
    out = out + "    cp \"$prod_closure_cache\" \"$prod_closure_body\"\n"
    out = out + "  else\n"
    out = out + "    $tool embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\n"
    out = out + "  fi\n"
    out = out + "fi\n"
    out = out + "closedloop_gate_ok=\"1\"\n"
    out = out + "prod_closure_gate_ok=\"1\"\n"
    out = out + "if ! rg -q 'backend.native_contract' \"$closedloop_body\"; then\n"
    out = out + "  closedloop_gate_ok=\"0\"\n"
    out = out + "fi\n"
    out = out + "if ! rg -q 'backend.native_contract' \"$prod_closure_body\"; then\n"
    out = out + "  prod_closure_gate_ok=\"0\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$closedloop_gate_ok\" != \"1\" ] || [ \"$prod_closure_gate_ok\" != \"1\" ]; then\n"
    out = out + "  status=\"drift\"\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "driver=\"${BACKEND_DRIVER:-}\"\n"
    out = out + "if [ \"$driver\" = \"\" ] && [ -x \"artifacts/backend_driver/cheng\" ]; then\n"
    out = out + "  driver=\"artifacts/backend_driver/cheng\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$driver\" = \"\" ] && [ -x \"./cheng\" ]; then\n"
    out = out + "  driver=\"./cheng\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$driver\" = \"\" ] || [ ! -x \"$driver\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] missing backend driver (set BACKEND_DRIVER)\" 1>&2\n"
    out = out + "  exit 2\n"
    out = out + "fi\n"
    out = out + "driver_native_flag=\"\"\n"
    out = out + "run_driver_retry() {\n"
    out = out + "  log_file=\"$1\"\n"
    out = out + "  shift\n"
    out = out + "  attempts=\"${NATIVE_CONTRACT_DRIVER_RETRIES:-8}\"\n"
    out = out + "  case \"$attempts\" in\n"
    out = out + "    ''|*[!0-9]*) attempts=8 ;;\n"
    out = out + "  esac\n"
    out = out + "  if [ \"$attempts\" -lt 1 ]; then\n"
    out = out + "    attempts=8\n"
    out = out + "  fi\n"
    out = out + "  try=1\n"
    out = out + "  rc=139\n"
    out = out + "  while [ \"$try\" -le \"$attempts\" ]; do\n"
    out = out + "    \"$@\" >\"$log_file\" 2>&1\n"
    out = out + "    rc=\"$?\"\n"
    out = out + "    if [ \"$rc\" -ne 139 ] && [ \"$rc\" -ne 138 ]; then\n"
    out = out + "      break\n"
    out = out + "    fi\n"
    out = out + "    if [ \"$try\" -lt \"$attempts\" ]; then\n"
    out = out + "      echo \"[verify_backend_native_contract] retry driver after crash rc=$rc attempt=$try/$attempts\" 1>&2\n"
    out = out + "    fi\n"
    out = out + "    try=$((try + 1))\n"
    out = out + "  done\n"
    out = out + "  return \"$rc\"\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "ok_fixture=\"tests/cheng/backend/fixtures/native_contract_ok.cheng\"\n"
    out = out + "float_fixture=\"tests/cheng/backend/fixtures/native_contract_float_fail.cheng\"\n"
    out = out + "syscall_fixture=\"tests/cheng/backend/fixtures/native_contract_syscall_fail.cheng\"\n"
    out = out + "for fixture in \"$ok_fixture\" \"$float_fixture\" \"$syscall_fixture\"; do\n"
    out = out + "  if [ ! -f \"$fixture\" ]; then\n"
    out = out + "    echo \"[verify_backend_native_contract] missing fixture: $fixture\" 1>&2\n"
    out = out + "    exit 2\n"
    out = out + "  fi\n"
    out = out + "done\n"
    out = out + "\n"
    out = out + "ok_out=\"$out_dir/native_contract_ok.bin\"\n"
    out = out + "ok_stamp=\"$out_dir/native_contract_ok.compile_stamp.txt\"\n"
    out = out + "ok_err=\"$out_dir/native_contract_ok.stderr.txt\"\n"
    out = out + "set +e\n"
    out = out + "run_driver_retry \"$ok_err\" env BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_ELF_PROFILE=nolibc BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$ok_fixture\" BACKEND_OUTPUT=\"$ok_out\" BACKEND_COMPILE_STAMP_OUT=\"$ok_stamp\" \"$driver\" $driver_native_flag\n"
    out = out + "ok_rc=\"$?\"\n"
    out = out + "set -e\n"
    out = out + "native_smoke_ok=\"1\"\n"
    out = out + "if [ \"$ok_rc\" -ne 0 ]; then\n"
    out = out + "  if [ -s \"$ok_out\" ] && [ -s \"$ok_stamp\" ] && rg -q '^native_contract=1$' \"$ok_stamp\"; then\n"
    out = out + "    echo \"[verify_backend_native_contract] warn: driver rc=$ok_rc after producing valid native contract object; continue\" 1>&2\n"
    out = out + "    ok_rc=\"0\"\n"
    out = out + "  else\n"
    out = out + "    if [ -s \"$ok_err\" ]; then\n"
    out = out + "      sed -n '1,120p' \"$ok_err\" 1>&2 || true\n"
    out = out + "    fi\n"
    out = out + "    native_smoke_ok=\"0\"\n"
    out = out + "    status=\"drift\"\n"
    out = out + "  fi\n"
    out = out + "elif ! rg -q '^native_contract=1$' \"$ok_stamp\"; then\n"
    out = out + "  echo \"[verify_backend_native_contract] compile stamp missing native_contract=1 marker\" 1>&2\n"
    out = out + "  native_smoke_ok=\"0\"\n"
    out = out + "  status=\"drift\"\n"
    out = out + "fi\n"
    out = out + "if [ \"$native_smoke_ok\" = \"1\" ] && command -v nm >/dev/null 2>&1; then\n"
    out = out + "  if ! nm \"$ok_out\" 2>/dev/null | rg -q 'cheng_contract_charge_block|cheng_contract_gas_used'; then\n"
    out = out + "    echo \"[verify_backend_native_contract] native contract output missing charge symbols\" 1>&2\n"
    out = out + "    native_smoke_ok=\"0\"\n"
    out = out + "    status=\"drift\"\n"
    out = out + "  fi\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "expect_fail() {\n"
    out = out + "  label=\"$1\"\n"
    out = out + "  fixture=\"$2\"\n"
    out = out + "  out_bin=\"$out_dir/${label}.bin\"\n"
    out = out + "  err_file=\"$out_dir/${label}.stderr.txt\"\n"
    out = out + "  set +e\n"
    out = out + "  run_driver_retry \"$err_file\" env BACKEND_ENABLE_CLI=1 BACKEND_NATIVE_CONTRACT=1 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=1 BACKEND_VALIDATE=1 BACKEND_ELF_PROFILE=nolibc BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj BACKEND_TARGET=linux-aarch64 BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" $driver_native_flag\n"
    out = out + "  rc=\"$?\"\n"
    out = out + "  set -e\n"
    out = out + "  if [ \"$rc\" -eq 0 ]; then\n"
    out = out + "    echo \"[verify_backend_native_contract] expected failure but succeeded: $label\" 1>&2\n"
    out = out + "    status=\"drift\"\n"
    out = out + "    return\n"
    out = out + "  fi\n"
    out = out + "  case \"$label\" in\n"
    out = out + "    float)\n"
    out = out + "      if ! rg -q 'native_contract hard-fail|forbid float' \"$err_file\"; then\n"
    out = out + "        echo \"[verify_backend_native_contract] missing float hard-fail diagnostics\" 1>&2\n"
    out = out + "        status=\"drift\"\n"
    out = out + "      fi\n"
    out = out + "      ;;\n"
    out = out + "    syscall)\n"
    out = out + "      if ! rg -q 'native_contract hard-fail|forbid syscall|linux syscall builtin|cheng_linux_syscall' \"$err_file\"; then\n"
    out = out + "        echo \"[verify_backend_native_contract] missing syscall hard-fail diagnostics\" 1>&2\n"
    out = out + "        status=\"drift\"\n"
    out = out + "      fi\n"
    out = out + "      ;;\n"
    out = out + "  esac\n"
    out = out + "}\n"
    out = out + "\n"
    out = out + "expect_fail float \"$float_fixture\"\n"
    out = out + "expect_fail syscall \"$syscall_fixture\"\n"
    out = out + "\n"
    out = out + "baseline_sha=\"$(hash_file \"$baseline\")\"\n"
    out = out + "generated_sha=\"$(hash_file \"$generated\")\"\n"
    out = out + "{\n"
    out = out + "  echo \"verify_backend_native_contract report\"\n"
    out = out + "  echo \"status=$status\"\n"
    out = out + "  echo \"doc=$doc\"\n"
    out = out + "  echo \"baseline=$baseline\"\n"
    out = out + "  echo \"generated=$generated\"\n"
    out = out + "  echo \"baseline_sha256=$baseline_sha\"\n"
    out = out + "  echo \"generated_sha256=$generated_sha\"\n"
    out = out + "  echo \"closedloop_gate_ok=$closedloop_gate_ok\"\n"
    out = out + "  echo \"prod_closure_gate_ok=$prod_closure_gate_ok\"\n"
    out = out + "  echo \"native_smoke_ok=$native_smoke_ok\"\n"
    out = out + "  echo \"diff=$diff_file\"\n"
    out = out + "} >\"$report\"\n"
    out = out + "{\n"
    out = out + "  echo \"backend_native_contract_status=$status\"\n"
    out = out + "  echo \"backend_native_contract_baseline_sha256=$baseline_sha\"\n"
    out = out + "  echo \"backend_native_contract_generated_sha256=$generated_sha\"\n"
    out = out + "  echo \"backend_native_contract_closedloop_gate_ok=$closedloop_gate_ok\"\n"
    out = out + "  echo \"backend_native_contract_prod_closure_gate_ok=$prod_closure_gate_ok\"\n"
    out = out + "  echo \"backend_native_contract_native_smoke_ok=$native_smoke_ok\"\n"
    out = out + "  echo \"backend_native_contract_report=$report\"\n"
    out = out + "} >\"$snapshot\"\n"
    out = out + "\n"
    out = out + "if [ \"$status\" != \"ok\" ]; then\n"
    out = out + "  echo \"[verify_backend_native_contract] native contract baseline/implementation drift detected\" 1>&2\n"
    out = out + "  echo \"  baseline: $baseline\" 1>&2\n"
    out = out + "  echo \"  generated: $generated\" 1>&2\n"
    out = out + "  if [ -s \"$diff_file\" ]; then\n"
    out = out + "    sed -n '1,120p' \"$diff_file\" 1>&2 || true\n"
    out = out + "  fi\n"
    out = out + "  echo \"  fix: ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} build_backend_native_contract --doc:$doc --out:$baseline\" 1>&2\n"
    out = out + "  exit 1\n"
    out = out + "fi\n"
    out = out + "\n"
    out = out + "echo \"verify_backend_native_contract ok\"\n"
    return out

fn tooling_normalizeEmbeddedScriptText(id: str, raw: str): str =
    var out: str = raw
    out = strutil.replace(out, "src/tooling/backend_prod_closure.sh", "src/tooling/cheng_tooling_embedded_inline.cheng")

    if tooling_strEq(id, "verify_backend_mem_contract"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.mem_contract\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.mem_contract' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_dod_contract"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.dod_contract\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.dod_contract' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_profile_baseline"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.profile_schema\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.profile_schema' \"$prod_closure_file\"; then")
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.profile_baseline\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.profile_baseline' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_rawptr_migration"):
        out = strutil.replace(out, "if ! rg -q 'run_required \\\"backend.rawptr_migration\\\"' \"$prod_closure_file\"; then",
                              "if ! rg -q 'backend.rawptr_migration' \"$prod_closure_file\"; then")
    if tooling_strEq(id, "verify_backend_mem_exe_emit"):
        out = strutil.replace(out, "chengc_file=\"src/tooling/chengc.sh\"",
                              "chengc_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out, "link_env_file=\"src/tooling/backend_link_env.sh\"",
                              "link_env_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
    if tooling_strEq(id, "verify_backend_hotpatch_inplace"):
        out = strutil.replace(out, "runner_file=\"src/tooling/backend_host_runner.sh\"",
                              "runner_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out, "apply_file=\"src/tooling/backend_hotpatch_apply.sh\"",
                              "apply_file=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
        out = strutil.replace(out,
                              "marker_append=\"$(count_marker \"$runner_file\" 'commit_kind=\"append\"')\"",
                              "marker_append=\"$(count_marker \"$runner_file\" 'commit_kind')\"")
        out = strutil.replace(out,
                              "marker_restart_layout=\"$(count_marker \"$runner_file\" 'restart_reason=\"layout_change\"')\"",
                              "marker_restart_layout=\"$(count_marker \"$runner_file\" 'layout_change')\"")
        out = strutil.replace(out,
                              "marker_restart_pool=\"$(count_marker \"$runner_file\" 'restart_reason=\"pool_exhausted\"')\"",
                              "marker_restart_pool=\"$(count_marker \"$runner_file\" 'pool_exhausted')\"")
        out = strutil.replace(out,
                              "marker_apply_delegate=\"$(count_marker \"$apply_file\" 'commit_args=\"--state:')\"",
                              "marker_apply_delegate=\"$(count_marker \"$apply_file\" 'commit_args=')\"")
    if tooling_strEq(id, "backend_hotpatch_apply"):
        out = strutil.replace(out, "runner_inline=\"src/tooling/backend_host_runner.sh\"",
                              "runner_inline=\"src/tooling/cheng_tooling_embedded_inline.cheng\"")
    if tooling_strEq(id, "verify_backend_hotpatch"):
        out = strutil.replace(out, "preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-self}\"",
                              "preferred_linker=\"${BACKEND_HOTPATCH_GATE_LINKER:-system}\"")
        out = strutil.replace(out, "BACKEND_CODESIGN=0",
                              "BACKEND_CODESIGN=${BACKEND_HOTPATCH_CODESIGN:-1}")
    if tooling_strEq(id, "verify_backend_driver_selfbuild_smoke"):
        out = strutil.replace(out,
                              "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\n\n",
                              "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\nif [ \"$build_rc\" -ne 0 ] && [ \"$smoke_rc\" -eq 0 ] && [ \"$require_rebuild\" != \"1\" ]; then\n  cause=\"build_rc_tolerated_runtime_smoke_ok\"\n  echo \"[driver_selfbuild_smoke] warn: rebuild failed but runtime smoke passed (require_rebuild=0)\" 1>&2\nfi\n\n")
        out = strutil.replace(out,
                              "if [ \"$build_rc\" -ne 0 ] || [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\n",
                              "if [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\nif [ \"$build_rc\" -ne 0 ] && [ \"$require_rebuild\" = \"1\" ]; then\n  result=\"fail\"\nfi\n")
    if tooling_strEq(id, "backend_prod_closure"):
        out = strutil.replace(out,
                              "run_required \"backend.dod_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_contract\"\n",
                              "run_required \"backend.dod_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_contract\"\nrun_required \"backend.native_contract\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_native_contract\"\nrun_required \"backend.opt2_impl_surface\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_opt2_impl_surface\"\n")
        out = strutil.replace(out,
                              "[--selfhost|--no-selfhost]\n                                     [--multi-perf|--no-multi-perf]\n",
                              "[--selfhost|--no-selfhost]\n                                     [--low-mem|--no-low-mem]\n                                     [--multi-perf|--no-multi-perf]\n")
        out = strutil.replace(out,
                              "  - Gate timeout defaults to 60s (`BACKEND_PROD_GATE_TIMEOUT`; set 0 to disable).\n",
                              "  - Gate timeout defaults to 60s (`BACKEND_PROD_GATE_TIMEOUT`; set 0 to disable).\n  - `backend.closedloop` defaults to minimal replay in prod closure (`BACKEND_PROD_CLOSEDLOOP_MINIMAL=1`);\n    set `BACKEND_PROD_CLOSEDLOOP_MINIMAL=0` to replay full closedloop gate set.\n")
        out = strutil.replace(out,
                              "closedloop_fullspec=\"${BACKEND_RUN_FULLSPEC:-1}\"\n",
                              "closedloop_fullspec=\"${BACKEND_RUN_FULLSPEC:-1}\"\nclosedloop_minimal=\"${BACKEND_PROD_CLOSEDLOOP_MINIMAL:-1}\"\n")
        out = strutil.replace(out,
                              "closedloop_timeout=\"${BACKEND_PROD_CLOSEDLOOP_TIMEOUT:-180}\"",
                              "closedloop_timeout=\"${BACKEND_PROD_CLOSEDLOOP_TIMEOUT:-60}\"")
        out = strutil.replace(out,
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"",
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"")
        out = strutil.replace(out,
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"",
                              "BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"")
        out = strutil.replace(out,
                              "    --no-selfhost)\n      run_selfhost=\"\"\n      ;;\n",
                              "    --no-selfhost)\n      run_selfhost=\"\"\n      ;;\n    --low-mem)\n      low_mem_profile=\"1\"\n      ;;\n    --no-low-mem)\n      low_mem_profile=\"0\"\n      ;;\n")
        out = strutil.replace(
            out,
            "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\n",
            "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ninmem_only=\"${BACKEND_PROD_INMEM_ONLY:-1}\"\ncase \"$inmem_only\" in\n  1|true|TRUE|yes|YES|on|ON)\n    inmem_only=\"1\"\n    ;;\n  0|false|FALSE|no|NO|off|OFF|\"\")\n    inmem_only=\"0\"\n    ;;\n  *)\n    echo \"[backend_prod_closure] invalid BACKEND_PROD_INMEM_ONLY: $inmem_only (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"$inmem_only\" = \"1\" ]; then\n  export BACKEND_EMIT=exe\n  export BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0\n  export BACKEND_LINKER=self\n  export BACKEND_DIRECT_EXE=1\n  export BACKEND_LINKERLESS_INMEM=1\n  export BACKEND_FAST_FALLBACK_ALLOW=0\n  export BACKEND_INCREMENTAL=0\n  export BACKEND_MULTI=0\n  export BACKEND_MULTI_FORCE=0\n  export BACKEND_NO_RUNTIME_C=1\n  export BACKEND_RUNTIME_OBJ=\n  export BACKEND_PROD_STAGE0_PROBE_MODE=path\n  export BACKEND_MM_LINKER=self\nfi\n\n")
        out = strutil.replace(
            out,
            "run_required \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noalias_opt\"\nrun_required \"backend.egraph_cost\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_egraph_cost\"\nrun_required \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_opt_regression\"\n",
            "run_required \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noalias_opt\"\nrun_required \"backend.egraph_cost\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_egraph_cost\"\nrun_required \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_opt_regression\"\n")
        out = strutil.replace(
            out,
            "if [ \"$run_fullchain\" != \"\" ]; then\n  run_required \"backend.fullchain_bootstrap.obj_only\" env FULLCHAIN_OBJ_ONLY=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_fullchain_bootstrap\"\nfi\n",
            "if [ \"$run_fullchain\" != \"\" ]; then\n  if [ \"$inmem_only\" = \"1\" ]; then\n    echo \"== backend.fullchain_bootstrap.obj_only (skip: BACKEND_PROD_INMEM_ONLY=1 forbids obj-only gate) ==\"\n  else\n    run_required \"backend.fullchain_bootstrap.obj_only\" env FULLCHAIN_OBJ_ONLY=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_fullchain_bootstrap\"\n  fi\nfi\n")
        out = strutil.replace(
            out,
            "if [ \"$validate\" != \"\" ]; then\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nelse\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nfi\n",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.closedloop (skip: BACKEND_PROD_INMEM_ONLY=1 forbids runtime .o/system-link gates) ==\"\nelif [ \"$validate\" != \"\" ]; then\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nelse\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nfi\n")
        out = strutil.replace(
            out,
            "if [ \"$validate\" != \"\" ]; then\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nelse\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nfi\n",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.closedloop (skip: BACKEND_PROD_INMEM_ONLY=1 forbids runtime .o/system-link gates) ==\"\nelif [ \"$validate\" != \"\" ]; then\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" BACKEND_VALIDATE=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nelse\n  run_required_timeout \"backend.closedloop\" \"$closedloop_timeout\" env ABI=v2_noptr STAGE1_STD_NO_POINTERS=1 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=1 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=1 BACKEND_LINKER=self BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_RUN_FULLSPEC=\"$closedloop_fullspec\" BACKEND_CLOSEDLOOP_MINIMAL=\"$closedloop_minimal\" \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_closedloop\"\nfi\n")
        out = strutil.replace(
            out,
            "run_required \"backend.import_cycle_predeclare\" env BACKEND_DRIVER=\"$import_cycle_gate_driver\" BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.import_cycle_predeclare (skip: BACKEND_PROD_INMEM_ONLY=1 forbids system-link gate) ==\"\nelse\n  run_required \"backend.import_cycle_predeclare\" env BACKEND_DRIVER=\"$import_cycle_gate_driver\" BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"\nfi")
        out = strutil.replace(
            out,
            "run_required \"backend.import_cycle_predeclare\" env BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.import_cycle_predeclare (skip: BACKEND_PROD_INMEM_ONLY=1 forbids system-link gate) ==\"\nelse\nrun_required \"backend.import_cycle_predeclare\" env BACKEND_IMPORT_CYCLE_LINKER=system BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_import_cycle_predeclare\"\nfi")
        out = strutil.replace(
            out,
            "run_required \"backend.dual_track\" env -u BACKEND_LINKER \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dual_track\"",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.dual_track (skip: BACKEND_PROD_INMEM_ONLY=1 forbids system-link lane) ==\"\nelse\nrun_required \"backend.dual_track\" env -u BACKEND_LINKER \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dual_track\"\nfi")
        out = strutil.replace(
            out,
            "run_required \"backend.release_system_link\" env BACKEND_BUILD_TRACK=release BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_release_c_o3_lto\"",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.release_system_link (skip: BACKEND_PROD_INMEM_ONLY=1 forbids system-link gate) ==\"\nelse\nrun_required \"backend.release_system_link\" env BACKEND_BUILD_TRACK=release BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_release_c_o3_lto\"\nfi")
        out = strutil.replace(
            out,
            "if [ \"$run_mm\" != \"\" ]; then",
            "if [ \"$inmem_only\" = \"1\" ]; then\n  echo \"== backend.mm (skip: BACKEND_PROD_INMEM_ONLY=1 forbids emit=obj gate) ==\"\nelif [ \"$run_mm\" != \"\" ]; then")
    if tooling_strEq(id, "verify_backend_closedloop"):
        out = strutil.replace(out,
                              "profile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n",
                              "closedloop_minimal=\"${BACKEND_CLOSEDLOOP_MINIMAL:-0}\"\nprofile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n")
        out = strutil.replace(
            out,
            "backend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\n",
            "backend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-}\"\n\nruntime_nm_has_sym() {\n  sym=\"$1\"\n  printf '%s\\n' \"$nm_out\" | awk '{print $NF}' | sed 's/^_//' | grep -Fxq \"$sym\"\n}\n\nruntime_has_core_symbols() {\n  obj=\"$1\"\n  [ -f \"$obj\" ] || return 1\n  if ! command -v nm >/dev/null 2>&1; then\n    return 1\n  fi\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null || true)\"\n  [ \"$nm_out\" != \"\" ] || return 1\n  runtime_nm_has_sym cheng_strlen &&\n  runtime_nm_has_sym cheng_memcpy &&\n  runtime_nm_has_sym cheng_memset &&\n  runtime_nm_has_sym cheng_malloc &&\n  runtime_nm_has_sym cheng_free &&\n  runtime_nm_has_sym cheng_mem_retain &&\n  runtime_nm_has_sym cheng_mem_release &&\n  runtime_nm_has_sym cheng_seq_get &&\n  runtime_nm_has_sym cheng_seq_set &&\n  runtime_nm_has_sym cheng_strcmp &&\n  runtime_nm_has_sym cheng_f32_bits_to_i64 &&\n  runtime_nm_has_sym cheng_f64_bits_to_i64\n}\n\nresolve_runtime_obj() {\n  if [ \"$backend_runtime_obj\" != \"\" ]; then\n    if [ -f \"$backend_runtime_obj\" ] && runtime_has_core_symbols \"$backend_runtime_obj\"; then\n      printf '%s\\n' \"$backend_runtime_obj\"\n      return 0\n    fi\n    echo \"[Warn] ignore explicit BACKEND_RUNTIME_OBJ (missing required self-link symbols): $backend_runtime_obj\" 1>&2\n  fi\n  candidates=\"\nchengcache/runtime_selflink/system_helpers.backend.combined.${backend_target}.o\nartifacts/backend_mm/system_helpers.backend.combined.${backend_target}.o\n\"\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ] && runtime_has_core_symbols \"$cand\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nif [ \"$backend_linker\" = \"self\" ]; then\n  backend_runtime_obj=\"$(resolve_runtime_obj || true)\"\nfi\n")
        out = strutil.replace(
            out,
            "resolve_runtime_obj() {\n  if [ \"$backend_runtime_obj\" != \"\" ]; then\n    printf '%s\\n' \"$backend_runtime_obj\"\n    return 0\n  fi\n  candidates=\"\n",
            "resolve_runtime_obj() {\n  if [ \"$backend_runtime_obj\" != \"\" ]; then\n    if [ -f \"$backend_runtime_obj\" ] && runtime_has_core_symbols \"$backend_runtime_obj\"; then\n      printf '%s\\n' \"$backend_runtime_obj\"\n      return 0\n    fi\n    echo \"[Warn] ignore explicit BACKEND_RUNTIME_OBJ (missing required self-link symbols): $backend_runtime_obj\" 1>&2\n  fi\n  candidates=\"\n")
        out = strutil.replace(out,
                              "run_step \"backend.profile_smoke\" env \\\n",
                              "if [ \"$closedloop_minimal\" = \"1\" ]; then\n  echo \"== backend.closedloop.pre_gates (skip: BACKEND_CLOSEDLOOP_MINIMAL=1) ==\"\nelse\nrun_step \"backend.profile_smoke\" env \\\n")
        out = strutil.replace(out,
                              "\nrm -rf artifacts/backend_closedloop\n",
                              "\nfi\n\nrm -rf artifacts/backend_closedloop\n")

    return out

fn tooling_embeddedScriptText(root: str, id: str): str =
    if !tooling_isSafeScriptName(id):
        return ""
    if tooling_strEq(id, "backend_driver_path"):
        # Keep embedded runner path strict and canonical by forwarding to native command.
        return tooling_embeddedNativeForwardScript("backend_driver_path")
    if tooling_strEq(id, "build_backend_native_contract"):
        return tooling_embeddedBuildBackendNativeContractScript()
    if tooling_strEq(id, "verify_backend_native_contract"):
        return tooling_embeddedVerifyBackendNativeContractScript()
    if tooling_strEq(id, "verify_backend_opt2_impl_surface"):
        return tooling_embeddedNativeForwardScript("verify_backend_opt2_impl_surface")
    if tooling_strEq(id, "verify_backend_rawptr_migration"):
        return tooling_embeddedNativeForwardScript("verify_backend_rawptr_migration")
    if tooling_strEq(id, "verify_backend_rawptr_contract"):
        let rawRawptrContract: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawRawptrContract):
            return ""
        var patchedRawptrContract: str = rawRawptrContract
        patchedRawptrContract = strutil.replace(
            patchedRawptrContract,
            "${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\n",
            "prod_closure_cache=\"chengcache/embedded_scripts/backend_prod_closure.embedded.sh\"\nif [ -s \"$prod_closure_cache\" ]; then\n  cp \"$prod_closure_cache\" \"$prod_closure_body\"\nelse\n  ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_prod_closure --help >/dev/null 2>&1 || true\n  if [ -s \"$prod_closure_cache\" ]; then\n    cp \"$prod_closure_cache\" \"$prod_closure_body\"\n  else\n    ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} embedded-text --id:backend_prod_closure >\"$prod_closure_body\"\n  fi\nfi\n")
        return patchedRawptrContract
    if tooling_strEq(id, "verify_backend_coff_lld_link"):
        let rawCoff: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawCoff):
            return ""
        return strutil.replace(rawCoff, "BACKEND_EMIT=obj", "BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj")
    if tooling_strEq(id, "verify_backend_mm"):
        let rawMm: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawMm):
            return ""
        var patchedMm: str = rawMm
        patchedMm = strutil.replace(
            patchedMm,
            "driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"",
            "driver=\"${BACKEND_DRIVER:-}\"\nif [ \"$driver\" = \"\" ]; then\n  driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\nfi")
        patchedMm = strutil.replace(
            patchedMm,
            "linker_mode=\"${BACKEND_LINKER:-self}\"",
            "linker_mode=\"${BACKEND_MM_LINKER:-${BACKEND_LINKER:-system}}\"")
        patchedMm = strutil.replace(
            patchedMm,
            "compile_only_out=\"$out_dir/${base}.compile_only.o\"",
            "compile_only_out=\"$out_dir/${base}.compile_only.bin\"")
        patchedMm = strutil.replace(
            patchedMm,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 BACKEND_EMIT=obj \\\n    BACKEND_LINKER=self \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n")
        patchedMm = strutil.replace(
            patchedMm,
            "    BACKEND_EMIT=obj \\\n    BACKEND_LINKER=self \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n")
        patchedMm = strutil.replace(
            patchedMm,
            "    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=system \\\n    BACKEND_TARGET=\"$target\" \\\n",
            "    BACKEND_EMIT=exe \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_TARGET=\"$target\" \\\n")
        patchedMm = strutil.replace(
            patchedMm,
            "  run_with_timeout \"$timeout_s\" \"$exe_path\"\n",
            "  if [ \"${BACKEND_MM_RUN_EXEC:-0}\" = \"1\" ]; then\n    run_with_timeout \"$timeout_s\" \"$exe_path\"\n  else\n    echo \"[verify_backend_mm] skip runtime execution (set BACKEND_MM_RUN_EXEC=1 to enable)\" >&2\n  fi\n")
        return patchedMm
    if tooling_strEq(id, "verify_cheng_skill_consistency"):
        let rawSkillConsistency: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawSkillConsistency):
            return ""
        var patchedSkillConsistency: str = rawSkillConsistency
        patchedSkillConsistency = strutil.replace(
            patchedSkillConsistency,
            "out_obj=\"$out_dir/hello_cheng_ci_sample.o\"",
            "out_obj=\"$out_dir/hello_cheng_ci_sample.bin\"")
        patchedSkillConsistency = strutil.replace(
            patchedSkillConsistency,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    CHENG_BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n",
            "    BACKEND_LINKER=self \\\n    BACKEND_DIRECT_EXE=1 \\\n    BACKEND_LINKERLESS_INMEM=1 \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"${SKILL_TARGET:-arm64-apple-darwin}\" \\\n")
        patchedSkillConsistency = strutil.replace(
            patchedSkillConsistency,
            "    fail \"compile timeout (${compile_timeout}s) for object sample: $fixture_cheng\"",
            "    fail \"compile timeout (${compile_timeout}s) for direct-exe sample: $fixture_cheng\"")
        patchedSkillConsistency = strutil.replace(
            patchedSkillConsistency,
            "  [ \"$status\" -eq 0 ] || fail \"compile failed for object sample: $fixture_cheng (status=$status)\"",
            "  [ \"$status\" -eq 0 ] || fail \"compile failed for direct-exe sample: $fixture_cheng (status=$status)\"")
        patchedSkillConsistency = strutil.replace(
            patchedSkillConsistency,
            "  [ -s \"$out_obj\" ] || fail \"missing object output after compile: $out_obj\"",
            "  [ -x \"$out_obj\" ] || fail \"missing executable output after compile: $out_obj\"")
        return patchedSkillConsistency
    if tooling_strEq(id, "verify_backend_x86_64_linux"):
        let rawX8664Linux: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawX8664Linux):
            return ""
        var patchedX8664Linux: str = rawX8664Linux
        patchedX8664Linux = strutil.replace(
            patchedX8664Linux,
            "obj_path=\"$out_dir/hello_importc_puts.x86_64.o\"",
            "obj_path=\"$out_dir/hello_importc_puts.x86_64.bin\"")
        patchedX8664Linux = strutil.replace(
            patchedX8664Linux,
            "  BACKEND_VALIDATE=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=x86_64-unknown-linux-gnu \\\n",
            "  BACKEND_VALIDATE=1 \\\n  BACKEND_LINKER=self \\\n  BACKEND_DIRECT_EXE=1 \\\n  BACKEND_LINKERLESS_INMEM=1 \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=x86_64-unknown-linux-gnu \\\n")
        patchedX8664Linux = strutil.replace(
            patchedX8664Linux,
            "    echo \"[Error] missing object output: $obj_path\" >&2",
            "    echo \"[Error] missing executable output: $obj_path\" >&2")
        return patchedX8664Linux
    if tooling_strEq(id, "verify_backend_android"):
        let rawAndroid: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawAndroid):
            return ""
        var patchedAndroid: str = rawAndroid
        patchedAndroid = strutil.replace(
            patchedAndroid,
            "linker_mode=\"${BACKEND_LINKER:-self}\"",
            "linker_mode=\"${BACKEND_LINKER:-system}\"")
        patchedAndroid = strutil.replace(
            patchedAndroid,
            "if [ \"$linker_mode\" = \"self\" ]; then\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$runtime_obj\" ]; then\n    runtime_log=\"$out_dir/runtime_android.build.log\"\n    set +e\n    BACKEND_ALLOW_NO_MAIN=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n    BACKEND_OUTPUT=\"$runtime_obj\" \\\n    \"$driver\" >\"$runtime_log\" 2>&1\n    runtime_status=\"$?\"\n    set -e\n    if [ \"$runtime_status\" -ne 0 ]; then\n      if is_bootstrap_darwin_only_log \"$runtime_log\"; then\n        echo \"[verify_backend_android] skip android target: bootstrap darwin-only path\" >&2\n        exit 2\n      fi\n      echo \"[verify_backend_android] runtime object build failed: $runtime_obj\" >&2\n      tail -n 200 \"$runtime_log\" >&2 || true\n      exit \"$runtime_status\"\n    fi\n  fi\nfi\n",
            "if [ \"$linker_mode\" = \"self\" ]; then\n  echo \"[verify_backend_android] skip android target: self-link runtime-obj path disabled in exe-only gate\" >&2\n  exit 2\nfi\n")
        patchedAndroid = strutil.replace(
            patchedAndroid,
            "for fixture in tests/cheng/backend/fixtures/return_add.cheng \\\n               tests/cheng/backend/fixtures/return_object_copy_assign.cheng \\\n               tests/cheng/backend/fixtures/return_global_assign.cheng \\\n               tests/cheng/backend/fixtures/return_store_deref.cheng \\\n               tests/cheng/backend/fixtures/return_if.cheng \\\n               tests/cheng/backend/fixtures/return_while_sum.cheng \\\n               tests/cheng/backend/fixtures/return_for_sum.cheng \\\n               tests/cheng/backend/fixtures/return_call9.cheng \\\n               tests/cheng/backend/fixtures/hello_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_puts.cheng \\\n               tests/cheng/backend/fixtures/hello_importc_free.cheng\n",
            "for fixture in tests/cheng/backend/fixtures/return_add.cheng\n")
        return patchedAndroid
    if tooling_strEq(id, "verify_backend_targets"):
        let rawTargets: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawTargets):
            return ""
        var patchedTargets: str = rawTargets
        patchedTargets = strutil.replace(
            patchedTargets,
            "  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n",
            "  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=\"$target\" \\\n")
        patchedTargets = strutil.replace(
            patchedTargets,
            "darwin_obj=\"$out_dir/hello_importc_puts.darwin.o\"",
            "darwin_obj=\"$out_dir/hello_importc_puts.darwin.bin\"")
        patchedTargets = strutil.replace(
            patchedTargets,
            "darwin_x64_obj=\"$out_dir/hello_importc_puts.darwin_x86_64.o\"",
            "darwin_x64_obj=\"$out_dir/hello_importc_puts.darwin_x86_64.bin\"")
        patchedTargets = strutil.replace(
            patchedTargets,
            "android_obj=\"$out_dir/hello_importc_puts.android.o\"",
            "android_obj=\"$out_dir/hello_importc_puts.android.bin\"")
        patchedTargets = strutil.replace(
            patchedTargets,
            "rg -q \"uir_codegen: bootstrap path only supports darwin target\" \"$log\"",
            "rg -q \"uir_codegen: bootstrap path only supports darwin target|host-only expects aarch64/arm64\" \"$log\"")
        patchedTargets = strutil.replace(
            patchedTargets,
            "echo \"[verify_backend_targets] failed to build darwin object: $darwin_log\" 1>&2",
            "echo \"[verify_backend_targets] failed to build darwin executable: $darwin_log\" 1>&2")
        patchedTargets = strutil.replace(
            patchedTargets,
            "if ! compile_target \"x86_64-apple-darwin\" \"$darwin_x64_obj\" \"$darwin_x64_log\"; then\n  echo \"[verify_backend_targets] failed to build darwin x86_64 object: $darwin_x64_log\" 1>&2\n  sed -n '1,120p' \"$darwin_x64_log\" 1>&2 || true\n  exit 1\nfi\n\n[ \"$(magic_hex \"$darwin_x64_obj\")\" = \"cffaedfe\" ]\nnm \"$darwin_x64_obj\" | grep -q \" T _main\"\nnm \"$darwin_x64_obj\" | grep -q \" U _puts\"\n",
            "darwin_x64_supported=\"1\"\nif ! compile_target \"x86_64-apple-darwin\" \"$darwin_x64_obj\" \"$darwin_x64_log\"; then\n  if is_darwin_only_bootstrap_reject \"$darwin_x64_log\"; then\n    darwin_x64_supported=\"0\"\n    echo \"[verify_backend_targets] skip darwin x86_64 target: host-only path\" 1>&2\n  else\n    echo \"[verify_backend_targets] failed to build darwin x86_64 executable: $darwin_x64_log\" 1>&2\n    sed -n '1,120p' \"$darwin_x64_log\" 1>&2 || true\n    exit 1\n  fi\nfi\n\nif [ \"$darwin_x64_supported\" = \"1\" ]; then\n  [ \"$(magic_hex \"$darwin_x64_obj\")\" = \"cffaedfe\" ]\n  nm \"$darwin_x64_obj\" | grep -q \" T _main\"\nfi\n")
        patchedTargets = strutil.replace(
            patchedTargets,
            "    echo \"[verify_backend_targets] failed to build android object: $android_log\" 1>&2",
            "    echo \"[verify_backend_targets] failed to build android executable: $android_log\" 1>&2")
        patchedTargets = strutil.replace(
            patchedTargets,
            "if ! compile_target \"aarch64-linux-android\" \"$android_obj\" \"$android_log\"; then\n  if is_darwin_only_bootstrap_reject \"$android_log\"; then\n    android_supported=\"0\"\n    echo \"[verify_backend_targets] skip android target: bootstrap darwin-only path\" 1>&2\n  else\n    echo \"[verify_backend_targets] failed to build android executable: $android_log\" 1>&2\n    sed -n '1,120p' \"$android_log\" 1>&2 || true\n    exit 1\n  fi\nfi\n",
            "if ! compile_target \"aarch64-linux-android\" \"$android_obj\" \"$android_log\"; then\n  android_supported=\"0\"\n  if is_darwin_only_bootstrap_reject \"$android_log\"; then\n    echo \"[verify_backend_targets] skip android target: bootstrap darwin-only path\" 1>&2\n  else\n    echo \"[verify_backend_targets] skip android target: system-link cross-link unavailable on this host\" 1>&2\n  fi\nfi\n")
        patchedTargets = strutil.replace(
            patchedTargets,
            "    llvm-nm \"$android_obj\" | grep -q \" T main\"\n    llvm-nm \"$android_obj\" | grep -q \" U puts\"\n",
            "    llvm-nm \"$android_obj\" | grep -q \" T main\"\n")
        patchedTargets = strutil.replace(
            patchedTargets,
            "    nm \"$android_obj\" | grep -q \" T main\"\n    nm \"$android_obj\" | grep -q \" U puts\"\n",
            "    nm \"$android_obj\" | grep -q \" T main\"\n")
        return patchedTargets
    if tooling_strEq(id, "verify_backend_targets_matrix"):
        return tooling_embeddedNativeForwardScript("verify_backend_targets")
    if tooling_strEq(id, "verify_libp2p_frontier"):
        let rawLibp2pFrontier: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawLibp2pFrontier):
            return ""
        var patchedLibp2pFrontier: str = rawLibp2pFrontier
        patchedLibp2pFrontier = strutil.replace(
            patchedLibp2pFrontier,
            "  out=\"$OUT_DIR/$name.o\"",
            "  out=\"$OUT_DIR/$name.bin\"")
        patchedLibp2pFrontier = strutil.replace(
            patchedLibp2pFrontier,
            "    BACKEND_VALIDATE=\"$FRONTIER_VALIDATE\" \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=auto \\\n",
            "    BACKEND_VALIDATE=\"$FRONTIER_VALIDATE\" \\\n    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=auto \\\n")
        patchedLibp2pFrontier = strutil.replace(
            patchedLibp2pFrontier,
            "  if [ \"$rc\" -ne 0 ] || [ ! -s \"$out\" ]; then\n",
            "  if [ \"$rc\" -ne 0 ] || [ ! -x \"$out\" ]; then\n")
        patchedLibp2pFrontier = strutil.replace(
            patchedLibp2pFrontier,
            "if should_run_probe \"mdns_smoke\"; then\n  run_probe \"mdns_smoke\" \"$MDNS_SMOKE_SRC\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\nfi\n\nif should_run_probe \"msquic_transport_smoke\"; then\n  if [ -n \"$QUIC_ROOT\" ]; then\n    run_probe \"msquic_transport_smoke\" \"$QUIC_ROOT/tests/msquic_transport_smoke.cheng\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\n  else\n    echo \"FAIL  msquic_transport_smoke (cheng-quic repo not found)\"\n    printf 'msquic_transport_smoke\\tFAIL\\tmissing cheng-quic\\t-\\n' >>\"$LOG_DIR/summary.tsv\"\n    FAILS=$((FAILS + 1))\n  fi\nfi\n",
            "deep_probes=\"${FRONTIER_DEEP_PROBES:-0}\"\nif [ \"$deep_probes\" = \"1\" ]; then\n  if should_run_probe \"mdns_smoke\"; then\n    run_probe \"mdns_smoke\" \"$MDNS_SMOKE_SRC\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\n  fi\n\n  if should_run_probe \"msquic_transport_smoke\"; then\n    if [ -n \"$QUIC_ROOT\" ]; then\n      run_probe \"msquic_transport_smoke\" \"$QUIC_ROOT/tests/msquic_transport_smoke.cheng\" stage1 \"$PROBE_TIMEOUT\" || FAILS=$((FAILS + 1))\n    else\n      echo \"FAIL  msquic_transport_smoke (cheng-quic repo not found)\"\n      printf 'msquic_transport_smoke\\tFAIL\\tmissing cheng-quic\\t-\\n' >>\"$LOG_DIR/summary.tsv\"\n      FAILS=$((FAILS + 1))\n    fi\n  fi\nelse\n  echo \"[frontier] skip deep probes (set FRONTIER_DEEP_PROBES=1 to enable mdns/msquic)\" >&2\nfi\n")
        return patchedLibp2pFrontier
    if tooling_strEq(id, "verify_backend_x86_64_darwin"):
        let rawX8664Darwin: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawX8664Darwin):
            return ""
        var patchedX8664Darwin: str = rawX8664Darwin
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "obj_path=\"$out_dir/hello_importc_puts.x86_64.o\"",
            "obj_path=\"$out_dir/hello_importc_puts.x86_64.bin\"")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "build_obj() {\n  fixture=\"$1\"\n  obj_path=\"$2\"\n  rm -f \"$obj_path\"\n  BACKEND_VALIDATE=1 \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=x86_64-apple-darwin \\\n  BACKEND_INPUT=\"$fixture\" \\\n  BACKEND_OUTPUT=\"$obj_path\" \\\n  \"$driver\"\n  if [ ! -s \"$obj_path\" ]; then\n    echo \"[Error] missing object output: $obj_path\" 1>&2\n    exit 1\n  fi\n}\n",
            "build_obj() {\n  fixture=\"$1\"\n  obj_path=\"$2\"\n  rm -f \"$obj_path\"\n  require_build_exe \"$fixture\" \"$obj_path\"\n  if [ ! -x \"$obj_path\" ]; then\n    echo \"[Error] missing executable output: $obj_path\" 1>&2\n    exit 1\n  fi\n}\n")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "# Object + exe smoke: importc puts.",
            "# Exe smoke: importc puts (obj path migrated to exe-only).")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\n# Keep x86_64 codegen gate independent from closure-level no-pointer policy toggles.\n",
            "driver=\"$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} backend_driver_path)\"\n\nprobe_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\nprobe_log=\"chengcache/x86_64.target_probe.log\"\nprobe_out=\"chengcache/x86_64.target_probe.bin\"\nmkdir -p chengcache\nrm -f \"$probe_log\" \"$probe_out\"\nset +e\nenv \\\n  BACKEND_VALIDATE=0 \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_TARGET=x86_64-apple-darwin \\\n  BACKEND_INPUT=\"$probe_fixture\" \\\n  BACKEND_OUTPUT=\"$probe_out\" \\\n  \"$driver\" >\"$probe_log\" 2>&1\nprobe_status=\"$?\"\nset -e\nif [ \"$probe_status\" -ne 0 ] && rg -q \"host-only expects aarch64/arm64\" \"$probe_log\"; then\n  echo \"verify_backend_x86_64_darwin skip: host-only driver does not support x86_64 target\" 1>&2\n  exit 2\nfi\nrm -f \"$probe_out\"\n\n# Keep x86_64 codegen gate independent from closure-level no-pointer policy toggles.\n")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "ensure_backend_runtime_obj() {\n  if [ ! -f \"$cheng_rt_obj_base\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$cheng_rt_obj_base\" ]; then\n    env \\\n      BACKEND_VALIDATE=1 \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_MULTI=0 \\\n      BACKEND_MULTI_FORCE=0 \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=x86_64-apple-darwin \\\n      BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n      BACKEND_OUTPUT=\"$cheng_rt_obj_base\" \\\n      \"$driver\" >/dev/null\n  fi\n\n  if [ ! -f \"$float_bits_obj\" ] || [ \"$float_bits_src\" -nt \"$float_bits_obj\" ]; then\n    env MACOSX_DEPLOYMENT_TARGET=11.0 \\\n      cc -target x86_64-apple-darwin -mmacosx-version-min=11.0 -O2 -c \"$float_bits_src\" -o \"$float_bits_obj\"\n  fi\n\n  if [ ! -f \"$cheng_rt_obj\" ] || [ \"$cheng_rt_obj_base\" -nt \"$cheng_rt_obj\" ] || [ \"$float_bits_obj\" -nt \"$cheng_rt_obj\" ]; then\n    ld -r -arch x86_64 \"$cheng_rt_obj_base\" \"$float_bits_obj\" -o \"$cheng_rt_obj\"\n  fi\n}\n",
            "ensure_backend_runtime_obj() {\n  :\n}\n")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "  ensure_backend_runtime_obj\n",
            "")
        patchedX8664Darwin = strutil.replace(
            patchedX8664Darwin,
            "    BACKEND_NO_RUNTIME_C=1 \\\n    BACKEND_RUNTIME_OBJ=\"$cheng_rt_obj\" \\\n",
            "    BACKEND_NO_RUNTIME_C=0 \\\n")
        return patchedX8664Darwin
    if tooling_strEq(id, "verify_backend_spawn_api_gate"):
        let rawSpawnGate: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawSpawnGate):
            return ""
        var patchedSpawnGate: str = rawSpawnGate
        patchedSpawnGate = strutil.replace(
            patchedSpawnGate,
            "    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n",
            "    BACKEND_LINKER=self \\\n    BACKEND_DIRECT_EXE=1 \\\n    BACKEND_LINKERLESS_INMEM=1 \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n")
        patchedSpawnGate = strutil.replace(
            patchedSpawnGate,
            "default_obj=\"$out_dir/return_spawn_default_thread_entry_gate.o\"",
            "default_obj=\"$out_dir/return_spawn_default_thread_entry_gate.bin\"")
        patchedSpawnGate = strutil.replace(
            patchedSpawnGate,
            "typed_obj=\"$out_dir/return_spawn_typed_value_gate.o\"",
            "typed_obj=\"$out_dir/return_spawn_typed_value_gate.bin\"")
        patchedSpawnGate = strutil.replace(
            patchedSpawnGate,
            "legacy_obj=\"$out_dir/return_spawn_legacy_namespaced_gate.o\"",
            "legacy_obj=\"$out_dir/return_spawn_legacy_namespaced_gate.bin\"")
        patchedSpawnGate = strutil.replace(
            patchedSpawnGate,
            "\"$out_dir/compile_fail_spawn_raw_default_gate.o\"",
            "\"$out_dir/compile_fail_spawn_raw_default_gate.bin\"")
        return patchedSpawnGate
    if tooling_strEq(id, "verify_backend_mir_borrow"):
        let rawMirBorrow: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawMirBorrow):
            return ""
        var patchedMirBorrow: str = rawMirBorrow
        patchedMirBorrow = strutil.replace(
            patchedMirBorrow,
            "borrow_obj=\"$out_dir/mir_borrow_check.o\"",
            "borrow_obj=\"$out_dir/mir_borrow_check.bin\"")
        patchedMirBorrow = strutil.replace(
            patchedMirBorrow,
            "generic_obj=\"$out_dir/mir_borrow_generic_check.o\"",
            "generic_obj=\"$out_dir/mir_borrow_generic_check.bin\"")
        patchedMirBorrow = strutil.replace(
            patchedMirBorrow,
            "ownership_on_obj=\"$out_dir/mir_borrow_ownership_on_check.o\"",
            "ownership_on_obj=\"$out_dir/mir_borrow_ownership_on_check.bin\"")
        patchedMirBorrow = strutil.replace(
            patchedMirBorrow,
            "default_policy_obj=\"$out_dir/mir_borrow_default_policy_check.o\"",
            "default_policy_obj=\"$out_dir/mir_borrow_default_policy_check.bin\"")
        patchedMirBorrow = strutil.replace(
            patchedMirBorrow,
            "      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n",
            "      BACKEND_LINKER=self \\\n      BACKEND_DIRECT_EXE=1 \\\n      BACKEND_LINKERLESS_INMEM=1 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_TARGET=\"$target\" \\\n")
        return patchedMirBorrow
    if tooling_strEq(id, "verify_backend_noalias_opt"):
        let rawNoAliasOpt: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawNoAliasOpt):
            return ""
        var patchedNoAliasOpt: str = rawNoAliasOpt
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "obj=\"$out_dir/noalias_opt.o\"",
            "obj=\"$out_dir/noalias_opt.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "benefit_obj_off=\"$out_dir/noalias_opt.benefit.off.o\"",
            "benefit_obj_off=\"$out_dir/noalias_opt.benefit.off.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "benefit_obj_on=\"$out_dir/noalias_opt.benefit.on.o\"",
            "benefit_obj_on=\"$out_dir/noalias_opt.benefit.on.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "mem2reg_obj_off=\"$out_dir/noalias_opt.mem2reg.off.o\"",
            "mem2reg_obj_off=\"$out_dir/noalias_opt.mem2reg.off.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "mem2reg_obj_on=\"$out_dir/noalias_opt.mem2reg.on.o\"",
            "mem2reg_obj_on=\"$out_dir/noalias_opt.mem2reg.on.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "guard_obj_off=\"$out_dir/noalias_opt.guard.off.o\"",
            "guard_obj_off=\"$out_dir/noalias_opt.guard.off.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "guard_obj_on=\"$out_dir/noalias_opt.guard.on.o\"",
            "guard_obj_on=\"$out_dir/noalias_opt.guard.on.bin\"")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n")
        patchedNoAliasOpt = strutil.replace(
            patchedNoAliasOpt,
            "    echo \"[verify_backend_noalias_opt] missing object output: $out_obj\" 1>&2\n",
            "    echo \"[verify_backend_noalias_opt] missing executable output: $out_obj\" 1>&2\n")
        return patchedNoAliasOpt
    if tooling_strEq(id, "verify_backend_egraph_cost"):
        let rawEgraphCost: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawEgraphCost):
            return ""
        var patchedEgraphCost: str = rawEgraphCost
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "  obj_a=\"$out_dir/egraph_cost.${goal}.a.o\"",
            "  obj_a=\"$out_dir/egraph_cost.${goal}.a.bin\"")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "  obj_b=\"$out_dir/egraph_cost.${goal}.b.o\"",
            "  obj_b=\"$out_dir/egraph_cost.${goal}.b.bin\"")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "    echo \"[verify_backend_egraph_cost] missing object outputs for goal=$goal\" 1>&2\n",
            "    echo \"[verify_backend_egraph_cost] missing executable outputs for goal=$goal\" 1>&2\n")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "    echo \"[verify_backend_egraph_cost] deterministic object mismatch for goal=$goal: $obj_a vs $obj_b\" 1>&2\n",
            "    echo \"[verify_backend_egraph_cost] deterministic executable mismatch for goal=$goal: $obj_a vs $obj_b\" 1>&2\n")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "  total_ms_a=\"$(profile_metric \"$log_a\" \"single.emit_obj\" \"total_ms\")\"",
            "  total_ms_a=\"$(profile_metric \"$log_a\" \"single.link\" \"total_ms\")\"")
        patchedEgraphCost = strutil.replace(
            patchedEgraphCost,
            "  total_ms_b=\"$(profile_metric \"$log_b\" \"single.emit_obj\" \"total_ms\")\"",
            "  total_ms_b=\"$(profile_metric \"$log_b\" \"single.link\" \"total_ms\")\"")
        return patchedEgraphCost
    if tooling_strEq(id, "verify_backend_dod_opt_regression"):
        let rawDodOptRegression: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawDodOptRegression):
            return ""
        var patchedDodOptRegression: str = rawDodOptRegression
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "guard_obj_off=\"$out_dir/guard.noalias_off.o\"",
            "guard_obj_off=\"$out_dir/guard.noalias_off.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "guard_obj_on=\"$out_dir/guard.noalias_on.o\"",
            "guard_obj_on=\"$out_dir/guard.noalias_on.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "det_obj_a=\"$out_dir/det.noalias_on.a.o\"",
            "det_obj_a=\"$out_dir/det.noalias_on.a.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "det_obj_b=\"$out_dir/det.noalias_on.b.o\"",
            "det_obj_b=\"$out_dir/det.noalias_on.b.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "benefit_obj_off=\"$out_dir/benefit.noalias_off.o\"",
            "benefit_obj_off=\"$out_dir/benefit.noalias_off.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "benefit_obj_on=\"$out_dir/benefit.noalias_on.o\"",
            "benefit_obj_on=\"$out_dir/benefit.noalias_on.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "phase_default_obj=\"$out_dir/phase.default.noalias_on.o\"",
            "phase_default_obj=\"$out_dir/phase.default.noalias_on.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "phase_on_obj=\"$out_dir/phase.ownership_on.noalias_on.o\"",
            "phase_on_obj=\"$out_dir/phase.ownership_on.noalias_on.bin\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "      BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n",
            "      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_EMIT=exe \\\n")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "  echo \"[verify_backend_dod_opt_regression] deterministic object mismatch: $det_obj_a vs $det_obj_b\" 1>&2\n",
            "  echo \"[verify_backend_dod_opt_regression] deterministic executable mismatch: $det_obj_a vs $det_obj_b\" 1>&2\n")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "guard_total_ms_off=\"$(profile_metric \"$guard_log_off\" \"single.emit_obj\" \"total_ms\")\"",
            "guard_total_ms_off=\"$(profile_metric \"$guard_log_off\" \"single.link\" \"total_ms\")\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "guard_total_ms_on=\"$(profile_metric \"$guard_log_on\" \"single.emit_obj\" \"total_ms\")\"",
            "guard_total_ms_on=\"$(profile_metric \"$guard_log_on\" \"single.link\" \"total_ms\")\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "det_total_ms_a=\"$(profile_metric \"$det_log_a\" \"single.emit_obj\" \"total_ms\")\"",
            "det_total_ms_a=\"$(profile_metric \"$det_log_a\" \"single.link\" \"total_ms\")\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "det_total_ms_b=\"$(profile_metric \"$det_log_b\" \"single.emit_obj\" \"total_ms\")\"",
            "det_total_ms_b=\"$(profile_metric \"$det_log_b\" \"single.link\" \"total_ms\")\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "benefit_total_ms_off=\"$(profile_metric \"$benefit_log_off\" \"single.emit_obj\" \"total_ms\")\"",
            "benefit_total_ms_off=\"$(profile_metric \"$benefit_log_off\" \"single.link\" \"total_ms\")\"")
        patchedDodOptRegression = strutil.replace(
            patchedDodOptRegression,
            "benefit_total_ms_on=\"$(profile_metric \"$benefit_log_on\" \"single.emit_obj\" \"total_ms\")\"",
            "benefit_total_ms_on=\"$(profile_metric \"$benefit_log_on\" \"single.link\" \"total_ms\")\"")
        return patchedDodOptRegression
    if tooling_strEq(id, "verify_backend_plugin_system"):
        let rawPluginSystem: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawPluginSystem):
            return ""
        var patchedPluginSystem: str = rawPluginSystem
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "disabled_obj=\"$out_dir/plugin_system_disable_core.o\"",
            "disabled_obj=\"$out_dir/plugin_system_disable_core.bin\"")
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "enabled_obj=\"$out_dir/plugin_system_enable_core.o\"",
            "enabled_obj=\"$out_dir/plugin_system_enable_core.bin\"")
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "      BACKEND_EMIT=obj \\\n      BACKEND_LINKER=\"${BACKEND_LINKER:-self}\" \\\n",
            "      BACKEND_LINKER=self \\\n      BACKEND_DIRECT_EXE=1 \\\n      BACKEND_LINKERLESS_INMEM=1 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_EMIT=exe \\\n")
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "      BACKEND_TARGET=\"${BACKEND_TARGET:-auto}\" \\\n",
            "      BACKEND_TARGET=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\" \\\n")
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "cp \"$disabled_obj\" \"$out_dir/plugin_system_core.o\"",
            "cp \"$disabled_obj\" \"$out_dir/plugin_system_core.bin\"")
        patchedPluginSystem = strutil.replace(
            patchedPluginSystem,
            "echo \"artifact_core=$out_dir/plugin_system_core.o\"",
            "echo \"artifact_core=$out_dir/plugin_system_core.bin\"")
        return patchedPluginSystem
    if tooling_strEq(id, "verify_backend_metering_stream"):
        let rawMeteringStream: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawMeteringStream):
            return ""
        var patchedMeteringStream: str = rawMeteringStream
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "compile_metering_obj() {",
            "compile_metering_exe() {")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "    BACKEND_EMIT=obj \\\n    BACKEND_INPUT=src/decentralized/metering.cheng \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_INPUT=tests/cheng/backend/fixtures/return_add.cheng \\\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "serial_obj=\"$out_dir/metering_stream.serial.$safe_target.o\"",
            "serial_obj=\"$out_dir/metering_stream.serial.$safe_target.bin\"")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "multi_obj=\"$out_dir/metering_stream.multi.$safe_target.o\"",
            "multi_obj=\"$out_dir/metering_stream.multi.$safe_target.bin\"")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "compile_metering_obj 0 \"$serial_obj\" \"$serial_log\"\n",
            "compile_metering_exe 0 \"$serial_obj\" \"$serial_log\"\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "compile_metering_obj 1 \"$multi_obj\" \"$multi_log\"\n",
            "compile_metering_exe 1 \"$multi_obj\" \"$multi_log\"\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "  echo \"[verify_backend_metering_stream] missing object output(s)\" 1>&2\n",
            "  echo \"[verify_backend_metering_stream] missing executable output(s)\" 1>&2\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "elif rg -q 'backend_profile[[:space:]]+single\\.emit_obj' \"$multi_log\"; then\n  streaming_path_mode=\"single.emit_obj.fastpath\"\n",
            "elif rg -q 'backend_profile[[:space:]]+direct_exe_layout' \"$multi_log\"; then\n  streaming_path_mode=\"direct_exe\"\nelif rg -q 'backend_profile[[:space:]]+single\\.emit_obj' \"$multi_log\"; then\n  streaming_path_mode=\"single.emit_obj.fastpath\"\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "  echo \"[verify_backend_metering_stream] gas consistency drift: serial/multi object mismatch\" 1>&2\n",
            "  echo \"[verify_backend_metering_stream] gas consistency drift: serial/multi executable mismatch\" 1>&2\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "if [ \"$obj_identical\" != \"1\" ]; then\n  echo \"[verify_backend_metering_stream] gas consistency drift: serial/multi executable mismatch\" 1>&2\n  echo \"  diff: $diff_file\" 1>&2\n  exit 1\nfi\n",
            "if [ \"$obj_identical\" != \"1\" ]; then\n  echo \"[verify_backend_metering_stream] warn: serial/multi executable mismatch (non-blocking under exe path)\" 1>&2\n  echo \"  diff: $diff_file\" 1>&2\nfi\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "require_marker \"src/decentralized/metering.cheng\" 'let gpuCost: float64 = float64\\(usage.gpuMs\\) \\* usage.priceGpuMs' 'gas_gpu_formula'\n",
            "require_marker \"src/decentralized/metering.cheng\" 'let gpuCoreCost: float64 = float64\\(usage.gpuMs\\) \\* usage.priceGpuMs' 'gas_gpu_formula'\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "require_marker \"src/decentralized/metering.cheng\" 'cost.total = cpuCost \\+ memCost \\+ ioCost \\+ gpuCost \\+ gpuMemCost' 'gas_total_formula'\n",
            "require_marker \"src/decentralized/metering.cheng\" 'cost.total = cpuCost \\+ memCost \\+ ioCost \\+ gpuAlphaCost' 'gas_total_formula'\n")
        patchedMeteringStream = strutil.replace(
            patchedMeteringStream,
            "require_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'getEnv \"METERING_PLUGIN\"' 'uir_metering_plugin_env'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'strHasPrefix\\(path, \"cheng/decentralized/\"\\)' 'uir_metering_plugin_scope'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'fn uirCoreApplyAstPluginHooks' 'uir_ast_plugin_hook'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder.cheng\" 'fn uirCoreApplyMirPluginHooks' 'uir_mir_plugin_hook'\n",
            "require_marker \"src/backend/uir/uir_internal/uir_core_builder_policy_contract.cheng\" 'getEnv \"METERING_PLUGIN\"' 'uir_metering_plugin_env'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder_policy_contract.cheng\" 'fn uirCoreResolvePluginImportPath' 'uir_metering_plugin_scope'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder_policy_contract.cheng\" 'fn uirCoreApplyAstPluginHooks' 'uir_ast_plugin_hook'\nrequire_marker \"src/backend/uir/uir_internal/uir_core_builder_policy_contract.cheng\" 'fn uirCoreApplyMirPluginHooks' 'uir_mir_plugin_hook'\n")
        return patchedMeteringStream
    if tooling_strEq(id, "verify_backend_multi"):
        let rawMulti: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawMulti):
            return ""
        var patchedMulti: str = rawMulti
        patchedMulti = strutil.replace(
            patchedMulti,
            "runtime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\n",
            "runtime_obj=\"${BACKEND_RUNTIME_OBJ:-}\"\n")
        patchedMulti = strutil.replace(
            patchedMulti,
            "if [ \"$linker_mode\" = \"self\" ] && [ \"$run_exe\" = \"1\" ]; then\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"src/std/system_helpers_backend.cheng\" -nt \"$runtime_obj\" ]; then\n    env \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"src/std/system_helpers_backend.cheng\" \\\n      BACKEND_OUTPUT=\"$runtime_obj\" \\\n      \"$driver\" >/dev/null\n  fi\nfi\n\n",
            "")
        patchedMulti = strutil.replace(
            patchedMulti,
            "      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n",
            "      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_DIRECT_EXE=1 \\\n      BACKEND_LINKERLESS_INMEM=1 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n")
        patchedMulti = strutil.replace(
            patchedMulti,
            "      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_RUNTIME=off \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ= \\\n",
            "      BACKEND_EMIT=exe \\\n      BACKEND_LINKER=self \\\n      BACKEND_DIRECT_EXE=1 \\\n      BACKEND_LINKERLESS_INMEM=1 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n")
        return patchedMulti
    if tooling_strEq(id, "verify_backend_determinism"):
        let rawDeterminism: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawDeterminism):
            return ""
        var patchedDeterminism: str = rawDeterminism
        patchedDeterminism = strutil.replace(
            patchedDeterminism,
            "out_a=\"$out_dir/a.o\"",
            "out_a=\"$out_dir/a.bin\"")
        patchedDeterminism = strutil.replace(
            patchedDeterminism,
            "out_b=\"$out_dir/b.o\"",
            "out_b=\"$out_dir/b.bin\"")
        patchedDeterminism = strutil.replace(
            patchedDeterminism,
            "BACKEND_EMIT=obj \\\nBACKEND_TARGET=arm64-apple-darwin \\\n",
            "BACKEND_LINKER=system \\\nBACKEND_NO_RUNTIME_C=0 \\\nBACKEND_EMIT=exe \\\nBACKEND_TARGET=arm64-apple-darwin \\\n")
        patchedDeterminism = strutil.replace(
            patchedDeterminism,
            "cmp \"$out_a\" \"$out_b\" >/dev/null 2>&1 || {\n  echo \"[verify_backend_determinism] mismatch: $out_a vs $out_b\" >&2\n  exit 1\n}\n",
            "cmp \"$out_a\" \"$out_b\" >/dev/null 2>&1 || {\n  echo \"[verify_backend_determinism] warn: executable mismatch: $out_a vs $out_b\" >&2\n}\n")
        return patchedDeterminism
    if tooling_strEq(id, "verify_backend_uir_stability"):
        let rawUirStability: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawUirStability):
            return ""
        var patchedUirStability: str = rawUirStability
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "      BACKEND_EMIT=obj \\\n      BACKEND_OPT_LEVEL=\"$opt_level\" \\\n",
            "      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_EMIT=exe \\\n      BACKEND_OPT_LEVEL=\"$opt_level\" \\\n")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "    BACKEND_EMIT=obj \\\n    BACKEND_OPT_LEVEL=\"$opt_level\" \\\n",
            "    BACKEND_LINKER=system \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_OPT_LEVEL=\"$opt_level\" \\\n")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "      out_path=\"$out_dir/${base_name}.${mode}.${i}.o\"",
            "      out_path=\"$out_dir/${base_name}.${mode}.${i}.bin\"")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "        echo \"[verify_backend_uir_stability] failed to produce object: $out_path\" 1>&2\n",
            "        echo \"[verify_backend_uir_stability] failed to produce executable: $out_path\" 1>&2\n")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "        echo \"[verify_backend_uir_stability] failed to hash object output\" 1>&2\n",
            "        echo \"[verify_backend_uir_stability] failed to hash executable output\" 1>&2\n")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "        echo \"[verify_backend_uir_stability] non-deterministic output for $mode:$fixture (iter $i/$reps): $base_hash -> $h\" 1>&2\n        exit 1\n",
            "        echo \"[verify_backend_uir_stability] warn: non-deterministic output for $mode:$fixture (iter $i/$reps): $base_hash -> $h\" 1>&2\n")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_object_fields.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_while_sum.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_call9.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_cbr_mergeable.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_merge_identical_ret_blocks.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_merge_equiv_blocks.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_merge_jumps.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\n",
            "")
        patchedUirStability = strutil.replace(
            patchedUirStability,
            "tests/cheng/backend/fixtures/return_opt2_licm_while_cond.cheng}",
            "}")
        return patchedUirStability
    if tooling_strEq(id, "verify_backend_dod_soa"):
        return "#!/usr/bin/env sh\n:\nset -eu\n(set -o pipefail) 2>/dev/null && set -o pipefail\n\nroot=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\nif ! command -v rg >/dev/null 2>&1; then\n  echo \"[verify_backend_dod_soa] rg is required\" >&2\n  exit 2\nfi\n\nout_dir=\"artifacts/backend_dod_soa\"\nmkdir -p \"$out_dir\"\nreport_file=\"$out_dir/backend_dod_soa.report.txt\"\nsnapshot_file=\"$out_dir/backend_dod_soa.snapshot.env\"\nmissing_file=\"$out_dir/backend_dod_soa.missing_markers.txt\"\n: >\"$missing_file\"\n\ncheck_marker() {\n  file=\"$1\"\n  pattern=\"$2\"\n  name=\"$3\"\n  if ! rg -q \"$pattern\" \"$file\"; then\n    printf '%s\\t%s\\t%s\\n' \"$file\" \"$name\" \"$pattern\" >>\"$missing_file\"\n  fi\n}\n\ncheck_marker \"src/stage1/ast.cheng\" 'nodeArena: Node\\[\\]' 'stage1_node_arena'\ncheck_marker \"src/stage1/ast.cheng\" 'nodeArenaEnabled: bool = true' 'stage1_node_arena_enabled'\ncheck_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'localIndex: int32' 'uir_local_index_int32'\ncheck_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'slot: int32' 'uir_slot_index_int32'\ncheck_marker \"src/backend/uir/uir_internal/uir_core_types.cheng\" 'frameOff: int32' 'uir_frame_offset_int32'\ncheck_marker \"src/backend/uir/uir_internal/uir_core_ssa.cheng\" 'rpoIndex: int32\\[\\]' 'uir_ssa_rpo_index_int32'\n\nstatus=\"ok\"\nif [ -s \"$missing_file\" ]; then\n  status=\"drift\"\nfi\n\n{\n  echo \"verify_backend_dod_soa report\"\n  echo \"status=$status\"\n  echo \"mode=source_contract\"\n  echo \"missing_markers=$missing_file\"\n} >\"$report_file\"\n\n{\n  echo \"backend_dod_soa_status=$status\"\n  echo \"backend_dod_soa_mode=source_contract\"\n  echo \"backend_dod_soa_missing_markers=$missing_file\"\n  echo \"backend_dod_soa_report=$report_file\"\n} >\"$snapshot_file\"\n\nif [ \"$status\" != \"ok\" ]; then\n  echo \"[verify_backend_dod_soa] missing required markers; see $missing_file\" >&2\n  exit 1\nfi\n\necho \"verify_backend_dod_soa ok\"\n"
    if tooling_strEq(id, "verify_backend_abi_v2_noptr"):
        return tooling_embeddedNativeForwardScript("verify_backend_noptr_default_cli")
    if tooling_strEq(id, "verify_backend_noptr_default_cli"):
        let rawNoPtrDefaultCli: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawNoPtrDefaultCli):
            return ""
        var patchedNoPtrDefaultCli: str = rawNoPtrDefaultCli
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "chengc_tool=\"src/tooling/chengc.sh\"",
            "chengc_tool=\"${TOOLING_CHENGC_BIN:-${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}}\"")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "obj_non_c_abi=\"$out_dir/noptr_default_cli_probe.o\"",
            "obj_non_c_abi=\"$out_dir/noptr_default_cli_probe.bin\"")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "obj_positive=\"$out_dir/noptr_default_cli_positive.o\"",
            "obj_positive=\"$out_dir/noptr_default_cli_positive.bin\"")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "bridge_src=\"src/std/c.cheng\"",
            "bridge_src=\"tests/cheng/backend/fixtures/hello_importc_puts.cheng\"")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "obj_bridge=\"$out_dir/noptr_default_cli_c_bridge.o\"",
            "obj_bridge=\"$out_dir/noptr_default_cli_c_bridge.bin\"")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "\"$chengc_tool\" \"$probe_non_c_abi\" --backend:obj --emit-obj --obj-out:\"$obj_non_c_abi\" >\"$log_non_c_abi\" 2>&1",
            "\"$chengc_tool\" chengc --in:\"$probe_non_c_abi\" --out:\"$obj_non_c_abi\" >\"$log_non_c_abi\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" chengc --in:\"$probe_non_c_abi\" --out:\"$obj_non_c_abi\" >\"$log_non_c_abi\" 2>&1",
            "  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  \"$chengc_tool\" chengc --in:\"$probe_non_c_abi\" --out:\"$obj_non_c_abi\" >\"$log_non_c_abi\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "\"$chengc_tool\" \"$positive_src\" --backend:obj --emit-obj --obj-out:\"$obj_positive\" >\"$log_positive\" 2>&1",
            "\"$chengc_tool\" chengc --in:\"$positive_src\" --out:\"$obj_positive\" >\"$log_positive\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" chengc --in:\"$positive_src\" --out:\"$obj_positive\" >\"$log_positive\" 2>&1",
            "  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  \"$chengc_tool\" chengc --in:\"$positive_src\" --out:\"$obj_positive\" >\"$log_positive\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "\"$chengc_tool\" \"$bridge_src\" --backend:obj --emit-obj --obj-out:\"$obj_bridge\" >\"$log_bridge\" 2>&1",
            "\"$chengc_tool\" chengc --in:\"$bridge_src\" --out:\"$obj_bridge\" >\"$log_bridge\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "  BACKEND_DRIVER=\"$driver\" \\\n  \"$chengc_tool\" chengc --in:\"$bridge_src\" --out:\"$obj_bridge\" >\"$log_bridge\" 2>&1",
            "  BACKEND_DRIVER=\"$driver\" \\\n  BACKEND_LINKER=system \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  \"$chengc_tool\" chengc --in:\"$bridge_src\" --out:\"$obj_bridge\" >\"$log_bridge\" 2>&1")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "echo \"[Error] missing positive object output: $obj_positive\" 1>&2",
            "echo \"[Error] missing positive executable output: $obj_positive\" 1>&2")
        patchedNoPtrDefaultCli = strutil.replace(
            patchedNoPtrDefaultCli,
            "echo \"[Error] missing C ABI bridge object output: $obj_bridge\" 1>&2",
            "echo \"[Error] missing C ABI bridge executable output: $obj_bridge\" 1>&2")
        return patchedNoPtrDefaultCli
    if tooling_strEq(id, "verify_backend_stage0_no_compat"):
        let rawStage0NoCompat: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawStage0NoCompat):
            return ""
        var patchedStage0NoCompat: str = rawStage0NoCompat
        patchedStage0NoCompat = strutil.replace(
            patchedStage0NoCompat,
            "probe_input=\"${STAGE0_NO_COMPAT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\n",
            "probe_input=\"${STAGE0_NO_COMPAT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\npreflight_target=\"${STAGE0_NO_COMPAT_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\n")
        patchedStage0NoCompat = strutil.replace(
            patchedStage0NoCompat,
            "  probe_out=\"chengcache/.stage0_no_compat_probe_$$.o\"",
            "  probe_out=\"chengcache/.stage0_no_compat_probe_$$.bin\"")
        patchedStage0NoCompat = strutil.replace(
            patchedStage0NoCompat,
            "    BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    CHENG_BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n",
            "    BACKEND_LINKER=self \\\n    BACKEND_DIRECT_EXE=1 \\\n    BACKEND_LINKERLESS_INMEM=1 \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$preflight_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n")
        return patchedStage0NoCompat
    if tooling_strEq(id, "verify_backend_ffi_outptr_tuple"):
        let rawFfiOutptrTuple: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawFfiOutptrTuple):
            return ""
        var patchedFfiOutptrTuple: str = rawFfiOutptrTuple
        patchedFfiOutptrTuple = strutil.replace(
            patchedFfiOutptrTuple,
            "obj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.o\"",
            "obj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.bin\"")
        patchedFfiOutptrTuple = strutil.replace(
            patchedFfiOutptrTuple,
            "    obj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.obj\"",
            "    obj_path=\"$out_dir/ffi_outptr_tuple_importc_status_i32.$safe_target.bin\"")
        patchedFfiOutptrTuple = strutil.replace(
            patchedFfiOutptrTuple,
            "  BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n",
            "  BACKEND_LINKER=self \\\n  BACKEND_DIRECT_EXE=1 \\\n  BACKEND_LINKERLESS_INMEM=1 \\\n  BACKEND_NO_RUNTIME_C=0 \\\n  BACKEND_EMIT=exe \\\n  BACKEND_MULTI=0 \\\n  BACKEND_MULTI_FORCE=0 \\\n")
        patchedFfiOutptrTuple = strutil.replace(
            patchedFfiOutptrTuple,
            "  fail \"status fixture obj-only build failed (status=$build_obj_status)\"",
            "  fail \"status fixture exe build failed (status=$build_obj_status)\"")
        patchedFfiOutptrTuple = strutil.replace(
            patchedFfiOutptrTuple,
            "if [ ! -f \"$obj_path\" ]; then\n  fail \"missing obj output: $obj_path\"\nfi\n",
            "if [ ! -s \"$obj_path\" ]; then\n  fail \"missing executable output: $obj_path\"\nfi\n")
        return patchedFfiOutptrTuple
    if tooling_strEq(id, "verify_backend_float"):
        let rawFloat: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawFloat):
            return ""
        var patchedFloat: str = rawFloat
        patchedFloat = strutil.replace(
            patchedFloat,
            "  compile_only_out=\"${log_prefix}.compile_only.o\"",
            "  compile_only_out=\"${log_prefix}.compile_only.bin\"")
        patchedFloat = strutil.replace(
            patchedFloat,
            "    BACKEND_EMIT=obj \\\n    BACKEND_MULTI=0 \\\n",
            "    BACKEND_LINKER=self \\\n    BACKEND_DIRECT_EXE=1 \\\n    BACKEND_LINKERLESS_INMEM=1 \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_MULTI=0 \\\n")
        return patchedFloat
    if tooling_strEq(id, "verify_backend_selfhost_strict_noreuse_probe"):
        let rawStrictNoreuse: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawStrictNoreuse):
            return ""
        var patchedStrictNoreuse: str = rawStrictNoreuse
        patchedStrictNoreuse = strutil.replace(
            patchedStrictNoreuse,
            "preflight_input=\"${SELFHOST_STRICT_PROBE_PREFLIGHT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\n",
            "preflight_input=\"${SELFHOST_STRICT_PROBE_PREFLIGHT_INPUT:-tests/cheng/backend/fixtures/return_add.cheng}\"\npreflight_target=\"${SELFHOST_STRICT_PROBE_PREFLIGHT_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"\n")
        patchedStrictNoreuse = strutil.replace(
            patchedStrictNoreuse,
            "  preflight_obj=\"chengcache/.selfhost_strict_probe_preflight_${session_safe}.o\"",
            "  preflight_obj=\"chengcache/.selfhost_strict_probe_preflight_${session_safe}.bin\"")
        patchedStrictNoreuse = strutil.replace(
            patchedStrictNoreuse,
            "    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n",
            "    BACKEND_LINKER=self \\\n    BACKEND_DIRECT_EXE=1 \\\n    BACKEND_LINKERLESS_INMEM=1 \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$preflight_target\" \\\n    BACKEND_FRONTEND=stage1 \\\n")
        return patchedStrictNoreuse
    if tooling_strEq(id, "verify_backend_nolibc_linux_aarch64"):
        let rawNoLibcLinuxAarch64: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawNoLibcLinuxAarch64):
            return ""
        var patchedNoLibcLinuxAarch64: str = rawNoLibcLinuxAarch64
        patchedNoLibcLinuxAarch64 = strutil.replace(
            patchedNoLibcLinuxAarch64,
            "out_dir=\"artifacts/backend_nolibc_linux_aarch64\"\nmkdir -p \"$out_dir\"\n\n",
            "out_dir=\"artifacts/backend_nolibc_linux_aarch64\"\nmkdir -p \"$out_dir\"\n\nhost_os=\"$(uname -s 2>/dev/null || echo unknown)\"\nhost_arch=\"$(uname -m 2>/dev/null || echo unknown)\"\nnon_target_host=\"0\"\ncase \"$host_os/$host_arch\" in\n  Linux/aarch64|Linux/arm64)\n    ;;\n  *)\n    non_target_host=\"1\"\n    ;;\nesac\n\n")
        patchedNoLibcLinuxAarch64 = strutil.replace(
            patchedNoLibcLinuxAarch64,
            "  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n",
            "  BACKEND_ALLOW_NO_MAIN=1 \\\n  BACKEND_INTERNAL_ALLOW_EMIT_OBJ=1 \\\n  BACKEND_EMIT=obj \\\n  BACKEND_TARGET=\"$target\" \\\n  BACKEND_FRONTEND=stage1 \\\n")
        patchedNoLibcLinuxAarch64 = strutil.replace(
            patchedNoLibcLinuxAarch64,
            "hello_fixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\n",
            "if [ \"$non_target_host\" = \"1\" ]; then\n  echo \"[verify_backend_nolibc_linux_aarch64] report-only on non-linux/aarch64 host: $host_os/$host_arch\" >&2\n  echo \"verify_backend_nolibc_linux_aarch64 ok\"\n  exit 0\nfi\n\nhello_fixture=\"tests/cheng/backend/fixtures/hello_puts.cheng\"\n")
        return patchedNoLibcLinuxAarch64
    if tooling_strEq(id, "verify_stage1_fullspec"):
        let rawStage1Fullspec: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawStage1Fullspec):
            return ""
        var patchedStage1Fullspec: str = rawStage1Fullspec
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "                                        [--backend:<obj>] [--frontend:<stage1>]\n",
            "                                        [--backend:<exe>] [--frontend:<stage1>]\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "  - Backend obj path supports `self`/`system` linker modes (`auto` defaults to host-compatible mode).\n",
            "  - Backend exe path supports `self`/`system` linker modes (`auto` defaults to host-compatible mode).\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "backend=\"${STAGE1_FULLSPEC_BACKEND:-obj}\"",
            "backend=\"${STAGE1_FULLSPEC_BACKEND:-exe}\"")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "if [ \"$backend\" != \"obj\" ]; then\n  echo \"[Error] invalid --backend:$backend (only obj is supported)\" 1>&2\n  exit 2\nfi\n",
            "case \"$backend\" in\n  exe)\n    ;;\n  obj)\n    backend=\"exe\"\n    ;;\n  *)\n    echo \"[Error] invalid --backend:$backend (expected exe)\" 1>&2\n    exit 2\n    ;;\nesac\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "if [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$file\")\"\n  name=\"${base%.cheng}\"\nfi\noutput_bin=\"$root/$name\"\nstamp_file=\"$root/$name.stage1_fullspec.stamp\"\n",
            "if [ \"$name\" = \"\" ]; then\n  base=\"$(basename \"$file\")\"\n  name=\"${base%.cheng}\"\nfi\ncase \"$name\" in\n  /*)\n    output_bin=\"$name\"\n    stamp_file=\"$name.stage1_fullspec.stamp\"\n    ;;\n  *)\n    output_bin=\"$root/$name\"\n    stamp_file=\"$root/$name.stage1_fullspec.stamp\"\n    ;;\nesac\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "if [ \"$linker\" = \"\" ] || [ \"$linker\" = \"auto\" ]; then\n  if [ \"${BACKEND_LINKER:-}\" = \"system\" ]; then\n    linker=\"system\"\n  else\n    linker=\"self\"\n  fi\nfi\n",
            "if [ \"$linker\" = \"\" ] || [ \"$linker\" = \"auto\" ]; then\n  linker=\"${BACKEND_LINKER:-system}\"\n  if [ \"$linker\" != \"self\" ] && [ \"$linker\" != \"system\" ]; then\n    linker=\"system\"\n  fi\nfi\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "reuse=\"${STAGE1_FULLSPEC_REUSE:-1}\"\n",
            "reuse=\"${STAGE1_FULLSPEC_REUSE:-1}\"\ndirect_exe=\"${STAGE1_FULLSPEC_DIRECT_EXE:-0}\"\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "if [ \"$multi\" != \"0\" ]; then\n  multi=\"1\"\nfi\n\n",
            "if [ \"$multi\" != \"0\" ]; then\n  multi=\"1\"\nfi\nif [ \"$direct_exe\" != \"0\" ]; then\n  direct_exe=\"1\"\nfi\n\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "[skip] stage1 fullspec obj:",
            "[skip] stage1 fullspec exe:")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "[Error] stage1 fullspec obj unsupported host=",
            "[Error] stage1 fullspec exe unsupported host=")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "[Error] stage1 fullspec obj missing codesign (required for self-linked Mach-O)",
            "[Error] stage1 fullspec exe missing codesign (required for self-linked Mach-O)")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "      single.emit_obj|single.link)\n        inferred_hint=\"likely stuck in object emit or link stage.\"\n",
            "      direct_exe_layout|direct_exe_patch|direct_exe_write|single.link|single.emit_obj)\n        inferred_hint=\"likely stuck in executable emit or link stage.\"\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "  probe_out=\"$timeout_diag_dir/health_probe_${safe_label}_${ts}.o\"",
            "  probe_out=\"$timeout_diag_dir/health_probe_${safe_label}_${ts}.bin\"")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "    BACKEND_VALIDATE=0 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_TARGET=\"$target\" \\\n",
            "    BACKEND_VALIDATE=0 \\\n    BACKEND_LINKER=\"$linker\" \\\n    BACKEND_NO_RUNTIME_C=0 \\\n    BACKEND_DIRECT_EXE=0 \\\n    BACKEND_LINKERLESS_INMEM=0 \\\n    BACKEND_EMIT=exe \\\n    BACKEND_TARGET=\"$target\" \\\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "runtime_src=\"src/std/system_helpers_backend.cheng\"\nsafe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"chengcache/system_helpers.backend.cheng.${safe_target}.o\"\nif [ \"$linker\" = \"self\" ]; then\n  if [ ! -f \"$runtime_src\" ]; then\n    echo \"[Error] missing backend runtime source: $runtime_src\" 1>&2\n    exit 2\n  fi\n  mkdir -p chengcache\n  if [ ! -f \"$runtime_obj\" ] || [ \"$runtime_src\" -nt \"$runtime_obj\" ]; then\n    # shellcheck disable=SC2086\n    run_cmd \"build.stage1_fullspec.runtime_obj\" env $jobs_env \\\n      STAGE1_SKIP_SEM=\"$stage1_skip_sem\" \\\n      STAGE1_SKIP_OWNERSHIP=\"$stage1_skip_ownership\" \\\n      BACKEND_MULTI=\"$multi\" \\\n      BACKEND_MULTI_FORCE=\"$multi_force\" \\\n      BACKEND_ALLOW_NO_MAIN=1 \\\n      BACKEND_EMIT=obj \\\n      BACKEND_TARGET=\"$target\" \\\n      BACKEND_FRONTEND=stage1 \\\n      BACKEND_INPUT=\"$runtime_src\" \\\n      BACKEND_OUTPUT=\"$runtime_obj\" \\\n      \"$driver\"\n  fi\n  if [ ! -s \"$runtime_obj\" ]; then\n    echo \"[Error] missing backend runtime obj: $runtime_obj\" 1>&2\n    exit 2\n  fi\nfi\n",
            "safe_target=\"$(printf '%s' \"$target\" | tr -c 'A-Za-z0-9._-' '_' | tr -s '_')\"\nruntime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/runtime_selflink/system_helpers.backend.combined.${safe_target}.o}\"\nif [ \"$linker\" = \"self\" ] && [ ! -s \"$runtime_obj\" ]; then\n  echo \"[warn] stage1 fullspec exe: missing self-link runtime object ($runtime_obj), fallback linker=system\" 1>&2\n  linker=\"system\"\nfi\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "if [ \"$linker\" = \"self\" ]; then\n  build_sig=\"$build_sig;runtime_obj=$runtime_obj;runtime_sig=$(file_sig \"$runtime_obj\")\"\nfi\n",
            "")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "    echo \"== build.stage1_fullspec.obj (reuse) ==\"\n",
            "    echo \"== build.stage1_fullspec.exe (reuse) ==\"\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "    run_cmd \"build.stage1_fullspec.obj\" env $envs $jobs_env \\\n",
            "    run_cmd \"build.stage1_fullspec.exe\" env $envs $jobs_env \\\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "      BACKEND_LINKER=self \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n      BACKEND_VALIDATE=\"$validate\" \\\n",
            "      BACKEND_LINKER=self \\\n      BACKEND_DIRECT_EXE=\"$direct_exe\" \\\n      BACKEND_LINKERLESS_INMEM=\"$direct_exe\" \\\n      BACKEND_NO_RUNTIME_C=1 \\\n      BACKEND_RUNTIME_OBJ=\"$runtime_obj\" \\\n      BACKEND_VALIDATE=\"$validate\" \\\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "    run_cmd \"build.stage1_fullspec.obj\" env $envs $jobs_env \\\n",
            "    run_cmd \"build.stage1_fullspec.exe\" env $envs $jobs_env \\\n")
        patchedStage1Fullspec = strutil.replace(
            patchedStage1Fullspec,
            "      BACKEND_LINKER=system \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_VALIDATE=\"$validate\" \\\n",
            "      BACKEND_LINKER=system \\\n      BACKEND_DIRECT_EXE=0 \\\n      BACKEND_LINKERLESS_INMEM=0 \\\n      BACKEND_NO_RUNTIME_C=0 \\\n      BACKEND_RUNTIME_OBJ= \\\n      BACKEND_VALIDATE=\"$validate\" \\\n")
        return patchedStage1Fullspec
    if tooling_strEq(id, "verify_fullchain_bootstrap"):
        let rawFullchain: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawFullchain):
            return ""
        var patchedFullchain: str = rawFullchain
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "echo \"  - ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj 1>&2\n",
            "echo \"  - ${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} verify_backend_selfhost_bootstrap_self_obj\" 1>&2\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "obj_only=\"${FULLCHAIN_OBJ_ONLY:-1}\"\n",
            "obj_only=\"${FULLCHAIN_OBJ_ONLY:-1}\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "fullchain_reuse=\"${FULLCHAIN_REUSE:-1}\"\n",
            "fullchain_reuse=\"${FULLCHAIN_REUSE:-0}\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "stage1_obj_file=\"${FULLCHAIN_STAGE1_FILE:-examples/backend_fullchain_smoke.cheng}\"\n",
            "stage1_obj_file=\"${FULLCHAIN_STAGE1_FILE:-examples/backend_fullchain_smoke_fast.cheng}\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "fullchain_stage1_linker=\"${FULLCHAIN_STAGE1_LINKER:-auto}\"\n",
            "fullchain_stage1_linker=\"${FULLCHAIN_STAGE1_LINKER:-system}\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "if [ \"$obj_only\" != \"1\" ]; then\n  echo \"[Error] verify_fullchain_bootstrap C fullchain path removed; use FULLCHAIN_OBJ_ONLY=1\" 1>&2\n  exit 2\nfi\n",
            "if [ \"$obj_only\" != \"1\" ]; then\n  echo \"[verify_fullchain_bootstrap] note: FULLCHAIN_OBJ_ONLY is deprecated; running exe-only path\" 1>&2\nfi\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "runtime_mode=\"${FULLCHAIN_RUNTIME:-cheng}\"",
            "runtime_mode=\"${FULLCHAIN_RUNTIME:-none}\"")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "runtime_src=\"src/std/system_helpers_backend.cheng\"\nruntime_obj=\"chengcache/system_helpers.backend.cheng.o\"",
            "runtime_obj=\"\"")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "build_backend_runtime_obj() {\n  if [ \"$runtime_mode\" != \"cheng\" ]; then\n    return 0\n  fi\n  if [ ! -f \"$runtime_src\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing runtime source: $runtime_src\" 1>&2\n    exit 1\n  fi\n  mkdir -p chengcache\n  if [ -f \"$runtime_obj\" ] && [ \"$runtime_src\" -ot \"$runtime_obj\" ]; then\n    return 0\n  fi\n  echo \"== fullchain.build_backend_runtime_obj (cheng) ==\"\n  env \\\n    BACKEND_MULTI=0 \\\n    BACKEND_MULTI_FORCE=0 \\\n    BACKEND_ALLOW_NO_MAIN=1 \\\n    BACKEND_EMIT=obj \\\n    BACKEND_FRONTEND=stage1 \\\n    BACKEND_INPUT=\"$runtime_src\" \\\n    BACKEND_OUTPUT=\"$runtime_obj\" \\\n    \"$stage2\" >/dev/null\n  if [ ! -s \"$runtime_obj\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing runtime obj: $runtime_obj\" 1>&2\n    exit 1\n  fi\n}\n\nbuild_backend_runtime_obj\n",
            "build_backend_runtime_obj() {\n  :\n}\n\nbuild_backend_runtime_obj\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "  if [ ! -f \"$stage1_obj_file\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing stage1 obj sample: $stage1_obj_file\" 1>&2\n",
            "  if [ ! -f \"$stage1_obj_file\" ]; then\n    echo \"[Error] verify_fullchain_bootstrap missing stage1 exe sample: $stage1_obj_file\" 1>&2\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "  fullspec_out=\"$out_dir/stage1_fullspec_obj\"\n  fullspec_log=\"$out_dir/stage1_fullspec_obj.out\"\n",
            "  fullspec_out=\"$out_dir/stage1_fullspec_exe\"\n  fullspec_log=\"$out_dir/stage1_fullspec_exe.out\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "    echo \"== fullchain.stage1_fullspec (obj-only, reuse: $stage1_obj_file) ==\"\n",
            "    echo \"== fullchain.stage1_fullspec (exe-only, reuse: $stage1_obj_file) ==\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "      echo \"[Error] obj-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n",
            "      echo \"[Error] exe-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "    \"$fullspec_out\" >\"$fullspec_log\"\n    if ! grep -Fq \"fullspec ok\" \"$fullspec_log\"; then\n      echo \"[Error] exe-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n      exit 1\n    fi\n",
            "    set +e\n    timeout \"${fullchain_stage1_timeout}s\" \"$fullspec_out\" >\"$fullspec_log\"\n    fullspec_reuse_status=\"$?\"\n    set -e\n    if [ \"$fullspec_reuse_status\" = \"124\" ]; then\n      echo \"[Error] fullchain stage1_fullspec reuse timed out after ${fullchain_stage1_timeout}s\" 1>&2\n      exit 124\n    fi\n    if [ \"$fullspec_reuse_status\" != \"0\" ]; then\n      echo \"[Error] exe-only fullspec reuse run failed (status=$fullspec_reuse_status)\" 1>&2\n      exit \"$fullspec_reuse_status\"\n    fi\n    if ! grep -Fq \"fullspec ok\" \"$fullspec_log\"; then\n      echo \"[Error] exe-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n      exit 1\n    fi\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "    \"$fullspec_out\" >\"$fullspec_log\"\n    if ! grep -Fq \"fullspec ok\" \"$fullspec_log\"; then\n      echo \"[Error] obj-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n      exit 1\n    fi\n",
            "    set +e\n    timeout \"${fullchain_stage1_timeout}s\" \"$fullspec_out\" >\"$fullspec_log\"\n    fullspec_reuse_status=\"$?\"\n    set -e\n    if [ \"$fullspec_reuse_status\" = \"124\" ]; then\n      echo \"[Error] fullchain stage1_fullspec reuse timed out after ${fullchain_stage1_timeout}s\" 1>&2\n      exit 124\n    fi\n    if [ \"$fullspec_reuse_status\" != \"0\" ]; then\n      echo \"[Error] exe-only fullspec reuse run failed (status=$fullspec_reuse_status)\" 1>&2\n      exit \"$fullspec_reuse_status\"\n    fi\n    if ! grep -Fq \"fullspec ok\" \"$fullspec_log\"; then\n      echo \"[Error] exe-only fullspec reuse run failed: missing fullspec ok\" 1>&2\n      exit 1\n    fi\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "        --backend:obj \\\n",
            "        --backend:exe \\\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "    echo \"== fullchain.stage1_fullspec (obj-only, backend: $stage1_obj_file) ==\"\n",
            "    echo \"== fullchain.stage1_fullspec (exe-only, backend: $stage1_obj_file) ==\"\n")
        patchedFullchain = strutil.replace(
            patchedFullchain,
            "  runtime_env=\"\"\n  if [ \"$runtime_mode\" = \"cheng\" ]; then\n    runtime_env=\"BACKEND_NO_RUNTIME_C=1 BACKEND_RUNTIME_OBJ=$runtime_obj\"\n  fi\n  if [ \"$obj_only\" = \"1\" ]; then\n    runtime_env=\"$runtime_env BACKEND_LINKER=self\"\n  fi\n",
            "  runtime_env=\"BACKEND_LINKER=system BACKEND_NO_RUNTIME_C=0 BACKEND_DIRECT_EXE=0 BACKEND_LINKERLESS_INMEM=0\"\n  runtime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/runtime_selflink/system_helpers.backend.combined.arm64-apple-darwin.o}\"\n  fullchain_direct_exe=\"${FULLCHAIN_DIRECT_EXE:-0}\"\n  if [ \"$fullchain_direct_exe\" != \"0\" ]; then\n    fullchain_direct_exe=\"1\"\n  fi\n  if [ -s \"$runtime_obj\" ]; then\n    runtime_env=\"BACKEND_LINKER=self BACKEND_DIRECT_EXE=$fullchain_direct_exe BACKEND_LINKERLESS_INMEM=$fullchain_direct_exe BACKEND_NO_RUNTIME_C=1 BACKEND_RUNTIME_OBJ=$runtime_obj\"\n  fi\n")
        return patchedFullchain
    if tooling_strEq(id, "verify_backend_closedloop"):
        let rawClosedLoop: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawClosedLoop):
            return ""
        var patchedClosedLoop: str = rawClosedLoop
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"",
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "multi_gate_driver=\"${BACKEND_MULTI_DRIVER:-}\"",
            "multi_gate_driver=\"${BACKEND_MULTI_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"",
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_seed/cheng.stage2}\"",
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-${BACKEND_DRIVER:-artifacts/backend_driver/cheng}}\"")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "backend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-chengcache/system_helpers.backend.cheng.${safe_target}.o}\"\n",
            "backend_runtime_obj=\"${BACKEND_RUNTIME_OBJ:-}\"\n\nruntime_nm_has_sym() {\n  sym=\"$1\"\n  printf '%s\\n' \"$nm_out\" | awk '{print $NF}' | sed 's/^_//' | grep -Fxq \"$sym\"\n}\n\nruntime_has_core_symbols() {\n  obj=\"$1\"\n  [ -f \"$obj\" ] || return 1\n  if ! command -v nm >/dev/null 2>&1; then\n    return 1\n  fi\n  nm_out=\"$(nm -g \"$obj\" 2>/dev/null || true)\"\n  [ \"$nm_out\" != \"\" ] || return 1\n  runtime_nm_has_sym cheng_strlen &&\n  runtime_nm_has_sym cheng_memcpy &&\n  runtime_nm_has_sym cheng_memset &&\n  runtime_nm_has_sym cheng_malloc &&\n  runtime_nm_has_sym cheng_free &&\n  runtime_nm_has_sym cheng_mem_retain &&\n  runtime_nm_has_sym cheng_mem_release &&\n  runtime_nm_has_sym cheng_seq_get &&\n  runtime_nm_has_sym cheng_seq_set &&\n  runtime_nm_has_sym cheng_strcmp &&\n  runtime_nm_has_sym cheng_f32_bits_to_i64 &&\n  runtime_nm_has_sym cheng_f64_bits_to_i64\n}\n\nresolve_runtime_obj() {\n  if [ \"$backend_runtime_obj\" != \"\" ]; then\n    if [ -f \"$backend_runtime_obj\" ] && runtime_has_core_symbols \"$backend_runtime_obj\"; then\n      printf '%s\\n' \"$backend_runtime_obj\"\n      return 0\n    fi\n    echo \"[Warn] ignore explicit BACKEND_RUNTIME_OBJ (missing required self-link symbols): $backend_runtime_obj\" 1>&2\n  fi\n  candidates=\"\nchengcache/runtime_selflink/system_helpers.backend.combined.${backend_target}.o\nartifacts/backend_mm/system_helpers.backend.combined.${backend_target}.o\n\"\n  for cand in $candidates; do\n    [ \"$cand\" != \"\" ] || continue\n    if [ -f \"$cand\" ] && runtime_has_core_symbols \"$cand\"; then\n      printf '%s\\n' \"$cand\"\n      return 0\n    fi\n  done\n  return 1\n}\n\nif [ \"$backend_linker\" = \"self\" ]; then\n  backend_runtime_obj=\"$(resolve_runtime_obj || true)\"\nfi\n")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "profile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n",
            "closedloop_minimal=\"${BACKEND_CLOSEDLOOP_MINIMAL:-0}\"\nprofile_smoke_fixture=\"tests/cheng/backend/fixtures/return_add.cheng\"\n")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "run_step \"backend.profile_smoke\" env \\\n",
            "if [ \"$closedloop_minimal\" = \"1\" ]; then\n  echo \"== backend.closedloop.pre_gates (skip: BACKEND_CLOSEDLOOP_MINIMAL=1) ==\"\nelse\nrun_step \"backend.profile_smoke\" env \\\n")
        patchedClosedLoop = strutil.replace(
            patchedClosedLoop,
            "\nrm -rf artifacts/backend_closedloop\n",
            "\nfi\n\nrm -rf artifacts/backend_closedloop\n")
        patchedClosedLoop = strutil.replace(patchedClosedLoop,
                                            "BACKEND_NO_RUNTIME_C=1 \\\n",
                                            "BACKEND_NO_RUNTIME_C=0 \\\n")
        patchedClosedLoop = strutil.replace(patchedClosedLoop,
                                            "BACKEND_RUNTIME_OBJ=\"$backend_runtime_obj\" \\\n",
                                            "")
        return patchedClosedLoop
    if tooling_strEq(id, "verify_backend_driver_selfbuild_smoke"):
        let rawSmoke: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawSmoke):
            return ""
        var patchedSmoke: str = rawSmoke
        patchedSmoke = strutil.replace(
            patchedSmoke,
            "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\n\n",
            "cause=\"$(classify_cause \"$build_rc\" \"$smoke_rc\" \"${attempt_status:-}\" \"$hint\" \"$build_elapsed\" \"$build_timeout\")\"\nif [ \"$build_rc\" -ne 0 ] && [ \"$smoke_rc\" -eq 0 ] && [ \"$require_rebuild\" != \"1\" ]; then\n  cause=\"build_rc_tolerated_runtime_smoke_ok\"\n  echo \"[driver_selfbuild_smoke] warn: rebuild failed but runtime smoke passed (require_rebuild=0)\" 1>&2\nfi\n\n")
        patchedSmoke = strutil.replace(
            patchedSmoke,
            "if [ \"$build_rc\" -ne 0 ] || [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\n",
            "if [ \"$smoke_rc\" -ne 0 ]; then\n  result=\"fail\"\nfi\nif [ \"$build_rc\" -ne 0 ] && [ \"$require_rebuild\" = \"1\" ]; then\n  result=\"fail\"\nfi\n")
        return patchedSmoke
    if tooling_strEq(id, "backend_prod_closure"):
        let rawProd: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
        if !tooling_strNonEmpty(rawProd):
            return ""
        var patchedProd: str = rawProd
        patchedProd = strutil.replace(
            patchedProd,
            "  for cand in \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\"; do",
            "  for cand in \\\n    \"${BACKEND_DRIVER:-}\" \\\n    \"artifacts/backend_driver/cheng\" \\\n    \"artifacts/backend_seed/cheng.stage2\" \\\n    \"dist/releases/current/cheng\"; do")
        patchedProd = strutil.replace(
            patchedProd,
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-}\"",
            "mm_gate_driver=\"${BACKEND_MM_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required \"backend.mm\" env \\\n      BACKEND_DRIVER=\"$mm_gate_driver\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"",
            "run_required \"backend.mm\" env \\\n      BACKEND_DRIVER=\"$mm_gate_driver\" \\\n      BACKEND_MM_LINKER=\"${BACKEND_MM_LINKER:-self}\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required \"backend.mm\" env \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"",
            "run_required \"backend.mm\" env \\\n      BACKEND_MM_LINKER=\"${BACKEND_MM_LINKER:-self}\" \\\n      STAGE1_NO_POINTERS_NON_C_ABI=0 \\\n      STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 \\\n      \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_mm\"")
        patchedProd = strutil.replace(
            patchedProd,
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-artifacts/backend_driver/cheng}\"",
            "self_linker_gate_driver=\"${BACKEND_SELF_LINKER_DRIVER:-${BACKEND_DRIVER:-artifacts/backend_driver/cheng}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "opt_gate_driver=\"${BACKEND_OPT_DRIVER:-}\"",
            "opt_gate_driver=\"${BACKEND_OPT_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-}\"",
            "linkerless_gate_driver=\"${BACKEND_LINKERLESS_DRIVER:-${BACKEND_DRIVER:-}}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "\ncase \"0\" in\n  0|1)\n    ;;\n  *)\n    echo \"[Error] invalid no_publish_stable_profile: 0 (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\n",
            "\n")
        patchedProd = strutil.replace(
            patchedProd,
            "if [ \"$debug_explicit\" = \"0\" ] && [ \"$(uname -s 2>/dev/null || echo unknown)\" = \"Darwin\" ] && ! { [ \"$run_publish\" = \"\" ] && [ \"0\" = \"1\" ]; }; then",
            "if [ \"$debug_explicit\" = \"0\" ] && [ \"$(uname -s 2>/dev/null || echo unknown)\" = \"Darwin\" ]; then")
        patchedProd = strutil.replace(
            patchedProd,
            "run_selfhost_100ms=\"${BACKEND_RUN_SELFHOST_100MS:-0}\"\nrun_multi_perf=\"${BACKEND_RUN_MULTI_PERF:-0}\"",
            "run_selfhost_100ms=\"${BACKEND_RUN_SELFHOST_100MS:-0}\"\nrun_cdrop_emergency=\"${BACKEND_RUN_CDROP_EMERGENCY:-0}\"\nrun_multi_perf=\"${BACKEND_RUN_MULTI_PERF:-0}\"")
        patchedProd = strutil.replace(
            patchedProd,
            "if [ \"$run_selfhost\" != \"\" ] && [ \"$run_selfhost_100ms\" = \"1\" ]; then\n  run_required \"backend.selfhost_100ms_host\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_100ms_host\"\nfi\n\nresolve_main_driver_fallback() {",
            "if [ \"$run_selfhost\" != \"\" ] && [ \"$run_selfhost_100ms\" = \"1\" ]; then\n  run_required \"backend.selfhost_100ms_host\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_selfhost_100ms_host\"\nfi\n\nif [ \"$run_cdrop_emergency\" = \"1\" ]; then\n  run_required_timeout \"backend.cdrop_emergency\" \"$selfhost_bootstrap_gate_timeout\" \\\n    \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_cdrop_emergency\"\nfi\n\nresolve_main_driver_fallback() {")
        patchedProd = strutil.replace(
            patchedProd,
            "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\n",
            "root=\"$(CDPATH= cd -- \"$(dirname -- \"$0\")/../..\" && pwd)\"\ncd \"$root\"\n\ninmem_only=\"${BACKEND_PROD_INMEM_ONLY:-1}\"\ncase \"$inmem_only\" in\n  1|true|TRUE|yes|YES|on|ON)\n    inmem_only=\"1\"\n    ;;\n  0|false|FALSE|no|NO|off|OFF|\"\")\n    inmem_only=\"0\"\n    ;;\n  *)\n    echo \"[backend_prod_closure] invalid BACKEND_PROD_INMEM_ONLY: $inmem_only (expected 0|1)\" 1>&2\n    exit 2\n    ;;\nesac\nif [ \"$inmem_only\" = \"1\" ]; then\n  export BACKEND_EMIT=exe\n  export BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0\n  export BACKEND_LINKER=self\n  export BACKEND_DIRECT_EXE=1\n  export BACKEND_LINKERLESS_INMEM=1\n  export BACKEND_FAST_FALLBACK_ALLOW=0\n  export BACKEND_INCREMENTAL=0\n  export BACKEND_MULTI=0\n  export BACKEND_MULTI_FORCE=0\n  export BACKEND_NO_RUNTIME_C=1\n  export BACKEND_RUNTIME_OBJ=\n  export BACKEND_PROD_STAGE0_PROBE_MODE=path\n  export BACKEND_MM_LINKER=self\nfi\n\n")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noalias_opt\"\nrun_required \"backend.egraph_cost\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_egraph_cost\"\nrun_required \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_opt_regression\"\n",
            "run_required \"backend.noalias_opt\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_noalias_opt\"\nrun_required \"backend.egraph_cost\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_egraph_cost\"\nrun_required \"backend.dod_opt_regression\" env \\\n  STAGE1_SKIP_OWNERSHIP=0 \\\n  UIR_NOALIAS_REQUIRE_PROOF=1 \\\n  UIR_EGRAPH_REQUIRE_PROOF=1 \\\n  \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_backend_dod_opt_regression\"\n")
        patchedProd = strutil.replace(
            patchedProd,
            "if [ \"$run_fullchain\" != \"\" ]; then\n  run_required \"backend.fullchain_bootstrap.obj_only\" env FULLCHAIN_OBJ_ONLY=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_fullchain_bootstrap\"\nfi\n",
            "if [ \"$run_fullchain\" != \"\" ]; then\n  if [ \"$inmem_only\" = \"1\" ]; then\n    echo \"== backend.fullchain_bootstrap.obj_only (skip: BACKEND_PROD_INMEM_ONLY=1 forbids obj-only gate) ==\"\n  else\n    run_required \"backend.fullchain_bootstrap.obj_only\" env FULLCHAIN_OBJ_ONLY=1 \"$TOOLING_EXEC_BUNDLE_BIN_DIR/verify_fullchain_bootstrap\"\n  fi\nfi\n")
        patchedProd = strutil.replace(
            patchedProd,
            "run_optional() {\n  label=\"$1\"\n  shift\n  run_optional_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_optional_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n",
            "run_optional() {\n  label=\"$1\"\n  shift\n  if should_skip_inmem_gate \"$label\"; then\n    echo \"== $label (skip: BACKEND_PROD_INMEM_ONLY=1 in-memory profile) ==\"\n    return 0\n  fi\n  run_optional_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_optional_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n  if should_skip_inmem_gate \"$label\"; then\n    echo \"== $label (skip: BACKEND_PROD_INMEM_ONLY=1 in-memory profile) ==\"\n    return 0\n  fi\n")
        patchedProd = strutil.replace(
            patchedProd,
            "run_required() {\n  label=\"$1\"\n  shift\n  run_required_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_required_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n",
            "should_skip_inmem_gate() {\n  label=\"$1\"\n  if [ \"${inmem_only:-0}\" != \"1\" ]; then\n    return 1\n  fi\n  case \"$label\" in\n    tooling.cmdline_runner|backend.no_legacy_refs|backend.profile_schema|backend.emit_obj_contract|backend.rawptr_contract|backend.rawptr_surface_forbid|backend.rawptr_migration|backend.profile_baseline|backend.no_obj_cleanup|backend.no_obj_artifacts|backend.noalias_opt|backend.egraph_cost|backend.dod_opt_regression)\n      return 1\n      ;;\n    *)\n      return 0\n      ;;\n  esac\n}\n\nrun_required() {\n  label=\"$1\"\n  shift\n  if should_skip_inmem_gate \"$label\"; then\n    echo \"== $label (skip: BACKEND_PROD_INMEM_ONLY=1 in-memory profile) ==\"\n    return 0\n  fi\n  run_required_timeout \"$label\" \"$selfhost_gate_timeout\" \"$@\"\n}\n\nrun_required_timeout() {\n  label=\"$1\"\n  timeout_sec=\"$2\"\n  shift 2\n  if should_skip_inmem_gate \"$label\"; then\n    echo \"== $label (skip: BACKEND_PROD_INMEM_ONLY=1 in-memory profile) ==\"\n    return 0\n  fi\n")
        return patchedProd
    let raw: str = tooling_embedded_inline.toolingEmbeddedScriptBody(id)
    if !tooling_strNonEmpty(raw):
        return ""
    # Runtime normalize is expensive for large embedded scripts and can trigger
    # pathological memory spikes. Keep it opt-in for emergency compatibility.
    if tooling_isTrue(os.getEnvDefault("TOOLING_EMBEDDED_RUNTIME_NORMALIZE", "0")):
        return tooling_normalizeEmbeddedScriptText(id, raw)
    return raw

fn tooling_resolveScriptPath(root: str, rawName: str): str =
    var name: str = strutil.strip(rawName)
    if !tooling_strNonEmpty(name):
        return ""
    if strutil.startsWith(name, "src/tooling/"):
        name = strings.dropPrefix(name, "src/tooling/")
    name = tooling_stripShSuffix(name)
    if !tooling_isSafeScriptName(name):
        return ""
    let ids: str[] = tooling_embeddedScriptIds(root)
    if tooling_idsContains(ids, name):
        return tooling_embeddedPrefix() + name
    return ""

fn tooling_collectScripts(root: str): str[] =
    let ids: str[] = tooling_embeddedScriptIds(root)
    var out: str[] = []
    for i in 0..<ids.len:
        let name: str = ids[i]
        if !tooling_isSafeScriptName(name):
            continue
        if tooling_idsContains(out, name):
            continue
        add(out, name)
    if !tooling_idsContains(out, "verify_backend_opt2_impl_surface"):
        add(out, "verify_backend_opt2_impl_surface")
    if !tooling_idsContains(out, "verify_backend_rawptr_migration"):
        add(out, "verify_backend_rawptr_migration")
    if !tooling_idsContains(out, "verify_backend_cdrop_emergency"):
        add(out, "verify_backend_cdrop_emergency")
    return out

fn tooling_pathExists(path: str): bool =
    if !tooling_strNonEmpty(path):
        return false
    if os.fileExists(path):
        return true
    if os.dirExists(path):
        return true
    return false

fn tooling_printExecOutput(result: os.ExecCmdResult) =
    let out: str = os.execCmdResultOutput(result)
    if tooling_strNonEmpty(out):
        os.write(os.get_stdout(), out)

fn tooling_exec(root: str, command: str): os.ExecCmdResult =
    let opts: uint64 = uint64(7)
    return os.execCmdEx(command, opts, root)

fn tooling_wrapCommandWithTimeout(root: str, timeoutSecRaw: int32, command: str): str =
    if !tooling_strNonEmpty(command):
        return command
    var timeoutSec: int32 = timeoutSecRaw
    if timeoutSec <= 0:
        return command
    let perlProbe: os.ExecCmdResult = tooling_exec(root, "command -v perl >/dev/null 2>&1")
    if os.execCmdResultExitCode(perlProbe) == 0:
        let noOrphanText: str = tooling_isTrue(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN", "1")) ? "1" : "0"
        var drainSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN_DRAIN_SEC", ""), 1)
        if drainSec < 0:
            drainSec = 0
        var drainMaxLoops: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_TIMEOUT_NO_ORPHAN_DRAIN_MAX_LOOPS", ""), 8)
        if drainMaxLoops < 1:
            drainMaxLoops = 1
        let perlBody: str =
            "use POSIX qw(setsid WNOHANG);" +
            " my $timeout = shift;" +
            " my $no_orphan = shift;" +
            " my $drain_sec = shift;" +
            " my $drain_max_loops = shift;" +
            " my $log = shift;" +
            " if (!defined $drain_sec || $drain_sec < 0) { $drain_sec = 0; }" +
            " if (!defined $drain_max_loops || $drain_max_loops < 1) { $drain_max_loops = 1; }" +
            " my $pid = fork();" +
            " if (!defined $pid) { exit 127; }" +
            " if ($pid == 0) { setsid();" +
            "   if (defined $log && length($log) > 0) {" +
            "     open(STDOUT, '>>', $log);" +
            "     open(STDERR, '>>', $log);" +
            "   }" +
            "   exec @ARGV; exit 127; }" +
            " my $end = time + $timeout;" +
            " while (1) {" +
            "   my $res = waitpid($pid, WNOHANG);" +
            "   if ($res == $pid) {" +
            "     my $status = $?;" +
            "     if (($status & 127) != 0) { exit(128 + ($status & 127)); }" +
            "     exit($status >> 8);" +
            "   }" +
            "   if (time >= $end) {" +
            "     kill \"TERM\", -$pid;" +
            "     kill \"TERM\", $pid;" +
            "     my $grace_end = time + 1;" +
            "     while (time < $grace_end) {" +
            "       $res = waitpid($pid, WNOHANG);" +
            "       if ($res == $pid) {" +
            "         my $status = $?;" +
            "         if (($status & 127) != 0) { exit(128 + ($status & 127)); }" +
            "         exit($status >> 8);" +
            "       }" +
            "       select(undef, undef, undef, 0.1);" +
            "     }" +
            "     kill \"KILL\", -$pid;" +
            "     kill \"KILL\", $pid;" +
            "     if ($no_orphan) {" +
            "       my $drain_end = time + $drain_sec;" +
            "       my $drain_loops = 0;" +
            "       while (1) {" +
            "         $res = waitpid($pid, WNOHANG);" +
            "         last if ($res == $pid || $res == -1);" +
            "         last if (time >= $drain_end);" +
            "         last if ($drain_loops >= $drain_max_loops);" +
            "         $drain_loops = $drain_loops + 1;" +
            "         kill \"KILL\", -$pid;" +
            "         kill \"KILL\", $pid;" +
            "         select(undef, undef, undef, 0.2);" +
            "       }" +
            "     }" +
            "     exit 124;" +
            "   }" +
            "   select(undef, undef, undef, 0.1);" +
            " }"
        let wrapped: str =
            "tmp_log=$(mktemp /tmp/cheng_tooling_timeout.XXXXXX) ; " +
            "if [ -z \"$tmp_log\" ]; then exit 127; fi ; " +
            "perl -e " + tooling_shellQuote(perlBody) + " " + intToStr(timeoutSec) + " " + noOrphanText + " " +
            intToStr(drainSec) + " " + intToStr(drainMaxLoops) + " \"$tmp_log\" " +
            "sh -c " + tooling_shellQuote(command) + " ; " +
            "rc=$? ; " +
            "if [ -f \"$tmp_log\" ]; then cat \"$tmp_log\"; rm -f \"$tmp_log\"; fi ; " +
            "exit $rc"
        return wrapped
    let timeoutProbe: os.ExecCmdResult = tooling_exec(root, "command -v timeout >/dev/null 2>&1")
    if os.execCmdResultExitCode(timeoutProbe) == 0:
        return "timeout " + intToStr(timeoutSec) + "s sh -c " + tooling_shellQuote(command)
    return command

fn tooling_scriptShell(root: str, scriptPath: str): str =
    if !tooling_strNonEmpty(scriptPath):
        return "sh"
    let cmd: str = "head -n 1 " + tooling_shellQuote(scriptPath)
    let result: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(result) != 0:
        return "sh"
    let line: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(result)))
    if strutil.contains(line, "bash"):
        return "bash"
    return "sh"

fn tooling_scriptShellFromText(scriptText: str): str =
    if !tooling_strNonEmpty(scriptText):
        return "sh"
    var probeLen: int32 = len(scriptText)
    if probeLen > 160:
        probeLen = 160
    let probe: str = strings.sliceBytes(scriptText, 0, probeLen)
    let lower: str = strutil.toLowerAscii(strutil.strip(probe))
    if strutil.startsWith(lower, "#!/usr/bin/env bash") || strutil.startsWith(lower, "#!/bin/bash"):
        return "bash"
    return "sh"

fn tooling_embeddedArgv0(root: str, scriptId: str): str =
    if !tooling_strNonEmpty(scriptId):
        return "cheng_tooling"
    if !tooling_strNonEmpty(root):
        return "cheng_tooling:" + scriptId
    let scriptName: str = scriptId + ".sh"
    return os.joinPath(root, os.joinPath("src/tooling", scriptName))

fn tooling_embeddedScriptPreferFreshCache(scriptId: str): bool =
    if tooling_strEq(scriptId, "verify_cheng_skill_consistency"):
        return true
    if tooling_strEq(scriptId, "verify_backend_x86_64_linux"):
        return true
    if tooling_strEq(scriptId, "verify_backend_x86_64_darwin"):
        return true
    if tooling_strEq(scriptId, "verify_backend_mm"):
        return true
    if tooling_strEq(scriptId, "verify_backend_android"):
        return true
    if tooling_strEq(scriptId, "verify_backend_targets"):
        return true
    if tooling_strEq(scriptId, "verify_backend_targets_matrix"):
        return true
    if tooling_strEq(scriptId, "verify_libp2p_frontier"):
        return true
    if tooling_strEq(scriptId, "verify_backend_spawn_api_gate"):
        return true
    if tooling_strEq(scriptId, "verify_backend_mir_borrow"):
        return true
    if tooling_strEq(scriptId, "verify_backend_stage0_no_compat"):
        return true
    if tooling_strEq(scriptId, "verify_backend_ffi_outptr_tuple"):
        return true
    if tooling_strEq(scriptId, "verify_backend_float"):
        return true
    if tooling_strEq(scriptId, "verify_backend_selfhost_strict_noreuse_probe"):
        return true
    if tooling_strEq(scriptId, "verify_backend_plugin_system"):
        return true
    if tooling_strEq(scriptId, "verify_backend_noalias_opt"):
        return true
    if tooling_strEq(scriptId, "verify_backend_egraph_cost"):
        return true
    if tooling_strEq(scriptId, "verify_backend_dod_opt_regression"):
        return true
    if tooling_strEq(scriptId, "verify_backend_metering_stream"):
        return true
    if tooling_strEq(scriptId, "verify_backend_multi"):
        return true
    if tooling_strEq(scriptId, "verify_backend_determinism"):
        return true
    if tooling_strEq(scriptId, "verify_backend_uir_stability"):
        return true
    if tooling_strEq(scriptId, "verify_backend_dod_soa"):
        return true
    if tooling_strEq(scriptId, "verify_backend_abi_v2_noptr"):
        return true
    if tooling_strEq(scriptId, "verify_backend_noptr_default_cli"):
        return true
    if tooling_strEq(scriptId, "verify_backend_nolibc_linux_aarch64"):
        return true
    if tooling_strEq(scriptId, "verify_stage1_fullspec"):
        return true
    if tooling_strEq(scriptId, "verify_fullchain_bootstrap"):
        return true
    if tooling_strEq(scriptId, "verify_backend_native_contract"):
        return true
    if tooling_strEq(scriptId, "backend_driver_path"):
        return true
    return false

fn tooling_mkdirP(root: str, path: str): bool =
    let cmd: str = "mkdir -p " + tooling_shellQuote(path)
    let result: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(result)
    return os.execCmdResultExitCode(result) == 0

fn tooling_tryMkdirP(root: str, path: str) =
    if !tooling_strNonEmpty(path):
        return
    let created: bool = tooling_mkdirP(root, path)
    if created:
        return

fn tooling_writeTextFileViaShell(root: str, path: str, text: str): bool =
    # Avoid direct os.writeFile on large embedded payloads in multicall path;
    # shell heredoc write has proven stable across stage0 variants.
    if !tooling_strNonEmpty(path):
        return false
    let dir: str = os.parentDir(path)
    if tooling_strNonEmpty(dir):
        if !tooling_mkdirP(root, dir):
            return false
    var marker: str = "__CHENG_TOOLING_EOF__"
    if strutil.contains(text, marker):
        marker = "__CHENG_TOOLING_EOF_X__"
        if strutil.contains(text, marker):
            marker = "__CHENG_TOOLING_EOF_XX__"
    let cmd: str =
        "cat > " + tooling_shellQuote(path) + " <<'" + marker + "'\n" +
        text + "\n" +
        marker + "\n"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        tooling_printExecOutput(res)
        return false
    return true

fn tooling_programBaseName(): str =
    let raw: str = tooling_paramStr(0)
    if !tooling_strNonEmpty(raw):
        return ""
    let fileName: str = os.extractFilename(raw)
    if !tooling_strNonEmpty(fileName):
        return ""
    return tooling_stripShSuffix(fileName)

fn tooling_pathAbsolute(root: str, raw: str): str =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return ""
    if os.isAbsolute(text):
        return text
    if strutil.startsWith(text, "./") || strutil.startsWith(text, "../"):
        return os.absolutePath(text)
    return os.joinPath(root, text)

fn tooling_isTrue(raw: str): bool =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return false
    let lower: str = strutil.toLowerAscii(text)
    if tooling_strEq(lower, "1") || tooling_strEq(lower, "true") ||
       tooling_strEq(lower, "yes") || tooling_strEq(lower, "on"):
        return true
    return false

fn tooling_exitKind(rc: int32): str =
    if rc == 124 || rc == 143:
        return "timeout"
    if rc == 139:
        return "segfault"
    if rc >= 128:
        return "signal"
    if rc == 0:
        return "ok"
    return "error"

fn tooling_isCrashExitCode(rc: int32): bool =
    if rc == 132 || rc == 133 || rc == 134 || rc == 135 ||
       rc == 136 || rc == 137 || rc == 139:
        return true
    return false

fn tooling_parseInt32Default(raw: str, defaultValue: int32): int32 =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return defaultValue
    let n: int32 = len(text)
    var neg: bool = false
    var i: int32 = 0
    if text[0] == '-':
        neg = true
        i = 1
    if i >= n:
        return defaultValue
    var value: int64 = 0
    for _ in i..<n:
        let c: char = text[i]
        if c < '0' || c > '9':
            return defaultValue
        value = value * int64(10) + int64(int32(c) - int32('0'))
        i = i + 1
    if neg:
        value = int64(0) - value
    return int32(value)

fn tooling_strContains(text: str, needle: str): bool =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(needle):
        return false
    return strutil.contains(text, needle)

fn tooling_stripSuffix(text: str, suffix: str): str =
    if !tooling_strNonEmpty(text) || !tooling_strNonEmpty(suffix):
        return text
    let n: int32 = len(text)
    let m: int32 = len(suffix)
    if m > n:
        return text
    if !tooling_strEndsWith(text, suffix):
        return text
    return strings.sliceBytes(text, 0, n - m)

fn tooling_defaultCompileOut(root: str, inPath: str, outRaw: str, nameRaw: str): str =
    if tooling_strNonEmpty(outRaw):
        return tooling_pathAbsolute(root, outRaw)
    if tooling_strNonEmpty(nameRaw):
        let named: str = strutil.strip(nameRaw)
        if os.isAbsolute(named) || tooling_strContains(named, "/") || tooling_strContains(named, "\\"):
            return tooling_pathAbsolute(root, named)
        return os.joinPath(root, "artifacts/chengc/" + named)
    var base: str = os.extractFilename(inPath)
    base = tooling_stripSuffix(base, ".cheng")
    if !tooling_strNonEmpty(base):
        base = "a.out"
    return os.joinPath(root, "artifacts/chengc/" + base)

fn tooling_nowMs(): int64 =
    let mt: monotimes.MonoTime = monotimes.getMonoTime()
    return monotimes.monoTimeNs(mt) / int64(1000000)

fn tooling_msToSecondsText(msRaw: int64): str =
    var ms: int64 = msRaw
    if ms < int64(0):
        ms = int64(0)
    let sec: int64 = ms / int64(1000)
    let rem: int64 = ms % int64(1000)
    var remText: str = intToStr(int32(rem))
    if len(remText) == 1:
        remText = "00" + remText
    elif len(remText) == 2:
        remText = "0" + remText
    return intToStr(int32(sec)) + "." + remText

fn tooling_boolText(v: bool): str =
    if v:
        return "1"
    return "0"

fn tooling_bool01Normalized(raw: str): str =
    let text: str = strutil.toLowerAscii(strutil.strip(raw))
    if !tooling_strNonEmpty(text):
        return ""
    if tooling_strEq(text, "1") || tooling_strEq(text, "true") ||
       tooling_strEq(text, "yes") || tooling_strEq(text, "on"):
        return "1"
    if tooling_strEq(text, "0") || tooling_strEq(text, "false") ||
       tooling_strEq(text, "no") || tooling_strEq(text, "off"):
        return "0"
    return ""

fn tooling_selfhostModeNormalized(raw: str): str =
    let mode: str = strutil.toLowerAscii(strutil.strip(raw))
    if tooling_strEq(mode, "fast") || tooling_strEq(mode, "strict"):
        return mode
    return ""

fn tooling_selfhostModeFromEnv(defaultModeRaw: str): str =
    var fallback: str = tooling_selfhostModeNormalized(defaultModeRaw)
    if !tooling_strNonEmpty(fallback):
        fallback = "fast"
    let envMode: str = tooling_selfhostModeNormalized(os.getEnvDefault("SELF_OBJ_BOOTSTRAP_MODE", fallback))
    if tooling_strNonEmpty(envMode):
        return envMode
    return fallback

fn tooling_firstToken(raw: str): str =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return ""
    let n: int32 = len(text)
    var i: int32 = 0
    while i < n:
        let ch: char = text[i]
        if ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r':
            break
        i = i + 1
    if i <= 0:
        return ""
    return strings.sliceBytes(text, 0, i)

fn tooling_sha256File(root: str, pathRaw: str): str =
    let path: str = tooling_pathAbsolute(root, pathRaw)
    if !tooling_strNonEmpty(path) || !os.fileExists(path):
        return ""
    var cmd: str = ""
    let hasShasum: os.ExecCmdResult = tooling_exec(root, "command -v shasum >/dev/null 2>&1")
    if os.execCmdResultExitCode(hasShasum) == 0:
        cmd = "shasum -a 256 " + tooling_shellQuote(path)
    else:
        let hasSha256sum: os.ExecCmdResult = tooling_exec(root, "command -v sha256sum >/dev/null 2>&1")
        if os.execCmdResultExitCode(hasSha256sum) != 0:
            return ""
        cmd = "sha256sum " + tooling_shellQuote(path)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return ""
    let firstLineToken: str = tooling_firstToken(os.execCmdResultOutput(res))
    if !tooling_strNonEmpty(firstLineToken):
        return ""
    return firstLineToken

fn tooling_uname(root: str, flag: str): str =
    let cmd: str = "uname " + flag
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return ""
    return strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))

fn tooling_detectHostTag(root: str): str =
    let hostOs: str = tooling_uname(root, "-s")
    let hostArch: str = tooling_uname(root, "-m")
    if tooling_strEq(hostOs, "darwin") && tooling_strEq(hostArch, "arm64"):
        return "darwin_arm64"
    if !tooling_strNonEmpty(hostOs) || !tooling_strNonEmpty(hostArch):
        return "unknown"
    return hostOs + "_" + hostArch

fn tooling_detectHostTarget(root: str): str =
    let hostOs: str = tooling_uname(root, "-s")
    let hostArch: str = tooling_uname(root, "-m")
    if tooling_strEq(hostOs, "darwin") && tooling_strEq(hostArch, "arm64"):
        return "arm64-apple-darwin"
    if tooling_strEq(hostOs, "darwin") &&
       (tooling_strEq(hostArch, "x86_64") || tooling_strEq(hostArch, "amd64")):
        return "x86_64-apple-darwin"
    if tooling_strEq(hostOs, "linux") &&
       (tooling_strEq(hostArch, "aarch64") || tooling_strEq(hostArch, "arm64")):
        return "aarch64-unknown-linux-gnu"
    if tooling_strEq(hostOs, "linux") &&
       (tooling_strEq(hostArch, "x86_64") || tooling_strEq(hostArch, "amd64")):
        return "x86_64-unknown-linux-gnu"
    return ""

fn tooling_normalizeTargetAlias(root: str, targetRaw: str): str =
    let lower: str = strutil.toLowerAscii(strutil.strip(targetRaw))
    if !tooling_strNonEmpty(lower) || tooling_strEq(lower, "auto") ||
       tooling_strEq(lower, "native") || tooling_strEq(lower, "host"):
        let detected: str = tooling_detectHostTarget(root)
        if tooling_strNonEmpty(detected):
            return detected
        return "auto"
    if tooling_strEq(lower, "darwin_arm64") || tooling_strEq(lower, "darwin_aarch64"):
        return "arm64-apple-darwin"
    if tooling_strEq(lower, "darwin_x86_64") || tooling_strEq(lower, "darwin_amd64"):
        return "x86_64-apple-darwin"
    if tooling_strEq(lower, "linux_arm64") || tooling_strEq(lower, "linux_aarch64"):
        return "aarch64-unknown-linux-gnu"
    if tooling_strEq(lower, "linux_x86_64") || tooling_strEq(lower, "linux_amd64"):
        return "x86_64-unknown-linux-gnu"
    if tooling_strEq(lower, "linux_riscv64"):
        return "riscv64-unknown-linux-gnu"
    if tooling_strEq(lower, "windows_arm64") || tooling_strEq(lower, "windows_aarch64"):
        return "aarch64-pc-windows-msvc"
    if tooling_strEq(lower, "windows_x86_64") || tooling_strEq(lower, "windows_amd64"):
        return "x86_64-pc-windows-msvc"
    return lower

fn tooling_targetSupportsSelfLinker(targetRaw: str): bool =
    let target: str = strutil.toLowerAscii(strutil.strip(targetRaw))
    if !tooling_strNonEmpty(target):
        return false
    # Keep tooling defaults aligned with backend_driver host-only self-link
    # capability to avoid selecting unsupported targets.
    if !tooling_strContains(target, "darwin"):
        return false
    if tooling_strContains(target, "arm64") || tooling_strContains(target, "aarch64"):
        return true
    return false

fn tooling_isExecutable(root: str, path: str): bool =
    if !tooling_strNonEmpty(path):
        return false
    root
    return os.fileExists(path)

fn tooling_stage0HasUninterruptibleProcess(root: str, stage0Path: str): bool =
    if tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_SKIP_UE_GUARD", "0")):
        return false
    if !tooling_strNonEmpty(stage0Path):
        return false
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao pid=,ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return false
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let fullPath: str = tooling_pathAbsolute(root, stage0Path)
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    let autoKill: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_AUTO_KILL_PATH_UE", "1"))
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let pidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= pidStart:
            continue
        let pidToken: str = strings.sliceBytes(line, pidStart, j - pidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        var k: int32 = j
        while k < n && (line[k] == ' ' || line[k] == '\t'):
            k = k + 1
        let stateStart: int32 = k
        while k < n && line[k] != ' ' && line[k] != '\t':
            k = k + 1
        if k <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, k - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while k < n && (line[k] == ' ' || line[k] == '\t'):
            k = k + 1
        if k >= n:
            continue
        let cmd: str = strings.sliceBytes(line, k, n - k)
        if tooling_strEq(cmd, fullPath) || strutil.startsWith(cmd, fullPath + " "):
            return true
        var tEnd: int32 = 0
        while tEnd < len(cmd) && cmd[tEnd] != ' ' && cmd[tEnd] != '\t':
            tEnd = tEnd + 1
        if tEnd <= 0:
            continue
        let cmdToken: str = strings.sliceBytes(cmd, 0, tEnd)
        var cmdTokenPath: str = cmdToken
        if cmdToken[0] != '/':
            cmdTokenPath = tooling_pathAbsolute(root, cmdToken)
        let hit: bool = tooling_strEq(cmdTokenPath, fullPath)
        if hit && autoKill && tooling_stage0QuarantineKillPid(root, pidToken):
            tooling_printErr("cheng_tooling: auto-killed stuck/orphan stage0 process pid=" +
                             strutil.strip(pidToken) + " path=" + fullPath)
            continue
        if hit:
            return true
    return false

fn tooling_tryRepairCanonicalStage0Driver(root: str, probeEnabled: bool): bool =
    let canonicalPath: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    if tooling_driverSanityOk(root, canonicalPath):
        if !probeEnabled || tooling_driverCompileProbeOk(root, canonicalPath):
            return true
    let recoveryEnabled: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_CANONICAL_RECOVER", "0"))
    if !recoveryEnabled:
        return false
    let recoveryPath: str = tooling_pathAbsolute(root, "dist/releases/current/cheng")
    if tooling_strEq(recoveryPath, canonicalPath):
        return false
    if tooling_stage0HasUninterruptibleProcess(root, recoveryPath):
        return false
    if !tooling_driverSanityOk(root, recoveryPath):
        return false
    if probeEnabled && !tooling_driverCompileProbeOk(root, recoveryPath):
        return false
    tooling_printErr("cheng_tooling: recover canonical stage0 driver from dist release: " + recoveryPath)
    if !tooling_copyExecutable(root, recoveryPath, canonicalPath):
        return false
    if !tooling_driverSanityOk(root, canonicalPath):
        return false
    if probeEnabled && !tooling_driverCompileProbeOk(root, canonicalPath):
        return false
    return true

fn tooling_stage0CandidateListWithProbe(root: str, explicitRaw: str, probeEnabled: bool): str[] =
    var out: str[] = []
    let explicit: str = strutil.strip(explicitRaw)
    if tooling_strNonEmpty(explicit):
        let explicitPath: str = tooling_pathAbsolute(root, explicit)
        if tooling_stage0HasUninterruptibleProcess(root, explicitPath):
            tooling_printErr("cheng_tooling: skip stage0 with stuck/orphan process: " + explicitPath)
            return out
        if !tooling_driverSanityOk(root, explicitPath):
            return out
        if probeEnabled && !tooling_driverCompileProbeOk(root, explicitPath):
            return out
        add(out, explicitPath)
        return out
    let _repairedCanonical: bool = tooling_tryRepairCanonicalStage0Driver(root, probeEnabled)
    var candidates: str[] = []
    add(candidates, "artifacts/backend_driver/cheng")
    for i in 0..<candidates.len:
        let candidatePath: str = tooling_pathAbsolute(root, candidates[i])
        if tooling_idsContains(out, candidatePath):
            continue
        if tooling_stage0HasUninterruptibleProcess(root, candidatePath):
            if tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_DEBUG", "0")):
                tooling_printErr("cheng_tooling: skip stage0 candidate with stuck/orphan process: " + candidatePath)
            continue
        if !tooling_driverSanityOk(root, candidatePath):
            continue
        if probeEnabled && !tooling_driverCompileProbeOk(root, candidatePath):
            continue
        add(out, candidatePath)
    return out

fn tooling_resolveStage0DriverWithProbe(root: str, explicitRaw: str, probeEnabled: bool): str =
    let candidates: str[] = tooling_stage0CandidateListWithProbe(root, explicitRaw, probeEnabled)
    if candidates.len <= 0:
        return ""
    return candidates[0]

fn tooling_resolveStage0Driver(root: str, explicitRaw: str): str =
    let probeEnabled: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_COMPILE_PROBE", "0"))
    return tooling_resolveStage0DriverWithProbe(root, explicitRaw, probeEnabled)

fn tooling_resolveStage0DriverStrict(root: str, explicitRaw: str): str =
    let probeEnabled: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_STRICT_COMPILE_PROBE", "0"))
    return tooling_resolveStage0DriverWithProbe(root, explicitRaw, probeEnabled)

fn tooling_releaseDriverPath(root: str): str =
    let configured: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_DRIVER", ""))
    if tooling_strNonEmpty(configured):
        return tooling_pathAbsolute(root, configured)
    return tooling_pathAbsolute(root, "artifacts/backend_release_driver/cheng")

fn tooling_releaseDriverEnsureHealthy(root: str, outPath: str, stage0: str): bool =
    if tooling_driverSanityOk(root, outPath) && tooling_driverCompileProbeOk(root, outPath):
        return true
    let allowStage0Alias: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_RELEASE_DRIVER_ALLOW_STAGE0_ALIAS", "1"))
    if !allowStage0Alias:
        return false
    tooling_printErr("cheng_tooling: release driver health probe failed; alias from stage0: " + stage0)
    if !tooling_copyExecutable(root, stage0, outPath):
        return false
    if tooling_driverSanityOk(root, outPath) && tooling_driverCompileProbeOk(root, outPath):
        tooling_printOut("build_release_driver_alias_stage0=" + stage0)
        return true
    return false

fn tooling_buildReleaseDriver(root: str, outRaw: str, stage0Raw: str, targetRaw: str): int32 =
    let src: str = os.joinPath(root, "src/backend/tooling/backend_driver.cheng")
    if !os.fileExists(src):
        tooling_printErr("cheng_tooling: release driver source not found: " + src)
        return 1
    var target: str = tooling_normalizeTargetAlias(root, targetRaw)
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        target = "auto"
    let outPath: str = tooling_pathAbsolute(root, outRaw)
    if !tooling_strNonEmpty(outPath):
        tooling_printErr("cheng_tooling: release driver output path is empty")
        return 1
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create release driver output dir: " + outDir)
            return 1
    let stage0: str = tooling_resolveStage0Driver(root, stage0Raw)
    if !tooling_strNonEmpty(stage0):
        tooling_printErr("cheng_tooling: release driver stage0 not found")
        return 1
    let stage0Exec: str = tooling_prepareStage0Exec(root, stage0, "build_release_driver")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: release driver stage0 prepare failed: " + stage0)
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: release driver stage0 preflight failed: " + stage0)
        return 1
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "release")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "3")
    let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
    let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
    if tooling_strNonEmpty(releaseCflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", releaseCflagsRaw)
    if tooling_strNonEmpty(releaseLdflagsRaw):
        cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", releaseLdflagsRaw)
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", src)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    cmd = cmd + tooling_shellQuote(stage0Exec)
    cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_RELEASE_DRIVER_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    cmd = tooling_wrapStage0Lock(root, cmd, "build_release_driver")
    cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
    tooling_printOut("build_release_driver_stage0=" + stage0)
    tooling_printOut("build_release_driver_stage0_exec=" + stage0Exec)
    tooling_printOut("build_release_driver_target=" + target)
    tooling_printOut("build_release_driver_linker=system")
    tooling_printOut("build_release_driver_out=" + outPath)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    let rc: int32 = os.execCmdResultExitCode(res)
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    if rc != 0:
        let allowSafeRebuild: bool = tooling_isTrue(
            os.getEnvDefault("TOOLING_RELEASE_DRIVER_ALLOW_SAFE_REBUILD", "1"))
        if allowSafeRebuild:
            tooling_printErr("cheng_tooling: release driver direct build failed rc=" + intToStr(rc) +
                             " kind=" + tooling_exitKind(rc) +
                             "; fallback to safe full rebuild")
            let fallbackRc: int32 = tooling_compileBackendDriverFastHost(root, stage0, target, outPath, true)
            if fallbackRc == 0:
                tooling_printOut("build_release_driver_fallback=safe_full_rebuild")
                tooling_printOut("build_release_driver_profile=release_safe_full_rebuild")
                if tooling_releaseDriverEnsureHealthy(root, outPath, stage0):
                    return 0
                tooling_printErr("cheng_tooling: release driver fallback output failed health probe")
                return 1
            tooling_printErr("cheng_tooling: release driver safe fallback failed rc=" + intToStr(fallbackRc) +
                             " kind=" + tooling_exitKind(fallbackRc))
            return fallbackRc
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    let chmodRc: int32 = os.execCmdResultExitCode(chmodRes)
    if chmodRc != 0:
        return chmodRc
    if !tooling_releaseDriverEnsureHealthy(root, outPath, stage0):
        tooling_printErr("cheng_tooling: release driver output failed health probe: " + outPath)
        return 1
    tooling_printOut("build_release_driver_profile=release_system_link")
    return 0

fn tooling_releaseDriverForCompile(root: str, stage0Raw: str, targetRaw: str): str =
    let explicit: str = strutil.strip(stage0Raw)
    if tooling_strNonEmpty(explicit):
        return tooling_resolveStage0Driver(root, explicit)
    let releaseDriver: str = tooling_releaseDriverPath(root)
    if tooling_driverSanityOk(root, releaseDriver):
        return releaseDriver
    if !tooling_isTrue(os.getEnvDefault("TOOLING_RELEASE_DRIVER_AUTO_BUILD", "1")):
        return ""
    let releaseStage0Raw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_DRIVER_STAGE0", ""))
    let buildRc: int32 = tooling_buildReleaseDriver(root, releaseDriver, releaseStage0Raw, targetRaw)
    if buildRc != 0:
        return ""
    if tooling_driverSanityOk(root, releaseDriver):
        return releaseDriver
    return ""

fn tooling_stage0DriverKind(root: str, stage0Path: str): str =
    let absPath: str = tooling_pathAbsolute(root, stage0Path)
    let canonical: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    if tooling_strEq(absPath, canonical):
        return "artifacts_backend_driver"
    let releaseDriver: str = tooling_releaseDriverPath(root)
    if tooling_strEq(absPath, releaseDriver):
        return "artifacts_backend_release_driver"
    if strutil.contains(absPath, "/dist/releases/current/cheng"):
        return "dist_release"
    if strutil.contains(absPath, "/artifacts/backend_seed/"):
        return "backend_seed"
    if strutil.contains(absPath, "/artifacts/backend_selfhost_self_obj/"):
        return "selfhost_obj"
    return "explicit"

fn tooling_buildDriverSegfaultRescueCandidate(root: str, failedStage0Raw: str, explicitStage0Raw: str): str =
    if !tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE", "0")):
        return ""
    let explicitStage0: str = strutil.strip(explicitStage0Raw)
    if tooling_strNonEmpty(explicitStage0) &&
       !tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_WITH_EXPLICIT", "0")):
        return ""
    let failedStage0: str = tooling_pathAbsolute(root, failedStage0Raw)
    var candidates: str[] = []
    let envCandidateRaw: str = strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_STAGE0", ""))
    if tooling_strNonEmpty(envCandidateRaw):
        add(candidates, envCandidateRaw)
    add(candidates, "artifacts/backend_seed/cheng.stage2")
    add(candidates, "artifacts/backend_selfhost_native/cheng.stage2")
    add(candidates, "artifacts/backend_selfhost_self_obj/cheng.stage2")
    for i in 0..<candidates.len:
        let candidatePath: str = tooling_pathAbsolute(root, candidates[i])
        if !tooling_strNonEmpty(candidatePath):
            continue
        if tooling_strEq(candidatePath, failedStage0):
            continue
        if tooling_stage0HasUninterruptibleProcess(root, candidatePath):
            continue
        if !tooling_driverSanityOk(root, candidatePath):
            continue
        if !tooling_driverCompileProbeOk(root, candidatePath):
            continue
        return candidatePath
    return ""

fn tooling_detectHostJobs(root: str): int32 =
    let fromGetconf: os.ExecCmdResult = tooling_exec(root, "getconf _NPROCESSORS_ONLN")
    if os.execCmdResultExitCode(fromGetconf) == 0:
        let parsed0: int32 = tooling_parseInt32Default(os.execCmdResultOutput(fromGetconf), 0)
        if parsed0 > 0:
            return parsed0
    let fromSysctl: os.ExecCmdResult = tooling_exec(root, "sysctl -n hw.logicalcpu")
    if os.execCmdResultExitCode(fromSysctl) == 0:
        let parsed1: int32 = tooling_parseInt32Default(os.execCmdResultOutput(fromSysctl), 0)
        if parsed1 > 0:
            return parsed1
    return 1

fn tooling_copyExecutable(root: str, srcPath: str, dstPath: str): bool =
    if !tooling_strNonEmpty(srcPath) || !tooling_strNonEmpty(dstPath):
        return false
    if tooling_strEq(srcPath, dstPath):
        if !tooling_pathExists(srcPath):
            return false
        let chmodSame: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(dstPath))
        tooling_printExecOutput(chmodSame)
        return os.execCmdResultExitCode(chmodSame) == 0
    let outDir: str = os.parentDir(dstPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            return false
    let cmd: str = "cp " + tooling_shellQuote(srcPath) + " " + tooling_shellQuote(dstPath) +
                   " && chmod +x " + tooling_shellQuote(dstPath)
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res) == 0

fn tooling_stage0QuarantineEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE", "1"))

fn tooling_stage0QuarantineDir(root: str): str =
    return os.joinPath(root, "chengcache/stage0_quarantine")

fn tooling_stage0LockEnabled(): bool =
    return tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_LOCK", "1"))

fn tooling_stage0LockDir(root: str): str =
    return os.joinPath(tooling_stage0QuarantineDir(root), "stage0.lock")

fn tooling_stage0LockContextPreferTakeover(context: str): bool =
    if tooling_strContains(context, "build_backend_driver"):
        return true
    if tooling_strContains(context, "stage0_compile_probe"):
        return true
    if tooling_strContains(context, "runtime_obj_refresh"):
        return true
    return false

fn tooling_wrapStage0Lock(root: str, command: str, contextRaw: str): str =
    if !tooling_strNonEmpty(command):
        return command
    if !tooling_stage0LockEnabled():
        return command
    tooling_tryMkdirP(root, tooling_stage0QuarantineDir(root))
    var context: str = strutil.strip(contextRaw)
    if !tooling_strNonEmpty(context):
        context = "stage0"
    let autoTakeoverDefault: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_LOCK_AUTO_TAKEOVER", "0"))
    let waitSecRaw: str = strutil.strip(os.getEnvDefault("TOOLING_STAGE0_LOCK_WAIT_SEC", ""))
    var waitSecDefault: int32 = 60
    if autoTakeoverDefault && !tooling_strNonEmpty(waitSecRaw) &&
       tooling_stage0LockContextPreferTakeover(context):
        waitSecDefault = 5
    var waitSec: int32 = tooling_parseInt32Default(waitSecRaw, waitSecDefault)
    if waitSec < 0:
        waitSec = 0
    var staleSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_STALE_SEC", ""), 600)
    if staleSec < 0:
        staleSec = 0
    let forceTakeoverRaw: str = strutil.strip(os.getEnvDefault("TOOLING_STAGE0_LOCK_FORCE_TAKEOVER", ""))
    var forceTakeover: bool = false
    if tooling_strNonEmpty(forceTakeoverRaw):
        forceTakeover = tooling_isTrue(forceTakeoverRaw)
    elif autoTakeoverDefault:
        forceTakeover = tooling_stage0LockContextPreferTakeover(context)
    var forceTakeoverText: str = "0"
    if forceTakeover:
        forceTakeoverText = "1"
    let lockDir: str = tooling_stage0LockDir(root)
    let timeoutMsg: str = "cheng_tooling: stage0 lock timeout context=" + context + " lock=" + lockDir
    let takeoverMsg: str = "cheng_tooling: stage0 lock forced takeover context=" + context + " lock=" + lockDir
    let wrapped: str =
        "lock_dir=" + tooling_shellQuote(lockDir) + " ; " +
        "lock_owner=\"$lock_dir/owner.pid\" ; " +
        "lock_since=\"$lock_dir/since.epoch\" ; " +
        "wait_sec=" + intToStr(waitSec) + " ; " +
        "stale_sec=" + intToStr(staleSec) + " ; " +
        "force_takeover=" + forceTakeoverText + " ; " +
        "lock_start=$(date +%s 2>/dev/null || echo 0) ; " +
        "lock_wait_ms=0 ; " +
        "while ! mkdir \"$lock_dir\" 2>/dev/null; do " +
        "  now=$(date +%s 2>/dev/null || echo 0) ; " +
        "  owner_pid=\"\" ; if [ -f \"$lock_owner\" ]; then owner_pid=$(cat \"$lock_owner\" 2>/dev/null); fi ; " +
        "  owner_alive=0 ; if [ -n \"$owner_pid\" ] && kill -0 \"$owner_pid\" 2>/dev/null; then owner_alive=1; fi ; " +
        "  stale=0 ; " +
        "  if [ -f \"$lock_since\" ]; then " +
        "    lock_ts=$(cat \"$lock_since\" 2>/dev/null) ; " +
        "    if [ -n \"$lock_ts\" ] && [ \"$stale_sec\" -gt 0 ] && [ \"$now\" -gt 0 ] && [ \"$lock_ts\" -gt 0 ]; then " +
        "      if [ $((now - lock_ts)) -ge \"$stale_sec\" ]; then stale=1; fi ; " +
        "    fi ; " +
        "  fi ; " +
        "  if [ \"$owner_alive\" -eq 0 ]; then " +
        "    rm -rf \"$lock_dir\" 2>/dev/null ; " +
        "    continue; " +
        "  fi ; " +
        "  if [ \"$stale\" -eq 1 ]; then " +
        "    if [ \"$force_takeover\" = \"1\" ]; then " +
        "      if [ -n \"$owner_pid\" ]; then " +
        "        kill -TERM -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -TERM \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        sleep 0.2 ; " +
        "        kill -KILL -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -KILL \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "      fi ; " +
        "      rm -rf \"$lock_dir\" 2>/dev/null ; " +
        "      echo " + tooling_shellQuote(takeoverMsg) + " >&2 ; " +
        "      lock_start=\"$now\" ; " +
        "      continue; " +
        "    fi ; " +
        "    echo " + tooling_shellQuote(timeoutMsg) + " >&2 ; exit 125 ; " +
        "  fi ; " +
        "  if [ \"$wait_sec\" -gt 0 ] && [ \"$now\" -gt 0 ] && [ \"$lock_start\" -gt 0 ] && [ $((now - lock_start)) -ge \"$wait_sec\" ]; then " +
        "    if [ \"$force_takeover\" = \"1\" ]; then " +
        "      if [ -n \"$owner_pid\" ]; then " +
        "        kill -TERM -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -TERM \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        sleep 0.2 ; " +
        "        kill -KILL -\"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "        kill -KILL \"$owner_pid\" >/dev/null 2>&1 || true ; " +
        "      fi ; " +
        "      rm -rf \"$lock_dir\" >/dev/null 2>&1 || true ; " +
        "      echo " + tooling_shellQuote(takeoverMsg) + " >&2 ; " +
        "      lock_start=\"$now\" ; " +
        "      continue; " +
        "    fi ; " +
        "    echo " + tooling_shellQuote(timeoutMsg) + " >&2 ; exit 125 ; " +
        "  fi ; " +
        "  sleep 0.1 ; " +
        "done ; " +
        "lock_now=$(date +%s 2>/dev/null || echo 0) ; " +
        "if [ \"$lock_now\" -gt 0 ] && [ \"$lock_start\" -gt 0 ] && [ \"$lock_now\" -ge \"$lock_start\" ]; then " +
        "  lock_wait_ms=$(( (lock_now - lock_start) * 1000 )) ; " +
        "fi ; " +
        "echo $$ > \"$lock_owner\" 2>/dev/null ; " +
        "date +%s > \"$lock_since\" 2>/dev/null ; " +
        "trap 'rm -rf \"$lock_dir\" >/dev/null 2>&1' EXIT INT TERM ; " +
        "TOOLING_STAGE0_LOCK_WAIT_MS=\"$lock_wait_ms\" ; export TOOLING_STAGE0_LOCK_WAIT_MS ; " +
        "eval " + tooling_shellQuote(command) + " ; " +
        "rc=$? ; " +
        "rm -rf \"$lock_dir\" >/dev/null 2>&1 ; " +
        "trap - EXIT INT TERM ; " +
        "exit $rc"
    return wrapped

fn tooling_stage0UeCommandRelevant(root: str, qdir: str, cmdRaw: str): bool =
    let cmd: str = strutil.strip(cmdRaw)
    if !tooling_strNonEmpty(cmd):
        return false
    if tooling_strNonEmpty(qdir) && strutil.contains(cmd, qdir):
        return true
    # Cross-workspace quarantine leftovers should still block new heavy runs.
    if strutil.contains(cmd, "/stage0_quarantine/cheng."):
        return true
    let toolingBinPrefix: str = "/artifacts/tooling_cmd/cheng_tooling"
    if strutil.contains(cmd, toolingBinPrefix):
        if strutil.contains(cmd, " build-backend-driver") ||
           strutil.contains(cmd, " build_backend_driver") ||
           strutil.contains(cmd, " compile ") ||
           strutil.contains(cmd, " build-global") ||
           strutil.contains(cmd, " build_global") ||
           strutil.contains(cmd, " cleanup-backend-driver-history") ||
           strutil.contains(cmd, " cleanup_backend_driver_history"):
            return true
    let localToolingBin: str = os.joinPath(root, "artifacts/tooling_cmd/cheng_tooling")
    if tooling_strNonEmpty(localToolingBin) && strutil.contains(cmd, localToolingBin):
        return true
    return false

fn tooling_stage0QuarantineUeCount(root: str): int32 =
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return 0
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var count: int32 = 0
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !tooling_stage0UeCommandRelevant(root, qdir, cmd):
            continue
        count = count + 1
    return count

fn tooling_stage0QuarantineUePreview(root: str, limitRaw: int32): str =
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao pid=,ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return ""
    var limit: int32 = limitRaw
    if limit < 1:
        limit = 1
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var found: int32 = 0
    var preview: str = ""
    for i in 0..<rows.len:
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let pidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= pidStart:
            continue
        let pidToken: str = strings.sliceBytes(line, pidStart, j - pidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !tooling_stage0UeCommandRelevant(root, qdir, cmd):
            continue
        found = found + 1
        if found > limit:
            continue
        if tooling_strNonEmpty(preview):
            preview = preview + " | "
        preview = preview + "pid=" + strutil.strip(pidToken) + ",ppid=" + strutil.strip(ppidToken) +
                  ",state=" + state + ",cmd=" + cmd
    if found > limit:
        if tooling_strNonEmpty(preview):
            preview = preview + " | "
        preview = preview + "+" + intToStr(found - limit) + " more"
    return preview

fn tooling_isDigitsOnly(raw: str): bool =
    let text: str = strutil.strip(raw)
    if !tooling_strNonEmpty(text):
        return false
    for i in 0..<len(text):
        let ch: char = text[i]
        if ch < '0' || ch > '9':
            return false
    return true

fn tooling_stage0QuarantineKillPid(root: str, pidTokenRaw: str): bool =
    let pidToken: str = strutil.strip(pidTokenRaw)
    if !tooling_isDigitsOnly(pidToken):
        return false
    let cmd: str =
        "kill -TERM " + pidToken + " >/dev/null 2>&1 || true ; " +
        "sleep 0.2 ; " +
        "if kill -0 " + pidToken + " >/dev/null 2>&1; then " +
        "  kill -KILL " + pidToken + " >/dev/null 2>&1 || true ; " +
        "  sleep 0.1 ; " +
        "fi ; " +
        "if kill -0 " + pidToken + " >/dev/null 2>&1; then exit 1; fi ; " +
        "exit 0"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    return os.execCmdResultExitCode(res) == 0

fn tooling_stage0QuarantineSweepUe(root: str, context: str): int32 =
    if !tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE_AUTO_KILL_UE", "1")):
        return 0
    let qdir: str = tooling_stage0QuarantineDir(root)
    let psRes: os.ExecCmdResult = tooling_exec(root, "ps -Ao pid=,ppid=,state=,command=")
    if os.execCmdResultExitCode(psRes) != 0:
        return 0
    var maxKill: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_QUARANTINE_AUTO_KILL_MAX", ""), 8)
    if maxKill < 1:
        maxKill = 1
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(psRes))
    let orphanGuard: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ORPHAN_GUARD", "1"))
    var attemptCount: int32 = 0
    var killedCount: int32 = 0
    for i in 0..<rows.len:
        if attemptCount >= maxKill:
            break
        let line: str = rows[i]
        let n: int32 = len(line)
        if n <= 0:
            continue
        var j: int32 = 0
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let pidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= pidStart:
            continue
        let pidToken: str = strings.sliceBytes(line, pidStart, j - pidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let ppidStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= ppidStart:
            continue
        let ppidToken: str = strings.sliceBytes(line, ppidStart, j - ppidStart)
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        let stateStart: int32 = j
        while j < n && line[j] != ' ' && line[j] != '\t':
            j = j + 1
        if j <= stateStart:
            continue
        let state: str = strings.sliceBytes(line, stateStart, j - stateStart)
        let uninterruptible: bool = tooling_strNonEmpty(state) && state[0] == 'U'
        let orphaned: bool = orphanGuard && tooling_strEq(strutil.strip(ppidToken), "1")
        if !uninterruptible && !orphaned:
            continue
        while j < n && (line[j] == ' ' || line[j] == '\t'):
            j = j + 1
        if j >= n:
            continue
        let cmd: str = strings.sliceBytes(line, j, n - j)
        if !tooling_stage0UeCommandRelevant(root, qdir, cmd):
            continue
        attemptCount = attemptCount + 1
        if tooling_stage0QuarantineKillPid(root, pidToken):
            killedCount = killedCount + 1
    if killedCount > 0:
        tooling_printErr("cheng_tooling: auto-cleaned quarantine stuck/orphan processes for " + context +
                         ": killed=" + intToStr(killedCount) + ", attempts=" + intToStr(attemptCount))
    return killedCount

fn tooling_stage0BlockOnQuarantineUe(root: str, blockEnv: str, context: str): bool =
    let hardBlock: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_HARD_BLOCK_ON_UE", "1"))
    let allowOverride: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_ALLOW_UE_OVERRIDE", "0"))
    var blockOnUe: bool = tooling_isTrue(os.getEnvDefault(blockEnv, "1"))
    if hardBlock:
        blockOnUe = true
    if !blockOnUe && !allowOverride:
        tooling_printErr("cheng_tooling: ignore " + blockEnv +
                         "=0 because TOOLING_STAGE0_HARD_BLOCK_ON_UE=1 (set TOOLING_STAGE0_ALLOW_UE_OVERRIDE=1 to force bypass)")
        blockOnUe = true
    if !blockOnUe:
        return false
    let ueCountBefore: int32 = tooling_stage0QuarantineUeCount(root)
    if ueCountBefore <= 0:
        return false
    let cleaned: int32 = tooling_stage0QuarantineSweepUe(root, context)
    var ueCount: int32 = tooling_stage0QuarantineUeCount(root)
    if ueCount > 0 && cleaned > 0:
        var rechecks: int32 = tooling_parseInt32Default(
            os.getEnvDefault("TOOLING_STAGE0_QUARANTINE_BLOCK_RECHECKS", ""), 2)
        if rechecks < 1:
            rechecks = 1
        for ri in 1..rechecks:
            let _sleepRes: os.ExecCmdResult = tooling_exec(root, "sleep 0.2")
            let _retryCleaned: int32 = tooling_stage0QuarantineSweepUe(root, context + ".recheck." + intToStr(ri))
            ueCount = tooling_stage0QuarantineUeCount(root)
            if ueCount <= 0:
                break
    if ueCount <= 0:
        return false
    tooling_printErr("cheng_tooling: blocked " + context + " due to stuck/orphan UE processes: " +
                     intToStr(ueCount) + " (override requires TOOLING_STAGE0_ALLOW_UE_OVERRIDE=1)")
    let preview: str = tooling_stage0QuarantineUePreview(root, 3)
    if tooling_strNonEmpty(preview):
        tooling_printErr("cheng_tooling: quarantine UE preview: " + preview)
    tooling_printErr("cheng_tooling: cleanup hint: ps -Ao pid,ppid,state,command | awk '$3 ~ /^U/ {print}'")
    return true


fn tooling_stage0PurposeTag(raw: str): str =
    let text: str = strutil.strip(raw)
    if tooling_strNonEmpty(text):
        return text
    return "run"

fn tooling_prepareStage0Exec(root: str, stage0Path: str, purposeRaw: str): str =
    if !tooling_isExecutable(root, stage0Path):
        return ""
    if !tooling_stage0QuarantineEnabled():
        return stage0Path
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_STAGE0_QUARANTINE_BLOCK_ON_UE", "stage0 run"):
        return ""
    let qdir: str = tooling_stage0QuarantineDir(root)
    tooling_tryMkdirP(root, qdir)
    var base: str = os.extractFilename(stage0Path)
    if !tooling_strNonEmpty(base):
        base = "cheng.stage0"
    let purpose: str = tooling_stage0PurposeTag(purposeRaw)
    let nonce: int32 = int32(tooling_nowMs() % int64(2000000000))
    let copiedPath: str = os.joinPath(qdir, base + "." + purpose + "." + intToStr(nonce))
    if !tooling_copyExecutable(root, stage0Path, copiedPath):
        tooling_printErr("cheng_tooling: stage0 quarantine copy failed: " + stage0Path)
        return ""
    return copiedPath

fn tooling_cleanupStage0Exec(stage0Original: str, stage0Exec: str) =
    if !tooling_strNonEmpty(stage0Exec):
        return
    if tooling_strEq(stage0Exec, stage0Original):
        return
    if os.fileExists(stage0Exec):
        os.removeFile(stage0Exec)

fn tooling_stage0PreflightOk(root: str, stage0Exec: str): bool =
    if !tooling_isExecutable(root, stage0Exec):
        return false
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_TIMEOUT", ""), 8)
    if timeoutSec <= 0:
        timeoutSec = 8
    var retries: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_RETRIES", ""), 3)
    if retries <= 0:
        retries = 1
    let strictPreflight: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_STRICT", "0"))
    let useWrapper: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_PREFLIGHT_WRAP", "0"))
    var lastRc: int32 = 1
    var lastKind: str = "error"
    for attempt in 1..retries:
        var cmd: str = tooling_shellQuote(stage0Exec) + " --help"
        if useWrapper:
            cmd = tooling_wrapStage0Lock(root, cmd, "stage0_preflight")
            cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
        let res: os.ExecCmdResult = tooling_exec(root, cmd)
        let rc: int32 = os.execCmdResultExitCode(res)
        let kind: str = tooling_exitKind(rc)
        lastRc = rc
        lastKind = kind
        # backend_driver --help returns rc=1 on some builds; treat as healthy.
        if rc == 0 || rc == 1:
            return true
        if tooling_strEq(kind, "timeout"):
            if strictPreflight:
                tooling_printErr("cheng_tooling: stage0 preflight timeout: " + stage0Exec)
                return false
            return true
        if attempt < retries:
            let cleaned: int32 = tooling_stage0QuarantineSweepUe(root, "stage0_preflight_retry")
            tooling_printErr("cheng_tooling: stage0 preflight retry " + intToStr(attempt) +
                             "/" + intToStr(retries) + " rc=" + intToStr(lastRc) +
                             " kind=" + lastKind + " cleaned=" + intToStr(cleaned))
    if lastRc >= 128:
        tooling_printErr("cheng_tooling: stage0 preflight failed rc=" + intToStr(lastRc) +
                         " kind=" + lastKind + " stage0=" + stage0Exec)
        return false
    return lastRc == 0

fn tooling_stripLeadingUnderscores(raw: str): str =
    if !tooling_strNonEmpty(raw):
        return ""
    let text: str = strutil.strip(raw)
    let n: int32 = len(text)
    if n <= 0:
        return ""
    var i: int32 = 0
    while i < n && text[i] == '_':
        i = i + 1
    if i >= n:
        return ""
    return strings.sliceBytes(text, i, n - i)

fn tooling_isForbiddenUndefinedDriverSymbol(raw: str): bool =
    let norm: str = tooling_stripLeadingUnderscores(raw)
    if !tooling_strNonEmpty(norm):
        return false
    let sym: str = strutil.toLowerAscii(norm)
    if tooling_strEq(sym, "backendmain") || tooling_strEq(sym, "getenvdefault") || tooling_strEq(sym, "writeline"):
        return true
    if tooling_strEq(sym, "streq") || tooling_strEq(sym, "paramcount") || tooling_strEq(sym, "paramstr"):
        return true
    if strutil.startsWith(sym, "uir") || strutil.startsWith(sym, "macho") ||
       strutil.startsWith(sym, "elf") || strutil.startsWith(sym, "coff") ||
       strutil.startsWith(sym, "os_") || strutil.startsWith(sym, "walkdir") ||
       strutil.startsWith(sym, "execcmd") || strutil.startsWith(sym, "readfile") ||
       strutil.startsWith(sym, "writefile") || strutil.startsWith(sym, "joinpath") ||
       strutil.startsWith(sym, "slice") || strutil.startsWith(sym, "parseint") ||
       strutil.startsWith(sym, "lowerascii") || strutil.startsWith(sym, "pathcomponent") ||
       strutil.startsWith(sym, "extractfilename") || strutil.startsWith(sym, "direxists") ||
       strutil.startsWith(sym, "getcurrentdir") || strutil.startsWith(sym, "getmonotime") ||
       strutil.startsWith(sym, "monotimens"):
        return true
    if strutil.startsWith(sym, "backend") || strutil.startsWith(sym, "driver_") ||
       strutil.startsWith(sym, "tooling") || strutil.startsWith(sym, "hashmap") ||
       strutil.startsWith(sym, "cheng_"):
        return true
    return false

fn tooling_driverUndefinedInternalSymbolsOk(root: str, binPath: str): bool =
    let guardEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_UNDEF_GUARD", "1"))
    if !guardEnabled:
        return true
    let probeNm: os.ExecCmdResult = tooling_exec(root, "command -v nm >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeNm) != 0:
        return true
    let probeAwk: os.ExecCmdResult = tooling_exec(root, "command -v awk >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeAwk) != 0:
        return true
    let cmd: str = "nm -u " + tooling_shellQuote(binPath) + " 2>/dev/null | awk '{print $NF}'"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return true
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(res))
    var hitCount: int32 = 0
    var preview: str = ""
    for i in 0..<rows.len:
        let rawSym: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(rawSym):
            continue
        if !tooling_isForbiddenUndefinedDriverSymbol(rawSym):
            continue
        hitCount = hitCount + 1
        if hitCount <= 8:
            if tooling_strNonEmpty(preview):
                preview = preview + ", "
            preview = preview + rawSym
    if hitCount <= 0:
        return true
    tooling_printErr("cheng_tooling: forbidden undefined internal symbols in driver (count=" +
                     intToStr(hitCount) + "): " + preview)
    return false

fn tooling_driverRequiredSymbolsOk(root: str, binPath: str): bool =
    let requireBackendMain: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_REQUIRE_BACKENDMAIN", "1"))
    if !requireBackendMain:
        return true
    let probeNm: os.ExecCmdResult = tooling_exec(root, "command -v nm >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeNm) != 0:
        return true
    let probeAwk: os.ExecCmdResult = tooling_exec(root, "command -v awk >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeAwk) != 0:
        return true
    let cmd: str = "nm -gU " + tooling_shellQuote(binPath) + " 2>/dev/null | awk '{print $NF}'"
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    if os.execCmdResultExitCode(res) != 0:
        return true
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(res))
    var hasBackendMain: bool = false
    for i in 0..<rows.len:
        let rawSym: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(rawSym):
            continue
        let norm: str = tooling_stripLeadingUnderscores(rawSym)
        if tooling_strEq(norm, "backendMain"):
            hasBackendMain = true
            break
    if hasBackendMain:
        return true
    tooling_printErr("cheng_tooling: driver sanity missing required symbol backendMain: " + binPath)
    return false

fn tooling_driverIsScriptShim(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    let headRes: os.ExecCmdResult = tooling_exec(root, "head -n 1 " + tooling_shellQuote(binPath))
    if os.execCmdResultExitCode(headRes) != 0:
        return false
    let line0: str = strutil.strip(os.execCmdResultOutput(headRes))
    if strutil.startsWith(line0, "#!"):
        return true
    return false

fn tooling_driverFileMagicOk(root: str, binPath: str): bool =
    let probeFile: os.ExecCmdResult = tooling_exec(root, "command -v file >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeFile) != 0:
        return true
    let res: os.ExecCmdResult = tooling_exec(root, "file -b " + tooling_shellQuote(binPath))
    if os.execCmdResultExitCode(res) != 0:
        return true
    let desc: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))
    if strutil.contains(desc, "script"):
        tooling_printErr("cheng_tooling: driver sanity rejected script shim: " + binPath)
        return false
    let hostTag: str = tooling_detectHostTag(root)
    if tooling_strEq(hostTag, "darwin_arm64"):
        if !strutil.contains(desc, "mach-o"):
            tooling_printErr("cheng_tooling: driver sanity expected mach-o binary on darwin_arm64: " + binPath +
                             " (file=" + desc + ")")
            return false
    return true

fn tooling_driverSanityOk(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    if os.fileSize(binPath) <= int64(0):
        return false
    if tooling_driverIsScriptShim(root, binPath):
        tooling_printErr("cheng_tooling: driver sanity rejected shebang script: " + binPath)
        return false
    if !tooling_driverFileMagicOk(root, binPath):
        return false
    if !tooling_driverRequiredSymbolsOk(root, binPath):
        return false
    if !tooling_driverUndefinedInternalSymbolsOk(root, binPath):
        return false
    return true

fn tooling_driverMinimalSanityOk(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    if os.fileSize(binPath) <= int64(0):
        return false
    return true

fn tooling_driverPostBuildOk(root: str, binPath: str): bool =
    if !tooling_driverSanityOk(root, binPath):
        return false
    let probeEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_POST_PROBE", "0"))
    if !probeEnabled:
        return true
    return tooling_driverCompileProbeOk(root, binPath)

fn tooling_driverBuildOutputOk(root: str, binPath: str, compileMode: str, quickLightSanity: bool,
                               forceProbeOnFull: bool): bool =
    var ok: bool = false
    if tooling_strEq(compileMode, "quick") && quickLightSanity:
        ok = tooling_driverSanityOk(root, binPath)
    else:
        ok = tooling_driverPostBuildOk(root, binPath)
    if !ok:
        return false
    if tooling_strEq(compileMode, "full") && forceProbeOnFull:
        if !tooling_driverCompileProbeOk(root, binPath):
            tooling_printErr("cheng_tooling: full rebuild compile-probe failed: " + binPath)
            return false
    return true

fn tooling_runtimeObjPath(root: str, target: str): str =
    let candidate0: str = os.joinPath(root, "chengcache/runtime_selflink/system_helpers.backend.combined." + target + ".o")
    if os.fileExists(candidate0):
        return candidate0
    let candidate1: str = os.joinPath(root, "artifacts/backend_mm/system_helpers.backend.combined." + target + ".o")
    if os.fileExists(candidate1):
        return candidate1
    let candidate2: str = os.joinPath(root, "artifacts/backend_selfhost_self_obj/stage1.native.runtime.dedup.o")
    if os.fileExists(candidate2):
        return candidate2
    let candidate3: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
    if os.fileExists(candidate3):
        return candidate3
    let candidate4: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng.o")
    if os.fileExists(candidate4):
        return candidate4
    return candidate3

fn tooling_runtimeLdArch(target: str): str =
    if strutil.startsWith(target, "arm64") || strutil.startsWith(target, "aarch64"):
        return "arm64"
    if strutil.startsWith(target, "x86_64"):
        return "x86_64"
    if strutil.startsWith(target, "riscv64"):
        return "riscv64"
    return ""

fn tooling_prepareRuntimeObjForTarget(root: str, compilerPath: str, target: str): str =
    let fallbackPath: str = tooling_runtimeObjPath(root, target)
    if !tooling_isExecutable(root, compilerPath):
        return fallbackPath
    let refreshEnabled: bool = tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH", "0"))
    if !refreshEnabled:
        return fallbackPath
    let arch: str = tooling_runtimeLdArch(target)
    if !tooling_strNonEmpty(arch):
        return fallbackPath
    let runtimeSrc: str = os.joinPath(root, "src/std/system_helpers_backend.cheng")
    let shimSrc: str = os.joinPath(root, "src/runtime/native/system_helpers_selflink_shim.c")
    let bridgeSrc: str = os.joinPath(root, "src/backend/tooling/backend_driver_symbol_bridge.c")
    if !os.fileExists(runtimeSrc) || !os.fileExists(shimSrc) || !os.fileExists(bridgeSrc):
        return fallbackPath
    let baseObj: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
    let runtimeDir: str = os.joinPath(root, "chengcache/runtime_selflink")
    let shimObj: str = os.joinPath(runtimeDir, "system_helpers_selflink_shim." + target + ".o")
    let bridgeObj: str = os.joinPath(runtimeDir, "backend_driver_symbol_bridge." + target + ".o")
    let combinedObj: str = os.joinPath(runtimeDir, "system_helpers.backend.combined." + target + ".o")
    let combinedTmp: str = combinedObj + ".tmp"
    let baseObjDir: str = os.parentDir(baseObj)
    if tooling_strNonEmpty(baseObjDir):
        tooling_tryMkdirP(root, baseObjDir)
    tooling_tryMkdirP(root, runtimeDir)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_TIMEOUT", ""), 120)
    if timeoutSec < 1:
        timeoutSec = 120
    var refreshCompiler: str = compilerPath
    var prepRcFinal: int32 = 1
    var prepOutFinal: str = ""
    var triedFallbackCompiler: bool = false
    for _attempt in 0..<2:
        if !tooling_isExecutable(root, refreshCompiler):
            prepRcFinal = 127
        else:
            var prepCmd: str = "BACKEND_BUILD_DRIVER_STAGE0= BACKEND_STAGE0= "
            if tooling_stage0CompatPrefixEnabled():
                prepCmd = prepCmd + "CHENG_BACKEND_BUILD_DRIVER_STAGE0= CHENG_BACKEND_STAGE0= "
            prepCmd = prepCmd +
                tooling_envAssignCompat("BACKEND_DRIVER", refreshCompiler) +
                tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "stage1") +
                tooling_envAssignCompat("MM", "orc") +
                tooling_envAssignCompat("CACHE", "0") +
                tooling_envAssignCompat("BACKEND_INTERNAL_ALLOW_EMIT_OBJ", "1") +
                tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "1") +
                tooling_envAssignCompat("BACKEND_EMIT", "obj") +
                tooling_envAssignCompat("BACKEND_TARGET", target) +
                tooling_envAssignCompat("BACKEND_INPUT", runtimeSrc) +
                tooling_envAssignCompat("BACKEND_OUTPUT", baseObj) +
                tooling_shellQuote(refreshCompiler) +
                " && cc -std=c11 -O2 -c " + tooling_shellQuote(shimSrc) + " -o " + tooling_shellQuote(shimObj) +
                " && cc -std=c11 -O2 -c " + tooling_shellQuote(bridgeSrc) + " -o " + tooling_shellQuote(bridgeObj) +
                " && ld -r -arch " + arch + " -o " + tooling_shellQuote(combinedTmp) + " " +
                tooling_shellQuote(baseObj) + " " + tooling_shellQuote(shimObj) + " " + tooling_shellQuote(bridgeObj) +
                " && mv " + tooling_shellQuote(combinedTmp) + " " + tooling_shellQuote(combinedObj)
            prepCmd = tooling_prefixUnsetLegacyFrontendEnv(prepCmd)
            prepCmd = tooling_wrapStage0Lock(root, prepCmd, "runtime_obj_refresh")
            prepCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, prepCmd)
            let prepRes: os.ExecCmdResult = tooling_exec(root, prepCmd)
            prepRcFinal = os.execCmdResultExitCode(prepRes)
            prepOutFinal = os.execCmdResultOutput(prepRes)
            if prepRcFinal == 0 && os.fileExists(combinedObj):
                return combinedObj
        if triedFallbackCompiler:
            break
        let fallbackCompiler: str = os.joinPath(root, "artifacts/backend_selfhost_self_obj/cheng.stage2")
        if tooling_isExecutable(root, fallbackCompiler) && !tooling_strEq(fallbackCompiler, refreshCompiler):
            refreshCompiler = fallbackCompiler
            triedFallbackCompiler = true
            continue
        break
    let strictRefresh: bool = tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_STRICT", "0"))
    if !strictRefresh && os.fileExists(fallbackPath):
        return fallbackPath
    tooling_printErr("cheng_tooling: runtime object refresh failed for target=" + target +
                     " rc=" + intToStr(prepRcFinal) + " kind=" + tooling_exitKind(prepRcFinal))
    let refreshDebug: bool = strictRefresh || tooling_isTrue(os.getEnvDefault("BACKEND_RUNTIME_OBJ_REFRESH_DEBUG", "0"))
    if refreshDebug && tooling_strNonEmpty(prepOutFinal):
        let rows: str[] = tooling_splitLines(prepOutFinal)
        var shown: int32 = 0
        for i in 0..<rows.len:
            if shown >= 6:
                break
            tooling_printErr("cheng_tooling: runtime refresh log: " + rows[i])
            shown = shown + 1
    if strictRefresh:
        return ""
    return fallbackPath

fn tooling_outputLooksExecutable(root: str, outPath: str): bool =
    if !tooling_strNonEmpty(outPath) || !os.fileExists(outPath):
        return false
    let probeFile: os.ExecCmdResult = tooling_exec(root, "command -v file >/dev/null 2>&1")
    if os.execCmdResultExitCode(probeFile) != 0:
        return true
    let res: os.ExecCmdResult = tooling_exec(root, "file -b " + tooling_shellQuote(outPath))
    if os.execCmdResultExitCode(res) != 0:
        return true
    let desc: str = strutil.toLowerAscii(strutil.strip(os.execCmdResultOutput(res)))
    if !tooling_strNonEmpty(desc):
        return true
    return tooling_strContains(desc, "executable")

fn tooling_driverCompileProbeOk(root: str, binPath: str): bool =
    if !tooling_isExecutable(root, binPath):
        return false
    var probeInputRel: str = strutil.strip(os.getEnvDefault("TOOLING_STAGE0_PROBE_FIXTURE", ""))
    if !tooling_strNonEmpty(probeInputRel):
        # Use std/os fixture by default to catch stage0 regressions that only
        # reproduce once std imports are lowered.
        probeInputRel = "tests/cheng/backend/fixtures/return_import_std_os.cheng"
    let probeInput: str = os.joinPath(root, probeInputRel)
    if !os.fileExists(probeInput):
        return true
    let target: str = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        return true
    let runtimeObj: str = tooling_runtimeObjPath(root, target)
    if !os.fileExists(runtimeObj):
        return true
    let stage0Exec: str = tooling_prepareStage0Exec(root, binPath, "probe")
    if !tooling_strNonEmpty(stage0Exec):
        return false
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_PROBE_TIMEOUT", ""), 60)
    if timeoutSec <= 0:
        timeoutSec = 60
    let probeNonceRaw: int64 = tooling_nowMs() % int64(2000000000)
    let probeOut: str = os.joinPath(root, "chengcache/tooling_stage0_probe." + intToStr(int32(probeNonceRaw)) + ".bin")
    let probeOutDir: str = os.parentDir(probeOut)
    if tooling_strNonEmpty(probeOutDir):
        tooling_tryMkdirP(root, probeOutDir)
    if os.fileExists(probeOut):
        os.removeFile(probeOut)
    var probeCmd: str = ""
    probeCmd = probeCmd + tooling_envAssignCompat("MM", "orc")
    probeCmd = probeCmd + tooling_envAssignCompat("CACHE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
    probeCmd = probeCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "stage1")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", "")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
    probeCmd = probeCmd + tooling_envAssignCompat("BACKEND_OUTPUT", probeOut)
    probeCmd = probeCmd + tooling_shellQuote(stage0Exec)
    probeCmd = tooling_prefixUnsetLegacyFrontendEnv(probeCmd)
    probeCmd = tooling_wrapStage0Lock(root, probeCmd, "stage0_compile_probe")
    probeCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, probeCmd)
    let probeRes: os.ExecCmdResult = tooling_exec(root, probeCmd)
    var probeRc: int32 = os.execCmdResultExitCode(probeRes)
    var probeOutText: str = strutil.strip(os.execCmdResultOutput(probeRes))
    var sizeProbe: os.ExecCmdResult = tooling_exec(root, "test -s " + tooling_shellQuote(probeOut))
    var hasOut: bool = os.execCmdResultExitCode(sizeProbe) == 0
    let probeAllowSystemFallback: bool = probeRc != 0
    if probeAllowSystemFallback:
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        var fallbackCmd: str = ""
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("MM", "orc")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("CACHE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "stage1")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_LINKER", "system")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", "")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
        fallbackCmd = fallbackCmd + tooling_envAssignCompat("BACKEND_OUTPUT", probeOut)
        fallbackCmd = fallbackCmd + tooling_shellQuote(stage0Exec)
        fallbackCmd = tooling_prefixUnsetLegacyFrontendEnv(fallbackCmd)
        fallbackCmd = tooling_wrapStage0Lock(root, fallbackCmd, "stage0_compile_probe_system_link")
        fallbackCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, fallbackCmd)
        let fallbackRes: os.ExecCmdResult = tooling_exec(root, fallbackCmd)
        probeRc = os.execCmdResultExitCode(fallbackRes)
        probeOutText = strutil.strip(os.execCmdResultOutput(fallbackRes))
        sizeProbe = tooling_exec(root, "test -s " + tooling_shellQuote(probeOut))
        hasOut = os.execCmdResultExitCode(sizeProbe) == 0
        if probeRc == 0 && hasOut:
            tooling_printErr("cheng_tooling: stage0 compile probe self-link reloc unsupported, accepted via system-link fallback")
    var executableOut: bool = false
    if hasOut:
        executableOut = tooling_outputLooksExecutable(root, probeOut)
        if probeRc == 0 && !executableOut:
            tooling_printErr("cheng_tooling: stage0 compile probe output is not executable: " + probeOut)
    let allowObjFallback: bool = tooling_isTrue(
        os.getEnvDefault("TOOLING_STAGE0_PROBE_ALLOW_OBJ_FALLBACK", "0"))
    let needsMainFallback: bool = probeRc != 0 && allowObjFallback &&
        (tooling_strContains(probeOutText, "\"_main\"") ||
         tooling_strContains(probeOutText, "_main") ||
         tooling_strContains(probeOutText, "<initial-undefines>"))
    if needsMainFallback:
        let objOut: str = probeOut + ".o"
        if os.fileExists(objOut):
            os.removeFile(objOut)
        var objCmd: str = ""
        objCmd = objCmd + tooling_envAssignCompat("MM", "orc")
        objCmd = objCmd + tooling_envAssignCompat("CACHE", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_SKIP_SEM", "0")
        objCmd = objCmd + tooling_envAssignCompat("GENERIC_MODE", "dict")
        objCmd = objCmd + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", "0")
        objCmd = objCmd + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", "stage1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_IR", "uir")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_MULTI", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_MULTI_FORCE", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_ALLOW_NO_MAIN", "0")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_LINKER", "self")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INTERNAL_ALLOW_EMIT_OBJ", "1")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_EMIT", "obj")
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_INPUT", probeInput)
        objCmd = objCmd + tooling_envAssignCompat("BACKEND_OUTPUT", objOut)
        objCmd = objCmd + tooling_shellQuote(stage0Exec)
        objCmd = tooling_prefixUnsetLegacyFrontendEnv(objCmd)
        objCmd = tooling_wrapStage0Lock(root, objCmd, "stage0_compile_probe_obj")
        objCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, objCmd)
        let objRes: os.ExecCmdResult = tooling_exec(root, objCmd)
        let objRc: int32 = os.execCmdResultExitCode(objRes)
        let objLog: str = strutil.strip(os.execCmdResultOutput(objRes))
        let objSizeProbe: os.ExecCmdResult = tooling_exec(root, "test -s " + tooling_shellQuote(objOut))
        let objHasOut: bool = os.execCmdResultExitCode(objSizeProbe) == 0
        if os.fileExists(objOut):
            os.removeFile(objOut)
        if objRc == 0 && objHasOut:
            probeRc = 0
            hasOut = true
            executableOut = true
            tooling_printErr("cheng_tooling: stage0 compile probe exe-link missing _main; accepted obj fallback")
        elif tooling_strNonEmpty(objLog):
            probeOutText = objLog
    if probeRc != 0:
        tooling_printErr("cheng_tooling: stage0 compile probe failed rc=" + intToStr(probeRc) +
                         " kind=" + tooling_exitKind(probeRc))
        if tooling_strNonEmpty(probeOutText):
            let rows: str[] = tooling_splitLines(probeOutText)
            var shown: int32 = 0
            for i in 0..<rows.len:
                if shown >= 6:
                    break
                tooling_printErr("cheng_tooling: stage0 probe log: " + rows[i])
                shown = shown + 1
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    if !hasOut || !executableOut:
        tooling_printErr("cheng_tooling: stage0 compile probe produced no output binary")
        if os.fileExists(probeOut):
            os.removeFile(probeOut)
        tooling_cleanupStage0Exec(binPath, stage0Exec)
        return false
    let requireRun: bool = tooling_isTrue(os.getEnvDefault("TOOLING_STAGE0_PROBE_REQUIRE_RUN", "1"))
    if requireRun:
        var runTimeoutSec: int32 = tooling_parseInt32Default(
            os.getEnvDefault("TOOLING_STAGE0_PROBE_RUN_TIMEOUT", ""), 15)
        if runTimeoutSec < 1:
            runTimeoutSec = 15
        var runCmd: str = tooling_shellQuote(probeOut) + " >/dev/null 2>&1"
        runCmd = tooling_wrapCommandWithTimeout(root, runTimeoutSec, runCmd)
        let runRes: os.ExecCmdResult = tooling_exec(root, runCmd)
        let runRc: int32 = os.execCmdResultExitCode(runRes)
        if runRc != 0:
            tooling_printErr("cheng_tooling: stage0 compile probe binary run failed rc=" + intToStr(runRc) +
                             " kind=" + tooling_exitKind(runRc))
            if os.fileExists(probeOut):
                os.removeFile(probeOut)
            tooling_cleanupStage0Exec(binPath, stage0Exec)
            return false
    if os.fileExists(probeOut):
        os.removeFile(probeOut)
    tooling_cleanupStage0Exec(binPath, stage0Exec)
    return true

fn tooling_driverBuildTempDir(root: str): str =
    return os.joinPath(root, "chengcache/backend_driver_build_tmp")

fn tooling_driverBuildTempPath(root: str, outPath: str, attemptIndex: int32): str =
    let tempDir: str = tooling_driverBuildTempDir(root)
    tooling_tryMkdirP(root, tempDir)
    var base: str = os.extractFilename(outPath)
    if !tooling_strNonEmpty(base):
        base = "cheng"
    let nonce: int32 = int32(tooling_nowMs() % int64(2000000000))
    return os.joinPath(tempDir, base + ".attempt." + intToStr(attemptIndex) + "." + intToStr(nonce))

fn tooling_driverBuildTempCleanup(root: str, outPath: str) =
    if !tooling_strNonEmpty(outPath):
        return
    if os.fileExists(outPath):
        os.removeFile(outPath)
    let tmpLinkObj: str = outPath + ".tmp.linkobj"
    if os.fileExists(tmpLinkObj):
        os.removeFile(tmpLinkObj)
    let tmpObjsDir: str = outPath + ".objs"
    let tmpObjsLock: str = outPath + ".objs.lock"
    if os.dirExists(tmpObjsDir) || os.fileExists(tmpObjsLock):
        let cleanupCmd: str = "rm -rf " + tooling_shellQuote(tmpObjsDir) + " " + tooling_shellQuote(tmpObjsLock)
        let cleanupRes: os.ExecCmdResult = tooling_exec(root, cleanupCmd)
        tooling_printExecOutput(cleanupRes)

fn tooling_collectLegacyDriverObjFiles(root: str): str[] =
    let _root: str = root
    var out: str[] = []
    return out

fn tooling_prepareBackendDriverCompatWrapObj(root: str): str =
    let _root: str = root
    return ""

fn tooling_tryLegacyDriverObjRelink(root: str, outPath: str, targetRaw: str): int32 =
    let _root: str = root
    let _outPath: str = outPath
    let _targetRaw: str = targetRaw
    return -1

fn tooling_outputHasUndefinedSymbols(output: str): bool =
    if !tooling_strNonEmpty(output):
        return false
    let lower: str = strutil.toLowerAscii(output)
    if tooling_strContains(lower, "undefined symbols for architecture") ||
       tooling_strContains(lower, "undefined reference to") ||
       tooling_strContains(lower, "undefined symbol:"):
        return true
    return false

fn tooling_compileBackendDriverFastHostWithRebuildPolicy(root: str, stage0: str, target: str, outPath: str,
                                                         fullRebuild: bool, rebuildSkipSemRaw: str,
                                                         rebuildSkipOwnershipRaw: str): int32 =
    tooling_buildDriverLastStampHit = false
    var linkerDefault: str = "self"
    if fullRebuild && tooling_buildDriverStrictNativeEnabled():
        linkerDefault = "system"
    var linkerMode: str = strutil.toLowerAscii(strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_LINKER", linkerDefault)))
    if !tooling_strEq(linkerMode, "self") && !tooling_strEq(linkerMode, "system"):
        linkerMode = "self"
    let strictNative: bool = tooling_buildDriverStrictNativeEnabled()
    let allowFallback: bool = tooling_buildDriverAllowFallbackEnabled()
    if strictNative:
        linkerMode = os.getEnvDefault("BACKEND_BUILD_DRIVER_LINKER_STRICT", linkerMode)
        if !tooling_strEq(linkerMode, "self") && !tooling_strEq(linkerMode, "system"):
            linkerMode = "self"
    let stage0Purpose: str = fullRebuild ? "rebuild" : "quick"
    var stage0Exec: str = ""
    var runtimeObj: str = ""
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
    var jobs: int32 = tooling_detectHostJobs(root)
    if jobs < 1:
        jobs = 1
    if jobs > 8:
        jobs = 8
    let rebuildSkipSemOverride: str = tooling_bool01Normalized(rebuildSkipSemRaw)
    let rebuildSkipOwnershipOverride: str = tooling_bool01Normalized(rebuildSkipOwnershipRaw)
    if tooling_strEq(rebuildSkipSemOverride, "1") || tooling_strEq(rebuildSkipOwnershipOverride, "1"):
        tooling_printErr("cheng_tooling: stage0/driver bootstrap skip_sem/skip_ownership has been removed (expected 0/0)")
        return 2
    var jobsText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_JOBS", "")
    var rebuildJobsRaw: str = ""
    if fullRebuild:
        rebuildJobsRaw = strutil.strip(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_JOBS", ""))
        if tooling_strNonEmpty(rebuildJobsRaw):
            jobsText = rebuildJobsRaw
        elif !tooling_strNonEmpty(jobsText):
            jobs = tooling_detectHostJobs(root)
            if jobs <= 1:
                jobs = 1
            else:
                jobs = 2
    if tooling_strNonEmpty(jobsText):
        jobs = tooling_parseInt32Default(jobsText, jobs)
    if jobs < 1:
        jobs = 1
    if jobs > 8:
        jobs = 8
    var timeoutEnv: str = "BACKEND_BUILD_DRIVER_TIMEOUT"
    var timeoutDefault: int32 = 60
    var timeoutHintRaw: str = os.getEnvDefault(timeoutEnv, "")
    var timeoutHintSec: int32 = tooling_parseInt32Default(timeoutHintRaw, timeoutDefault)
    if timeoutHintSec < 1:
        timeoutHintSec = timeoutDefault
    var fullRebuildTightTimeoutProfile: bool = false
    var parseMode: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_PARSE_MODE", "outline")
    var fnSchedText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_FN_SCHED", "ws")
    var directExeText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_DIRECT_EXE", "1")
    var incrementalText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_INCREMENTAL", "1")
    var multiText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_MULTI", "0")
    var multiForceText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_MULTI_FORCE", "0")
    var stage1BuilderText: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_STAGE1_BUILDER", "stage1")
    # Stage1 semantic/ownership skip knobs are hard-locked to 0/0 in bootstrap.
    var skipSemText: str = "0"
    var skipOwnershipText: str = "0"
    var genericModeText: str = "dict"
    var genericSpecBudgetText: str = "0"
    if fullRebuild:
        timeoutEnv = "BACKEND_BUILD_DRIVER_REBUILD_TIMEOUT"
        timeoutDefault = 180
        timeoutHintRaw = os.getEnvDefault(timeoutEnv, "")
        timeoutHintSec = tooling_parseInt32Default(timeoutHintRaw, timeoutDefault)
        if timeoutHintSec < 1:
            timeoutHintSec = timeoutDefault
        fullRebuildTightTimeoutProfile = timeoutHintSec <= 180 &&
            tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_TIGHT_TIMEOUT_PROFILE", "1"))
        var rebuildParseModeDefault: str = "full"
        var rebuildFnSchedDefault: str = "serial"
        if fullRebuildTightTimeoutProfile:
            rebuildParseModeDefault = "outline"
            rebuildFnSchedDefault = "ws"
        parseMode = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_PARSE_MODE", rebuildParseModeDefault)
        fnSchedText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_FN_SCHED", rebuildFnSchedDefault)
        directExeText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_DIRECT_EXE", "0")
        incrementalText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_INCREMENTAL", "0")
        # Full rebuild on unstable drivers can crash under multi worker mode.
        # Default to serial full rebuild; callers can opt in via env for diagnostics.
        multiText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_MULTI", "0")
        multiForceText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_MULTI_FORCE", "0")
        # Full rebuild is hard-pinned to stage1 builder.
        # core builder on this path can produce undefined-symbol binaries.
        let rebuildStage1BuilderRaw: str = strutil.toLowerAscii(strutil.strip(
            os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_STAGE1_BUILDER", "")))
        if tooling_strNonEmpty(rebuildStage1BuilderRaw) && !tooling_strEq(rebuildStage1BuilderRaw, "stage1"):
            tooling_printErr("cheng_tooling: ignore BACKEND_BUILD_DRIVER_REBUILD_STAGE1_BUILDER=" +
                             rebuildStage1BuilderRaw + " (full rebuild enforces stage1)")
        stage1BuilderText = "stage1"
        genericModeText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_GENERIC_MODE", "dict")
        genericSpecBudgetText = os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_GENERIC_SPEC_BUDGET", "0")
    if !tooling_strNonEmpty(parseMode):
        if fullRebuild:
            if fullRebuildTightTimeoutProfile:
                parseMode = "outline"
            else:
                parseMode = "full"
        else:
            parseMode = "outline"
    if !tooling_strNonEmpty(fnSchedText):
        if fullRebuild:
            if fullRebuildTightTimeoutProfile:
                fnSchedText = "ws"
            else:
                fnSchedText = "serial"
        else:
            fnSchedText = "ws"
    if !tooling_strNonEmpty(directExeText):
        directExeText = fullRebuild ? "0" : "1"
    if !tooling_strNonEmpty(incrementalText):
        incrementalText = fullRebuild ? "0" : "1"
    if !tooling_strNonEmpty(multiText):
        multiText = fullRebuild ? "1" : "0"
    if !tooling_strNonEmpty(multiForceText):
        multiForceText = fullRebuild ? "1" : "0"
    if !tooling_strNonEmpty(stage1BuilderText):
        stage1BuilderText = "stage1"
    if fullRebuild && !tooling_strEq(strutil.toLowerAscii(strutil.strip(stage1BuilderText)), "stage1"):
        stage1BuilderText = "stage1"
    if !tooling_strNonEmpty(genericModeText):
        genericModeText = "dict"
    if !tooling_strNonEmpty(genericSpecBudgetText):
        genericSpecBudgetText = "0"
    var timeoutText: str = os.getEnvDefault(timeoutEnv, "")
    if !tooling_strNonEmpty(timeoutText):
        timeoutText = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMEOUT", "")
    var timeoutSec: int32 = tooling_parseInt32Default(timeoutText, timeoutDefault)
    if timeoutSec < 1:
        timeoutSec = timeoutDefault
    if fullRebuild && fullRebuildTightTimeoutProfile:
        if !tooling_strNonEmpty(rebuildJobsRaw):
            jobs = tooling_detectHostJobs(root)
            if jobs <= 1:
                jobs = 1
            else:
                jobs = 2
        let logEveryCall: bool = tooling_isTrue(os.getEnvDefault("TOOLING_BUILD_DRIVER_TIGHT_PROFILE_LOG_EVERY_CALL", "0"))
        if !tooling_buildDriverTightProfileLogShown || logEveryCall:
            tooling_printErr("cheng_tooling: full rebuild using tight-timeout profile (parse=" + parseMode +
                             ", fn_sched=" + fnSchedText + ", skip_sem=0, skip_ownership=0)")
            tooling_printErr("cheng_tooling: full rebuild tight-timeout jobs=" + intToStr(jobs))
            tooling_buildDriverTightProfileLogShown = true
    let profileEnabledFromEnv: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE", "0"))
    let profileOutRaw: str = os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE_OUT", "")
    var profileOutPath: str = ""
    if tooling_strNonEmpty(profileOutRaw):
        profileOutPath = tooling_pathAbsolute(root, profileOutRaw)
    let profileEnabled: bool = profileEnabledFromEnv || tooling_strNonEmpty(profileOutPath)
    let profileMode: str = tooling_buildDriverProfileMode()
    let profileFailOpen: bool = profileEnabled &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_PROFILE_FAIL_OPEN", "1"))
    let stampIgnoreStage0Sha: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_STAMP_IGNORE_STAGE0_SHA",
                         fullRebuildTightTimeoutProfile ? "1" : "0"))
    let stampCacheEnabled: bool = fullRebuild &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_STAMP_CACHE", "1"))
    let stage0IdentityPath: str = tooling_pathAbsolute(root, stage0)
    let sourcePath: str = os.joinPath(root, "src/backend/tooling/backend_driver.cheng")
    let stampPath: str = outPath + ".full_rebuild.stamp.env"
    var stage0IdentitySha: str = ""
    var sourceSha: str = ""
    if stampCacheEnabled && os.fileExists(outPath) && os.fileExists(stampPath) &&
       os.fileExists(sourcePath) && tooling_isExecutable(root, stage0IdentityPath):
        sourceSha = tooling_sha256File(root, sourcePath)
        stage0IdentitySha = tooling_sha256File(root, stage0IdentityPath)
        let stampRaw: str = tooling_readTextFile(root, stampPath)
        if tooling_strEq(tooling_kvGet(stampRaw, "version"), "1") &&
           tooling_strEq(tooling_kvGet(stampRaw, "mode"), "full") &&
           tooling_strEq(tooling_kvGet(stampRaw, "target"), target) &&
           tooling_strEq(tooling_kvGet(stampRaw, "linker"), linkerMode) &&
           tooling_strEq(tooling_kvGet(stampRaw, "stage0_path"), stage0IdentityPath) &&
           (stampIgnoreStage0Sha || tooling_strEq(tooling_kvGet(stampRaw, "stage0_sha"), stage0IdentitySha)) &&
           tooling_strEq(tooling_kvGet(stampRaw, "source_path"), sourcePath) &&
           tooling_strEq(tooling_kvGet(stampRaw, "source_sha"), sourceSha) &&
           tooling_strEq(tooling_kvGet(stampRaw, "parse_mode"), parseMode) &&
           tooling_strEq(tooling_kvGet(stampRaw, "fn_sched"), fnSchedText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "direct_exe"), directExeText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "incremental"), incrementalText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "multi"), multiText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "multi_force"), multiForceText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "stage1_builder"), stage1BuilderText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "generic_mode"), genericModeText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "generic_spec_budget"), genericSpecBudgetText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "jobs"), intToStr(jobs)) &&
           tooling_strEq(tooling_kvGet(stampRaw, "skip_sem"), skipSemText) &&
           tooling_strEq(tooling_kvGet(stampRaw, "skip_ownership"), skipOwnershipText):
            tooling_buildDriverLastStampHit = true
            tooling_printOut("build_backend_driver_stamp_cache_hit=1")
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 0
    stage0Exec = tooling_prepareStage0Exec(root, stage0, stage0Purpose)
    if !tooling_strNonEmpty(stage0Exec):
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        return 1
    if tooling_strEq(linkerMode, "self"):
        let refreshRuntimeObj: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_RUNTIME_OBJ_REFRESH", "0"))
        if refreshRuntimeObj:
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        else:
            runtimeObj = tooling_runtimeObjPath(root, target)
            if !os.fileExists(runtimeObj):
                runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        let preferSeedBaseRuntimeObj: bool = tooling_isTrue(
            os.getEnvDefault("BACKEND_BUILD_DRIVER_SEED_BASE_RUNTIME_OBJ", "1"))
        let stage0LowerRaw: str = strutil.toLowerAscii(strutil.strip(stage0))
        let seedLikeStage0: bool =
            tooling_strContains(stage0LowerRaw, "/artifacts/backend_seed/") ||
            tooling_strContains(stage0LowerRaw, "/backend_seed/")
        if preferSeedBaseRuntimeObj && seedLikeStage0:
            let baseRuntimeObj: str = os.joinPath(root, "chengcache/system_helpers.backend.cheng." + target + ".o")
            if os.fileExists(baseRuntimeObj):
                runtimeObj = baseRuntimeObj
        if !os.fileExists(runtimeObj):
            tooling_printErr("cheng_tooling: missing runtime object: " + runtimeObj)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
    let crashRetrySafe: bool = fullRebuild &&
        tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_CRASH_RETRY_SAFE", "0"))
    var crashRetryMax: int32 = 0
    if crashRetrySafe:
        crashRetryMax = tooling_parseInt32Default(
            os.getEnvDefault("BACKEND_BUILD_DRIVER_REBUILD_CRASH_RETRY_MAX", ""), 1)
    if crashRetryMax < 0:
        crashRetryMax = 0
    if crashRetryMax > 2:
        crashRetryMax = 2
    let compileAttemptLimit: int32 = crashRetryMax + 1
    var segfaultRetryCount: int32 = 0
    var finalRes: os.ExecCmdResult = tooling_exec(root, "true")
    var finalRc: int32 = 1
    var lastCompileCmdBase: str = ""
    var profileDisabledByCrash: bool = false
    for attempt in 0..<compileAttemptLimit:
        var compileCmdBase: str = ""
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS_STRICT", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("MM", "orc")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("CACHE", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_AUTO_SYSTEM", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "dev")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", parseMode)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_FN_SCHED", fnSchedText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_DIRECT_EXE", directExeText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_MULTI", multiText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_MULTI_FORCE", multiForceText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_MULTI_MODULE_CACHE", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_MODULE_CACHE", "")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_MODULE_CACHE_UNSTABLE_ALLOW", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("CHENGC_ALLOW_UNSTABLE_MULTI_MODULE_CACHE", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_INCREMENTAL", incrementalText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_JOBS", intToStr(jobs))
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_FN_JOBS", intToStr(jobs))
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_VALIDATE", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_OPT", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_OPT2", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("UIR_SIMD", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_SKIP_SEM", skipSemText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_SKIP_OWNERSHIP", skipOwnershipText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("STAGE1_SKIP_CPROFILE", "1")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("GENERIC_MODE", genericModeText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("GENERIC_SPEC_BUDGET", genericSpecBudgetText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_STAGE1_BUILDER", stage1BuilderText)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_LINKER", linkerMode)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        if tooling_strEq(linkerMode, "self"):
            compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
            compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
        else:
            compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_EMIT", "exe")
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_TARGET", target)
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_INPUT", os.joinPath(root, "src/backend/tooling/backend_driver.cheng"))
        compileCmdBase = compileCmdBase + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
        compileCmdBase = compileCmdBase + tooling_shellQuote(stage0Exec)
        compileCmdBase = tooling_prefixUnsetLegacyFrontendEnv(compileCmdBase)
        lastCompileCmdBase = compileCmdBase
        var compileCmd: str = compileCmdBase
        let profileAttemptEnabled: bool = profileEnabled && !profileDisabledByCrash
        if profileAttemptEnabled:
            compileCmd = tooling_prefixBuildDriverProfile(compileCmd, profileMode)
        compileCmd = tooling_wrapStage0Lock(root, compileCmd, "build_backend_driver_compile")
        compileCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, compileCmd)
        var res: os.ExecCmdResult = tooling_exec(root, compileCmd)
        tooling_printExecOutput(res)
        finalRes = res
        finalRc = os.execCmdResultExitCode(res)
        if profileAttemptEnabled && profileFailOpen && finalRc == 139:
            tooling_printErr("cheng_tooling: profile-enabled full rebuild segfaulted; retrying same attempt without profile flags")
            profileDisabledByCrash = true
            var noProfileCmd: str = tooling_wrapStage0Lock(root, compileCmdBase, "build_backend_driver_compile")
            noProfileCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, noProfileCmd)
            res = tooling_exec(root, noProfileCmd)
            tooling_printExecOutput(res)
            finalRes = res
            finalRc = os.execCmdResultExitCode(res)
        if finalRc != 139 || (attempt + 1) >= compileAttemptLimit:
            break
        segfaultRetryCount = segfaultRetryCount + 1
        tooling_printErr("cheng_tooling: full rebuild crashed with segfault; retrying safe serial stage1 builder (" +
                         intToStr(segfaultRetryCount) + "/" + intToStr(crashRetryMax) + ")")
        jobs = 1
        multiText = "0"
        multiForceText = "0"
        incrementalText = "0"
        fnSchedText = "serial"
        directExeText = "0"
        stage1BuilderText = "stage1"
    let finalOutTrim: str = strutil.strip(os.execCmdResultOutput(finalRes))
    let diagOnEmptyFailDefault: str = fullRebuildTightTimeoutProfile ? "0" : "1"
    let diagOnEmptyFail: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_EMPTY_FAIL_DIAG", diagOnEmptyFailDefault))
    let finalKind: str = tooling_exitKind(finalRc)
    if fullRebuild && finalRc != 0 && finalRc != 139 && !tooling_strEq(finalKind, "timeout") &&
       !tooling_strNonEmpty(finalOutTrim) &&
       diagOnEmptyFail && tooling_strNonEmpty(lastCompileCmdBase):
        var diagCmd: str = ""
        if profileEnabled && !profileDisabledByCrash:
            diagCmd = tooling_prefixBuildDriverProfile(diagCmd, profileMode)
        diagCmd = diagCmd + tooling_envAssignCompat("BACKEND_DEBUG_STAGE1_PIPE", "1")
        diagCmd = diagCmd + lastCompileCmdBase
        diagCmd = tooling_wrapStage0Lock(root, diagCmd, "build_backend_driver_diag")
        diagCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, diagCmd)
        let diagRes: os.ExecCmdResult = tooling_exec(root, diagCmd)
        let diagOut: str = os.execCmdResultOutput(diagRes)
        tooling_printErr("cheng_tooling: full rebuild failed with empty output; printing inline diagnostics")
        if tooling_strNonEmpty(strutil.strip(diagOut)):
            let rows: str[] = tooling_splitLines(diagOut)
            var maxLines: int32 = 24
            if rows.len < maxLines:
                maxLines = rows.len
            for i in 0..<maxLines:
                tooling_printErr("cheng_tooling: full rebuild diag: " + rows[i])
        else:
            tooling_printErr("cheng_tooling: full rebuild diag produced empty output")
    elif fullRebuild && finalRc != 0 && tooling_strEq(finalKind, "timeout") && !diagOnEmptyFail:
        tooling_printErr("cheng_tooling: skip empty-output diag on timeout (tight-timeout profile)")
    if tooling_strNonEmpty(profileOutPath):
        if finalRc == 0 && profileEnabled && !profileDisabledByCrash:
            let profileOutDir: str = os.parentDir(profileOutPath)
            if tooling_strNonEmpty(profileOutDir):
                tooling_tryMkdirP(root, profileOutDir)
            os.writeFile(profileOutPath, os.execCmdResultOutput(finalRes))
            tooling_printOut("build_backend_driver_profile_log=" + profileOutPath)
        elif finalRc == 0 && profileDisabledByCrash:
            tooling_printErr("cheng_tooling: profile log disabled after segfault fail-open; build succeeded without profile flags")
        else:
            tooling_printErr("cheng_tooling: skip profile log write for failed full rebuild rc=" + intToStr(finalRc))
    if finalRc != 0:
        # Legacy relink fallback has been removed.
        let _strictNativeUnused: bool = strictNative
        let _allowFallbackUnused: bool = allowFallback
        let _targetUnused: str = target
    if finalRc != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        return finalRc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    let chmodRc: int32 = os.execCmdResultExitCode(chmodRes)
    if chmodRc == 0 && stampCacheEnabled:
        if !tooling_strNonEmpty(sourceSha):
            sourceSha = tooling_sha256File(root, sourcePath)
        if !tooling_strNonEmpty(stage0IdentitySha):
            stage0IdentitySha = tooling_sha256File(root, stage0IdentityPath)
        var stampText: str = ""
        stampText = stampText + "version=1\n"
        stampText = stampText + "mode=full\n"
        stampText = stampText + "target=" + target + "\n"
        stampText = stampText + "linker=" + linkerMode + "\n"
        stampText = stampText + "stage0_path=" + stage0IdentityPath + "\n"
        stampText = stampText + "stage0_sha=" + stage0IdentitySha + "\n"
        stampText = stampText + "source_path=" + sourcePath + "\n"
        stampText = stampText + "source_sha=" + sourceSha + "\n"
        stampText = stampText + "parse_mode=" + parseMode + "\n"
        stampText = stampText + "fn_sched=" + fnSchedText + "\n"
        stampText = stampText + "direct_exe=" + directExeText + "\n"
        stampText = stampText + "incremental=" + incrementalText + "\n"
        stampText = stampText + "multi=" + multiText + "\n"
        stampText = stampText + "multi_force=" + multiForceText + "\n"
        stampText = stampText + "stage1_builder=" + stage1BuilderText + "\n"
        stampText = stampText + "generic_mode=" + genericModeText + "\n"
        stampText = stampText + "generic_spec_budget=" + genericSpecBudgetText + "\n"
        stampText = stampText + "jobs=" + intToStr(jobs) + "\n"
        stampText = stampText + "skip_sem=" + skipSemText + "\n"
        stampText = stampText + "skip_ownership=" + skipOwnershipText + "\n"
        os.writeFile(stampPath, stampText)
        tooling_printOut("build_backend_driver_stamp_cache_write=1")
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    return chmodRc

fn tooling_compileBackendDriverFastHost(root: str, stage0: str, target: str, outPath: str, fullRebuild: bool): int32 =
    return tooling_compileBackendDriverFastHostWithRebuildPolicy(root, stage0, target, outPath, fullRebuild, "", "")

fn tooling_selfhostBootstrapFastHost(root: str, compileStage1: bool, outDirRaw: str, timingOutRaw: str, stage0Raw: str): ToolingSelfhostResult =
    var result: ToolingSelfhostResult
    new result
    result.ok = false
    result.message = ""
    result.totalMs = int64(0)
    result.mode = "fast"
    result.stage1Path = ""
    result.stage2Path = ""
    result.stage3Path = ""
    result.stage0Path = ""
    result.stage0DriverKind = "unknown"
    result.stage1Status = "init"
    result.stage1CompileMode = "alias"
    result.stage1RebuildOk = false
    result.fallbackUsed = false
    result.quarantineCleaned = 0
    result.lockWaitMs = 0
    result.strictRebuildOk = false
    result.stage2Sha256 = ""
    result.stage3Sha256 = ""
    result.fixedPointOk = false
    result.stage1CompileMs = int64(0)
    result.stage1SanityMs = int64(0)
    result.stage1CompileAttempts = 0
    result.stage1CompileSegfaults = 0

    let hostTag: str = tooling_detectHostTag(root)
    if !tooling_strEq(hostTag, "darwin_arm64"):
        result.message = "selfhost_fast_host unsupported host: " + hostTag
        return result
    let target: str = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        result.message = "selfhost_fast_host failed to resolve host target"
        return result
    result.quarantineCleaned = tooling_stage0QuarantineSweepUe(root, "selfhost_fast_host")
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_SELFHOST_BLOCK_ON_UE", "selfhost_fast_host"):
        result.message = "selfhost_fast_host blocked by quarantine stuck/orphan processes"
        return result

    let explicitStage0Raw: str = strutil.strip(stage0Raw)
    var stage0: str = tooling_resolveStage0DriverStrict(root, stage0Raw)
    if !tooling_strNonEmpty(stage0) && tooling_strNonEmpty(explicitStage0Raw):
        result.message = "selfhost_fast_host explicit stage0 failed strict probe: " + explicitStage0Raw
        return result
    if !tooling_strNonEmpty(stage0):
        result.message = "selfhost_fast_host missing stage0 driver"
        return result
    result.stage0Path = stage0
    result.stage0DriverKind = tooling_stage0DriverKind(root, stage0)

    var outDir: str = outDirRaw
    if !tooling_strNonEmpty(outDir):
        outDir = "artifacts/backend_selfhost_self_obj"
    outDir = tooling_pathAbsolute(root, outDir)
    if !tooling_mkdirP(root, outDir):
        result.message = "selfhost_fast_host failed to create out dir: " + outDir
        return result
    let stage1Path: str = os.joinPath(outDir, "cheng.stage1")
    let stage2Path: str = os.joinPath(outDir, "cheng.stage2")
    result.stage1Path = stage1Path
    result.stage2Path = stage2Path

    let startedMs: int64 = tooling_nowMs()
    let stage1StartedMs: int64 = tooling_nowMs()
    var stage1Status: str = "alias"
    var stage1CompileMode: str = "alias"
    let strictRebuild: bool = tooling_selfhostStrictRebuildEnabled()
    let requireStage1Rebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_REQUIRE_REBUILD", "0")))
    let stage1FullRebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FULL_REBUILD", "0")))
    let stage1ForceProbeOnFull: bool = compileStage1 &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FORCE_PROBE_ON_FULL", "0"))
    let stage1AutoFullOnRequire: bool = compileStage1 && !stage1FullRebuild && requireStage1Rebuild &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_AUTO_FULL_ON_REQUIRE", "1"))
    let stage1QuickLightSanity: bool = compileStage1 && !stage1FullRebuild &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_QUICK_LIGHT_SANITY", "1"))
    let stage1StampHitFastSanity: bool = compileStage1 && stage1FullRebuild &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_STAMP_HIT_FAST_SANITY", "1"))
    var compileStage1TextBase: str = "0"
    if compileStage1:
        compileStage1TextBase = "1"
        if stage1FullRebuild:
            stage1CompileMode = "full"
        else:
            stage1CompileMode = "quick"
    result.stage1CompileMode = stage1CompileMode
    var stage1CompileMsTotal: int64 = int64(0)
    var stage1SanityMsTotal: int64 = int64(0)
    var stage1CompileAttempts: int32 = 0
    var stage1CompileSegfaults: int32 = 0
    if compileStage1:
        let compileStarted0: int64 = tooling_nowMs()
        var rcBuild: int32 = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, stage1FullRebuild)
        stage1CompileMsTotal = stage1CompileMsTotal + (tooling_nowMs() - compileStarted0)
        stage1CompileAttempts = stage1CompileAttempts + 1
        if rcBuild != 0 && tooling_strEq(tooling_exitKind(rcBuild), "segfault"):
            stage1CompileSegfaults = stage1CompileSegfaults + 1
        var stage1BuildOk: bool = false
        if rcBuild == 0:
            let sanityStarted0: int64 = tooling_nowMs()
            if stage1StampHitFastSanity && tooling_buildDriverLastStampHit:
                stage1BuildOk = tooling_driverMinimalSanityOk(root, stage1Path)
            else:
                stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                            stage1ForceProbeOnFull)
            stage1SanityMsTotal = stage1SanityMsTotal + (tooling_nowMs() - sanityStarted0)
        if stage1AutoFullOnRequire && (!stage1BuildOk || rcBuild != 0):
            tooling_printErr("cheng_tooling: selfhost fast stage1 quick rebuild failed or not runnable; retrying full-rebuild because require-rebuild is enabled")
            stage1CompileMode = "full"
            let compileStarted1: int64 = tooling_nowMs()
            rcBuild = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, true)
            stage1CompileMsTotal = stage1CompileMsTotal + (tooling_nowMs() - compileStarted1)
            stage1CompileAttempts = stage1CompileAttempts + 1
            if rcBuild != 0 && tooling_strEq(tooling_exitKind(rcBuild), "segfault"):
                stage1CompileSegfaults = stage1CompileSegfaults + 1
            if rcBuild == 0:
                let sanityStarted1: int64 = tooling_nowMs()
                if stage1StampHitFastSanity && tooling_buildDriverLastStampHit:
                    stage1BuildOk = tooling_driverMinimalSanityOk(root, stage1Path)
                else:
                    stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                                stage1ForceProbeOnFull)
                stage1SanityMsTotal = stage1SanityMsTotal + (tooling_nowMs() - sanityStarted1)
            else:
                stage1BuildOk = false
        if !stage1BuildOk && rcBuild != 0 && tooling_strEq(tooling_exitKind(rcBuild), "segfault"):
            let rescueStage0: str = tooling_buildDriverSegfaultRescueCandidate(root, stage0, explicitStage0Raw)
            if tooling_strNonEmpty(rescueStage0):
                tooling_printErr("cheng_tooling: selfhost fast stage1 segfault; retrying with rescue stage0: " + rescueStage0)
                stage0 = rescueStage0
                result.stage0Path = stage0
                result.stage0DriverKind = tooling_stage0DriverKind(root, stage0)
                let retryFull: bool = tooling_strEq(stage1CompileMode, "full")
                let compileStarted2: int64 = tooling_nowMs()
                rcBuild = tooling_compileBackendDriverFastHost(root, stage0, target, stage1Path, retryFull)
                stage1CompileMsTotal = stage1CompileMsTotal + (tooling_nowMs() - compileStarted2)
                stage1CompileAttempts = stage1CompileAttempts + 1
                if rcBuild != 0 && tooling_strEq(tooling_exitKind(rcBuild), "segfault"):
                    stage1CompileSegfaults = stage1CompileSegfaults + 1
                if rcBuild == 0:
                    let sanityStarted2: int64 = tooling_nowMs()
                    if stage1StampHitFastSanity && tooling_buildDriverLastStampHit:
                        stage1BuildOk = tooling_driverMinimalSanityOk(root, stage1Path)
                    else:
                        stage1BuildOk = tooling_driverBuildOutputOk(root, stage1Path, stage1CompileMode, stage1QuickLightSanity,
                                                                    stage1ForceProbeOnFull)
                    stage1SanityMsTotal = stage1SanityMsTotal + (tooling_nowMs() - sanityStarted2)
                else:
                    stage1BuildOk = false
        if stage1BuildOk:
            stage1Status = "rebuild"
            result.stage1RebuildOk = true
            result.fallbackUsed = false
        else:
            result.stage1CompileMs = stage1CompileMsTotal
            result.stage1SanityMs = stage1SanityMsTotal
            result.stage1CompileAttempts = stage1CompileAttempts
            result.stage1CompileSegfaults = stage1CompileSegfaults
            if requireStage1Rebuild:
                if rcBuild != 0:
                    result.message = "selfhost_fast_host stage1 compile failed rc=" + intToStr(rcBuild) +
                                     " kind=" + tooling_exitKind(rcBuild)
                else:
                    result.message = "selfhost_fast_host stage1 compile output sanity failed"
                return result
            if !tooling_copyExecutable(root, stage0, stage1Path):
                if rcBuild != 0:
                    result.message = "selfhost_fast_host stage1 compile failed rc=" + intToStr(rcBuild) +
                                     " kind=" + tooling_exitKind(rcBuild)
                else:
                    result.message = "selfhost_fast_host stage1 compile output sanity failed and stage0 reuse copy failed"
                return result
            stage1Status = "reused_stage0"
            result.stage1RebuildOk = false
            result.fallbackUsed = true
    else:
        if !tooling_copyExecutable(root, stage0, stage1Path):
            result.message = "selfhost_fast_host stage1 alias copy failed"
            return result
        stage1Status = "alias"
        result.stage1RebuildOk = false
        # Alias mode is the intentional default fast path, not a fallback.
        result.fallbackUsed = false
    result.stage1CompileMs = stage1CompileMsTotal
    result.stage1SanityMs = stage1SanityMsTotal
    result.stage1CompileAttempts = stage1CompileAttempts
    result.stage1CompileSegfaults = stage1CompileSegfaults
    let stage1Ms: int64 = tooling_nowMs() - stage1StartedMs
    result.stage1Status = stage1Status
    result.stage1CompileMode = stage1CompileMode
    result.strictRebuildOk = !compileStage1 || !strictRebuild || result.stage1RebuildOk

    let stage2StartedMs: int64 = tooling_nowMs()
    if !tooling_copyExecutable(root, stage1Path, stage2Path):
        result.message = "selfhost_fast_host stage2 alias copy failed"
        return result
    let stage2Ms: int64 = tooling_nowMs() - stage2StartedMs

    let totalMs: int64 = tooling_nowMs() - startedMs
    result.totalMs = totalMs
    result.ok = true
    result.message = "ok"

    var timingOut: str = timingOutRaw
    if !tooling_strNonEmpty(timingOut):
        timingOut = os.joinPath(outDir, "selfhost_timing_native.tsv")
    timingOut = tooling_pathAbsolute(root, timingOut)
    let timingDir: str = os.parentDir(timingOut)
    tooling_tryMkdirP(root, timingDir)
    let timingText: str =
        "stage1\t" + stage1Status + "\t" + tooling_msToSecondsText(stage1Ms) + "\n" +
        "stage2\talias\t" + tooling_msToSecondsText(stage2Ms) + "\n" +
        "total\tok\t" + tooling_msToSecondsText(totalMs) + "\n"
    os.writeFile(timingOut, timingText)
    result.lockWaitMs = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_WAIT_MS", ""), 0)
    return result

fn tooling_selfhostWriteTiming(root: str, outDirRaw: str, timingOutRaw: str, stage1Status: str, stage1Ms: int64,
                               stage2Status: str, stage2Ms: int64, stage3Status: str, stage3Ms: int64,
                               hashStatus: str, hashMs: int64, totalStatus: str, totalMs: int64) =
    var outDir: str = outDirRaw
    if !tooling_strNonEmpty(outDir):
        outDir = "artifacts/backend_selfhost_self_obj"
    outDir = tooling_pathAbsolute(root, outDir)
    var timingOut: str = timingOutRaw
    if !tooling_strNonEmpty(timingOut):
        timingOut = os.joinPath(outDir, "selfhost_timing_native.tsv")
    timingOut = tooling_pathAbsolute(root, timingOut)
    let timingDir: str = os.parentDir(timingOut)
    tooling_tryMkdirP(root, timingDir)
    let timingText: str =
        "stage1\t" + stage1Status + "\t" + tooling_msToSecondsText(stage1Ms) + "\n" +
        "stage2\t" + stage2Status + "\t" + tooling_msToSecondsText(stage2Ms) + "\n" +
        "stage3\t" + stage3Status + "\t" + tooling_msToSecondsText(stage3Ms) + "\n" +
        "hash_check\t" + hashStatus + "\t" + tooling_msToSecondsText(hashMs) + "\n" +
        "total\t" + totalStatus + "\t" + tooling_msToSecondsText(totalMs) + "\n"
    os.writeFile(timingOut, timingText)

fn tooling_selfhostBootstrapStrictHost(root: str, outDirRaw: str, timingOutRaw: str, stage0Raw: str): ToolingSelfhostResult =
    var result: ToolingSelfhostResult
    new result
    result.ok = false
    result.message = ""
    result.totalMs = int64(0)
    result.mode = "strict"
    result.stage1Path = ""
    result.stage2Path = ""
    result.stage3Path = ""
    result.stage0Path = ""
    result.stage0DriverKind = "unknown"
    result.stage1Status = "init"
    result.stage1CompileMode = "full"
    result.stage1RebuildOk = false
    result.fallbackUsed = false
    result.quarantineCleaned = 0
    result.lockWaitMs = 0
    result.strictRebuildOk = false
    result.stage2Sha256 = ""
    result.stage3Sha256 = ""
    result.fixedPointOk = false
    result.stage1CompileMs = int64(0)
    result.stage1SanityMs = int64(0)
    result.stage1CompileAttempts = 0
    result.stage1CompileSegfaults = 0

    let hostTag: str = tooling_detectHostTag(root)
    if !tooling_strEq(hostTag, "darwin_arm64"):
        result.message = "selfhost_strict_host unsupported host: " + hostTag
        return result
    let target: str = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        result.message = "selfhost_strict_host failed to resolve host target"
        return result
    result.quarantineCleaned = tooling_stage0QuarantineSweepUe(root, "selfhost_strict_host")
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_SELFHOST_BLOCK_ON_UE", "selfhost_strict_host"):
        result.message = "selfhost_strict_host blocked by quarantine stuck/orphan processes"
        return result

    let explicitStage0Raw: str = strutil.strip(stage0Raw)
    let stage0: str = tooling_resolveStage0DriverStrict(root, stage0Raw)
    if !tooling_strNonEmpty(stage0) && tooling_strNonEmpty(explicitStage0Raw):
        result.message = "selfhost_strict_host explicit stage0 failed strict probe: " + explicitStage0Raw
        return result
    if !tooling_strNonEmpty(stage0):
        result.message = "selfhost_strict_host missing stage0 driver"
        return result
    result.stage0Path = stage0
    result.stage0DriverKind = tooling_stage0DriverKind(root, stage0)

    var outDir: str = outDirRaw
    if !tooling_strNonEmpty(outDir):
        outDir = "artifacts/backend_selfhost_self_obj"
    outDir = tooling_pathAbsolute(root, outDir)
    if !tooling_mkdirP(root, outDir):
        result.message = "selfhost_strict_host failed to create out dir: " + outDir
        return result
    result.stage1Path = os.joinPath(outDir, "cheng.stage1")
    result.stage2Path = os.joinPath(outDir, "cheng.stage2")
    result.stage3Path = os.joinPath(outDir, "cheng.stage3.witness")

    let strictDiagAllowMismatch: bool = tooling_isTrue(
        os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STRICT_DIAG_ALLOW_MISMATCH", "0"))
    let strictForceProbeOnFull: bool = tooling_isTrue(
        os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STRICT_FORCE_PROBE", "0"))
    let strictSkipSem: str = "0"
    let strictSkipOwnership: str = "0"

    let startedMs: int64 = tooling_nowMs()
    var stage1Ms: int64 = int64(0)
    var stage2Ms: int64 = int64(0)
    var stage3Ms: int64 = int64(0)
    var hashMs: int64 = int64(0)
    var stage1Status: str = "fail"
    var stage2Status: str = "skip"
    var stage3Status: str = "skip"
    var hashStatus: str = "skip"

    let stage1StartedMs: int64 = tooling_nowMs()
    let rcStage1: int32 = tooling_compileBackendDriverFastHostWithRebuildPolicy(
        root, stage0, target, result.stage1Path, true, strictSkipSem, strictSkipOwnership)
    stage1Ms = tooling_nowMs() - stage1StartedMs
    if rcStage1 != 0:
        result.message = "selfhost_strict_host stage1 compile failed rc=" + intToStr(rcStage1) +
                         " kind=" + tooling_exitKind(rcStage1)
        let totalFail1: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail1
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail1)
        return result
    if !tooling_driverBuildOutputOk(root, result.stage1Path, "full", false, strictForceProbeOnFull):
        result.message = "selfhost_strict_host stage1 output sanity failed"
        let totalFail1Sanity: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail1Sanity
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail1Sanity)
        return result
    stage1Status = "rebuild"
    result.stage1Status = "rebuild"
    result.stage1CompileMode = "full"
    result.stage1RebuildOk = true
    result.strictRebuildOk = true

    let stage2StartedMs: int64 = tooling_nowMs()
    let rcStage2: int32 = tooling_compileBackendDriverFastHostWithRebuildPolicy(
        root, result.stage1Path, target, result.stage2Path, true, strictSkipSem, strictSkipOwnership)
    stage2Ms = tooling_nowMs() - stage2StartedMs
    if rcStage2 != 0:
        stage2Status = "fail"
        result.message = "selfhost_strict_host stage2 compile failed rc=" + intToStr(rcStage2) +
                         " kind=" + tooling_exitKind(rcStage2)
        let totalFail2: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail2
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail2)
        return result
    if !tooling_driverBuildOutputOk(root, result.stage2Path, "full", false, strictForceProbeOnFull):
        stage2Status = "fail"
        result.message = "selfhost_strict_host stage2 output sanity failed"
        let totalFail2Sanity: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail2Sanity
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail2Sanity)
        return result
    stage2Status = "rebuild"

    let stage3StartedMs: int64 = tooling_nowMs()
    let rcStage3: int32 = tooling_compileBackendDriverFastHostWithRebuildPolicy(
        root, result.stage2Path, target, result.stage3Path, true, strictSkipSem, strictSkipOwnership)
    stage3Ms = tooling_nowMs() - stage3StartedMs
    if rcStage3 != 0:
        stage3Status = "fail"
        result.message = "selfhost_strict_host stage3 witness compile failed rc=" + intToStr(rcStage3) +
                         " kind=" + tooling_exitKind(rcStage3)
        let totalFail3: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail3
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail3)
        return result
    if !tooling_driverBuildOutputOk(root, result.stage3Path, "full", false, strictForceProbeOnFull):
        stage3Status = "fail"
        result.message = "selfhost_strict_host stage3 witness output sanity failed"
        let totalFail3Sanity: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalFail3Sanity
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalFail3Sanity)
        return result
    stage3Status = "rebuild"

    let hashStartedMs: int64 = tooling_nowMs()
    result.stage2Sha256 = tooling_sha256File(root, result.stage2Path)
    result.stage3Sha256 = tooling_sha256File(root, result.stage3Path)
    hashMs = tooling_nowMs() - hashStartedMs
    if !tooling_strNonEmpty(result.stage2Sha256) || !tooling_strNonEmpty(result.stage3Sha256):
        hashStatus = "fail"
        result.message = "selfhost_strict_host requires SHA-256 tool (shasum or sha256sum)"
        let totalHashFail: int64 = tooling_nowMs() - startedMs
        result.totalMs = totalHashFail
        tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                    stage2Status, stage2Ms, stage3Status, stage3Ms,
                                    hashStatus, hashMs, "fail", totalHashFail)
        return result

    result.fixedPointOk = tooling_strEq(result.stage2Sha256, result.stage3Sha256)
    if result.fixedPointOk:
        hashStatus = "ok"
        result.message = "ok"
        result.ok = true
    else:
        hashStatus = "mismatch"
        if strictDiagAllowMismatch:
            result.ok = true
            result.message = "selfhost_strict_host fixed-point mismatch allowed by SELF_OBJ_BOOTSTRAP_STRICT_DIAG_ALLOW_MISMATCH=1"
        else:
            result.ok = false
            result.message = "selfhost_strict_host fixed-point mismatch stage2=" + result.stage2Sha256 +
                             " stage3=" + result.stage3Sha256 +
                             " stage2_path=" + result.stage2Path +
                             " stage3_path=" + result.stage3Path
    let totalMs: int64 = tooling_nowMs() - startedMs
    result.totalMs = totalMs
    let totalStatus: str = result.ok ? "ok" : "fail"
    tooling_selfhostWriteTiming(root, outDir, timingOutRaw, stage1Status, stage1Ms,
                                stage2Status, stage2Ms, stage3Status, stage3Ms,
                                hashStatus, hashMs, totalStatus, totalMs)
    result.lockWaitMs = tooling_parseInt32Default(os.getEnvDefault("TOOLING_STAGE0_LOCK_WAIT_MS", ""), 0)
    return result

fn tooling_sortInt32Asc(values: int32[]): int32[] =
    var out: int32[] = []
    for i in 0..<values.len:
        add(out, values[i])
    for i in 1..<out.len:
        let key: int32 = out[i]
        var j: int32 = i - 1
        while j >= 0 && out[j] > key:
            out[j + 1] = out[j]
            j = j - 1
        out[j + 1] = key
    return out

fn tooling_pickPercentile(sorted: int32[], pct: int32): int32 =
    if sorted.len <= 0:
        return -1
    var k: int32 = (pct * sorted.len + 99) / 100
    if k < 1:
        k = 1
    if k > sorted.len:
        k = sorted.len
    return sorted[k - 1]

fn tooling_backendDriverHistoryKeep(name: str): bool =
    if tooling_strEq(name, "cheng"):
        return true
    if tooling_strEq(name, "cheng.full_rebuild.stamp.env"):
        return true
    if tooling_strEq(name, "cheng.objs"):
        return true
    if tooling_strEq(name, "cheng.objs.lock"):
        return true
    return false

fn tooling_cmdCleanupBackendDriverHistory(root: str, dryRun: bool): int32 =
    let backendDir: str = os.joinPath(root, "artifacts/backend_driver")
    if !os.dirExists(backendDir):
        tooling_printOut("cleanup_backend_driver_history_status=noop")
        tooling_printOut("cleanup_backend_driver_history_dir_missing=" + backendDir)
        return 0
    let scanCmd: str = "find " + tooling_shellQuote(backendDir) + " -maxdepth 1 -mindepth 1 -name 'cheng*' -print"
    let scanRes: os.ExecCmdResult = tooling_exec(root, scanCmd)
    let scanRc: int32 = os.execCmdResultExitCode(scanRes)
    if scanRc != 0:
        tooling_printErr("cheng_tooling: cleanup_backend_driver_history scan failed")
        tooling_printExecOutput(scanRes)
        return scanRc
    let rows: str[] = tooling_splitLines(os.execCmdResultOutput(scanRes))
    var removedCount: int32 = 0
    var keepCount: int32 = 0
    var scannedCount: int32 = 0
    for i in 0..<rows.len:
        let path: str = strutil.strip(rows[i])
        if !tooling_strNonEmpty(path):
            continue
        scannedCount = scannedCount + 1
        let base: str = os.extractFilename(path)
        if tooling_backendDriverHistoryKeep(base):
            keepCount = keepCount + 1
            continue
        removedCount = removedCount + 1
        if dryRun:
            tooling_printOut("cleanup_backend_driver_history_plan_remove=" + path)
            continue
        let rmCmd: str = "rm -rf " + tooling_shellQuote(path)
        let rmRes: os.ExecCmdResult = tooling_exec(root, rmCmd)
        let rmRc: int32 = os.execCmdResultExitCode(rmRes)
        if rmRc != 0:
            tooling_printErr("cheng_tooling: cleanup_backend_driver_history remove failed: " + path)
            tooling_printExecOutput(rmRes)
            return rmRc
    tooling_printOut("cleanup_backend_driver_history_scanned=" + intToStr(scannedCount))
    tooling_printOut("cleanup_backend_driver_history_kept=" + intToStr(keepCount))
    tooling_printOut("cleanup_backend_driver_history_removed=" + intToStr(removedCount))
    if dryRun:
        tooling_printOut("cleanup_backend_driver_history_dry_run=1")
    else:
        tooling_printOut("cleanup_backend_driver_history_dry_run=0")
    return 0

fn tooling_cmdDriverPath(root: str, explicitRaw: str): int32 =
    let stage0: str = tooling_resolveStage0Driver(root, explicitRaw)
    if !tooling_strNonEmpty(stage0):
        tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    tooling_printOut(stage0)
    return 0

fn tooling_cmdCleanupBackendDriverHistoryFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var dryRun: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("cleanup-backend-driver-history options:")
            tooling_printOut("  --dry-run                   print files to remove, no write")
            return 0
        if tooling_strEq(arg, "--dry-run"):
            dryRun = true
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown cleanup-backend-driver-history arg: " + arg)
        return 1
    return tooling_cmdCleanupBackendDriverHistory(root, dryRun)

fn tooling_cmdBuildBackendDriver(root: str, outRaw: str, stage0Raw: str, targetRaw: str, requireRebuild: bool): int32 =
    var target: str = strutil.strip(targetRaw)
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        tooling_printErr("cheng_tooling: failed to detect target")
        return 1
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_BUILD_DRIVER_BLOCK_ON_UE", "build_backend_driver"):
        return 1
    let explicitStage0Raw: str = strutil.strip(stage0Raw)
    let stage0ProbeEnabled: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_STAGE0_PROBE", "0"))
    let stage0Candidates: str[] = tooling_stage0CandidateListWithProbe(root, stage0Raw, stage0ProbeEnabled)
    if stage0Candidates.len <= 0 && tooling_strNonEmpty(explicitStage0Raw):
        tooling_printErr("cheng_tooling: explicit stage0 failed strict probe: " + explicitStage0Raw)
        return 1
    if stage0Candidates.len <= 0:
        tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    var outPath: str = outRaw
    if !tooling_strNonEmpty(outPath):
        outPath = "artifacts/backend_driver/cheng"
    outPath = tooling_pathAbsolute(root, outPath)
    let canonicalDriverPath: str = tooling_pathAbsolute(root, "artifacts/backend_driver/cheng")
    let autoCleanHistory: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_AUTO_CLEAN_HISTORY", "1"))
    let strictNative: bool = tooling_buildDriverStrictNativeEnabled()
    let allowFallback: bool = tooling_buildDriverAllowFallbackEnabled()
    let quickLightSanity: bool = false
    let forceProbeDefault: str = strictNative ? "1" : "0"
    let forceProbeOnFull: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_FULL_FORCE_PROBE", forceProbeDefault))
    let noRecover: bool = !allowFallback || tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_NO_RECOVER", "1"))
    let keepFailedAttempt: bool = tooling_isTrue(
        os.getEnvDefault("BACKEND_BUILD_DRIVER_KEEP_FAILED_ATTEMPT", "0"))
    var maxStage0Attempts: int32 = tooling_parseInt32Default(os.getEnvDefault("BACKEND_BUILD_DRIVER_MAX_STAGE0_ATTEMPTS", ""), 0)
    if maxStage0Attempts < 0:
        maxStage0Attempts = 0
    let compileMode: str = "full"
    var stage0AttemptCandidates: str[] = stage0Candidates
    var attemptCount: int32 = stage0AttemptCandidates.len
    if maxStage0Attempts > 0 && maxStage0Attempts < attemptCount:
        attemptCount = maxStage0Attempts
    var lastRc: int32 = 1
    var lastCompileMode: str = compileMode
    var lastStage0: str = ""
    var fallbackStage0: str = ""
    var i: int32 = 0
    while i < attemptCount:
        let stage0: str = stage0AttemptCandidates[i]
        var stage0ReusePath: str = stage0
        var attemptFallbackUsed: bool = false
        if !tooling_strNonEmpty(fallbackStage0):
            fallbackStage0 = stage0
        let attemptIndex: int32 = i + 1
        tooling_printErr("cheng_tooling: build_backend_driver stage0 attempt " + intToStr(attemptIndex) +
                         "/" + intToStr(attemptCount) + " driver=" + stage0)
        let attemptOutPath: str = tooling_driverBuildTempPath(root, outPath, attemptIndex)
        tooling_driverBuildTempCleanup(root, attemptOutPath)
        var attemptCompileMode: str = compileMode
        var rc: int32 = tooling_compileBackendDriverFastHost(root, stage0ReusePath, target, attemptOutPath, true)
        var postBuildOk: bool = false
        if rc == 0:
            postBuildOk = tooling_driverBuildOutputOk(root, attemptOutPath, attemptCompileMode, quickLightSanity, forceProbeOnFull)
        lastRc = rc
        lastCompileMode = attemptCompileMode
        if rc == 0 && postBuildOk:
            if !tooling_copyExecutable(root, attemptOutPath, outPath):
                tooling_printErr("cheng_tooling: stage0 attempt output install failed: " + attemptOutPath)
                postBuildOk = false
            tooling_driverBuildTempCleanup(root, attemptOutPath)
        if rc == 0 && postBuildOk:
            tooling_printOut("build_backend_driver_compile_mode=" + attemptCompileMode)
            tooling_printOut("build_backend_driver_rebuilt=1")
            tooling_printOut("build_backend_driver_fallback_used=" + (attemptFallbackUsed ? "1" : "0"))
            tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
            tooling_printOut("build_backend_driver_ok=" + outPath)
            if autoCleanHistory && tooling_strEq(outPath, canonicalDriverPath):
                let cleanRc: int32 = tooling_cmdCleanupBackendDriverHistory(root, false)
                if cleanRc != 0:
                    return cleanRc
            return 0
        if !keepFailedAttempt:
            tooling_driverBuildTempCleanup(root, attemptOutPath)
        else:
            tooling_printErr("cheng_tooling: keep failed attempt artifact: " + attemptOutPath)
        if rc != 0:
            tooling_printErr("cheng_tooling: stage0 attempt failed rc=" + intToStr(rc) +
                             " kind=" + tooling_exitKind(rc) + " driver=" + stage0)
            if tooling_strEq(tooling_exitKind(rc), "segfault"):
                let canQueueRescue: bool = (maxStage0Attempts <= 0) || (stage0AttemptCandidates.len < maxStage0Attempts)
                if canQueueRescue:
                    let rescueStage0: str = tooling_buildDriverSegfaultRescueCandidate(root, stage0, explicitStage0Raw)
                    if tooling_strNonEmpty(rescueStage0) && !tooling_idsContains(stage0AttemptCandidates, rescueStage0):
                        add(stage0AttemptCandidates, rescueStage0)
                        attemptCount = stage0AttemptCandidates.len
                        tooling_printErr("cheng_tooling: stage0 segfault detected; queued rescue stage0 candidate: " + rescueStage0)
        else:
            tooling_printErr("cheng_tooling: stage0 attempt output sanity failed: " + stage0)
        lastStage0 = stage0
        i = i + 1
    # Shim fallback removed.
    if requireRebuild:
        tooling_printErr("cheng_tooling: require-rebuild enabled; all stage0 attempts failed, stage0 reuse disabled")
        tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
        tooling_printOut("build_backend_driver_rebuilt=0")
        tooling_printOut("build_backend_driver_fallback_used=0")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printOut("build_backend_driver_ok=" + outPath)
        if lastRc != 0:
            return lastRc
        return 1
    if noRecover:
        if strictNative && !requireRebuild:
            # Strict-native mode no longer allows stage0 reuse on fail.
            let _fallbackStage0Unused: str = fallbackStage0
        tooling_printErr("cheng_tooling: build backend driver compile failed rc=" + intToStr(lastRc) +
                         " kind=" + tooling_exitKind(lastRc) + "; no-recover enabled, stage0 reuse disabled")
        tooling_printOut("build_backend_driver_compile_mode=" + lastCompileMode)
        tooling_printOut("build_backend_driver_rebuilt=0")
        tooling_printOut("build_backend_driver_fallback_used=0")
        tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printOut("build_backend_driver_ok=" + outPath)
        if lastRc != 0:
            return lastRc
        return 1
    tooling_printOut("build_backend_driver_fallback_used=0")
    tooling_printOut("build_backend_driver_strict_native=" + (strictNative ? "1" : "0"))
    if lastRc != 0:
        tooling_printOut("build_backend_driver_last_stage0=" + lastStage0)
        tooling_printOut("build_backend_driver_last_rc=" + intToStr(lastRc))
        tooling_printOut("build_backend_driver_last_kind=" + tooling_exitKind(lastRc))
        tooling_printErr("cheng_tooling: build backend driver failed rc=" + intToStr(lastRc))
        return lastRc
    tooling_printErr("cheng_tooling: build backend driver output sanity failed: " + outPath)
    return 1

fn tooling_cmdSelfhostBootstrapFastHost(root: str, compileStage1: bool, outDirRaw: str, timingOutRaw: str, stage0Raw: str): int32 =
    let res: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, outDirRaw, timingOutRaw, stage0Raw)
    if res == nil || !res.ok:
        var msg: str = "unknown failure"
        if res != nil:
            msg = res.message
        tooling_printErr("cheng_tooling: selfhost bootstrap fast host failed: " + msg)
        return 1
    tooling_printOut("selfhost_fast_stage1=" + res.stage1Path)
    tooling_printOut("selfhost_fast_stage2=" + res.stage2Path)
    tooling_printOut("selfhost_fast_stage0=" + res.stage0Path)
    tooling_printOut("selfhost_fast_stage0_driver_kind=" + res.stage0DriverKind)
    tooling_printOut("selfhost_fast_stage1_status=" + res.stage1Status)
    tooling_printOut("selfhost_fast_stage1_compile_mode=" + res.stage1CompileMode)
    var stage1RebuildOkText: str = "0"
    if res.stage1RebuildOk:
        stage1RebuildOkText = "1"
    var fallbackUsedText: str = "0"
    if res.fallbackUsed:
        fallbackUsedText = "1"
    var strictRebuildOkText: str = "0"
    if res.strictRebuildOk:
        strictRebuildOkText = "1"
    tooling_printOut("selfhost_fast_stage1_rebuild_ok=" + stage1RebuildOkText)
    tooling_printOut("selfhost_fast_fallback_used=" + fallbackUsedText)
    tooling_printOut("selfhost_fast_quarantine_cleaned=" + intToStr(res.quarantineCleaned))
    tooling_printOut("selfhost_fast_lock_wait_ms=" + intToStr(res.lockWaitMs))
    tooling_printOut("selfhost_fast_strict_rebuild_ok=" + strictRebuildOkText)
    tooling_printOut("selfhost_fast_total_ms=" + intToStr(int32(res.totalMs)))
    return 0

fn tooling_cmdSelfhost100msHost(root: str, hostOnlyRaw: str, itersRaw: str, p95Raw: str, p99Raw: str, enforceRaw: str, reportRaw: str, compileStage1: bool, outDirRaw: str, stage0Raw: str): int32 =
    var hostOnly: str = strutil.strip(hostOnlyRaw)
    if !tooling_strNonEmpty(hostOnly):
        hostOnly = "darwin_arm64"
    let defaultIters: int32 = compileStage1 ? 1 : 5
    var iters: int32 = tooling_parseInt32Default(itersRaw, defaultIters)
    if iters <= 0:
        iters = defaultIters
    var p95Limit: int32 = tooling_parseInt32Default(p95Raw, 100)
    if p95Limit <= 0:
        p95Limit = 100
    var p99Limit: int32 = tooling_parseInt32Default(p99Raw, 120)
    if p99Limit <= 0:
        p99Limit = 120
    let enforce: bool = tooling_isTrue(enforceRaw)
    let strictRebuild: bool = tooling_selfhostStrictRebuildEnabled()
    let requireStage1Rebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_REQUIRE_REBUILD", "0")))
    let stage1FullRebuild: bool = compileStage1 &&
        (strictRebuild || tooling_isTrue(os.getEnvDefault("SELFHOST_STAGE1_FULL_REBUILD", "0")))
    var stage1CompileModeBase: str = "alias"
    if compileStage1:
        if stage1FullRebuild:
            stage1CompileModeBase = "full"
        else:
            stage1CompileModeBase = "quick"
    var compileStage1TextBase: str = "0"
    if compileStage1:
        compileStage1TextBase = "1"

    let hostTag: str = tooling_detectHostTag(root)
    var reportPath: str = reportRaw
    if !tooling_strNonEmpty(reportPath):
        reportPath = "artifacts/backend_selfhost_100ms_host/report.tsv"
    reportPath = tooling_pathAbsolute(root, reportPath)
    let reportDir: str = os.parentDir(reportPath)
    tooling_tryMkdirP(root, reportDir)

    if hostTag != hostOnly:
        let reportSkip: str =
            "host=" + hostTag + "\n" +
            "host_only=" + hostOnly + "\n" +
            "compile_stage1=" + compileStage1TextBase + "\n" +
            "stage1_compile_mode=" + stage1CompileModeBase + "\n" +
            "strict_rebuild_ok=0\n" +
            "fallback_used=0\n" +
            "quarantine_cleaned=0\n" +
            "lock_wait_ms=0\n" +
            "status=skip_non_target_host\n"
        os.writeFile(reportPath, reportSkip)
        tooling_printOut("[selfhost_100ms_native] skip on non-target host: host=" + hostTag + " target=" + hostOnly)
        return 0
    var totalsMs: int32[] = []
    var stage1RebuildCount: int32 = 0
    var stage1ReuseCount: int32 = 0
    var stage1AliasCount: int32 = 0
    var stage1CompileModeFullCount: int32 = 0
    var stage1CompileModeQuickCount: int32 = 0
    var stage1CompileModeAliasCount: int32 = 0
    var fallbackUsedCount: int32 = 0
    var quarantineCleanedTotal: int32 = 0
    var lockWaitMsMax: int32 = 0
    var strictRebuildOkCount: int32 = 0
    var stage1CompileMsTotal: int64 = int64(0)
    var stage1CompileMsMax: int64 = int64(0)
    var stage1SanityMsTotal: int64 = int64(0)
    var stage1CompileAttemptsTotal: int32 = 0
    var stage1CompileSegfaultsTotal: int32 = 0
    var stage0DriverKindSummary: str = ""
    var warmupOk: bool = true
    var outDirInput: str = outDirRaw
    if !tooling_strNonEmpty(outDirInput):
        outDirInput = "artifacts/backend_selfhost_100ms_host"
    let outDir: str = tooling_pathAbsolute(root, outDirInput)
    tooling_tryMkdirP(root, outDir)
    let prewarmStage1: bool = compileStage1 && iters > 1 &&
        tooling_isTrue(os.getEnvDefault("SELFHOST_100MS_PREWARM_STAGE1", "1"))
    if prewarmStage1:
        let warmupTimingPath: str = os.joinPath(outDir, "selfhost_timing_native.warmup.tsv")
        let warmupRes: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, outDir, warmupTimingPath, stage0Raw)
        if warmupRes == nil || !warmupRes.ok:
            warmupOk = false
            var msgWarm: str = "unknown failure"
            if warmupRes != nil:
                msgWarm = warmupRes.message
            tooling_printErr("[selfhost_100ms_native] warmup failed (continue): reason=" + msgWarm)
            tooling_printOut("selfhost_100ms_warmup_failed=1")
        else:
            tooling_printOut("selfhost_100ms_warmup_ms=" + intToStr(int32(warmupRes.totalMs)))
    for i in 1..iters:
        let timingPath: str = os.joinPath(outDir, "selfhost_timing_native." + intToStr(i) + ".tsv")
        let res: ToolingSelfhostResult = tooling_selfhostBootstrapFastHost(root, compileStage1, outDir, timingPath, stage0Raw)
        if res == nil || !res.ok:
            var msg: str = "unknown failure"
            var stage0DriverKindFail: str = "unknown"
            var fallbackUsedFail: str = "0"
            var quarantineCleanedFail: str = "0"
            var lockWaitMsFail: str = "0"
            var strictRebuildOkFail: str = "0"
            var stage1CompileMsFail: str = "0"
            var stage1SanityMsFail: str = "0"
            var stage1CompileAttemptsFail: str = "0"
            var stage1CompileSegfaultsFail: str = "0"
            if res != nil:
                msg = res.message
                stage0DriverKindFail = res.stage0DriverKind
                if res.fallbackUsed:
                    fallbackUsedFail = "1"
                quarantineCleanedFail = intToStr(res.quarantineCleaned)
                lockWaitMsFail = intToStr(res.lockWaitMs)
                if res.strictRebuildOk:
                    strictRebuildOkFail = "1"
                stage1CompileMsFail = intToStr(int32(res.stage1CompileMs))
                stage1SanityMsFail = intToStr(int32(res.stage1SanityMs))
                stage1CompileAttemptsFail = intToStr(res.stage1CompileAttempts)
                stage1CompileSegfaultsFail = intToStr(res.stage1CompileSegfaults)
            let reportFail: str =
                "host=" + hostTag + "\n" +
                "iters=" + intToStr(iters) + "\n" +
                "failed_iter=" + intToStr(i) + "\n" +
                "status=bootstrap_fail\n" +
                "reason=" + msg + "\n" +
                "compile_stage1=" + compileStage1TextBase + "\n" +
                "stage1_compile_mode=" + stage1CompileModeBase + "\n" +
                "stage0_driver_kind=" + stage0DriverKindFail + "\n" +
                "fallback_used=" + fallbackUsedFail + "\n" +
                "quarantine_cleaned=" + quarantineCleanedFail + "\n" +
                "lock_wait_ms=" + lockWaitMsFail + "\n" +
                "strict_rebuild_ok=" + strictRebuildOkFail + "\n" +
                "stage1_compile_ms=" + stage1CompileMsFail + "\n" +
                "stage1_sanity_ms=" + stage1SanityMsFail + "\n" +
                "stage1_compile_attempts=" + stage1CompileAttemptsFail + "\n" +
                "stage1_compile_segfaults=" + stage1CompileSegfaultsFail + "\n" +
                "limit_p95_ms=" + intToStr(p95Limit) + "\n" +
                "limit_p99_ms=" + intToStr(p99Limit) + "\n"
            os.writeFile(reportPath, reportFail)
            tooling_printErr("[selfhost_100ms_native] bootstrap failed: iter=" + intToStr(i) + " reason=" + msg)
            if enforce:
                return 1
            return 0
        add(totalsMs, int32(res.totalMs))
        if res.fallbackUsed:
            fallbackUsedCount = fallbackUsedCount + 1
        quarantineCleanedTotal = quarantineCleanedTotal + res.quarantineCleaned
        if res.lockWaitMs > lockWaitMsMax:
            lockWaitMsMax = res.lockWaitMs
        if res.strictRebuildOk:
            strictRebuildOkCount = strictRebuildOkCount + 1
        stage1CompileMsTotal = stage1CompileMsTotal + res.stage1CompileMs
        if res.stage1CompileMs > stage1CompileMsMax:
            stage1CompileMsMax = res.stage1CompileMs
        stage1SanityMsTotal = stage1SanityMsTotal + res.stage1SanityMs
        stage1CompileAttemptsTotal = stage1CompileAttemptsTotal + res.stage1CompileAttempts
        stage1CompileSegfaultsTotal = stage1CompileSegfaultsTotal + res.stage1CompileSegfaults
        if !tooling_strNonEmpty(stage0DriverKindSummary):
            stage0DriverKindSummary = res.stage0DriverKind
        elif !tooling_strEq(stage0DriverKindSummary, res.stage0DriverKind):
            stage0DriverKindSummary = "mixed"
        if tooling_strEq(res.stage1Status, "rebuild") && res.stage1RebuildOk:
            stage1RebuildCount = stage1RebuildCount + 1
        elif tooling_strEq(res.stage1Status, "reused_stage0"):
            stage1ReuseCount = stage1ReuseCount + 1
        elif tooling_strEq(res.stage1Status, "alias"):
            stage1AliasCount = stage1AliasCount + 1
        if tooling_strEq(res.stage1CompileMode, "full"):
            stage1CompileModeFullCount = stage1CompileModeFullCount + 1
        elif tooling_strEq(res.stage1CompileMode, "quick"):
            stage1CompileModeQuickCount = stage1CompileModeQuickCount + 1
        else:
            stage1CompileModeAliasCount = stage1CompileModeAliasCount + 1
    if totalsMs.len <= 0:
        tooling_printErr("[selfhost_100ms_native] empty totals")
        return 1
    let sorted: int32[] = tooling_sortInt32Asc(totalsMs)
    let p95Ms: int32 = tooling_pickPercentile(sorted, 95)
    let p99Ms: int32 = tooling_pickPercentile(sorted, 99)
    var maxMs: int32 = 0
    for i in 0..<sorted.len:
        if sorted[i] > maxMs:
            maxMs = sorted[i]
    var status: str = "ok"
    if p95Ms > p95Limit || p99Ms > p99Limit:
        status = "regression"
    var stage1StatusSummary: str = "alias"
    var stage1CompileModeSummary: str = "alias"
    var stage1RebuildOk: bool = false
    if compileStage1:
        if stage1CompileModeFullCount == iters:
            stage1CompileModeSummary = "full"
        elif stage1CompileModeQuickCount == iters:
            stage1CompileModeSummary = "quick"
        elif stage1CompileModeFullCount > 0 && stage1CompileModeQuickCount > 0:
            stage1CompileModeSummary = "mixed_full_quick"
        elif stage1CompileModeAliasCount == iters:
            stage1CompileModeSummary = "alias"
        else:
            stage1CompileModeSummary = "mixed"
        if stage1RebuildCount == iters:
            stage1StatusSummary = "rebuild"
            stage1RebuildOk = true
        elif stage1RebuildCount > 0 && stage1ReuseCount > 0:
            stage1StatusSummary = "mixed_rebuild_reuse"
            stage1RebuildOk = false
        elif stage1ReuseCount > 0:
            stage1StatusSummary = "reused_stage0"
            stage1RebuildOk = false
        else:
            stage1StatusSummary = "unknown"
            stage1RebuildOk = false
    var stage1RebuildOkText: str = "0"
    if stage1RebuildOk:
        stage1RebuildOkText = "1"
    var fallbackUsedText: str = fallbackUsedCount > 0 ? "1" : "0"
    var strictRebuildOkText: str = "0"
    if !strictRebuild || strictRebuildOkCount == iters:
        strictRebuildOkText = "1"
    var stage1CompileMsAvg: int32 = 0
    var stage1SanityMsAvg: int32 = 0
    if iters > 0:
        stage1CompileMsAvg = int32(stage1CompileMsTotal / int64(iters))
        stage1SanityMsAvg = int32(stage1SanityMsTotal / int64(iters))
    if !tooling_strNonEmpty(stage0DriverKindSummary):
        stage0DriverKindSummary = "unknown"
    var prewarmStage1Text: str = "0"
    if prewarmStage1:
        prewarmStage1Text = "1"
    var warmupOkText: str = "1"
    if !warmupOk:
        warmupOkText = "0"
    let report: str =
        "host=" + hostTag + "\n" +
        "iters=" + intToStr(iters) + "\n" +
        "compile_stage1=" + compileStage1TextBase + "\n" +
        "prewarm_stage1=" + prewarmStage1Text + "\n" +
        "prewarm_ok=" + warmupOkText + "\n" +
        "stage1_compile_mode=" + stage1CompileModeSummary + "\n" +
        "stage1_status=" + stage1StatusSummary + "\n" +
        "stage1_rebuild_ok=" + stage1RebuildOkText + "\n" +
        "stage0_driver_kind=" + stage0DriverKindSummary + "\n" +
        "fallback_used=" + fallbackUsedText + "\n" +
        "quarantine_cleaned=" + intToStr(quarantineCleanedTotal) + "\n" +
        "lock_wait_ms=" + intToStr(lockWaitMsMax) + "\n" +
        "strict_rebuild_ok=" + strictRebuildOkText + "\n" +
        "stage1_compile_ms_avg=" + intToStr(stage1CompileMsAvg) + "\n" +
        "stage1_compile_ms_max=" + intToStr(int32(stage1CompileMsMax)) + "\n" +
        "stage1_sanity_ms_avg=" + intToStr(stage1SanityMsAvg) + "\n" +
        "stage1_compile_attempts_total=" + intToStr(stage1CompileAttemptsTotal) + "\n" +
        "stage1_compile_segfaults_total=" + intToStr(stage1CompileSegfaultsTotal) + "\n" +
        "p95_ms=" + intToStr(p95Ms) + "\n" +
        "p99_ms=" + intToStr(p99Ms) + "\n" +
        "max_ms=" + intToStr(maxMs) + "\n" +
        "limit_p95_ms=" + intToStr(p95Limit) + "\n" +
        "limit_p99_ms=" + intToStr(p99Limit) + "\n" +
        "status=" + status + "\n"
    os.writeFile(reportPath, report)
    tooling_printOut("[selfhost_100ms_native] host=" + hostTag +
                     " p95=" + intToStr(p95Ms) + "ms p99=" + intToStr(p99Ms) +
                     "ms max=" + intToStr(maxMs) + "ms status=" + status +
                     " stage0_driver_kind=" + stage0DriverKindSummary +
                     " fallback_used=" + fallbackUsedText +
                     " stage1_compile_mode=" + stage1CompileModeSummary +
                     " stage1_status=" + stage1StatusSummary +
                     " stage1_rebuild_ok=" + stage1RebuildOkText +
                     " strict_rebuild_ok=" + strictRebuildOkText +
                     " stage1_compile_ms_avg=" + intToStr(stage1CompileMsAvg) +
                     " stage1_compile_segfaults_total=" + intToStr(stage1CompileSegfaultsTotal))
    let enforcePerfWithCompileStage1: bool = compileStage1 &&
                                            tooling_isTrue(os.getEnvDefault("SELFHOST_100MS_ENFORCE_WITH_COMPILE_STAGE1", "1"))
    let enforcePerfGate: bool = enforce && (!compileStage1 || enforcePerfWithCompileStage1)
    if !tooling_strEq(status, "ok") && enforcePerfGate:
        return 1
    if requireStage1Rebuild && !stage1RebuildOk:
        return 1
    return 0

fn tooling_printCompileUsage() =
    tooling_printOut("compile options:")
    tooling_printOut("  --in:<file.cheng>            source file path")
    tooling_printOut("  --out:<path>                 output executable path")
    tooling_printOut("  --name:<name-or-path>        output name (defaults under artifacts/chengc)")
    tooling_printOut("  --target:<triple>            backend target triple")
    tooling_printOut("  --stage0:<path>              explicit driver executable (release defaults to BACKEND_RELEASE_DRIVER)")
    tooling_printOut("  --linker:self|system         linker mode (default: auto; dev=self when supported)")
    tooling_printOut("  --release                    release build track")
    tooling_printOut("  --dev                        dev build track (default)")
    tooling_printOut("  --run                        run output after successful compile")
    tooling_printOut("  [positional input]           same as --in:<file.cheng>")
    tooling_printOut("  env: TOOLING_COMPILE_STAGE0_AUTO_REBUILD_ON_PREFLIGHT_FAIL=1|0 (default 1)")
    tooling_printOut("  env: TOOLING_COMPILE_TIMEOUT=180 (default)")
    tooling_printOut("       TOOLING_COMPILE_BLOCK_ON_UE=1|0 (default 1; hard-block follows TOOLING_STAGE0_HARD_BLOCK_ON_UE)")

fn tooling_cmdCompileExe(root: str, inRaw: str, outRaw: str, nameRaw: str, targetRaw: str,
                         stage0Raw: str, linkerRaw: str, releaseBuild: bool, runAfter: bool): int32 =
    let inPath: str = tooling_pathAbsolute(root, inRaw)
    if !tooling_strNonEmpty(inPath) || !os.fileExists(inPath):
        tooling_printErr("cheng_tooling: compile input not found: " + inRaw)
        return 1
    if tooling_stage0BlockOnQuarantineUe(root, "TOOLING_COMPILE_BLOCK_ON_UE", "compile_exe"):
        return 1
    var stage0: str = ""
    if releaseBuild:
        stage0 = tooling_releaseDriverForCompile(root, stage0Raw, targetRaw)
    else:
        stage0 = tooling_resolveStage0Driver(root, stage0Raw)
    if !tooling_strNonEmpty(stage0):
        if releaseBuild:
            tooling_printErr("cheng_tooling: release driver not found/build failed (set BACKEND_RELEASE_DRIVER or run build-release-driver)")
        else:
            tooling_printErr("cheng_tooling: stage0 driver not found")
        return 1
    var stage0Exec: str = tooling_prepareStage0Exec(root, stage0, "compile")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: stage0 prepare failed")
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        let autoRecoverOnPreflightFail: bool =
            tooling_isTrue(os.getEnvDefault("TOOLING_COMPILE_STAGE0_AUTO_REBUILD_ON_PREFLIGHT_FAIL", "1"))
        let canAutoRecover: bool = autoRecoverOnPreflightFail &&
            !releaseBuild && !tooling_strNonEmpty(strutil.strip(stage0Raw))
        var recovered: bool = false
        if canAutoRecover:
            tooling_printErr("cheng_tooling: stage0 preflight failed; attempting build-backend-driver recovery")
            let rebuildRc: int32 = tooling_cmdBuildBackendDriver(root, "", "", targetRaw, true)
            if rebuildRc == 0:
                let recoveredStage0: str = tooling_resolveStage0Driver(root, "")
                if tooling_strNonEmpty(recoveredStage0):
                    stage0 = recoveredStage0
                    stage0Exec = tooling_prepareStage0Exec(root, stage0, "compile_recovered")
                    if tooling_strNonEmpty(stage0Exec) && tooling_stage0PreflightOk(root, stage0Exec):
                        recovered = true
                    elif tooling_strNonEmpty(stage0Exec):
                        tooling_cleanupStage0Exec(stage0, stage0Exec)
                        stage0Exec = ""
        if !recovered:
            tooling_printErr("cheng_tooling: stage0 preflight failed: " + stage0)
            return 1
    var target: str = tooling_normalizeTargetAlias(root, targetRaw)
    if !tooling_strNonEmpty(target):
        target = "auto"
    var linker: str = strutil.toLowerAscii(strutil.strip(linkerRaw))
    if !tooling_strNonEmpty(linker) || tooling_strEq(linker, "auto"):
        if releaseBuild:
            linker = "system"
        elif tooling_targetSupportsSelfLinker(target):
            linker = "self"
        else:
            linker = "system"
    if !tooling_strEq(linker, "system") && !tooling_strEq(linker, "self"):
        tooling_printErr("cheng_tooling: invalid --linker (expected self|system): " + linker)
        return 1
    let outPath: str = tooling_defaultCompileOut(root, inPath, outRaw, nameRaw)
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    var buildTrack: str = releaseBuild ? "release" : "dev"
    var cmd: str = ""
    cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", buildTrack)
    cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", linker)
    if releaseBuild:
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
        cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", "3")
        let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
        let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
        if tooling_strNonEmpty(releaseCflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", releaseCflagsRaw)
        if tooling_strNonEmpty(releaseLdflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", releaseLdflagsRaw)
    else:
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "outline")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "ws")
        cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "1")
    cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
    cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
    cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
    cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", inPath)
    cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
    if tooling_strEq(linker, "self"):
        var runtimeObj: str = tooling_runtimeObjPath(root, target)
        if !os.fileExists(runtimeObj):
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        if !os.fileExists(runtimeObj):
            tooling_printErr("cheng_tooling: missing runtime object for self-link: " + runtimeObj)
            tooling_cleanupStage0Exec(stage0, stage0Exec)
            return 1
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
        cmd = cmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
    else:
        cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
    cmd = cmd + tooling_shellQuote(stage0Exec)
    let cmdBase: str = tooling_prefixUnsetLegacyFrontendEnv(cmd)
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_COMPILE_TIMEOUT", ""), 180)
    if timeoutSec < 1:
        timeoutSec = 180
    var runCmd: str = tooling_wrapStage0Lock(root, cmdBase, "compile_exe")
    runCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, runCmd)
    var res: os.ExecCmdResult = tooling_exec(root, runCmd)
    tooling_printExecOutput(res)
    var rc: int32 = os.execCmdResultExitCode(res)
    var retrySafeUsed: bool = false
    var retrySystemLinkUsed: bool = false
    let retrySafeOnCrash: bool = !releaseBuild &&
        tooling_isTrue(os.getEnvDefault("TOOLING_COMPILE_DEV_CRASH_RETRY_SAFE", "1"))
    var safeCmdBase: str = cmdBase
    if rc != 0 && retrySafeOnCrash && tooling_isCrashExitCode(rc):
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "1"),
                                      tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0"))
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "outline"),
                                      tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full"))
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_FN_SCHED", "ws"),
                                      tooling_envAssignCompat("BACKEND_FN_SCHED", "serial"))
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_DIRECT_EXE", "1"),
                                      tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0"))
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "1"),
                                      tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0"))
        safeCmdBase = strutil.replace(safeCmdBase,
                                      tooling_envAssignCompat("BACKEND_INCREMENTAL", "1"),
                                      tooling_envAssignCompat("BACKEND_INCREMENTAL", "0"))
        safeCmdBase = tooling_envAssignCompat("BACKEND_OPT", "0") +
                      tooling_envAssignCompat("BACKEND_OPT2", "0") +
                      tooling_envAssignCompat("BACKEND_OPT_LEVEL", "0") +
                      safeCmdBase
        tooling_printErr("cheng_tooling: compile crashed rc=" + intToStr(rc) +
                         " kind=" + tooling_exitKind(rc) +
                         "; retry safe dev profile")
        var retryCmd: str = tooling_wrapStage0Lock(root, safeCmdBase, "compile_exe_retry_safe")
        retryCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, retryCmd)
        res = tooling_exec(root, retryCmd)
        tooling_printExecOutput(res)
        rc = os.execCmdResultExitCode(res)
        retrySafeUsed = true
    let retrySystemOnCrash: bool = !releaseBuild &&
        tooling_isTrue(os.getEnvDefault("TOOLING_COMPILE_DEV_CRASH_RETRY_SYSTEM_LINK", "1"))
    if rc != 0 && retrySystemOnCrash && tooling_isCrashExitCode(rc):
        var systemCmdBase: str = safeCmdBase
        systemCmdBase = strutil.replace(systemCmdBase,
                                        tooling_envAssignCompat("BACKEND_LINKER", "self"),
                                        tooling_envAssignCompat("BACKEND_LINKER", "system"))
        systemCmdBase = strutil.replace(systemCmdBase,
                                        tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1"),
                                        tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0"))
        systemCmdBase = tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", "") + systemCmdBase
        tooling_printErr("cheng_tooling: compile crashed rc=" + intToStr(rc) +
                         " kind=" + tooling_exitKind(rc) +
                         "; retry dev system-link profile")
        var systemRetryCmd: str = tooling_wrapStage0Lock(root, systemCmdBase, "compile_exe_retry_system_link")
        systemRetryCmd = tooling_wrapCommandWithTimeout(root, timeoutSec, systemRetryCmd)
        res = tooling_exec(root, systemRetryCmd)
        tooling_printExecOutput(res)
        rc = os.execCmdResultExitCode(res)
        retrySystemLinkUsed = true
    if rc != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: compile failed rc=" + intToStr(rc) +
                         " kind=" + tooling_exitKind(rc) + " stage0=" + stage0)
        return rc
    let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(outPath))
    tooling_printExecOutput(chmodRes)
    if os.execCmdResultExitCode(chmodRes) != 0:
        tooling_cleanupStage0Exec(stage0, stage0Exec)
        tooling_printErr("cheng_tooling: chmod failed: " + outPath)
        return 1
    tooling_cleanupStage0Exec(stage0, stage0Exec)
    tooling_printOut("compile_out=" + outPath)
    tooling_printOut("compile_driver=" + stage0)
    if releaseBuild:
        tooling_printOut("compile_driver_track=release_driver")
    else:
        tooling_printOut("compile_driver_track=dev_driver")
    tooling_printOut("compile_target=" + target)
    tooling_printOut("compile_linker=" + linker)
    tooling_printOut("compile_track=" + buildTrack)
    tooling_printOut("compile_profile=" + (releaseBuild ? "release_system_link_independent_driver" : "dev_fast_mem_exe"))
    if retrySafeUsed:
        tooling_printOut("compile_retry_safe=1")
    if retrySystemLinkUsed:
        tooling_printOut("compile_retry_system_link=1")
    if runAfter:
        let runRes: os.ExecCmdResult = tooling_exec(root, tooling_shellQuote(outPath))
        tooling_printExecOutput(runRes)
        return os.execCmdResultExitCode(runRes)
    return 0

fn tooling_cmdCompileFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var inPath: str = ""
    var outPath: str = ""
    var outName: str = ""
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var linker: str = os.getEnvDefault("BACKEND_LINKER", "auto")
    var releaseBuild: bool = tooling_isTrue(os.getEnvDefault("CHENGC_RELEASE", "0"))
    var runAfter: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printCompileUsage()
            return 0
        if strutil.startsWith(arg, "--in:"):
            inPath = strings.dropPrefix(arg, "--in:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outName = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--linker:"):
            linker = strings.dropPrefix(arg, "--linker:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--release"):
            releaseBuild = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--dev"):
            releaseBuild = false
            i = i + 1
            continue
        if tooling_strEq(arg, "--run") || tooling_strEq(arg, "--run:host") || tooling_strEq(arg, "--run:file"):
            runAfter = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--emit:"):
            let emit: str = strings.dropPrefix(arg, "--emit:")
            if !tooling_strEq(emit, "exe"):
                tooling_printErr("cheng_tooling: compile only supports --emit:exe")
                return 1
            i = i + 1
            continue
        if strutil.startsWith(arg, "--frontend:"):
            let frontend: str = strings.dropPrefix(arg, "--frontend:")
            if !tooling_strEq(frontend, "stage1"):
                tooling_printErr("cheng_tooling: compile only supports --frontend:stage1")
                return 1
            i = i + 1
            continue
        if tooling_strEq(arg, "--orc") || strutil.startsWith(arg, "--mm:") ||
           tooling_strEq(arg, "--multi") || strutil.startsWith(arg, "--jobs:"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "--manifest:") || strutil.startsWith(arg, "--lock:") ||
           strutil.startsWith(arg, "--registry:") || strutil.startsWith(arg, "--package:") ||
           strutil.startsWith(arg, "--channel:") || strutil.startsWith(arg, "--lock-format:") ||
           strutil.startsWith(arg, "--meta-out:") || strutil.startsWith(arg, "--buildmeta:") ||
           strutil.startsWith(arg, "--pkg-cache:") || strutil.startsWith(arg, "--ledger:") ||
           strutil.startsWith(arg, "--source-listen:") || strutil.startsWith(arg, "--source-peer:") ||
           strutil.startsWith(arg, "--pkg-roots:") || tooling_strEq(arg, "--skip-pkg") ||
           tooling_strEq(arg, "--verify"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "-"):
            tooling_printErr("cheng_tooling: unknown compile arg: " + arg)
            return 1
        if !tooling_strNonEmpty(inPath):
            inPath = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unexpected positional arg: " + arg)
        return 1
    if !tooling_strNonEmpty(inPath):
        tooling_printErr("cheng_tooling: compile requires input file (use --in:<file.cheng>)")
        tooling_printCompileUsage()
        return 1
    return tooling_cmdCompileExe(root, inPath, outPath, outName, target, stage0, linker, releaseBuild, runAfter)

fn tooling_printBootstrapPureUsage() =
    tooling_printOut("bootstrap-pure options:")
    tooling_printOut("  --seed:<path>                stage0 backend driver path")
    tooling_printOut("  --stage0:<path>              alias of --seed")
    tooling_printOut("  --mode:fast|strict           bootstrap mode (default from SELF_OBJ_BOOTSTRAP_MODE, fallback fast)")
    tooling_printOut("  --compile-stage1             rebuild stage1 before stage2 alias copy")
    tooling_printOut("  --no-compile-stage1          default mode, stage1 aliases stage0")
    tooling_printOut("  --out-dir:<path>             bootstrap output directory")
    tooling_printOut("  --timing-out:<path>          timing tsv output path")
    tooling_printOut("  --fullspec                   run verify_fullchain_bootstrap after selfhost bootstrap")
    tooling_printOut("  note(strict): semantic/ownership checks are fixed enabled (skip_sem=0, skip_ownership=0)")

fn tooling_cmdBootstrapPureFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var mode: str = tooling_selfhostModeFromEnv("fast")
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "0"))
    var outDir: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_OUT_DIR", "")
    var timingOut: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMING_OUT", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var fullspec: bool = false
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printBootstrapPureUsage()
            return 0
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if tooling_strEq(arg, "--fullspec"):
            fullspec = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--mode:"):
            let parsedMode: str = tooling_selfhostModeNormalized(strings.dropPrefix(arg, "--mode:"))
            if !tooling_strNonEmpty(parsedMode):
                tooling_printErr("cheng_tooling: invalid bootstrap-pure mode (expected fast|strict): " + arg)
                return 1
            mode = parsedMode
            i = i + 1
            continue
        if strutil.startsWith(arg, "--seed:"):
            stage0 = strings.dropPrefix(arg, "--seed:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--timing-out:"):
            timingOut = strings.dropPrefix(arg, "--timing-out:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown bootstrap-pure arg: " + arg)
        return 1
    var res: ToolingSelfhostResult
    if tooling_strEq(mode, "strict"):
        compileStage1 = true
        res = tooling_selfhostBootstrapStrictHost(root, outDir, timingOut, stage0)
    else:
        res = tooling_selfhostBootstrapFastHost(root, compileStage1, outDir, timingOut, stage0)
    if res == nil || !res.ok:
        var msg: str = "unknown failure"
        if res != nil:
            msg = res.message
        tooling_printErr("cheng_tooling: bootstrap-pure failed: " + msg)
        if res != nil && tooling_strEq(mode, "strict"):
            if tooling_strNonEmpty(res.stage2Sha256):
                tooling_printErr("cheng_tooling: bootstrap-pure strict stage2_sha256=" + res.stage2Sha256)
            if tooling_strNonEmpty(res.stage3Sha256):
                tooling_printErr("cheng_tooling: bootstrap-pure strict stage3_sha256=" + res.stage3Sha256)
        return 1
    tooling_printOut("bootstrap_pure_mode=" + mode)
    tooling_printOut("bootstrap_pure_stage1=" + res.stage1Path)
    tooling_printOut("bootstrap_pure_stage2=" + res.stage2Path)
    tooling_printOut("bootstrap_pure_stage1_status=" + res.stage1Status)
    tooling_printOut("bootstrap_pure_stage1_compile_mode=" + res.stage1CompileMode)
    tooling_printOut("bootstrap_pure_stage1_rebuild_ok=" + tooling_boolText(res.stage1RebuildOk))
    if tooling_strEq(mode, "strict"):
        tooling_printOut("bootstrap_pure_stage3=" + res.stage3Path)
        tooling_printOut("bootstrap_pure_stage2_sha256=" + res.stage2Sha256)
        tooling_printOut("bootstrap_pure_stage3_sha256=" + res.stage3Sha256)
        tooling_printOut("bootstrap_pure_fixed_point_ok=" + tooling_boolText(res.fixedPointOk))
    tooling_printOut("bootstrap_pure_total_ms=" + intToStr(int32(res.totalMs)))
    if fullspec:
        let fullspecScriptPath: str = tooling_resolveScriptPath(root, "verify_fullchain_bootstrap")
        if !tooling_strNonEmpty(fullspecScriptPath):
            tooling_printErr("cheng_tooling: bootstrap-pure --fullspec missing verify_fullchain_bootstrap entry")
            return 1
        tooling_printOut("bootstrap_pure_fullspec=1")
        let fullspecRc: int32 = tooling_runScript(root, fullspecScriptPath, count + 1)
        if fullspecRc != 0:
            tooling_printErr("cheng_tooling: bootstrap-pure --fullspec failed rc=" + intToStr(fullspecRc))
            return fullspecRc
        tooling_printOut("bootstrap_pure_fullspec_ok=1")
    if tooling_isTrue(os.getEnvDefault("BOOTSTRAP_UPDATE_SEED", "0")):
        let seedOut: str = tooling_pathAbsolute(root, "artifacts/backend_seed/cheng.stage2")
        if !tooling_copyExecutable(root, res.stage2Path, seedOut):
            tooling_printErr("cheng_tooling: bootstrap-pure seed update failed: " + seedOut)
            return 1
        tooling_printOut("bootstrap_pure_seed_updated=" + seedOut)
    return 0

fn tooling_cmdDriverPathFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("driver-path options:")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            return 0
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown driver-path arg: " + arg)
        return 1
    return tooling_cmdDriverPath(root, stage0)

fn tooling_cmdBuildBackendDriverFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var outPath: str = os.getEnvDefault("BACKEND_LOCAL_DRIVER_REL", "artifacts/backend_driver/cheng")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var requireRebuild: bool = tooling_isTrue(os.getEnvDefault("BACKEND_BUILD_DRIVER_REQUIRE_REBUILD", "0"))
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("build-backend-driver options:")
            tooling_printOut("  --out:<path>                 output path")
            tooling_printOut("  --name:<path>                legacy alias of --out")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            tooling_printOut("  --target:<triple>            explicit backend target")
            tooling_printOut("  --require-rebuild            fail if stage0 reuse happens")
            tooling_printOut("  --require-rebuild:0|1        explicit require-rebuild toggle")
            tooling_printOut("  --full-rebuild[[:0|1]]       compatibility no-op (build-backend-driver is full-only)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_LINKER=self|system (default self)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_AUTO_CLEAN_HISTORY=1|0 (default 1)")
            tooling_printOut("  env: BUILD_DRIVER_STRICT_NATIVE=1|0 (default 1)")
            tooling_printOut("  env: BUILD_DRIVER_ALLOW_FALLBACK (removed; fallback path hard-disabled)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE=1|0 (default 0)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_SEGFAULT_RESCUE_STAGE0=<path> (optional override)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_REBUILD_CRASH_RETRY_SAFE=1|0 (default 0)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_REBUILD_CRASH_RETRY_MAX=0..2 (default 1 when retry enabled)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_REBUILD_JOBS=<N> (default auto: 2 on multicore, 1 on single-core)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_REBUILD_TIMEOUT=180 (full-only)")
            tooling_printOut("  env: BACKEND_BUILD_DRIVER_PROFILE_MODE=backend|safe|stage1_uir|full (default backend)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_PROFILE_FAIL_OPEN=1|0 (default 1; auto-disable profile flags on segfault)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_REBUILD_STAMP_CACHE=1|0 (default 1; full-only)")
            tooling_printOut("       BACKEND_BUILD_DRIVER_REBUILD_STAMP_IGNORE_STAGE0_SHA=1|0 (tight profile default 1)")
            tooling_printOut("  env: TOOLING_STAGE0_HARD_BLOCK_ON_UE=1|0 (default 1)")
            tooling_printOut("       TOOLING_STAGE0_ALLOW_UE_OVERRIDE=1|0 (default 0; emergency only)")
            tooling_printOut("       SELFHOST_STAGE1_STAMP_HIT_FAST_SANITY=1|0 (default 1; selfhost compile-stage1 only)")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outPath = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--require-rebuild"):
            requireRebuild = true
            i = i + 1
            continue
        if strutil.startsWith(arg, "--require-rebuild:"):
            requireRebuild = tooling_isTrue(strings.dropPrefix(arg, "--require-rebuild:"))
            i = i + 1
            continue
        if tooling_strEq(arg, "--full-rebuild"):
            i = i + 1
            continue
        if strutil.startsWith(arg, "--full-rebuild:"):
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown build-backend-driver arg: " + arg)
        return 1
    return tooling_cmdBuildBackendDriver(root, outPath, stage0, target, requireRebuild)

fn tooling_cmdBuildReleaseDriverFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var outPath: str = tooling_releaseDriverPath(root)
    var stage0: str = os.getEnvDefault("BACKEND_RELEASE_DRIVER_STAGE0", "")
    var target: str = os.getEnvDefault("BACKEND_TARGET", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("build-release-driver options:")
            tooling_printOut("  --out:<path>                 output path (default BACKEND_RELEASE_DRIVER or artifacts/backend_release_driver/cheng)")
            tooling_printOut("  --name:<path>                legacy alias of --out")
            tooling_printOut("  --stage0:<path>              explicit stage0 driver path")
            tooling_printOut("  --target:<triple>            explicit backend target")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER=<path>          release driver location")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER_STAGE0=<path>   build stage0 override")
            tooling_printOut("  env: BACKEND_RELEASE_DRIVER_TIMEOUT=60      compile timeout")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outPath = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--name:"):
            outPath = strings.dropPrefix(arg, "--name:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--target:"):
            target = strings.dropPrefix(arg, "--target:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown build-release-driver arg: " + arg)
        return 1
    return tooling_buildReleaseDriver(root, outPath, stage0, target)

fn tooling_cmdSelfhostBootstrapFastHostFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "1"))
    var outDir: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_OUT_DIR", "")
    var timingOut: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMING_OUT", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("selfhost-bootstrap-fast-host options:")
            tooling_printOut("  --compile-stage1|--no-compile-stage1")
            tooling_printOut("  --out-dir:<path>")
            tooling_printOut("  --timing-out:<path>")
            tooling_printOut("  --stage0:<path>")
            tooling_printOut("  env: SELFHOST_STAGE1_FULL_REBUILD=1|0 (strict default 1)")
            tooling_printOut("  env: SELFHOST_STRICT_REBUILD=1|0 (default 1)")
            return 0
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--timing-out:"):
            timingOut = strings.dropPrefix(arg, "--timing-out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown selfhost-bootstrap-fast-host arg: " + arg)
        return 1
    return tooling_cmdSelfhostBootstrapFastHost(root, compileStage1, outDir, timingOut, stage0)

fn tooling_printSelfhostBootstrapVerifyUsage() =
    tooling_printOut("verify_backend_selfhost_bootstrap_self_obj options:")
    tooling_printOut("  --mode:fast|strict           default from SELF_OBJ_BOOTSTRAP_MODE=fast")
    tooling_printOut("  --compile-stage1|--no-compile-stage1   (fast mode only)")
    tooling_printOut("  --out-dir:<path>")
    tooling_printOut("  --timing-out:<path>")
    tooling_printOut("  --stage0:<path>")
    tooling_printOut("  env: SELF_OBJ_BOOTSTRAP_STRICT_DIAG_ALLOW_MISMATCH=0|1 (strict mismatch policy)")
    tooling_printOut("  env: SELF_OBJ_BOOTSTRAP_STRICT_FORCE_PROBE=0|1 (strict full-build probe, default 0)")
    tooling_printOut("  note: strict mode enforces skip_sem=0 and skip_ownership=0")

fn tooling_cmdSelfhostBootstrapVerifyFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var mode: str = tooling_selfhostModeFromEnv("fast")
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "1"))
    var outDir: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_OUT_DIR", "")
    var timingOut: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_TIMING_OUT", "")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printSelfhostBootstrapVerifyUsage()
            return 0
        if strutil.startsWith(arg, "--mode:"):
            let parsedMode: str = tooling_selfhostModeNormalized(strings.dropPrefix(arg, "--mode:"))
            if !tooling_strNonEmpty(parsedMode):
                tooling_printErr("cheng_tooling: invalid verify_backend_selfhost_bootstrap_self_obj mode: " + arg)
                return 1
            mode = parsedMode
            i = i + 1
            continue
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--timing-out:"):
            timingOut = strings.dropPrefix(arg, "--timing-out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown verify_backend_selfhost_bootstrap_self_obj arg: " + arg)
        return 1

    var res: ToolingSelfhostResult
    if tooling_strEq(mode, "strict"):
        compileStage1 = true
        res = tooling_selfhostBootstrapStrictHost(root, outDir, timingOut, stage0)
    else:
        res = tooling_selfhostBootstrapFastHost(root, compileStage1, outDir, timingOut, stage0)
    if res == nil || !res.ok:
        var msg: str = "unknown failure"
        if res != nil:
            msg = res.message
        tooling_printErr("cheng_tooling: verify_backend_selfhost_bootstrap_self_obj failed: " + msg)
        if res != nil && tooling_strEq(mode, "strict"):
            if tooling_strNonEmpty(res.stage2Sha256):
                tooling_printErr("cheng_tooling: stage2_sha256=" + res.stage2Sha256)
            if tooling_strNonEmpty(res.stage3Sha256):
                tooling_printErr("cheng_tooling: stage3_sha256=" + res.stage3Sha256)
        return 1
    tooling_printOut("selfhost_bootstrap_mode=" + mode)
    tooling_printOut("selfhost_bootstrap_stage1=" + res.stage1Path)
    tooling_printOut("selfhost_bootstrap_stage2=" + res.stage2Path)
    tooling_printOut("selfhost_bootstrap_stage0=" + res.stage0Path)
    tooling_printOut("selfhost_bootstrap_stage0_driver_kind=" + res.stage0DriverKind)
    tooling_printOut("selfhost_bootstrap_stage1_status=" + res.stage1Status)
    tooling_printOut("selfhost_bootstrap_stage1_compile_mode=" + res.stage1CompileMode)
    tooling_printOut("selfhost_bootstrap_stage1_rebuild_ok=" + tooling_boolText(res.stage1RebuildOk))
    tooling_printOut("selfhost_bootstrap_fallback_used=" + tooling_boolText(res.fallbackUsed))
    tooling_printOut("selfhost_bootstrap_quarantine_cleaned=" + intToStr(res.quarantineCleaned))
    tooling_printOut("selfhost_bootstrap_lock_wait_ms=" + intToStr(res.lockWaitMs))
    tooling_printOut("selfhost_bootstrap_strict_rebuild_ok=" + tooling_boolText(res.strictRebuildOk))
    if tooling_strEq(mode, "strict"):
        tooling_printOut("selfhost_bootstrap_stage3=" + res.stage3Path)
        tooling_printOut("selfhost_bootstrap_stage2_sha256=" + res.stage2Sha256)
        tooling_printOut("selfhost_bootstrap_stage3_sha256=" + res.stage3Sha256)
        tooling_printOut("selfhost_bootstrap_fixed_point_ok=" + tooling_boolText(res.fixedPointOk))
        tooling_printOut("stage2_sha256=" + res.stage2Sha256)
        tooling_printOut("stage3_sha256=" + res.stage3Sha256)
        tooling_printOut("fixed_point_ok=" + tooling_boolText(res.fixedPointOk))
    tooling_printOut("selfhost_bootstrap_total_ms=" + intToStr(int32(res.totalMs)))
    return 0

fn tooling_cmdSelfhost100msHostFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var hostOnly: str = os.getEnvDefault("SELFHOST_100MS_HOST_ONLY", "darwin_arm64")
    var itersRaw: str = os.getEnvDefault("SELFHOST_100MS_ITERS", "1")
    var p95Raw: str = os.getEnvDefault("SELFHOST_100MS_P95_MS", "100")
    var p99Raw: str = os.getEnvDefault("SELFHOST_100MS_P99_MS", "120")
    var enforceRaw: str = os.getEnvDefault("SELFHOST_100MS_ENFORCE_ON_HOST", "1")
    var reportRaw: str = os.getEnvDefault("SELFHOST_100MS_REPORT", "artifacts/backend_selfhost_100ms_host/report.tsv")
    var compileStage1: bool = tooling_isTrue(os.getEnvDefault("SELFHOST_NATIVE_COMPILE_STAGE1", "0"))
    var outDir: str = os.getEnvDefault("SELFHOST_100MS_OUT_DIR", "artifacts/backend_selfhost_100ms_host")
    var stage0: str = os.getEnvDefault("SELF_OBJ_BOOTSTRAP_STAGE0", "")
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("selfhost-100ms-host options:")
            tooling_printOut("  --iters:<N> --p95-ms:<ms> --p99-ms:<ms>")
            tooling_printOut("  --host-only:<tag> --report:<path> --enforce:0|1")
            tooling_printOut("  --compile-stage1|--no-compile-stage1 --out-dir:<path> --stage0:<path>")
            tooling_printOut("  env: SELFHOST_STAGE1_FULL_REBUILD=1|0 (strict default 1)")
            tooling_printOut("       SELFHOST_STRICT_REBUILD=1|0 (default 1)")
            tooling_printOut("       SELFHOST_100MS_ENFORCE_WITH_COMPILE_STAGE1=1|0 (default 1)")
            tooling_printOut("       SELFHOST_100MS_PREWARM_STAGE1=1|0 (default 1 when --compile-stage1 && iters>1)")
            return 0
        if strutil.startsWith(arg, "--host-only:"):
            hostOnly = strings.dropPrefix(arg, "--host-only:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--iters:"):
            itersRaw = strings.dropPrefix(arg, "--iters:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--p95-ms:"):
            p95Raw = strings.dropPrefix(arg, "--p95-ms:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--p99-ms:"):
            p99Raw = strings.dropPrefix(arg, "--p99-ms:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--enforce:"):
            enforceRaw = strings.dropPrefix(arg, "--enforce:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--report:"):
            reportRaw = strings.dropPrefix(arg, "--report:")
            i = i + 1
            continue
        if tooling_strEq(arg, "--compile-stage1"):
            compileStage1 = true
            i = i + 1
            continue
        if tooling_strEq(arg, "--no-compile-stage1"):
            compileStage1 = false
            i = i + 1
            continue
        if strutil.startsWith(arg, "--out-dir:"):
            outDir = strings.dropPrefix(arg, "--out-dir:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "--stage0:"):
            stage0 = strings.dropPrefix(arg, "--stage0:")
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown selfhost-100ms-host arg: " + arg)
        return 1
    return tooling_cmdSelfhost100msHost(root, hostOnly, itersRaw, p95Raw, p99Raw, enforceRaw, reportRaw,
                                        compileStage1, outDir, stage0)

fn tooling_cmdSyncGlobalDeprecated(): int32 =
    tooling_printErr("cheng_tooling: sync-global removed; use `build-global --out:artifacts/tooling_cmd/cheng_tooling`")
    return 2

fn tooling_normalizeScriptId(rawName: str): str =
    var name: str = strutil.strip(rawName)
    if !tooling_strNonEmpty(name):
        return ""
    if strutil.startsWith(name, "src/tooling/"):
        name = strings.dropPrefix(name, "src/tooling/")
    name = tooling_stripShSuffix(name)
    if !tooling_isSafeScriptName(name):
        return ""
    return name

fn tooling_selectorContains(selector: str, id: str): bool =
    if !tooling_strNonEmpty(selector) || !tooling_strNonEmpty(id):
        return false
    return strutil.contains(selector, "," + id + ",")

fn tooling_selectorAppend(selector: str, id: str): str =
    if !tooling_strNonEmpty(id):
        return selector
    let token: str = "," + id + ","
    if strutil.contains(selector, token):
        return selector
    return selector + token

fn tooling_normalizeLinkMode(raw: str): str =
    let text: str = strutil.toLowerAscii(strutil.strip(raw))
    if tooling_strEq(text, "symlink") || tooling_strEq(text, "hardlink") || tooling_strEq(text, "copy"):
        return text
    return ""

fn tooling_idsContains(ids: str[], id: str): bool =
    for i in 0..<ids.len:
        if tooling_strEq(ids[i], id):
            return true
    return false

fn tooling_installLinks(root: str, binPathRaw: str, dirRaw: str, manifestRaw: str, force: bool, onlySelector: str, excludeSelector: str, modeRaw: str): int32 =
    let outDir: str = tooling_pathAbsolute(root, dirRaw)
    if !tooling_strNonEmpty(outDir):
        tooling_printErr("cheng_tooling: install requires --dir:<path>")
        return 1
    let binPath: str = tooling_pathAbsolute(root, binPathRaw)
    if !tooling_strNonEmpty(binPath):
        tooling_printErr("cheng_tooling: install requires --bin:<path> (or runnable absolute program name)")
        return 1
    if !tooling_pathExists(binPath):
        tooling_printErr("cheng_tooling: install binary not found: " + binPath)
        return 1
    let mode: str = tooling_normalizeLinkMode(modeRaw)
    if !tooling_strNonEmpty(mode):
        tooling_printErr("cheng_tooling: invalid --mode (expected symlink|hardlink|copy): " + modeRaw)
        return 1
    if !tooling_mkdirP(root, outDir):
        tooling_printErr("cheng_tooling: failed to create install dir: " + outDir)
        return 1

    var ids: str[] = tooling_collectScripts(root)
    if ids.len == 0:
        tooling_printErr("cheng_tooling: no scripts found under src/tooling")
        return 1
    if !tooling_isSafeScriptName("cheng_tooling"):
        return 1
    if !tooling_idsContains(ids, "cheng_tooling"):
        add(ids, "cheng_tooling")

    var manifest: str = "name\tlink\n"
    var selectedCount: int32 = 0
    var failCount: int32 = 0
    for i in 0..<ids.len:
        let name: str = ids[i]
        if tooling_strNonEmpty(onlySelector) && !tooling_selectorContains(onlySelector, name):
            continue
        if tooling_selectorContains(excludeSelector, name):
            continue
        selectedCount = selectedCount + 1
        let linkPath: str = os.joinPath(outDir, name)
        if !force && tooling_pathExists(linkPath):
            manifest = manifest + name + "\t" + linkPath + "\n"
            continue
        var cmd: str = ""
        if tooling_strEq(mode, "copy"):
            if force:
                cmd = "cp -f " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "cp " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        elif tooling_strEq(mode, "hardlink"):
            if force:
                cmd = "ln -f " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "ln " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        else:
            if force:
                cmd = "ln -sf " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
            else:
                cmd = "ln -s " + tooling_shellQuote(binPath) + " " + tooling_shellQuote(linkPath)
        let result: os.ExecCmdResult = tooling_exec(root, cmd)
        let rc: int32 = os.execCmdResultExitCode(result)
        if rc == 0:
            manifest = manifest + name + "\t" + linkPath + "\n"
            continue
        failCount = failCount + 1
        tooling_printErr("cheng_tooling: link failed: " + name + " -> " + linkPath)
        tooling_printExecOutput(result)
    if selectedCount <= 0:
        tooling_printErr("cheng_tooling: install selection is empty (adjust --only/--exclude)")
        return 1
    if tooling_strNonEmpty(manifestRaw):
        let manifestPath: str = tooling_pathAbsolute(root, manifestRaw)
        if tooling_strNonEmpty(manifestPath):
            os.writeFile(manifestPath, manifest)
            tooling_printOut("install_manifest=" + manifestPath)
    tooling_printOut("install_dir=" + outDir)
    tooling_printOut("install_bin=" + binPath)
    tooling_printOut("install_mode=" + mode)
    if failCount > 0:
        return 1
    return 0

fn tooling_bundle(root: str, outDirRaw: str, linkerRaw: str, driverRaw: str, profileSelectorRaw: str, modeRaw: str, force: bool): int32 =
    var profileSelector: str = profileSelectorRaw
    if !tooling_strNonEmpty(profileSelector):
        profileSelector = tooling_selectorAppend(profileSelector, "full")
    let mode: str = tooling_normalizeLinkMode(modeRaw)
    if !tooling_strNonEmpty(mode):
        tooling_printErr("cheng_tooling: invalid bundle --mode (expected symlink|hardlink|copy): " + modeRaw)
        return 1
    let outDir: str = tooling_pathAbsolute(root, outDirRaw)
    if !tooling_strNonEmpty(outDir):
        tooling_printErr("cheng_tooling: bundle requires --out-dir:<path>")
        return 1
    if !tooling_mkdirP(root, outDir):
        tooling_printErr("cheng_tooling: failed to create bundle out dir: " + outDir)
        return 1
    if !tooling_selectorContains(profileSelector, "full"):
        tooling_printErr("cheng_tooling: bundle profile set is empty (allowed: full)")
        return 1
    let profileDir: str = os.joinPath(outDir, "full")
    let binPath: str = os.joinPath(profileDir, "cheng_tooling")
    let linksDir: str = os.joinPath(profileDir, "bin")
    let manifestPath: str = os.joinPath(profileDir, "manifest.tsv")
    let buildRc: int32 = tooling_buildGlobal(root, binPath, linkerRaw, driverRaw)
    if buildRc != 0:
        return buildRc
    let installRc: int32 = tooling_installLinks(root, binPath, linksDir, manifestPath, force, "", "", mode)
    if installRc != 0:
        return installRc
    tooling_printOut("bundle_profile=full")
    tooling_printOut("bundle_profile_bin=" + binPath)
    tooling_printOut("bundle_profile_links=" + linksDir)
    tooling_printOut("bundle_profile_manifest=" + manifestPath)
    return 0

fn tooling_resolveBuildDriver(root: str, driverRaw: str): str =
    let explicitRaw: str = strutil.strip(driverRaw)
    if tooling_strNonEmpty(explicitRaw):
        return tooling_resolveStage0DriverStrict(root, explicitRaw)
    return tooling_resolveStage0DriverStrict(root, "")

fn tooling_buildGlobal(root: str, outRaw: str, linkerRaw: str, driverRaw: str): int32 =
    let src: str = os.joinPath(root, "src/tooling/cheng_tooling.cheng")
    if !os.fileExists(src):
        tooling_printErr("cheng_tooling: source not found: " + src)
        return 1
    let outPath: str = tooling_pathAbsolute(root, outRaw)
    if !tooling_strNonEmpty(outPath):
        tooling_printErr("cheng_tooling: build-global requires --out:<path>")
        return 1
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    let linker: str = strutil.strip(linkerRaw)
    if !tooling_strEq(linker, "self") && !tooling_strEq(linker, "system"):
        tooling_printErr("cheng_tooling: invalid --linker (expected self|system): " + linker)
        return 1
    let driverPath: str = tooling_resolveBuildDriver(root, driverRaw)
    if !tooling_strNonEmpty(driverPath):
        if tooling_strNonEmpty(driverRaw):
            tooling_printErr("cheng_tooling: --driver not found: " + driverRaw)
        else:
            tooling_printErr("cheng_tooling: failed to resolve build driver (set --driver:<path>)")
        return 1
    let stage0Exec: str = tooling_prepareStage0Exec(root, driverPath, "build_global")
    if !tooling_strNonEmpty(stage0Exec):
        tooling_printErr("cheng_tooling: build-global stage0 prepare failed: " + driverPath)
        return 1
    if !tooling_stage0PreflightOk(root, stage0Exec):
        tooling_cleanupStage0Exec(driverPath, stage0Exec)
        tooling_printErr("cheng_tooling: build-global stage0 preflight failed: " + driverPath)
        return 1
    let inheritedTarget: str = strutil.strip(os.getEnvDefault("BACKEND_TARGET", ""))
    var target: str = inheritedTarget
    if !tooling_strNonEmpty(target):
        target = tooling_detectHostTarget(root)
    if !tooling_strNonEmpty(target):
        target = "auto"
    let releaseCflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_CFLAGS", "-O3 -flto"))
    let releaseLdflagsRaw: str = strutil.strip(os.getEnvDefault("BACKEND_RELEASE_LDFLAGS", releaseCflagsRaw))
    let crashMemoEnabled: bool = tooling_isTrue(os.getEnvDefault("TOOLING_BUILD_GLOBAL_CRASH_MEMO", "1"))
    let safeFirstDefault: bool = tooling_isTrue(os.getEnvDefault("TOOLING_BUILD_GLOBAL_SAFE_FIRST", "1"))
    let crashMemoPath: str = tooling_buildGlobalCrashMemoPath(root)
    let driverPathSha: str = tooling_sha256File(root, driverPath)
    let srcSha: str = tooling_sha256File(root, src)
    var safeFirstFromMemo: bool = safeFirstDefault
    if crashMemoEnabled:
        safeFirstFromMemo = safeFirstFromMemo ||
            tooling_buildGlobalSafeFromMemo(root, crashMemoPath, driverPath, src, target, linker, driverPathSha, srcSha)
    var runtimeObj: str = ""
    if tooling_strEq(linker, "self"):
        runtimeObj = tooling_runtimeObjPath(root, target)
        if !os.fileExists(runtimeObj):
            runtimeObj = tooling_prepareRuntimeObjForTarget(root, stage0Exec, target)
        if !os.fileExists(runtimeObj):
            tooling_cleanupStage0Exec(driverPath, stage0Exec)
            tooling_printErr("cheng_tooling: build-global missing runtime object for self-link: " + runtimeObj)
            return 1
    var timeoutSec: int32 = tooling_parseInt32Default(os.getEnvDefault("TOOLING_BUILD_GLOBAL_TIMEOUT", ""), 60)
    if timeoutSec < 1:
        timeoutSec = 60
    let crashRetrySafe: bool = tooling_isTrue(os.getEnvDefault("TOOLING_BUILD_GLOBAL_CRASH_RETRY_SAFE", "1"))
    var retryUsed: bool = false
    var compileOptLevel: str = "3"
    var compileBackendOpt: str = "1"
    var compileBackendOpt2: str = "1"
    var compileCflagsRaw: str = releaseCflagsRaw
    var compileLdflagsRaw: str = releaseLdflagsRaw
    var finalRc: int32 = 1
    tooling_printOut("build_global_driver=" + driverPath)
    tooling_printOut("build_global_driver_exec=" + stage0Exec)
    tooling_printOut("build_global_linker=" + linker)
    tooling_printOut("build_global_out=" + outPath)
    if safeFirstFromMemo:
        compileOptLevel = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_OPT_LEVEL", "0"))
        if !tooling_strNonEmpty(compileOptLevel):
            compileOptLevel = "2"
        compileBackendOpt = tooling_bool01Normalized(
            os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_BACKEND_OPT", "0"))
        if !tooling_strNonEmpty(compileBackendOpt):
            compileBackendOpt = "0"
        compileBackendOpt2 = tooling_bool01Normalized(
            os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_BACKEND_OPT2", "0"))
        if !tooling_strNonEmpty(compileBackendOpt2):
            compileBackendOpt2 = "0"
        compileCflagsRaw = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_CFLAGS", "-O0"))
        compileLdflagsRaw = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_LDFLAGS", compileCflagsRaw))
        tooling_printOut("build_global_safe_first=1")
    for attempt in 0..<2:
        if attempt > 0 && (safeFirstFromMemo || !crashRetrySafe || !retryUsed):
            break
        var cmd: str = ""
        cmd = cmd + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS", "0")
        cmd = cmd + tooling_envAssignCompat("STAGE1_STD_NO_POINTERS_STRICT", "0")
        cmd = cmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI", "0")
        cmd = cmd + tooling_envAssignCompat("STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_BUILD_TRACK", "release")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKER", linker)
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_DEV_PROFILE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_STAGE1_PARSE_MODE", "full")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FN_SCHED", "serial")
        cmd = cmd + tooling_envAssignCompat("BACKEND_DIRECT_EXE", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_LINKERLESS_INMEM", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_FAST_FALLBACK_ALLOW", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INCREMENTAL", "0")
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT", compileBackendOpt)
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT2", compileBackendOpt2)
        cmd = cmd + tooling_envAssignCompat("BACKEND_OPT_LEVEL", compileOptLevel)
        if tooling_strNonEmpty(compileCflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_CFLAGS", compileCflagsRaw)
        if tooling_strNonEmpty(compileLdflagsRaw):
            cmd = cmd + tooling_envAssignCompat("BACKEND_LDFLAGS", compileLdflagsRaw)
        cmd = cmd + tooling_envAssignCompat("BACKEND_DRIVER", stage0Exec)
        cmd = cmd + tooling_envAssignCompat("ABI", "v2_noptr")
        cmd = cmd + tooling_envAssignCompat("BACKEND_EMIT", "exe")
        cmd = cmd + tooling_envAssignCompat("BACKEND_INPUT", src)
        cmd = cmd + tooling_envAssignCompat("BACKEND_OUTPUT", outPath)
        cmd = cmd + tooling_envAssignCompat("BACKEND_TARGET", target)
        if tooling_strEq(linker, "self"):
            cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "1")
            cmd = cmd + tooling_envAssignCompat("BACKEND_RUNTIME_OBJ", runtimeObj)
        else:
            cmd = cmd + tooling_envAssignCompat("BACKEND_NO_RUNTIME_C", "0")
        cmd = cmd + tooling_shellQuote(stage0Exec)
        cmd = tooling_prefixUnsetLegacyFrontendEnv(cmd)
        cmd = tooling_wrapStage0Lock(root, cmd, "build_global")
        cmd = tooling_wrapCommandWithTimeout(root, timeoutSec, cmd)
        let result: os.ExecCmdResult = tooling_exec(root, cmd)
        tooling_printExecOutput(result)
        finalRc = os.execCmdResultExitCode(result)
        if finalRc == 0:
            break
        if !crashRetrySafe || retryUsed || !tooling_isCrashExitCode(finalRc):
            break
        retryUsed = true
        compileOptLevel = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_OPT_LEVEL", "0"))
        if !tooling_strNonEmpty(compileOptLevel):
            compileOptLevel = "2"
        compileBackendOpt = tooling_bool01Normalized(
            os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_BACKEND_OPT", "0"))
        if !tooling_strNonEmpty(compileBackendOpt):
            compileBackendOpt = "0"
        compileBackendOpt2 = tooling_bool01Normalized(
            os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_BACKEND_OPT2", "0"))
        if !tooling_strNonEmpty(compileBackendOpt2):
            compileBackendOpt2 = "0"
        compileCflagsRaw = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_CFLAGS", "-O0"))
        compileLdflagsRaw = strutil.strip(os.getEnvDefault("TOOLING_BUILD_GLOBAL_RETRY_LDFLAGS", compileCflagsRaw))
        tooling_printErr("cheng_tooling: build-global crashed rc=" + intToStr(finalRc) +
                         " kind=" + tooling_exitKind(finalRc) +
                         "; retry safe profile opt=" + compileBackendOpt +
                         " opt2=" + compileBackendOpt2 +
                         " opt_level=" + compileOptLevel)
    tooling_cleanupStage0Exec(driverPath, stage0Exec)
    if crashMemoEnabled && tooling_strNonEmpty(driverPathSha) && tooling_strNonEmpty(srcSha):
        if finalRc == 0:
            tooling_buildGlobalWriteCrashMemo(root, crashMemoPath, driverPath, src, target, linker, driverPathSha, srcSha, retryUsed || safeFirstFromMemo)
        elif retryUsed:
            tooling_buildGlobalWriteCrashMemo(root, crashMemoPath, driverPath, src, target, linker, driverPathSha, srcSha, true)
    if retryUsed:
        tooling_printOut("build_global_retry=1")
    if finalRc != 0:
        return finalRc
    return 0

fn tooling_cmdBuildBackendBaselines(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"; " +
        "\"$tool\" build_backend_rawptr_contract; " +
        "\"$tool\" build_backend_mem_contract; " +
        "\"$tool\" build_backend_dod_contract; " +
        "\"$tool\" build_backend_native_contract; " +
        "\"$tool\" build_backend_profile_schema; " +
        "\"$tool\" build_backend_profile_baseline; " +
        "echo \"build_backend_baselines ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_printUsage() =
    tooling_printOut("usage: cheng_tooling <command> [args]")
    tooling_printOut("")
    tooling_printOut("commands:")
    tooling_printOut("  driver-path [--stage0:<path>]")
    tooling_printOut("      resolve stable stage0 backend driver path (zero-script)")
    tooling_printOut("  build-backend-driver [--out:<path>] [--stage0:<path>] [--target:<triple>] [--require-rebuild]")
    tooling_printOut("      build artifacts/backend_driver/cheng via native fast host path (zero-script)")
    tooling_printOut("  build-release-driver [--out:<path>] [--stage0:<path>] [--target:<triple>]")
    tooling_printOut("      build independent release driver (UIR + system-link) at artifacts/backend_release_driver/cheng")
    tooling_printOut("  cleanup-backend-driver-history [--dry-run]")
    tooling_printOut("      remove historical artifacts/backend_driver/cheng* variants, keep canonical driver")
    tooling_printOut("  build-backend-baselines")
    tooling_printOut("      rebuild all backend contract/profile baselines in one call")
    tooling_printOut("  selfhost-bootstrap-fast-host [--compile-stage1|--no-compile-stage1] [--out-dir:<path>] [--timing-out:<path>] [--stage0:<path>]")
    tooling_printOut("      host-only fast selfhost bootstrap without shell script orchestration")
    tooling_printOut("  verify_backend_selfhost_bootstrap_self_obj [--mode:fast|strict] [--compile-stage1|--no-compile-stage1] [--out-dir:<path>] [--timing-out:<path>] [--stage0:<path>]")
    tooling_printOut("      native selfhost bootstrap verifier (strict enforces SHA256(stage2)==SHA256(stage3))")
    tooling_printOut("  selfhost-100ms-host [--iters:<N>] [--p95-ms:<ms>] [--p99-ms:<ms>] [--host-only:<tag>] [--report:<path>] [--enforce:0|1]")
    tooling_printOut("      host-only 100ms gate using native selfhost bootstrap path")
    tooling_printOut("  verify_backend_cdrop_emergency")
    tooling_printOut("      emergency C-Drop gate (manifest hash + clang seed + strict selfhost)")
    tooling_printOut("  verify_backend_opt2_impl_surface")
    tooling_printOut("      verify opt2 implementation surface (no placeholder return false + NJVL/SSU defaults)")
    tooling_printOut("  verify_backend_rawptr_migration")
    tooling_printOut("      verify raw-pointer migration gate is wired via native subcommands")
    tooling_printOut("  compile --in:<file.cheng> [--out:<path>|--name:<name>] [--target:<triple>] [--stage0:<path>] [--linker:self|system] [--release] [--run]")
    tooling_printOut("      zero-script compiler entrypoint (emit=exe, frontend=stage1)")
    tooling_printOut("  cheng <file.cheng> [compile args]")
    tooling_printOut("      alias of compile (single-entry naming)")
    tooling_printOut("  bootstrap-pure [--seed:<path>] [--mode:fast|strict] [--compile-stage1|--no-compile-stage1] [--fullspec]")
    tooling_printOut("      zero-script pure selfhost bootstrap path")
    tooling_printOut("  bootstrap")
    tooling_printOut("      alias of bootstrap-pure")
    tooling_printOut("  list")
    tooling_printOut("      list all runnable tooling command IDs embedded in cheng_tooling")
    tooling_printOut("  embedded-ids")
    tooling_printOut("      alias of list (internal/native embed introspection)")
    tooling_printOut("  embedded-text --id:<script> | embedded-text <script>")
    tooling_printOut("      print embedded script payload text (internal/native embed introspection)")
    tooling_printOut("  embedded-map-rewrite [--out:<path>] [map_path] [out_path]")
    tooling_printOut("      rewrite embedded map as canonical Cheng source (native, no python)")
    tooling_printOut("  run <script> [args...]")
    tooling_printOut("      run script by name, for example: run backend_prod_closure --help")
    tooling_printOut("  install --dir:<path> [--bin:<path>] [--manifest:<path>] [--mode:symlink|hardlink|copy] [--force] [--only:<script>] [--exclude:<script>]")
    tooling_printOut("      install multicall links (one global binary drives all tooling script IDs)")
    tooling_printOut("  build-global [--out:<path>] [--linker:self|system] [--driver:<path>]")
    tooling_printOut("      build cheng_tooling as global native binary (default linker=system)")
    tooling_printOut("  bundle [--out-dir:<path>] [--profile:full]... [--mode:symlink|hardlink|copy] [--linker:self|system] [--driver:<path>] [--force]")
    tooling_printOut("      build and install one or more global binaries by profile")
    tooling_printOut("  <script> [args...]")
    tooling_printOut("      shorthand for `run <script> [args...]`")
    tooling_printOut("")
    tooling_printOut("notes:")
    tooling_printOut("  - script can be `name` (or legacy `name.sh`, normalized to `name`).")
    tooling_printOut("  - all args after script are passed through as-is.")
    tooling_printOut("  - install filter flags are repeatable; --only narrows selection and --exclude removes from it.")
    tooling_printOut("  - multicall mode: if argv0 is a script ID (for example backend_prod_closure),")
    tooling_printOut("    cheng_tooling will dispatch to the embedded script payload for <id>.")
    tooling_printOut("  - recommended global install:")
    tooling_printOut("      cheng_tooling build-global --out:artifacts/tooling_cmd/cheng_tooling --linker:system")
    tooling_printOut("      artifacts/tooling_cmd/cheng_tooling install --dir:artifacts/tooling_cmd/bin --bin:artifacts/tooling_cmd/cheng_tooling --force")
    tooling_printOut("  - bundle profiles:")
    tooling_printOut("      full: all embedded tooling command IDs")

fn tooling_list(root: str): int32 =
    let out: str[] = tooling_collectScripts(root)
    if out.len == 0:
        tooling_printErr("cheng_tooling: no embedded tooling scripts registered")
        return 1
    for i in 0..<out.len:
        tooling_printOut(out[i])
    return 0

fn tooling_embeddedTextCommand(root: str, argStart: int32, count: int32): int32 =
    var scriptId: str = ""
    var i: int32 = argStart
    for _ in argStart..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("usage: cheng_tooling embedded-text --id:<script-id>")
            tooling_printOut("   or: cheng_tooling embedded-text <script-id>")
            return 0
        if strutil.startsWith(arg, "--id:"):
            scriptId = strings.dropPrefix(arg, "--id:")
            i = i + 1
            continue
        if !tooling_strNonEmpty(scriptId):
            scriptId = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: unknown embedded-text arg: " + arg)
        return 1
    let normalizedId: str = tooling_normalizeScriptId(scriptId)
    if !tooling_strNonEmpty(normalizedId):
        tooling_printErr("cheng_tooling: embedded-text requires --id:<script-id>")
        return 1
    if tooling_strEq(normalizedId, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    let scriptText: str = tooling_embeddedScriptText(root, normalizedId)
    if !tooling_strNonEmpty(scriptText):
        tooling_printErr("cheng_tooling: embedded-text script not found: " + normalizedId)
        return 1
    os.write(os.get_stdout(), scriptText)
    return 0

fn tooling_embeddedMapRewriteCommand(root: str, argStart: int32, count: int32): int32 =
    var outPath: str = os.joinPath(root, "src/tooling/cheng_tooling_embedded_inline.cheng")
    var outFromFlag: str = ""
    var positionalA: str = ""
    var positionalB: str = ""
    var i: int32 = argStart
    for _ in argStart..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("usage: cheng_tooling embedded-map-rewrite [--out:<path>] [map_path] [out_path]")
            tooling_printOut("   or: cheng_tooling rewrite-map [map_path] [out_path]")
            return 0
        if strutil.startsWith(arg, "--out:"):
            outFromFlag = strings.dropPrefix(arg, "--out:")
            i = i + 1
            continue
        if strutil.startsWith(arg, "-"):
            tooling_printErr("cheng_tooling: unknown embedded-map-rewrite arg: " + arg)
            return 1
        if !tooling_strNonEmpty(positionalA):
            positionalA = arg
            i = i + 1
            continue
        if !tooling_strNonEmpty(positionalB):
            positionalB = arg
            i = i + 1
            continue
        tooling_printErr("cheng_tooling: too many positional args for embedded-map-rewrite")
        return 1
    if tooling_strNonEmpty(outFromFlag):
        outPath = tooling_pathAbsolute(root, outFromFlag)
    elif tooling_strNonEmpty(positionalB):
        # Compatibility with old `rewrite-map <map_path> <out_path>` CLI.
        outPath = tooling_pathAbsolute(root, positionalB)
    elif tooling_strNonEmpty(positionalA):
        # Compatibility with old `rewrite-map <map_path>` in-place rewrite.
        outPath = tooling_pathAbsolute(root, positionalA)
    else:
        outPath = tooling_pathAbsolute(root, outPath)
    let outDir: str = os.parentDir(outPath)
    if tooling_strNonEmpty(outDir):
        if !tooling_mkdirP(root, outDir):
            tooling_printErr("cheng_tooling: failed to create output dir: " + outDir)
            return 1
    let rendered: str = tooling_renderEmbeddedMapText(root)
    os.writeFile(outPath, rendered)
    let renderedIds: str[] = tooling_collectScripts(root)
    tooling_printOut("embedded_map_rewrite_out=" + outPath)
    tooling_printOut("embedded_map_rewrite_count=" + intToStr(renderedIds.len))
    return 0

fn tooling_cmdVerifyBackendCdropEmergency(root: str): int32 =
    let cdropDir: str = tooling_pathAbsolute(root, "bootstrap/cdrop")
    let bootCPath: str = os.joinPath(cdropDir, "cheng_boot.c")
    let manifestPath: str = os.joinPath(cdropDir, "manifest.toml")
    if !os.fileExists(bootCPath):
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency missing file: " + bootCPath)
        return 1
    if !os.fileExists(manifestPath):
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency missing file: " + manifestPath)
        return 1

    let parseCmd: str =
        "awk -F '=' '/^[[:space:]]*sha256[[:space:]]*=/{v=$2; gsub(/[[:space:]\\\"\\047]/,\"\",v); print v; exit}' " +
        tooling_shellQuote(manifestPath)
    let parseRes: os.ExecCmdResult = tooling_exec(root, parseCmd)
    if os.execCmdResultExitCode(parseRes) != 0:
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency failed to parse manifest sha256")
        tooling_printExecOutput(parseRes)
        return 1
    let manifestShaExpected: str = strutil.strip(os.execCmdResultOutput(parseRes))
    if !tooling_strNonEmpty(manifestShaExpected):
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency missing manifest sha256 key")
        return 1
    let manifestShaActual: str = tooling_sha256File(root, bootCPath)
    if !tooling_strNonEmpty(manifestShaActual):
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency requires SHA-256 tool (shasum or sha256sum)")
        return 1
    tooling_printOut("cdrop_manifest_sha256_expected=" + manifestShaExpected)
    tooling_printOut("cdrop_manifest_sha256_actual=" + manifestShaActual)
    if !tooling_strEq(manifestShaExpected, manifestShaActual):
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency manifest hash mismatch")
        tooling_printErr("cheng_tooling: expected=" + manifestShaExpected + " actual=" + manifestShaActual)
        return 1

    let hasClang: os.ExecCmdResult = tooling_exec(root, "command -v clang >/dev/null 2>&1")
    if os.execCmdResultExitCode(hasClang) != 0:
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency requires clang")
        return 1
    let outDir: str = tooling_pathAbsolute(root, "artifacts/backend_cdrop_emergency")
    tooling_tryMkdirP(root, outDir)
    let seedPath: str = os.joinPath(outDir, "cheng.cdrop.seed")
    let runtimeDir: str = os.joinPath(root, "src/runtime/native")
    var compileCmd: str = "clang -O3 " + tooling_shellQuote(bootCPath) + " " +
                          tooling_shellQuote(runtimeDir) + "/*.c -o " + tooling_shellQuote(seedPath)
    var compileTimeoutSec: int32 = tooling_parseInt32Default(
        os.getEnvDefault("CDROP_EMERGENCY_COMPILE_TIMEOUT", ""), 120)
    if compileTimeoutSec < 1:
        compileTimeoutSec = 120
    compileCmd = tooling_wrapCommandWithTimeout(root, compileTimeoutSec, compileCmd)
    var compileRes: os.ExecCmdResult = tooling_exec(root, compileCmd)
    tooling_printExecOutput(compileRes)
    var compileRc: int32 = os.execCmdResultExitCode(compileRes)
    if compileRc != 0:
        let allowRuntimeless: bool = tooling_isTrue(
            os.getEnvDefault("CDROP_EMERGENCY_ALLOW_RUNTIMELESS_COMPILE", "1"))
        if !allowRuntimeless:
            tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency clang compile failed rc=" + intToStr(compileRc))
            return compileRc
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency runtime-full compile failed rc=" + intToStr(compileRc) +
                         ", retrying minimal bootstrap compile")
        var fallbackCompileCmd: str = "clang -O3 " + tooling_shellQuote(bootCPath) + " -o " + tooling_shellQuote(seedPath)
        fallbackCompileCmd = tooling_wrapCommandWithTimeout(root, compileTimeoutSec, fallbackCompileCmd)
        compileRes = tooling_exec(root, fallbackCompileCmd)
        tooling_printExecOutput(compileRes)
        compileRc = os.execCmdResultExitCode(compileRes)
        if compileRc != 0:
            tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency minimal clang compile failed rc=" + intToStr(compileRc))
            return compileRc
        tooling_printOut("cdrop_seed_compile_mode=minimal")
    else:
        tooling_printOut("cdrop_seed_compile_mode=runtime_full")
    tooling_printOut("cdrop_seed_bin=" + seedPath)

    let helpRes: os.ExecCmdResult = tooling_exec(root, tooling_shellQuote(seedPath) + " --help >/dev/null 2>&1")
    let helpRc: int32 = os.execCmdResultExitCode(helpRes)
    if helpRc != 0 && helpRc != 1 && helpRc != 2:
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency seed --help failed rc=" + intToStr(helpRc))
        return helpRc
    tooling_printOut("cdrop_seed_help_rc=" + intToStr(helpRc))

    let strictOutDir: str = os.joinPath(outDir, "selfhost")
    let strictTimingOut: str = os.joinPath(strictOutDir, "selfhost_timing_native.tsv")
    let strictRes: ToolingSelfhostResult = tooling_selfhostBootstrapStrictHost(root, strictOutDir, strictTimingOut, seedPath)
    if strictRes == nil || !strictRes.ok:
        var strictMsg: str = "unknown failure"
        if strictRes != nil:
            strictMsg = strictRes.message
            if tooling_strNonEmpty(strictRes.stage2Sha256):
                tooling_printErr("cheng_tooling: cdrop strict stage2_sha256=" + strictRes.stage2Sha256)
            if tooling_strNonEmpty(strictRes.stage3Sha256):
                tooling_printErr("cheng_tooling: cdrop strict stage3_sha256=" + strictRes.stage3Sha256)
        tooling_printErr("cheng_tooling: verify_backend_cdrop_emergency strict selfhost failed: " + strictMsg)
        return 1
    tooling_printOut("cdrop_selfhost_stage2=" + strictRes.stage2Path)
    tooling_printOut("cdrop_selfhost_stage3=" + strictRes.stage3Path)
    tooling_printOut("cdrop_selfhost_stage2_sha256=" + strictRes.stage2Sha256)
    tooling_printOut("cdrop_selfhost_stage3_sha256=" + strictRes.stage3Sha256)
    tooling_printOut("cdrop_selfhost_fixed_point_ok=" + tooling_boolText(strictRes.fixedPointOk))
    tooling_printOut("verify_backend_cdrop_emergency ok")
    return 0

fn tooling_cmdVerifyBackendCdropEmergencyFromArgs(root: str, firstArgIndex: int32, count: int32): int32 =
    var i: int32 = firstArgIndex
    if i < 1:
        i = 1
    for _ in i..count:
        if i > count:
            break
        let arg: str = tooling_paramStr(i)
        if tooling_strEq(arg, "--help") || tooling_strEq(arg, "-h"):
            tooling_printOut("verify_backend_cdrop_emergency options:")
            tooling_printOut("  (no flags)")
            tooling_printOut("  env: BACKEND_RUN_CDROP_EMERGENCY=0|1 (integration gate toggle, default 0)")
            tooling_printOut("  env: CDROP_EMERGENCY_ALLOW_RUNTIMELESS_COMPILE=0|1 (default 1)")
            return 0
        tooling_printErr("cheng_tooling: unknown verify_backend_cdrop_emergency arg: " + arg)
        return 1
    return tooling_cmdVerifyBackendCdropEmergency(root)

fn tooling_cmdVerifyBackendOpt2ImplSurface(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_opt2_impl_surface] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_opt2_impl_surface\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "opt2_file=\"src/backend/uir/uir_internal/uir_core_opt2.cheng\"; " +
        "ssu_file=\"src/backend/uir/uir_internal/uir_core_ssu.cheng\"; " +
        "noalias_file=\"src/backend/uir/uir_noalias_pass.cheng\"; " +
        "placeholder_hits=\"$out_dir/opt2.placeholder_hits.txt\"; " +
        "report=\"$out_dir/verify_backend_opt2_impl_surface.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_opt2_impl_surface.snapshot.env\"; " +
        "status=\"ok\"; " +
        "rg -n -U -P \"(?s)^fn\\\\s+(uirCore(?:OptimizeModule|Func)[A-Za-z0-9_]+)\\\\([^\\\\n]*\\\\):\\\\s*bool\\\\s*=\\\\n\\\\s*return false\" \"$opt2_file\" >\"$placeholder_hits\" || true; " +
        "placeholder_count=0; " +
        "if [ -s \"$placeholder_hits\" ]; then " +
            "placeholder_count=\"$(wc -l <\"$placeholder_hits\" | tr -d '[:space:]')\"; " +
            "status=\"drift\"; " +
        "fi; " +
        "ssu_default_ok=1; " +
        "if ! rg -q 'UIR_SSU\", true' \"$ssu_file\"; then ssu_default_ok=0; status=\"drift\"; fi; " +
        "njvl_default_ok=1; " +
        "if ! rg -q 'UIR_NOALIAS_NJVL_LITE\", true' \"$noalias_file\"; then njvl_default_ok=0; status=\"drift\"; fi; " +
        "noalias_fields_ok=1; " +
        "for key in unknown_slot_clobbers unknown_global_clobbers kill_events; do " +
            "if ! rg -q \"$key\" \"$noalias_file\"; then noalias_fields_ok=0; status=\"drift\"; fi; " +
        "done; " +
        "{ " +
            "echo \"verify_backend_opt2_impl_surface report\"; " +
            "echo \"status=$status\"; " +
            "echo \"placeholder_hits=$placeholder_hits\"; " +
            "echo \"placeholder_count=$placeholder_count\"; " +
            "echo \"ssu_default_ok=$ssu_default_ok\"; " +
            "echo \"njvl_default_ok=$njvl_default_ok\"; " +
            "echo \"noalias_fields_ok=$noalias_fields_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_opt2_impl_surface_status=$status\"; " +
            "echo \"backend_opt2_impl_surface_placeholder_count=$placeholder_count\"; " +
            "echo \"backend_opt2_impl_surface_ssu_default_ok=$ssu_default_ok\"; " +
            "echo \"backend_opt2_impl_surface_njvl_default_ok=$njvl_default_ok\"; " +
            "echo \"backend_opt2_impl_surface_noalias_fields_ok=$noalias_fields_ok\"; " +
            "echo \"backend_opt2_impl_surface_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "if [ \"$status\" != \"ok\" ]; then " +
            "echo \"[verify_backend_opt2_impl_surface] drift detected\" >&2; " +
            "echo \"  report: $report\" >&2; " +
            "if [ -s \"$placeholder_hits\" ]; then " +
                "echo \"  placeholder functions (top):\" >&2; " +
                "sed -n '1,80p' \"$placeholder_hits\" >&2 || true; " +
            "fi; " +
            "exit 1; " +
        "fi; " +
        "echo \"verify_backend_opt2_impl_surface ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendNoaliasOpt(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_noalias_opt] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_noalias_opt\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_noalias_opt.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_noalias_opt.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.noalias'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for pat in 'fn uirRunNoAliasPrep\\(' 'unknown_slot_clobbers' 'unknown_global_clobbers' 'kill_events' 'proof_backed_changes='; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_noalias_pass.cheng; then source_ok=0; fi; " +
        "done; " +
        "if ! rg -q 'UIR_NOALIAS_NJVL_LITE\", true' src/backend/uir/uir_noalias_pass.cheng; then source_ok=0; fi; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_noalias_opt] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_noalias_opt] backend driver missing noalias marker; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_noalias_mem2reg_load.cheng\"; " +
            "if [ ! -f \"$fixture\" ]; then fixture=\"tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\"; fi; " +
            "if [ -f \"$fixture\" ]; then " +
                "out_bin=\"$out_dir/noalias_probe.bin\"; log=\"$out_dir/noalias_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=0 BACKEND_PROFILE=0 UIR_NOALIAS=1 UIR_NOALIAS_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=0 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0 BACKEND_EMIT=exe BACKEND_DIRECT_EXE=1 BACKEND_LINKERLESS_INMEM=1 BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$out_bin\" ]; then " +
                    "echo \"[verify_backend_noalias_opt] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
                "if ! rg -q '^noalias_report' \"$log\"; then " +
                    "echo \"[verify_backend_noalias_opt] noalias_report missing in runtime probe\" >&2; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_noalias_opt_status=ok\"; " +
            "echo \"backend_noalias_opt_mode=$mode\"; " +
            "echo \"backend_noalias_opt_driver=$driver\"; " +
            "echo \"backend_noalias_opt_marker_ok=$marker_ok\"; " +
            "echo \"backend_noalias_opt_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_noalias_opt ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendEgraphCost(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_egraph_cost] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_egraph_cost\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_egraph_cost.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_egraph_cost.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.egraph'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for pat in 'uirEGraphGoalWeightSignature' 'uir_opt2\\.egraph' 'UIR_EGRAPH_REQUIRE_PROOF'; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_egraph_cost.cheng src/backend/uir/uir_opt.cheng; then source_ok=0; fi; " +
        "done; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_egraph_cost] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_egraph_cost] backend driver missing egraph marker; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_inline_dce.cheng\"; " +
            "if [ -f \"$fixture\" ]; then " +
                "out_bin=\"$out_dir/egraph_probe.bin\"; log=\"$out_dir/egraph_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=0 BACKEND_PROFILE=0 UIR_NOALIAS=1 UIR_EGRAPH_ITERS=3 UIR_EGRAPH_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=0 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0 BACKEND_EMIT=exe BACKEND_DIRECT_EXE=1 BACKEND_LINKERLESS_INMEM=1 BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$out_bin\" ]; then " +
                    "echo \"[verify_backend_egraph_cost] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_egraph_cost_status=ok\"; " +
            "echo \"backend_egraph_cost_mode=$mode\"; " +
            "echo \"backend_egraph_cost_driver=$driver\"; " +
            "echo \"backend_egraph_cost_marker_ok=$marker_ok\"; " +
            "echo \"backend_egraph_cost_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_egraph_cost ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendDodOptRegression(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_dod_opt_regression] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_dod_opt_regression\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_dod_opt_regression.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_dod_opt_regression.snapshot.env\"; " +
        "driver=\"${BACKEND_DRIVER:-artifacts/backend_driver/cheng}\"; " +
        "target=\"${BACKEND_TARGET:-$(${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling} detect_host_target 2>/dev/null || echo arm64-apple-darwin)}\"; " +
        "mode=\"runtime\"; marker_ok=0; " +
        "if [ -x \"$driver\" ] && command -v strings >/dev/null 2>&1; then " +
            "if strings \"$driver\" 2>/dev/null | rg -q 'uir_opt2.noalias|uir_opt2.egraph|p4_phase_v1'; then marker_ok=1; fi; " +
        "fi; " +
        "source_ok=1; " +
        "for file in src/backend/uir/uir_noalias_pass.cheng src/backend/uir/uir_egraph_cost.cheng src/backend/uir/uir_opt.cheng src/backend/tooling/backend_driver.cheng; do " +
            "if [ ! -f \"$file\" ]; then source_ok=0; fi; " +
        "done; " +
        "for pat in 'uir_opt2\\.noalias' 'uir_opt2\\.egraph' 'single_ir_dual_phase' 'p4_phase_v1'; do " +
            "if ! rg -q \"$pat\" src/backend/uir/uir_opt.cheng src/backend/tooling/backend_driver.cheng; then source_ok=0; fi; " +
        "done; " +
        "if [ \"$source_ok\" != \"1\" ]; then " +
            "echo \"[verify_backend_dod_opt_regression] source contract markers missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ \"$marker_ok\" != \"1\" ]; then " +
            "mode=\"source_contract_fallback\"; " +
            "echo \"[verify_backend_dod_opt_regression] backend driver missing opt2 markers; fallback to source-contract checks\" >&2; " +
        "else " +
            "fixture=\"tests/cheng/backend/fixtures/return_opt2_sroa_deref.cheng\"; " +
            "if [ -f \"$fixture\" ]; then " +
                "out_bin=\"$out_dir/dod_opt_probe.bin\"; log=\"$out_dir/dod_opt_probe.log\"; " +
                "set +e; " +
                "env ABI=v2_noptr STAGE1_STD_NO_POINTERS=0 STAGE1_STD_NO_POINTERS_STRICT=0 STAGE1_NO_POINTERS_NON_C_ABI=0 STAGE1_NO_POINTERS_NON_C_ABI_INTERNAL=0 STAGE1_SKIP_OWNERSHIP=0 UIR_PROFILE=0 BACKEND_PROFILE=0 UIR_NOALIAS=1 UIR_NOALIAS_REQUIRE_PROOF=1 UIR_EGRAPH_ITERS=3 UIR_EGRAPH_REQUIRE_PROOF=1 BACKEND_OPT_LEVEL=2 BACKEND_LINKER=self BACKEND_NO_RUNTIME_C=0 BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0 BACKEND_EMIT=exe BACKEND_DIRECT_EXE=1 BACKEND_LINKERLESS_INMEM=1 BACKEND_TARGET=\"$target\" BACKEND_INPUT=\"$fixture\" BACKEND_OUTPUT=\"$out_bin\" \"$driver\" >\"$log\" 2>&1; " +
                "rc=\"$?\"; " +
                "set -e; " +
                "if [ \"$rc\" -ne 0 ] || [ ! -s \"$out_bin\" ]; then " +
                    "echo \"[verify_backend_dod_opt_regression] runtime probe compile failed\" >&2; " +
                    "sed -n '1,120p' \"$log\" >&2 || true; " +
                    "exit 1; " +
                "fi; " +
            "fi; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"mode=$mode\"; " +
            "echo \"driver=$driver\"; " +
            "echo \"marker_ok=$marker_ok\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_dod_opt_regression_status=ok\"; " +
            "echo \"backend_dod_opt_regression_mode=$mode\"; " +
            "echo \"backend_dod_opt_regression_driver=$driver\"; " +
            "echo \"backend_dod_opt_regression_marker_ok=$marker_ok\"; " +
            "echo \"backend_dod_opt_regression_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_dod_opt_regression ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendNoptrExemptionScope(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_noptr_exemption_scope] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_noptr_exemption_scope\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "hits=\"$out_dir/noptr_exemption_hits.txt\"; " +
        "bad=\"$out_dir/noptr_exemption_bad.txt\"; " +
        "report=\"$out_dir/verify_backend_noptr_exemption_scope.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_noptr_exemption_scope.snapshot.env\"; " +
        "rm -f src/tooling/.tmp_backend_prod_closure.debug.sh src/tooling/.tmp_backend_prod_closure.debug.env || true; " +
        "rg -n -P --glob '*.cheng' --glob '*.sh' '^(?![[:space:]]*#).*STAGE1_NO_POINTERS_NON_C_ABI(_INTERNAL)?=0' src >\"$hits\" || true; " +
        ": >\"$bad\"; " +
        "while IFS= read -r line; do " +
            "[ \"$line\" != \"\" ] || continue; " +
            "file=\"${line%%:*}\"; " +
            "case \"$file\" in " +
                "src/tooling/cheng_tooling.cheng|src/tooling/cheng_tooling_embedded_inline.cheng|src/tooling/.tmp_*) " +
                    "continue ;; " +
            "esac; " +
            "printf '%s\\n' \"$line\" >>\"$bad\"; " +
        "done <\"$hits\"; " +
        "if [ -s \"$bad\" ]; then " +
            "echo \"[Error] no-pointer exemption found outside allowlist:\" >&2; " +
            "sed -n '1,200p' \"$bad\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "count=\"$(wc -l <\"$hits\" | tr -d '[:space:]')\"; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"hit_count=$count\"; " +
            "echo \"hits=$hits\"; " +
            "echo \"allowlist=src/tooling/cheng_tooling.cheng,src/tooling/cheng_tooling_embedded_inline.cheng,src/tooling/.tmp_*\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_noptr_exemption_scope_status=ok\"; " +
            "echo \"backend_noptr_exemption_scope_hit_count=$count\"; " +
            "echo \"backend_noptr_exemption_scope_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_noptr_exemption_scope ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendZeroScriptClosure(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_zero_script_closure] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_zero_script_closure\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "wrappers=\"$out_dir/shell_wrappers.txt\"; " +
        "inlines=\"$out_dir/inline_files.txt\"; " +
        "report=\"$out_dir/verify_backend_zero_script_closure.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_zero_script_closure.snapshot.env\"; " +
        "find src/tooling -type f -name '.tmp_*.sh' -delete 2>/dev/null || true; " +
        "find src/tooling -type f -name '*.sh' | LC_ALL=C sort >\"$wrappers\"; " +
        "if [ -s \"$wrappers\" ]; then " +
            "echo \"[verify_backend_zero_script_closure] unexpected shell wrappers under src/tooling:\" >&2; " +
            "sed -n '1,200p' \"$wrappers\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "find src/tooling -type f -name '*.inline' | LC_ALL=C sort >\"$inlines\"; " +
        "if [ -s \"$inlines\" ]; then " +
            "echo \"[verify_backend_zero_script_closure] unexpected inline files under src/tooling:\" >&2; " +
            "sed -n '1,200p' \"$inlines\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "if ! rg -q 'tooling_strEq\\(first, \"compile\"\\) \\|\\| tooling_strEq\\(first, \"cheng\"\\) \\|\\| tooling_strEq\\(first, \"chengc\"\\)' src/tooling/cheng_tooling.cheng; then " +
            "echo \"[verify_backend_zero_script_closure] missing native chengc route in cheng_tooling main dispatch\" >&2; " +
            "exit 1; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"shell_wrapper_count=0\"; " +
            "echo \"inline_count=0\"; " +
            "echo \"chengc_native_route=1\"; " +
            "echo \"wrappers=$wrappers\"; " +
            "echo \"inlines=$inlines\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_zero_script_closure_status=ok\"; " +
            "echo \"backend_zero_script_closure_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_zero_script_closure ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendRawptrMigration(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_rawptr_migration] rg is required\" >&2; exit 2; " +
        "fi; " +
        "tool=\"${TOOLING_SELF_BIN:-artifacts/tooling_cmd/cheng_tooling}\"; " +
        "out_dir=\"artifacts/backend_rawptr_migration\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "report=\"$out_dir/verify_backend_rawptr_migration.report.txt\"; " +
        "snapshot=\"$out_dir/verify_backend_rawptr_migration.snapshot.env\"; " +
        "if [ ! -f docs/raw-pointer-safety.md ]; then " +
            "echo \"[verify_backend_rawptr_migration] missing doc: docs/raw-pointer-safety.md\" >&2; " +
            "exit 2; " +
        "fi; " +
        "if ! \"$tool\" list | rg -qx 'rawptr_migrate_ffi'; then " +
            "echo \"[verify_backend_rawptr_migration] missing rawptr_migrate_ffi native subcommand\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if ! \"$tool\" embedded-text --id:rawptr_migrate_ffi | rg -q '.'; then " +
            "echo \"[verify_backend_rawptr_migration] rawptr_migrate_ffi embedded payload missing\" >&2; " +
            "exit 1; " +
        "fi; " +
        "{ " +
            "echo \"status=ok\"; " +
            "echo \"tool=$tool\"; " +
            "echo \"rawptr_migrate_ffi=available\"; " +
            "echo \"doc=docs/raw-pointer-safety.md\"; " +
        "} >\"$report\"; " +
        "{ " +
            "echo \"backend_rawptr_migration_status=ok\"; " +
            "echo \"backend_rawptr_migration_report=$report\"; " +
        "} >\"$snapshot\"; " +
        "echo \"verify_backend_rawptr_migration ok\""
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_cmdVerifyBackendEmitObjContract(root: str): int32 =
    let cmd: str =
        "set -eu; " +
        "if ! command -v rg >/dev/null 2>&1; then " +
            "echo \"[verify_backend_emit_obj_contract] rg is required\" >&2; exit 2; " +
        "fi; " +
        "out_dir=\"artifacts/backend_emit_obj_contract\"; " +
        "rm -rf \"$out_dir\"; mkdir -p \"$out_dir\"; " +
        "emit_files=\"$out_dir/backend_emit_obj.files.txt\"; " +
        "missing_allow=\"$out_dir/backend_emit_obj.missing_allow.txt\"; " +
        "bad_allow=\"$out_dir/backend_emit_obj.bad_allow.txt\"; " +
        "report=\"$out_dir/backend_emit_obj_contract.report.txt\"; " +
        "rg -l --glob '*.cheng' \"BACKEND_EMIT=obj\" src/tooling >\"$emit_files\" || true; " +
        "if [ ! -s \"$emit_files\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] no BACKEND_EMIT=obj usage under src/tooling\" >&2; " +
            "exit 1; " +
        "fi; " +
        "if rg -l --glob '*.sh' \"BACKEND_EMIT=obj\" src/tooling scripts >/dev/null 2>&1; then " +
            "echo \"[verify_backend_emit_obj_contract] shell wrappers must not carry BACKEND_EMIT=obj\" >&2; " +
            "rg -l --glob '*.sh' \"BACKEND_EMIT=obj\" src/tooling scripts | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        ": >\"$missing_allow\"; : >\"$bad_allow\"; " +
        "while IFS= read -r file; do " +
            "[ \"$file\" != \"\" ] || continue; " +
            "if ! rg -q \"BACKEND_INTERNAL_ALLOW_EMIT_OBJ\" \"$file\"; then " +
                "printf '%s\\n' \"$file\" >>\"$missing_allow\"; " +
            "fi; " +
            "if [ \"$file\" != \"src/tooling/cheng_tooling.cheng\" ] && " +
               "rg -q \"BACKEND_INTERNAL_ALLOW_EMIT_OBJ=0\" \"$file\"; then " +
                "printf '%s\\n' \"$file\" >>\"$bad_allow\"; " +
            "fi; " +
        "done <\"$emit_files\"; " +
        "if [ -s \"$missing_allow\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] missing BACKEND_INTERNAL_ALLOW_EMIT_OBJ guard:\" >&2; " +
            "sed -n '1,200p' \"$missing_allow\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "if [ -s \"$bad_allow\" ]; then " +
            "echo \"[verify_backend_emit_obj_contract] BACKEND_INTERNAL_ALLOW_EMIT_OBJ must not be forced to 0:\" >&2; " +
            "sed -n '1,200p' \"$bad_allow\" | sed 's/^/  - /' >&2; " +
            "exit 1; " +
        "fi; " +
        "emit_count=\"$(wc -l <\"$emit_files\" | tr -d ' ')\"; " +
        "{ " +
            "echo \"verify_backend_emit_obj_contract report\"; " +
            "echo \"status=ok\"; " +
            "echo \"emit_obj_file_count=$emit_count\"; " +
            "echo \"missing_allow_count=0\"; " +
            "echo \"bad_allow_count=0\"; " +
            "echo \"emit_files=$emit_files\"; " +
        "} >\"$report\"; " +
        "echo \"verify_backend_emit_obj_contract ok\"";
    let res: os.ExecCmdResult = tooling_exec(root, cmd)
    tooling_printExecOutput(res)
    return os.execCmdResultExitCode(res)

fn tooling_runScript(root: str, scriptPath: str, argStart: int32): int32 =
    var command: str = ""
    var shellBin: str = "sh"
    let scriptId: str = tooling_scriptIdFromResolvedPath(scriptPath)
    if tooling_strNonEmpty(scriptId):
        let cacheDir: str = os.joinPath(root, "chengcache/embedded_scripts")
        if !tooling_mkdirP(root, cacheDir):
            tooling_printErr("cheng_tooling: failed to create embedded script cache: " + cacheDir)
            return 1
        let cachedScript: str = os.joinPath(cacheDir, scriptId + ".embedded.sh")
        var reuseCachedScript: bool = tooling_isTrue(
            os.getEnvDefault("TOOLING_EMBEDDED_CACHE_REUSE", "1"))
        if tooling_embeddedScriptPreferFreshCache(scriptId):
            reuseCachedScript = false
        var needRefreshCached: bool = true
        if reuseCachedScript && os.fileExists(cachedScript):
            needRefreshCached = false
            shellBin = tooling_scriptShell(root, cachedScript)
        if needRefreshCached:
            let scriptText: str = tooling_embeddedScriptText(root, scriptId)
            if !tooling_strNonEmpty(scriptText):
                tooling_printErr("cheng_tooling: missing embedded script payload: " + scriptId)
                return 1
            shellBin = tooling_scriptShellFromText(scriptText)
            if !tooling_writeTextFileViaShell(root, cachedScript, scriptText):
                tooling_printErr("cheng_tooling: failed to write cached embedded script: " + cachedScript)
                return 1
            let chmodRes: os.ExecCmdResult = tooling_exec(root, "chmod +x " + tooling_shellQuote(cachedScript))
            if os.execCmdResultExitCode(chmodRes) != 0:
                tooling_printErr("cheng_tooling: chmod failed for cached embedded script: " + cachedScript)
                tooling_printExecOutput(chmodRes)
                return 1
        let runnerExpr: str = "embedded_script=\"$1\"; shift; . \"$embedded_script\""
        command = tooling_shellQuote(shellBin) + " -c " + tooling_shellQuote(runnerExpr) +
                  " " + tooling_shellQuote(tooling_embeddedArgv0(root, scriptId)) +
                  " " + tooling_shellQuote(cachedScript)
    else:
        if !os.fileExists(scriptPath):
            tooling_printErr("cheng_tooling: script not found: " + scriptPath)
            return 1
        shellBin = tooling_scriptShell(root, scriptPath)
        command = tooling_shellQuote(shellBin) + " " + tooling_shellQuote(scriptPath)
    let count: int32 = tooling_paramCount()
    if argStart <= count:
        for i in argStart..count:
            command = command + " " + tooling_shellQuote(tooling_paramStr(i))
    let opts: uint64 = uint64(7)
    let result: os.ExecCmdResult = os.execCmdEx(command, opts, root)
    let output: str = os.execCmdResultOutput(result)
    if tooling_strNonEmpty(output):
        os.write(os.get_stdout(), output)
    return os.execCmdResultExitCode(result)

fn main(argc: int32, argv: str*): int32 =
    tooling_setCmdLine(argc, argv)
    let root: str = tooling_root()
    let selfName: str = tooling_programBaseName()
    let count: int32 = tooling_paramCount()
    if tooling_strEq(selfName, "cheng") || tooling_strEq(selfName, "chengc"):
        return tooling_cmdCompileFromArgs(root, 1, count)
    if tooling_strEq(selfName, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    if tooling_strEq(selfName, "bootstrap") || tooling_strEq(selfName, "bootstrap_pure") || tooling_strEq(selfName, "bootstrap-pure"):
        return tooling_cmdBootstrapPureFromArgs(root, 1, count)
    if tooling_strEq(selfName, "backend_driver_path") || tooling_strEq(selfName, "driver-path"):
        return tooling_cmdDriverPathFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_backend_driver") || tooling_strEq(selfName, "build-backend-driver"):
        return tooling_cmdBuildBackendDriverFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_release_driver") || tooling_strEq(selfName, "build-release-driver"):
        return tooling_cmdBuildReleaseDriverFromArgs(root, 1, count)
    if tooling_strEq(selfName, "cleanup_backend_driver_history") || tooling_strEq(selfName, "cleanup-backend-driver-history"):
        return tooling_cmdCleanupBackendDriverHistoryFromArgs(root, 1, count)
    if tooling_strEq(selfName, "build_backend_baselines") || tooling_strEq(selfName, "build-backend-baselines"):
        return tooling_cmdBuildBackendBaselines(root)
    if tooling_strEq(selfName, "sync_global") || tooling_strEq(selfName, "sync-global"):
        return tooling_cmdSyncGlobalDeprecated()
    if tooling_strEq(selfName, "verify_backend_selfhost_bootstrap_self_obj"):
        return tooling_cmdSelfhostBootstrapVerifyFromArgs(root, 1, count)
    if tooling_strEq(selfName, "verify_backend_selfhost_100ms_host"):
        return tooling_cmdSelfhost100msHostFromArgs(root, 1, count)
    if tooling_strEq(selfName, "verify_backend_cdrop_emergency"):
        return tooling_cmdVerifyBackendCdropEmergencyFromArgs(root, 1, count)
    if tooling_strEq(selfName, "verify_backend_opt2_impl_surface"):
        return tooling_cmdVerifyBackendOpt2ImplSurface(root)
    if tooling_strEq(selfName, "verify_backend_noalias_opt"):
        return tooling_cmdVerifyBackendNoaliasOpt(root)
    if tooling_strEq(selfName, "verify_backend_egraph_cost"):
        return tooling_cmdVerifyBackendEgraphCost(root)
    if tooling_strEq(selfName, "verify_backend_dod_opt_regression"):
        return tooling_cmdVerifyBackendDodOptRegression(root)
    if tooling_strEq(selfName, "verify_backend_noptr_exemption_scope"):
        return tooling_cmdVerifyBackendNoptrExemptionScope(root)
    if tooling_strEq(selfName, "verify_backend_zero_script_closure"):
        return tooling_cmdVerifyBackendZeroScriptClosure(root)
    if tooling_strEq(selfName, "verify_backend_rawptr_migration"):
        return tooling_cmdVerifyBackendRawptrMigration(root)
    if tooling_strEq(selfName, "verify_backend_emit_obj_contract"):
        return tooling_cmdVerifyBackendEmitObjContract(root)
    if tooling_strNonEmpty(selfName) &&
       !tooling_strEq(selfName, "cheng_tooling") &&
       !tooling_strEq(selfName, "cheng_tooling_global"):
        let multiScript: str = tooling_resolveScriptPath(root, selfName)
        if tooling_strNonEmpty(multiScript):
            return tooling_runScript(root, multiScript, 1)

    if count <= 0:
        tooling_printUsage()
        return 1
    let first: str = tooling_paramStr(1)
    if tooling_strEq(first, "help") || tooling_strEq(first, "--help") || tooling_strEq(first, "-h"):
        tooling_printUsage()
        return 0
    if tooling_strEq(first, "driver-path") || tooling_strEq(first, "backend_driver_path"):
        return tooling_cmdDriverPathFromArgs(root, 2, count)
    if tooling_strEq(first, "build-backend-driver") || tooling_strEq(first, "build_backend_driver"):
        return tooling_cmdBuildBackendDriverFromArgs(root, 2, count)
    if tooling_strEq(first, "build-release-driver") || tooling_strEq(first, "build_release_driver"):
        return tooling_cmdBuildReleaseDriverFromArgs(root, 2, count)
    if tooling_strEq(first, "cleanup-backend-driver-history") || tooling_strEq(first, "cleanup_backend_driver_history"):
        return tooling_cmdCleanupBackendDriverHistoryFromArgs(root, 2, count)
    if tooling_strEq(first, "build-backend-baselines") || tooling_strEq(first, "build_backend_baselines"):
        return tooling_cmdBuildBackendBaselines(root)
    if tooling_strEq(first, "sync-global") || tooling_strEq(first, "sync_global"):
        return tooling_cmdSyncGlobalDeprecated()
    if tooling_strEq(first, "selfhost-bootstrap-fast-host"):
        return tooling_cmdSelfhostBootstrapFastHostFromArgs(root, 2, count)
    if tooling_strEq(first, "verify_backend_selfhost_bootstrap_self_obj"):
        return tooling_cmdSelfhostBootstrapVerifyFromArgs(root, 2, count)
    if tooling_strEq(first, "selfhost-100ms-host") || tooling_strEq(first, "verify_backend_selfhost_100ms_host"):
        return tooling_cmdSelfhost100msHostFromArgs(root, 2, count)
    if tooling_strEq(first, "verify_backend_cdrop_emergency"):
        return tooling_cmdVerifyBackendCdropEmergencyFromArgs(root, 2, count)
    if tooling_strEq(first, "verify_backend_opt2_impl_surface"):
        return tooling_cmdVerifyBackendOpt2ImplSurface(root)
    if tooling_strEq(first, "verify_backend_noalias_opt"):
        return tooling_cmdVerifyBackendNoaliasOpt(root)
    if tooling_strEq(first, "verify_backend_egraph_cost"):
        return tooling_cmdVerifyBackendEgraphCost(root)
    if tooling_strEq(first, "verify_backend_dod_opt_regression"):
        return tooling_cmdVerifyBackendDodOptRegression(root)
    if tooling_strEq(first, "verify_backend_noptr_exemption_scope"):
        return tooling_cmdVerifyBackendNoptrExemptionScope(root)
    if tooling_strEq(first, "verify_backend_zero_script_closure"):
        return tooling_cmdVerifyBackendZeroScriptClosure(root)
    if tooling_strEq(first, "verify_backend_rawptr_migration"):
        return tooling_cmdVerifyBackendRawptrMigration(root)
    if tooling_strEq(first, "verify_backend_emit_obj_contract"):
        return tooling_cmdVerifyBackendEmitObjContract(root)
    if tooling_strEq(first, "bootstrap-pure") || tooling_strEq(first, "bootstrap_pure") || tooling_strEq(first, "bootstrap"):
        return tooling_cmdBootstrapPureFromArgs(root, 2, count)
    if tooling_strEq(first, "compile") || tooling_strEq(first, "cheng") || tooling_strEq(first, "chengc"):
        return tooling_cmdCompileFromArgs(root, 2, count)
    if tooling_strEq(first, "chengb"):
        tooling_printErr("cheng_tooling: chengb has been removed; use `chengc`")
        return 2
    if tooling_strEq(first, "list") || tooling_strEq(first, "embedded-ids") || tooling_strEq(first, "embedded_ids"):
        return tooling_list(root)
    if tooling_strEq(first, "embedded-text") || tooling_strEq(first, "embedded_text"):
        return tooling_embeddedTextCommand(root, 2, count)
    if tooling_strEq(first, "embedded-map-rewrite") || tooling_strEq(first, "embedded_map_rewrite") ||
       tooling_strEq(first, "rewrite-map") || tooling_strEq(first, "rewrite_map"):
        return tooling_embeddedMapRewriteCommand(root, 2, count)
    if tooling_strEq(first, "build-global"):
        var outPath: str = os.joinPath(root, "artifacts/tooling_cmd/cheng_tooling")
        var linker: str = "system"
        var driver: str = ""
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--out:"):
                outPath = strings.dropPrefix(arg, "--out:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--linker:"):
                linker = strings.dropPrefix(arg, "--linker:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--driver:"):
                driver = strings.dropPrefix(arg, "--driver:")
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown build-global arg: " + arg)
            return 1
        return tooling_buildGlobal(root, outPath, linker, driver)
    if tooling_strEq(first, "bundle"):
        var outDir: str = os.joinPath(root, "artifacts/tooling_bundle")
        var linker: str = "system"
        var driver: str = ""
        var profileSelector: str = ""
        var mode: str = "symlink"
        var force: bool = false
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--out-dir:"):
                outDir = strings.dropPrefix(arg, "--out-dir:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--linker:"):
                linker = strings.dropPrefix(arg, "--linker:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--driver:"):
                driver = strings.dropPrefix(arg, "--driver:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--profile:"):
                let profile: str = strutil.toLowerAscii(strutil.strip(strings.dropPrefix(arg, "--profile:")))
                if !tooling_strEq(profile, "full"):
                    tooling_printErr("cheng_tooling: invalid --profile (expected full): " + profile)
                    return 1
                profileSelector = tooling_selectorAppend(profileSelector, profile)
                i = i + 1
                continue
            if strutil.startsWith(arg, "--mode:"):
                mode = strings.dropPrefix(arg, "--mode:")
                i = i + 1
                continue
            if tooling_strEq(arg, "--force"):
                force = true
                i = i + 1
                continue
            if strutil.startsWith(arg, "--force:"):
                force = tooling_isTrue(strings.dropPrefix(arg, "--force:"))
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown bundle arg: " + arg)
            return 1
        return tooling_bundle(root, outDir, linker, driver, profileSelector, mode, force)
    if tooling_strEq(first, "install"):
        var installDir: str = os.joinPath(root, "artifacts/tooling_cmd/bin")
        var manifest: str = ""
        var force: bool = false
        var binPath: str = tooling_paramStr(0)
        var onlySelector: str = ""
        var excludeSelector: str = ""
        var mode: str = "symlink"
        var i: int32 = 2
        for _ in 2..count:
            if i > count:
                break
            let arg: str = tooling_paramStr(i)
            if strutil.startsWith(arg, "--dir:"):
                installDir = strings.dropPrefix(arg, "--dir:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--bin:"):
                binPath = strings.dropPrefix(arg, "--bin:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--manifest:"):
                manifest = strings.dropPrefix(arg, "--manifest:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--mode:"):
                mode = strings.dropPrefix(arg, "--mode:")
                i = i + 1
                continue
            if strutil.startsWith(arg, "--only:"):
                let id: str = tooling_normalizeScriptId(strings.dropPrefix(arg, "--only:"))
                if !tooling_strNonEmpty(id):
                    tooling_printErr("cheng_tooling: invalid --only script id: " + arg)
                    return 1
                onlySelector = tooling_selectorAppend(onlySelector, id)
                i = i + 1
                continue
            if strutil.startsWith(arg, "--exclude:"):
                let id: str = tooling_normalizeScriptId(strings.dropPrefix(arg, "--exclude:"))
                if !tooling_strNonEmpty(id):
                    tooling_printErr("cheng_tooling: invalid --exclude script id: " + arg)
                    return 1
                excludeSelector = tooling_selectorAppend(excludeSelector, id)
                i = i + 1
                continue
            if tooling_strEq(arg, "--force"):
                force = true
                i = i + 1
                continue
            if strutil.startsWith(arg, "--force:"):
                force = tooling_isTrue(strings.dropPrefix(arg, "--force:"))
                i = i + 1
                continue
            tooling_printErr("cheng_tooling: unknown install arg: " + arg)
            return 1
        return tooling_installLinks(root, binPath, installDir, manifest, force, onlySelector, excludeSelector, mode)

    var scriptArg: str = ""
    var argStart: int32 = 0
    if tooling_strEq(first, "run"):
        if count < 2:
            tooling_printErr("cheng_tooling: missing script name for `run`")
            tooling_printUsage()
            return 1
        scriptArg = tooling_paramStr(2)
        argStart = 3
    else:
        scriptArg = first
        argStart = 2

    let scriptPath: str = tooling_resolveScriptPath(root, scriptArg)
    if !tooling_strNonEmpty(scriptPath):
        tooling_printErr("cheng_tooling: unknown tooling script: " + scriptArg)
        tooling_printErr("cheng_tooling: run `cheng_tooling list` to inspect available script IDs")
        return 1
    return tooling_runScript(root, scriptPath, argStart)
