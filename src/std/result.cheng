# std/result
type
    ErrorInfo =
        code: int32
        msg: str

type
    Result[T] =
        ok: bool
        value: T
        err: ErrorInfo

fn ErrorOk(): ErrorInfo =
    var e: ErrorInfo
    e.code = 0
    e.msg = ""
    return e

fn ErrorNew(msg: str): ErrorInfo =
    var e: ErrorInfo
    e.code = 0
    e.msg = msg
    return e

fn ErrorCode(code: int32, msg: str): ErrorInfo =
    var e: ErrorInfo
    e.code = code
    e.msg = msg
    return e

fn IsError(e: ErrorInfo): bool =
    if e.code != 0:
        return true
    return len(e.msg) > 0

fn ErrorCodeOf(e: ErrorInfo): int32 =
    return e.code

fn ErrorMessage(e: ErrorInfo): str =
    if len(e.msg) == 0:
        return ""
    return e.msg

fn ErrorFormat(e: ErrorInfo): str =
    if len(e.msg) == 0:
        return "error"
    return e.msg

fn Ok(value: T): Result[T] =
    var out: Result[T]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err(err: str): Result[T] =
    var out: Result[T]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn ErrCode(code: int32, msg: str): Result[T] =
    var out: Result[T]
    out.ok = false
    out.err = ErrorCode(code, msg)
    return out

fn ErrInfo(err: ErrorInfo): Result[T] =
    var out: Result[T]
    out.ok = false
    out.err = err
    return out

fn IsOk(r: Result[T]): bool =
    return r.ok

fn IsErr(r: Result[T]): bool =
    return !r.ok

fn Value(r: Result[T]): T =
    return r.value

fn ErrorInfoOf(r: Result[T]): ErrorInfo =
    return r.err

fn Error(r: Result[T]): str =
    return ErrorMessage(r.err)

# Non-generic symbol closure for stage1/self-link builds.
fn Error_bool(r: Result[bool]): str =
    return ErrorMessage(r.err)


# Stage1/self-link fallback symbols: concrete Result specializations that are
# required by production bootstrap hot paths.
fn Ok_bool(value: bool): Result[bool] =
    var out: Result[bool]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_bool(err: str): Result[bool] =
    var out: Result[bool]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn ErrInfo_bool(err: ErrorInfo): Result[bool] =
    var out: Result[bool]
    out.ok = false
    out.err = err
    return out

fn ErrorInfoOf_bool(r: Result[bool]): ErrorInfo =
    return r.err

fn Ok_int32(value: int32): Result[int32] =
    var out: Result[int32]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_int32(err: str): Result[int32] =
    var out: Result[int32]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn ErrInfo_int32(err: ErrorInfo): Result[int32] =
    var out: Result[int32]
    out.ok = false
    out.err = err
    return out

fn ErrorInfoOf_int32(r: Result[int32]): ErrorInfo =
    return r.err

fn Ok_int64(value: int64): Result[int64] =
    var out: Result[int64]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_int64(err: str): Result[int64] =
    var out: Result[int64]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn Ok_uint32(value: uint32): Result[uint32] =
    var out: Result[uint32]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_uint32(err: str): Result[uint32] =
    var out: Result[uint32]
    out.ok = false
    out.err = ErrorNew(err)
    return out

fn Ok_str(value: str): Result[str] =
    var out: Result[str]
    out.ok = true
    out.value = value
    out.err = ErrorOk()
    return out

fn Err_str(err: str): Result[str] =
    var out: Result[str]
    out.ok = false
    out.err = ErrorNew(err)
    return out
