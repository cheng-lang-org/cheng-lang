# Sequence module

fn cheng__seqNextCap(curCap: int32, needLen: int32): int32 =
    var cap: int32 = curCap
    if cap < 4:
        cap = 4
    while cap < needLen:
        cap = cap * 2
        if cap <= 0:
            cap = needLen
            break
    return cap

fn cheng__seqGrowToRaw(pBuffer: void**, pCap: int32*, minCap: int32, typeSize: int32) =
    if minCap <= 0:
        return
    let cap: int32 = *pCap
    let buffer: void* = *pBuffer
    if buffer != nil && minCap <= cap:
        return
    var newCap: int32 = cap
    if newCap < minCap:
        newCap = cheng__seqNextCap(cap, minCap)
    if newCap <= 0:
        newCap = cheng__seqNextCap(0, minCap)
    let oldBytes: int32 = (buffer != nil) ? (cap * typeSize) : 0
    let newBytes: int32 = newCap * typeSize
    let newBuffer: void* = realloc(buffer, newBytes)
    if newBuffer == nil:
        panic "cheng: out of memory"
    *pBuffer = newBuffer
    *pCap = newCap
    if newBytes > oldBytes:
        zeroMem(ptr_add(newBuffer, oldBytes), newBytes - oldBytes)

fn cheng__seqZeroTailRaw(buffer: void*, cap: int32, len: int32, target: int32, typeSize: int32) =
    if buffer == nil || target <= len:
        return
    let fromBytes: int32 = len * typeSize
    let toBytes: int32 = target * typeSize
    if toBytes > fromBytes:
        zeroMem(ptr_add(buffer, fromBytes), toBytes - fromBytes)

fn setLen(seqInst: var T[], newLen: int) =
    var target: int32 = int32(newLen)
    if target < 0:
        target = 0
    if target > seqInst.cap || (target > 0 && seqInst.buffer == nil):
        cheng__seqGrowToRaw(&seqInst.buffer, &seqInst.cap, target, int32(sizeof T))
    if target > seqInst.len:
        cheng__seqZeroTailRaw(seqInst.buffer, seqInst.cap, seqInst.len, target, int32(sizeof T))
    seqInst.len = target

fn setLen(seqInst: var T[], newLen: int32) =
    setLen(seqInst, int(newLen))

fn setLen(seqInst: T[]*, newLen: int) =
    if seqInst == nil:
        return
    var target: int32 = int32(newLen)
    if target < 0:
        target = 0
    if target > seqInst->cap || (target > 0 && seqInst->buffer == nil):
        cheng__seqGrowToRaw(&seqInst->buffer, &seqInst->cap, target, int32(sizeof T))
    if target > seqInst->len:
        cheng__seqZeroTailRaw(seqInst->buffer, seqInst->cap, seqInst->len, target, int32(sizeof T))
    seqInst->len = target

fn setLen(seqInst: T[]*, newLen: int32) =
    setLen(seqInst, int(newLen))

fn setLenPtr(seqInst: var T[], newLen: int) =
    setLen(seqInst, newLen)

fn reserve(seqInst: var T[], newCap: int32) =
    if newCap <= seqInst.cap && seqInst.buffer != nil:
        return
    if newCap < 0:
        return
    cheng__seqGrowToRaw(&seqInst.buffer, &seqInst.cap, newCap, int32(sizeof T))

fn reserve(seqInst: var T[], newCap: int) =
    reserve(seqInst, int32(newCap))

fn reserve(seqInst: T[]*, newCap: int32) =
    if seqInst == nil:
        return
    if newCap <= seqInst->cap && seqInst->buffer != nil:
        return
    if newCap < 0:
        return
    cheng__seqGrowToRaw(&seqInst->buffer, &seqInst->cap, newCap, int32(sizeof T))

fn reserve(seqInst: T[]*, newCap: int) =
    reserve(seqInst, int32(newCap))

fn reservePtr(seqInst: var T[], newCap: int32) =
    reserve(seqInst, newCap)

fn clear(seqInst: var T[]) =
    seqInst.len = 0

fn resize(seqInst: var T[], newLen: int, capHint: int32 = 0) =
    if capHint > 0:
        reserve(seqInst, capHint)
    setLen(seqInst, newLen)

fn len(seqInst: T[]): int32 =
    return seqInst.len

fn dataPtr(seqInst: T[]): void* =
    return seqInst.buffer

fn get(seqInst: T[], at: int32): T =
    return seqInst[at]

fn get(seqInst: T[]*, at: int32): T =
    if seqInst == nil:
        panic "seqs.get: nil seq pointer"
    return seqInst[at]

fn add(seqInst: var T[], val: T) =
    if seqInst.buffer == nil || seqInst.len >= seqInst.cap:
        cheng__seqGrowToRaw(&seqInst.buffer, &seqInst.cap, seqInst.len + 1, int32(sizeof T))
    let elemBytes: int32 = seqInst.len * int32(sizeof T)
    let writePtr: T* = T*(ptr_add(seqInst.buffer, elemBytes))
    *writePtr = val
    seqInst.len = seqInst.len + 1

fn seqAdd(seqInst: var T[], val: T) =
    add(seqInst, val)

fn add(seqInst: T[]*, val: T) =
    if seqInst == nil:
        return
    if seqInst->buffer == nil || seqInst->len >= seqInst->cap:
        cheng__seqGrowToRaw(&seqInst->buffer, &seqInst->cap, seqInst->len + 1, int32(sizeof T))
    let elemBytes: int32 = seqInst->len * int32(sizeof T)
    let writePtr: T* = T*(ptr_add(seqInst->buffer, elemBytes))
    *writePtr = val
    seqInst->len = seqInst->len + 1

fn add(seqInst: var ptr[], val: void*) =
    let valPtr: ptr = ptr(val)
    add(seqInst, valPtr)

fn add(seqInst: ptr[]*, val: void*) =
    if seqInst == nil:
        return
    let valPtr: ptr = ptr(val)
    add(seqInst, valPtr)

fn findImpl(seqInst: T[], val: T, start: int32): int32 =
    var index: int32 = start
    if index < 0:
        index = 0
    let __for_guard_start_index_1 = index
    for __for_guard_index_1 in __for_guard_start_index_1..<seqInst.len:
        if ! (index < seqInst.len):
            break
        if seqInst[index] == val:
            return index
        index = index + 1
    return -1

fn find(seqInst: T[], val: T): int32 =
    return findImpl(seqInst, val, 0)

fn find(seqInst: T[], val: T, start: int32): int32 =
    return findImpl(seqInst, val, start)

fn delete(seqInst: var T[], at: int32) =
    if at < 0 || at >= seqInst.len:
        return
    var index: int32 = at
    let __for_guard_start_index_2 = index
    for __for_guard_index_2 in __for_guard_start_index_2..<seqInst.len:
        if ! (index + 1 < seqInst.len):
            break
        let srcBytes: int32 = (index + 1) * int32(sizeof T)
        let dstBytes: int32 = index * int32(sizeof T)
        let srcPtr: T* = T*(ptr_add(seqInst.buffer, srcBytes))
        let dstPtr: T* = T*(ptr_add(seqInst.buffer, dstBytes))
        *dstPtr = *srcPtr
        index = index + 1
    seqInst.len = seqInst.len - 1

fn delete(seqInst: T[]*, at: int32) =
    if seqInst == nil:
        return
    if at < 0 || at >= seqInst->len:
        return
    var index: int32 = at
    while index + 1 < seqInst->len:
        let srcBytes: int32 = (index + 1) * int32(sizeof T)
        let dstBytes: int32 = index * int32(sizeof T)
        let srcPtr: T* = T*(ptr_add(seqInst->buffer, srcBytes))
        let dstPtr: T* = T*(ptr_add(seqInst->buffer, dstBytes))
        *dstPtr = *srcPtr
        index = index + 1
    seqInst->len = seqInst->len - 1

fn freeSeqPtr(seqInst: var T[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0

fn freeSeqPtr(seqInst: T[]*) =
    if seqInst == nil:
        return
    if seqInst->buffer != nil:
        memRelease(seqInst->buffer)
    seqInst->buffer = nil
    seqInst->len = 0
    seqInst->cap = 0

fn freeSeq(seqInst: var T[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0

# Stage1/self-link fallback symbol for concrete str sequence free helper.
fn freeSeq_str(seqInst: var str[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0

fn freeSeq_ptr(seqInst: var ptr[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0

fn reset(seqInst: var T[]) =
    freeSeq(seqInst)

fn arcRetainSeq(seqInst: T[]) =
    if seqInst.buffer != nil:
        memRetain(seqInst.buffer)

fn arcReleaseSeq(seqInst: T[]) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)

# Monomorphized legacy alias for str sequence (kept for bootstrap compatibility).
type
    seq_string = str[]

fn newSeq_string(seqLen: int32, seqCap: int32): seq_string =
    var seqInst: seq_string
    if seqCap > 0:
        reserve(seqInst, seqCap)
    if seqLen > 0:
        setLen(seqInst, seqLen)
    return seqInst

fn get_string(seqInst: seq_string, at: int32): str =
    return seqInst[at]

fn add_string(seqInst: var seq_string, val: str) =
    add(seqInst, val)

fn arcRetainSeqString(seqInst: str[]) =
    if seqInst.buffer != nil:
        memRetain(seqInst.buffer)
    var index: int32 = 0
    let __for_guard_start_index_5 = index
    for __for_guard_index_5 in __for_guard_start_index_5..<seqInst.len:
        if ! (index < seqInst.len):
            break
        let value: str = seqInst[index]
        if value != nil:
            memRetain(void*(value))
        index = index + 1

fn arcReleaseSeqString(seqInst: str[]) =
    var index: int32 = 0
    let __for_guard_start_index_6 = index
    for __for_guard_index_6 in __for_guard_start_index_6..<seqInst.len:
        if ! (index < seqInst.len):
            break
        let value: str = seqInst[index]
        if value != nil:
            memRelease(void*(value))
        index = index + 1
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)

fn arcRetainSeq_string(seqInst: seq_string) =
    arcRetainSeqString(seqInst)

fn arcReleaseSeq_string(seqInst: seq_string) =
    arcReleaseSeqString(seqInst)

fn freeSeqPtr_string(seqInst: var seq_string) =
    if seqInst.buffer != nil:
        memRelease(seqInst.buffer)
    seqInst.buffer = nil
    seqInst.len = 0
    seqInst.cap = 0

fn __cheng_vec_contains(seqInst: T[], val: T): bool =
    var index: int32 = 0
    let count: int32 = seqInst.len
    let __for_guard_start_index_7 = index
    for __for_guard_index_7 in __for_guard_start_index_7..<count:
        if ! (index < count):
            break
        let cur: T = seqInst[index]
        if cur == val:
            return true
        index = index + 1
    return false

fn __cheng_slice_vec(seqInst: T[], start: int32, stop: int32, exclusive: bool): T[] =
    var startIndex: int32 = start
    var endIndex: int32 = stop
    if exclusive:
        endIndex = endIndex - 1
    if startIndex < 0:
        startIndex = 0
    var out: T[]
    if endIndex < startIndex || seqInst.len <= 0:
        return out
    if startIndex >= seqInst.len:
        return out
    if endIndex >= seqInst.len:
        endIndex = seqInst.len - 1
    reserve(out, endIndex - startIndex + 1)
    var index: int32 = startIndex
    let __for_guard_start_index_8 = index
    for __for_guard_index_8 in __for_guard_start_index_8..endIndex:
        if ! (index <= endIndex):
            break
        add(out, seqInst[index])
        index = index + 1
    return out
