# SHA-256 digest.

import std/rawbytes
import std/system
fn u32Mask(): int64 =
    return (int64(1) << 32) - 1

fn u32(x: int64): int64 =
    return x & u32Mask()

fn rotr32(x: int64, n: int32): int64 =
    let v: int64 = u32 x
    let rotated: int64 = (v >> n) | (v << (32 - n))
    return u32 rotated

fn ch(x: int64, y: int64, z: int64): int64 =
    let xu: int64 = u32 x
    let yu: int64 = u32 y
    let zu: int64 = u32 z
    let notXuRaw: int64 = xu ^ u32Mask()
    let notXu: int64 = u32 notXuRaw
    let mixed: int64 = (xu & yu) ^ (notXu & zu)
    return u32 mixed

fn maj(x: int64, y: int64, z: int64): int64 =
    let xu: int64 = u32 x
    let yu: int64 = u32 y
    let zu: int64 = u32 z
    let mixed: int64 = (xu & yu) ^ (xu & zu) ^ (yu & zu)
    return u32 mixed

fn bigSigma0(x: int64): int64 =
    let mixed: int64 = rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22)
    return u32 mixed

fn bigSigma1(x: int64): int64 =
    let mixed: int64 = rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25)
    return u32 mixed

fn smallSigma0(x: int64): int64 =
    let xu: int64 = u32 x
    let mixed: int64 = rotr32(x, 7) ^ rotr32(x, 18) ^ (xu >> 3)
    return u32 mixed

fn smallSigma1(x: int64): int64 =
    let xu: int64 = u32 x
    let mixed: int64 = rotr32(x, 17) ^ rotr32(x, 19) ^ (xu >> 10)
    return u32 mixed

fn u32FromBytes(b0: int32, b1: int32, b2: int32, b3: int32): int64 =
    return (int64(b0) << 24) | (int64(b1) << 16) | (int64(b2) << 8) | int64(b3)

fn k256(i: int32): int64 =
    case i
    of 0: return u32FromBytes(0x42, 0x8a, 0x2f, 0x98)
    of 1: return u32FromBytes(0x71, 0x37, 0x44, 0x91)
    of 2: return u32FromBytes(0xb5, 0xc0, 0xfb, 0xcf)
    of 3: return u32FromBytes(0xe9, 0xb5, 0xdb, 0xa5)
    of 4: return u32FromBytes(0x39, 0x56, 0xc2, 0x5b)
    of 5: return u32FromBytes(0x59, 0xf1, 0x11, 0xf1)
    of 6: return u32FromBytes(0x92, 0x3f, 0x82, 0xa4)
    of 7: return u32FromBytes(0xab, 0x1c, 0x5e, 0xd5)
    of 8: return u32FromBytes(0xd8, 0x07, 0xaa, 0x98)
    of 9: return u32FromBytes(0x12, 0x83, 0x5b, 0x01)
    of 10: return u32FromBytes(0x24, 0x31, 0x85, 0xbe)
    of 11: return u32FromBytes(0x55, 0x0c, 0x7d, 0xc3)
    of 12: return u32FromBytes(0x72, 0xbe, 0x5d, 0x74)
    of 13: return u32FromBytes(0x80, 0xde, 0xb1, 0xfe)
    of 14: return u32FromBytes(0x9b, 0xdc, 0x06, 0xa7)
    of 15: return u32FromBytes(0xc1, 0x9b, 0xf1, 0x74)
    of 16: return u32FromBytes(0xe4, 0x9b, 0x69, 0xc1)
    of 17: return u32FromBytes(0xef, 0xbe, 0x47, 0x86)
    of 18: return u32FromBytes(0x0f, 0xc1, 0x9d, 0xc6)
    of 19: return u32FromBytes(0x24, 0x0c, 0xa1, 0xcc)
    of 20: return u32FromBytes(0x2d, 0xe9, 0x2c, 0x6f)
    of 21: return u32FromBytes(0x4a, 0x74, 0x84, 0xaa)
    of 22: return u32FromBytes(0x5c, 0xb0, 0xa9, 0xdc)
    of 23: return u32FromBytes(0x76, 0xf9, 0x88, 0xda)
    of 24: return u32FromBytes(0x98, 0x3e, 0x51, 0x52)
    of 25: return u32FromBytes(0xa8, 0x31, 0xc6, 0x6d)
    of 26: return u32FromBytes(0xb0, 0x03, 0x27, 0xc8)
    of 27: return u32FromBytes(0xbf, 0x59, 0x7f, 0xc7)
    of 28: return u32FromBytes(0xc6, 0xe0, 0x0b, 0xf3)
    of 29: return u32FromBytes(0xd5, 0xa7, 0x91, 0x47)
    of 30: return u32FromBytes(0x06, 0xca, 0x63, 0x51)
    of 31: return u32FromBytes(0x14, 0x29, 0x29, 0x67)
    of 32: return u32FromBytes(0x27, 0xb7, 0x0a, 0x85)
    of 33: return u32FromBytes(0x2e, 0x1b, 0x21, 0x38)
    of 34: return u32FromBytes(0x4d, 0x2c, 0x6d, 0xfc)
    of 35: return u32FromBytes(0x53, 0x38, 0x0d, 0x13)
    of 36: return u32FromBytes(0x65, 0x0a, 0x73, 0x54)
    of 37: return u32FromBytes(0x76, 0x6a, 0x0a, 0xbb)
    of 38: return u32FromBytes(0x81, 0xc2, 0xc9, 0x2e)
    of 39: return u32FromBytes(0x92, 0x72, 0x2c, 0x85)
    of 40: return u32FromBytes(0xa2, 0xbf, 0xe8, 0xa1)
    of 41: return u32FromBytes(0xa8, 0x1a, 0x66, 0x4b)
    of 42: return u32FromBytes(0xc2, 0x4b, 0x8b, 0x70)
    of 43: return u32FromBytes(0xc7, 0x6c, 0x51, 0xa3)
    of 44: return u32FromBytes(0xd1, 0x92, 0xe8, 0x19)
    of 45: return u32FromBytes(0xd6, 0x99, 0x06, 0x24)
    of 46: return u32FromBytes(0xf4, 0x0e, 0x35, 0x85)
    of 47: return u32FromBytes(0x10, 0x6a, 0xa0, 0x70)
    of 48: return u32FromBytes(0x19, 0xa4, 0xc1, 0x16)
    of 49: return u32FromBytes(0x1e, 0x37, 0x6c, 0x08)
    of 50: return u32FromBytes(0x27, 0x48, 0x77, 0x4c)
    of 51: return u32FromBytes(0x34, 0xb0, 0xbc, 0xb5)
    of 52: return u32FromBytes(0x39, 0x1c, 0x0c, 0xb3)
    of 53: return u32FromBytes(0x4e, 0xd8, 0xaa, 0x4a)
    of 54: return u32FromBytes(0x5b, 0x9c, 0xca, 0x4f)
    of 55: return u32FromBytes(0x68, 0x2e, 0x6f, 0xf3)
    of 56: return u32FromBytes(0x74, 0x8f, 0x82, 0xee)
    of 57: return u32FromBytes(0x78, 0xa5, 0x63, 0x6f)
    of 58: return u32FromBytes(0x84, 0xc8, 0x78, 0x14)
    of 59: return u32FromBytes(0x8c, 0xc7, 0x02, 0x08)
    of 60: return u32FromBytes(0x90, 0xbe, 0xff, 0xfa)
    of 61: return u32FromBytes(0xa4, 0x50, 0x6c, 0xeb)
    of 62: return u32FromBytes(0xbe, 0xf9, 0xa3, 0xf7)
    of 63: return u32FromBytes(0xc6, 0x71, 0x78, 0xf2)
    else: return 0

fn getU32BE(data: Bytes, offset: int32): int64 =
    let b0: int64 = int64(bytesGet(data, offset))
    let b1: int64 = int64(bytesGet(data, offset + 1))
    let b2: int64 = int64(bytesGet(data, offset + 2))
    let b3: int64 = int64(bytesGet(data, offset + 3))
    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

fn setU32BE(data: Bytes, offset: int32, value: int64) =
    let v: int64 = u32(value)
    let byte0: int64 = (v >> 24) & 255
    let byte1: int64 = (v >> 16) & 255
    let byte2: int64 = (v >> 8) & 255
    let byte3: int64 = v & 255
    bytesSet(data, offset, int32(byte0))
    bytesSet(data, offset + 1, int32(byte1))
    bytesSet(data, offset + 2, int32(byte2))
    bytesSet(data, offset + 3, int32(byte3))

fn sha256Digest(data: Bytes): Bytes =
    var h0: int64 = u32FromBytes(0x6a, 0x09, 0xe6, 0x67)
    var h1: int64 = u32FromBytes(0xbb, 0x67, 0xae, 0x85)
    var h2: int64 = u32FromBytes(0x3c, 0x6e, 0xf3, 0x72)
    var h3: int64 = u32FromBytes(0xa5, 0x4f, 0xf5, 0x3a)
    var h4: int64 = u32FromBytes(0x51, 0x0e, 0x52, 0x7f)
    var h5: int64 = u32FromBytes(0x9b, 0x05, 0x68, 0x8c)
    var h6: int64 = u32FromBytes(0x1f, 0x83, 0xd9, 0xab)
    var h7: int64 = u32FromBytes(0x5b, 0xe0, 0xcd, 0x19)

    let inputLen: int32 = bytesLen data
    var padZero: int32 = 0
    while ((inputLen + 1 + padZero) % 64) != 56:
        padZero = padZero + 1
    let totalLen: int32 = inputLen + 1 + padZero + 8
    let msg: Bytes = bytesAlloc totalLen
    if inputLen > 0:
        copyMem(msg.data, data.data, inputLen)
    bytesSet(msg, inputLen, 0x80)
    var bitLen: int64 = int64(inputLen) * 8
    for i in 0..<8:
        let byteVal: int64 = bitLen & 255
        bytesSet(msg, totalLen - 1 - i, int32(byteVal))
        bitLen = bitLen >> 8

    let wbufLen: int32 = 64 * 4
    let wbuf: Bytes = bytesAlloc wbufLen
    var offset: int32 = 0
    while offset < totalLen:
        for t in 0..<16:
            let word: int64 = getU32BE(msg, offset + t * 4)
            setU32BE(wbuf, t * 4, word)
        t = 16
        let __for_start_t_1 = t
        for __for_t_1 in __for_start_t_1..<64:
            t = __for_t_1
            let w2: int64 = getU32BE(wbuf, (t - 2) * 4)
            let w7: int64 = getU32BE(wbuf, (t - 7) * 4)
            let w15: int64 = getU32BE(wbuf, (t - 15) * 4)
            let w16: int64 = getU32BE(wbuf, (t - 16) * 4)
            let sum: int64 = w16 + smallSigma0 w15 + w7 + smallSigma1 w2
            let next: int64 = u32(sum)
            setU32BE(wbuf, t * 4, next)
            t = t + 1

        var a: int64 = h0
        var b: int64 = h1
        var c: int64 = h2
        var d: int64 = h3
        var e: int64 = h4
        var f: int64 = h5
        var g: int64 = h6
        var h: int64 = h7

        t = 0
        let __for_start_t_2 = t
        for __for_t_2 in __for_start_t_2..<64:
            t = __for_t_2
            let wt: int64 = getU32BE(wbuf, t * 4)
            let sum1: int64 = h + bigSigma1 e + ch(e, f, g) + k256 t + wt
            let t1: int64 = u32 sum1
            let sum2: int64 = bigSigma0 a + maj(a, b, c)
            let t2: int64 = u32 sum2
            h = g
            g = f
            f = e
            let sumE: int64 = d + t1
            e = u32 sumE
            d = c
            c = b
            b = a
            let sumA: int64 = t1 + t2
            a = u32 sumA
            t = t + 1

        let sumH0: int64 = h0 + a
        let sumH1: int64 = h1 + b
        let sumH2: int64 = h2 + c
        let sumH3: int64 = h3 + d
        let sumH4: int64 = h4 + e
        let sumH5: int64 = h5 + f
        let sumH6: int64 = h6 + g
        let sumH7: int64 = h7 + h
        h0 = u32 sumH0
        h1 = u32 sumH1
        h2 = u32 sumH2
        h3 = u32 sumH3
        h4 = u32 sumH4
        h5 = u32 sumH5
        h6 = u32 sumH6
        h7 = u32 sumH7
        offset = offset + 64

    let out: Bytes = bytesAlloc 32
    setU32BE(out, 0, h0)
    setU32BE(out, 4, h1)
    setU32BE(out, 8, h2)
    setU32BE(out, 12, h3)
    setU32BE(out, 16, h4)
    setU32BE(out, 20, h5)
    setU32BE(out, 24, h6)
    setU32BE(out, 28, h7)
    return out
