# GF(256) arithmetic helpers(AES polynomial).

import std/result
import std/rawbytes
const
    gf256Poly = 0x11b

fn gf256Add(a: int32, b: int32): int32 =
    return a ^ b

fn gf256Mul(a: int32, b: int32): int32 =
    var x: int32 = a & 255
    var y: int32 = b & 255
    var res: int32 = 0
    for i in 0..<8:
        if (y & 1) != 0:
            res = res ^ x
        let carry: int32 = x & 0x80
        x = (x << 1) & 0xFF
        if carry != 0:
            x = x ^(gf256Poly & 0xFF)
        y = y >> 1
    return res & 0xFF

fn gf256Pow(a: int32, exp: int32): int32 =
    var result: int32 = 1
    var base: int32 = a & 255
    var e: int32 = exp
    while e > 0:
        if (e & 1) != 0:
            result = gf256Mul(result, base)
        base = gf256Mul(base, base)
        e = e >> 1
    return result & 0xFF

fn gf256Inv(a: int32): Result[int32] =
    let v: int32 = a & 255
    if v == 0:
        return Err[int32]("gf256: inverse of zero")
    return Ok[int32](gf256Pow(v, 254))

fn gf256MulBytes(data: Bytes, factor: int32): Bytes =
    let out: Bytes = bytesAlloc(bytesLen(data))
    for i in 0..<bytesLen(data):
        let v: int32 = gf256Mul(bytesGet(data, i), factor)
        bytesSet(out, i, v)
    return out

fn gf256XorBytes(a: Bytes, b: Bytes): Result[Bytes] =
    if bytesLen(a) != bytesLen(b):
        return Err[Bytes]("gf256: length mismatch")
    let out: Bytes = bytesAlloc(bytesLen(a))
    for i in 0..<bytesLen(a):
        bytesSet(out, i, bytesGet(a, i) ^ bytesGet(b, i))
    return Ok[Bytes](out)
