# ChaCha20-Poly1305 AEAD(RFC 8439).

import std/result
import std/rawbytes
import std/buffer
const
    chaChaPolyKeySize: int32 = 32
    chaChaPolyNonceSize: int32 = 12
    chaChaPolyTagSize: int32 = 16
    chaChaStateWords: int32 = 16

type
    ChaChaPolyKey =
        data: Bytes

    ChaChaPolyNonce =
        data: Bytes

    ChaChaPolyTag =
        data: Bytes

fn intoChaChaPolyKey(data: Bytes): Result[ChaChaPolyKey] =
    if bytesLen(data) != chaChaPolyKeySize:
        return Err[ChaChaPolyKey]("chacha20poly1305: invalid key size")
    var key: ChaChaPolyKey
    key.data = data
    return Ok[ChaChaPolyKey](key)

fn intoChaChaPolyNonce(data: Bytes): Result[ChaChaPolyNonce] =
    if bytesLen(data) != chaChaPolyNonceSize:
        return Err[ChaChaPolyNonce]("chacha20poly1305: invalid nonce size")
    var nonce: ChaChaPolyNonce
    nonce.data = data
    return Ok[ChaChaPolyNonce](nonce)

fn intoChaChaPolyTag(data: Bytes): Result[ChaChaPolyTag] =
    if bytesLen(data) != chaChaPolyTagSize:
        return Err[ChaChaPolyTag]("chacha20poly1305: invalid tag size")
    var tag: ChaChaPolyTag
    tag.data = data
    return Ok[ChaChaPolyTag](tag)

fn chachaU32Mask(): int64 =
    return (int64(1) << 32) - 1

fn chachaU32(x: int64): int64 =
    return x & chachaU32Mask()

fn rotl32(x: int64, n: int32): int64 =
    return chachaU32((x << n) | (chachaU32(x) >> (32 - n)))

fn loadU32LE(data: Bytes, offset: int32): int64 =
    let b0: int64 = int64(bytesGet(data, offset))
    let b1: int64 = int64(bytesGet(data, offset + 1))
    let b2: int64 = int64(bytesGet(data, offset + 2))
    let b3: int64 = int64(bytesGet(data, offset + 3))
    return chachaU32(b0 | (b1 << 8) | (b2 << 16) | (b3 << 24))

fn loadU32LE(data: var Bytes, offset: int32): int64 =
    let b0: int64 = int64(bytesGet(data, offset))
    let b1: int64 = int64(bytesGet(data, offset + 1))
    let b2: int64 = int64(bytesGet(data, offset + 2))
    let b3: int64 = int64(bytesGet(data, offset + 3))
    return chachaU32(b0 | (b1 << 8) | (b2 << 16) | (b3 << 24))

fn storeU32LE(data: Bytes, offset: int32, value: int64) =
    let v: int64 = chachaU32(value)
    bytesSet(data, offset, int32(v & 0xff))
    bytesSet(data, offset + 1, int32((v >> 8) & 0xff))
    bytesSet(data, offset + 2, int32((v >> 16) & 0xff))
    bytesSet(data, offset + 3, int32((v >> 24) & 0xff))

fn storeU32LE(data: var Bytes, offset: int32, value: int64) =
    let v: int64 = chachaU32(value)
    bytesSet(data, offset, int32(v & 0xff))
    bytesSet(data, offset + 1, int32((v >> 8) & 0xff))
    bytesSet(data, offset + 2, int32((v >> 16) & 0xff))
    bytesSet(data, offset + 3, int32((v >> 24) & 0xff))

fn chachaQuarterRound(state: var Bytes, a: int32, b: int32,
                      c: int32, d: int32) =
    let ao: int32 = a * 4
    let bo: int32 = b * 4
    let co: int32 = c * 4
    let dof: int32 = d * 4
    var av: int64 = loadU32LE(state, ao)
    var bv: int64 = loadU32LE(state, bo)
    var cv: int64 = loadU32LE(state, co)
    var dv: int64 = loadU32LE(state, dof)
    av = chachaU32(av + bv)
    dv = rotl32(dv ^ av, 16)
    cv = chachaU32(cv + dv)
    bv = rotl32(bv ^ cv, 12)
    av = chachaU32(av + bv)
    dv = rotl32(dv ^ av, 8)
    cv = chachaU32(cv + dv)
    bv = rotl32(bv ^ cv, 7)
    storeU32LE(state, ao, av)
    storeU32LE(state, bo, bv)
    storeU32LE(state, co, cv)
    storeU32LE(state, dof, dv)

fn chacha20Block(key: Bytes, counter: int32, nonce: Bytes): Bytes =
    let state: Bytes = bytesAlloc(64)
    storeU32LE(state, 0, int64(0x61707865))
    storeU32LE(state, 4, int64(0x3320646e))
    storeU32LE(state, 8, int64(0x79622d32))
    storeU32LE(state, 12, int64(0x6b206574))
    for i in 0..<8:
        storeU32LE(state, (4 + i) * 4, loadU32LE(key, i * 4))
    storeU32LE(state, 48, chachaU32(counter))
    storeU32LE(state, 52, loadU32LE(nonce, 0))
    storeU32LE(state, 56, loadU32LE(nonce, 4))
    storeU32LE(state, 60, loadU32LE(nonce, 8))
    let working: Bytes = bytesAlloc(64)
    for j in 0..<64:
        bytesSet(working, j, bytesGet(state, j))
    for rounds in 0..<10:
        chachaQuarterRound(working, 0, 4, 8, 12)
        chachaQuarterRound(working, 1, 5, 9, 13)
        chachaQuarterRound(working, 2, 6, 10, 14)
        chachaQuarterRound(working, 3, 7, 11, 15)
        chachaQuarterRound(working, 0, 5, 10, 15)
        chachaQuarterRound(working, 1, 6, 11, 12)
        chachaQuarterRound(working, 2, 7, 8, 13)
        chachaQuarterRound(working, 3, 4, 9, 14)
    let out: Bytes = bytesAlloc(64)
    for i in 0..<chaChaStateWords:
        let v: int64 = chachaU32(loadU32LE(working, i * 4) + loadU32LE(state, i * 4))
        storeU32LE(out, i * 4, v)
    return out

fn chacha20Xor(data: Bytes, key: Bytes, nonce: Bytes, counter: int32): Result[bool] =
    let total: int32 = bytesLen(data)
    if total <= 0:
        return Ok[bool](true)
    var blockCounter: int32 = counter
    var offset: int32 = 0
    let __for_guard_start_offset_1 = offset
    for __for_guard_offset_1 in __for_guard_start_offset_1..<total:
        if ! (offset < total):
            break
        let block: Bytes = chacha20Block(key, blockCounter, nonce)
        let blockLen: int32 = 64
        for i in 0..<blockLen:
            if !(offset < total):
                break
            let v: int32 = bytesGet(data, offset) ^ bytesGet(block, i)
            bytesSet(data, offset, v)
            offset = offset + 1
        blockCounter = blockCounter + 1
    return Ok[bool](true)

type
    PolyState =
        r0: int64
        r1: int64
        r2: int64
        r3: int64
        r4: int64
        s1: int64
        s2: int64
        s3: int64
        s4: int64
        h0: int64
        h1: int64
        h2: int64
        h3: int64
        h4: int64

fn poly1305Init(key: Bytes): PolyState =
    let t0: int64 = loadU32LE(key, 0)
    let t1: int64 = loadU32LE(key, 4)
    let t2: int64 = loadU32LE(key, 8)
    let t3: int64 = loadU32LE(key, 12)
    var st: PolyState
    st.r0 = t0 & 0x3ffffff
    st.r1 = ((t0 >> 26) | (t1 << 6)) & 0x3ffff03
    st.r2 = ((t1 >> 20) | (t2 << 12)) & 0x3ffc0ff
    st.r3 = ((t2 >> 14) | (t3 << 18)) & 0x3f03fff
    st.r4 = (t3 >> 8) & 0x00fffff
    st.s1 = st.r1 * 5
    st.s2 = st.r2 * 5
    st.s3 = st.r3 * 5
    st.s4 = st.r4 * 5
    st.h0 = 0
    st.h1 = 0
    st.h2 = 0
    st.h3 = 0
    st.h4 = 0
    return st

fn poly1305Block(st: var PolyState, block: Bytes, hibit: int64) =
    let t0: int64 = loadU32LE(block, 0)
    let t1: int64 = loadU32LE(block, 4)
    let t2: int64 = loadU32LE(block, 8)
    let t3: int64 = loadU32LE(block, 12)
    let b0: int64 = t0 & 0x3ffffff
    let b1: int64 = ((t0 >> 26) | (t1 << 6)) & 0x3ffffff
    let b2: int64 = ((t1 >> 20) | (t2 << 12)) & 0x3ffffff
    let b3: int64 = ((t2 >> 14) | (t3 << 18)) & 0x3ffffff
    let b4: int64 = (t3 >> 8) | hibit
    st.h0 = st.h0 + b0
    st.h1 = st.h1 + b1
    st.h2 = st.h2 + b2
    st.h3 = st.h3 + b3
    st.h4 = st.h4 + b4
    let d0: int64 = st.h0 * st.r0 + st.h1 * st.s4 + st.h2 * st.s3 + st.h3 * st.s2 + st.h4 * st.s1
    let d1: int64 = st.h0 * st.r1 + st.h1 * st.r0 + st.h2 * st.s4 + st.h3 * st.s3 + st.h4 * st.s2
    let d2: int64 = st.h0 * st.r2 + st.h1 * st.r1 + st.h2 * st.r0 + st.h3 * st.s4 + st.h4 * st.s3
    let d3: int64 = st.h0 * st.r3 + st.h1 * st.r2 + st.h2 * st.r1 + st.h3 * st.r0 + st.h4 * st.s4
    let d4: int64 = st.h0 * st.r4 + st.h1 * st.r3 + st.h2 * st.r2 + st.h3 * st.r1 + st.h4 * st.r0
    var c: int64 = d0 >> 26
    st.h0 = d0 & 0x3ffffff
    var d1c: int64 = d1 + c
    c = d1c >> 26
    st.h1 = d1c & 0x3ffffff
    var d2c: int64 = d2 + c
    c = d2c >> 26
    st.h2 = d2c & 0x3ffffff
    var d3c: int64 = d3 + c
    c = d3c >> 26
    st.h3 = d3c & 0x3ffffff
    var d4c: int64 = d4 + c
    c = d4c >> 26
    st.h4 = d4c & 0x3ffffff
    st.h0 = st.h0 + c * 5
    c = st.h0 >> 26
    st.h0 = st.h0 & 0x3ffffff
    st.h1 = st.h1 + c

fn poly1305Tag(key: Bytes, data: Bytes): Bytes =
    var st: PolyState = poly1305Init(key)
    let total: int32 = bytesLen(data)
    var offset: int32 = 0
    while offset + 16 <= total:
        let block: Bytes = bytesSliceView(data, offset, 16)
        poly1305Block(st, block, 1 << 24)
        offset = offset + 16
    if offset < total:
        let block: Bytes = bytesAlloc(16)
        for i in 0..<total - offset:
            bytesSet(block, i, bytesGet(data, offset + i))
        bytesSet(block, total - offset, 1)
        poly1305Block(st, block, 0)
    var c: int64 = st.h1 >> 26
    st.h1 = st.h1 & 0x3ffffff
    st.h2 = st.h2 + c
    c = st.h2 >> 26
    st.h2 = st.h2 & 0x3ffffff
    st.h3 = st.h3 + c
    c = st.h3 >> 26
    st.h3 = st.h3 & 0x3ffffff
    st.h4 = st.h4 + c
    c = st.h4 >> 26
    st.h4 = st.h4 & 0x3ffffff
    st.h0 = st.h0 + c * 5
    c = st.h0 >> 26
    st.h0 = st.h0 & 0x3ffffff
    st.h1 = st.h1 + c
    var g0: int64 = st.h0 + 5
    c = g0 >> 26
    g0 = g0 & 0x3ffffff
    var g1: int64 = st.h1 + c
    c = g1 >> 26
    g1 = g1 & 0x3ffffff
    var g2: int64 = st.h2 + c
    c = g2 >> 26
    g2 = g2 & 0x3ffffff
    var g3: int64 = st.h3 + c
    c = g3 >> 26
    g3 = g3 & 0x3ffffff
    var g4: int64 = st.h4 + c - (1 << 26)
    if g4 >= 0:
        st.h0 = g0
        st.h1 = g1
        st.h2 = g2
        st.h3 = g3
        st.h4 = g4
    let f0: int64 = chachaU32(st.h0 | (st.h1 << 26))
    let f1: int64 = chachaU32((st.h1 >> 6) | (st.h2 << 20))
    let f2: int64 = chachaU32((st.h2 >> 12) | (st.h3 << 14))
    let f3: int64 = chachaU32((st.h3 >> 18) | (st.h4 << 8))
    let s0: int64 = loadU32LE(key, 16)
    let s1: int64 = loadU32LE(key, 20)
    let s2: int64 = loadU32LE(key, 24)
    let s3: int64 = loadU32LE(key, 28)
    var t0: int64 = f0 + s0
    var t1: int64 = f1 + s1 + (t0 >> 32)
    var t2: int64 = f2 + s2 + (t1 >> 32)
    var t3: int64 = f3 + s3 + (t2 >> 32)
    let tag: Bytes = bytesAlloc(16)
    storeU32LE(tag, 0, t0)
    storeU32LE(tag, 4, t1)
    storeU32LE(tag, 8, t2)
    storeU32LE(tag, 12, t3)
    return tag

fn poly1305Pad16(buf: var ByteBuffer, length: int32) =
    let rem: int32 = length % 16
    if rem == 0:
        return
    for i in 0..<16 - rem:
        appendByte(buf, 0)

fn appendU64LE(buf: var ByteBuffer, value: int64) =
    var v: int64 = value
    for i in 0..<8:
        appendByte(buf, int32(v & 0xff))
        v = v >> 8

fn buildPoly1305Input(aad: Bytes, ciphertext: Bytes): Bytes =
    var buf: ByteBuffer = newByteBuffer()
    appendBytes(buf, aad)
    poly1305Pad16(buf, bytesLen(aad))
    appendBytes(buf, ciphertext)
    poly1305Pad16(buf, bytesLen(ciphertext))
    appendU64LE(buf, int64(bytesLen(aad)))
    appendU64LE(buf, int64(bytesLen(ciphertext)))
    return toBytes(buf)

fn tagEqual(a: Bytes, b: Bytes): bool =
    if bytesLen(a) != bytesLen(b):
        return false
    var diff: int32 = 0
    for i in 0..<bytesLen(a):
        diff = diff | (bytesGet(a, i) ^ bytesGet(b, i))
    return diff == 0

fn encrypt(key: ChaChaPolyKey, nonce: ChaChaPolyNonce, tag: var ChaChaPolyTag, data: Bytes, aad: Bytes): Result[bool] =
    if bytesLen(key.data) != chaChaPolyKeySize:
        return Err[bool]("chacha20poly1305: invalid key")
    if bytesLen(nonce.data) != chaChaPolyNonceSize:
        return Err[bool]("chacha20poly1305: invalid nonce")
    let block0: Bytes = chacha20Block(key.data, 0, nonce.data)
    let polyKey: Bytes = bytesSlice(block0, 0, 32)
    let xorRes: Result[bool] = chacha20Xor(data, key.data, nonce.data, 1)
    if IsErr(xorRes):
        return Err[bool](Error(xorRes))
    let macInput: Bytes = buildPoly1305Input(aad, data)
    let tagBytes: Bytes = poly1305Tag(polyKey, macInput)
    tag.data = tagBytes
    return Ok[bool](true)

fn decrypt(key: ChaChaPolyKey, nonce: ChaChaPolyNonce, tag: ChaChaPolyTag, data: Bytes, aad: Bytes): Result[bool] =
    if bytesLen(key.data) != chaChaPolyKeySize:
        return Err[bool]("chacha20poly1305: invalid key")
    if bytesLen(nonce.data) != chaChaPolyNonceSize:
        return Err[bool]("chacha20poly1305: invalid nonce")
    if bytesLen(tag.data) != chaChaPolyTagSize:
        return Err[bool]("chacha20poly1305: invalid tag")
    let block0: Bytes = chacha20Block(key.data, 0, nonce.data)
    let polyKey: Bytes = bytesSlice(block0, 0, 32)
    let macInput: Bytes = buildPoly1305Input(aad, data)
    let expect: Bytes = poly1305Tag(polyKey, macInput)
    if ! tagEqual(expect, tag.data):
        return Err[bool]("chacha20poly1305: tag mismatch")
    let xorRes: Result[bool] = chacha20Xor(data, key.data, nonce.data, 1)
    if IsErr(xorRes):
        return Err[bool](Error(xorRes))
    return Ok[bool](true)
