
@importc("__cheng_linux_syscall0")
fn cheng_linux_syscall0(nr: int64): int64
@importc("__cheng_linux_syscall1")
fn cheng_linux_syscall1(nr: int64, a0: int64): int64
@importc("__cheng_linux_syscall2")
fn cheng_linux_syscall2(nr: int64, a0: int64, a1: int64): int64
@importc("__cheng_linux_syscall3")
fn cheng_linux_syscall3(nr: int64, a0: int64, a1: int64, a2: int64): int64
@importc("__cheng_linux_syscall4")
fn cheng_linux_syscall4(nr: int64, a0: int64, a1: int64, a2: int64, a3: int64): int64
@importc("__cheng_linux_syscall5")
fn cheng_linux_syscall5(nr: int64, a0: int64, a1: int64, a2: int64, a3: int64, a4: int64): int64
@importc("__cheng_linux_syscall6")
fn cheng_linux_syscall6(nr: int64, a0: int64, a1: int64, a2: int64, a3: int64, a4: int64, a5: int64): int64

const
    cheng_sys_write: int64 = 64
    cheng_sys_exit: int64 = 93
    cheng_sys_exit_group: int64 = 94
    cheng_sys_mmap: int64 = 222
    cheng_sys_munmap: int64 = 215
    cheng_sys_socket: int64 = 198
    cheng_sys_send: int64 = 64
    cheng_sys_recv: int64 = 65
    cheng_sys_bind: int64 = 200
    cheng_sys_listen: int64 = 201
    cheng_sys_getsockname: int64 = 204
    cheng_sys_getpeername: int64 = 205
    cheng_sys_connect: int64 = 203
    cheng_sys_accept: int64 = 202
    cheng_sys_shutdown: int64 = 210
    cheng_sys_socketpair: int64 = 199
    cheng_sys_getsockopt: int64 = 209
    cheng_sys_sendto: int64 = 206
    cheng_sys_recvfrom: int64 = 207
    cheng_sys_setsockopt: int64 = 208
    cheng_sys_sendmsg: int64 = 211
    cheng_sys_recvmsg: int64 = 212
    cheng_sys_close: int64 = 57

    cheng_af_inet: int32 = 2
    cheng_af_inet6: int32 = 10
    cheng_sock_stream: int32 = 1
    cheng_sock_dgram: int32 = 2
    cheng_ipproto_ip: int32 = 0
    cheng_ipproto_udp: int32 = 17
    cheng_sol_socket: int32 = 1
    cheng_sol_udp: int32 = 17
    cheng_so_reuseaddr: int32 = 2
    cheng_so_reuseport: int32 = 15
    cheng_so_broadcast: int32 = 6
    cheng_so_rcvtimeo: int32 = 20
    cheng_so_sndtimeo: int32 = 21
    cheng_ip_ttl: int32 = 2
    cheng_ip_multicast_if: int32 = 32
    cheng_ip_multicast_ttl: int32 = 33
    cheng_ip_multicast_loop: int32 = 34
    cheng_ip_add_membership: int32 = 35
    cheng_ip_drop_membership: int32 = 36
    cheng_msg_oob: int32 = 1
    cheng_msg_peek: int32 = 2
    cheng_msg_dont_route: int32 = 4
    cheng_msg_more: int32 = 32768
    cheng_msg_waitall: int32 = 256
    cheng_msg_waitforone: int32 = 0x10000
    cheng_msg_eor: int32 = 128
    cheng_msg_dontwait: int32 = 64
    cheng_msg_nosignal: int32 = 16384
    cheng_inaddr_loopback: int32 = 2130706433
    cheng_inaddr_any: int32 = 0
    cheng_sockaddr_in_len: int32 = 16
    cheng_ebadf: int32 = 9
    cheng_einval: int32 = 22
    cheng_efault: int32 = 14

    cheng_prot_read: int64 = 1
    cheng_prot_write: int64 = 2
    cheng_map_private: int64 = 2
    cheng_map_anon: int64 = 32

    cheng_page_size: int64 = 4096
    cheng_ptrmap_tomb: uint64 = 1

type
    VoidPtr = void*
    ChengRawHdr =
        mapSize: int64

    ChengMemScope =
        parent: ChengMemScope*
        head: ChengMemBlock*

    ChengMemBlock =
        prev: ChengMemBlock*
        next: ChengMemBlock*
        scope: ChengMemScope*
        size: int64
        mapSize: int64
        rc: int32
        _pad: int32

    ChengSeqHeader =
        len: int32
        cap: int32
        buffer: void*

    ChengAwaitI32 =
        status: int32
        value: int32

    ChengAwaitVoid =
        status: int32

    ChengChanI32 =
        cap: int32
        count: int32
        head: int32
        tail: int32
        buffer: int32*
    ChengIov =
        base: void*
        len: int64
    ChengMsghdr =
        name: void*
        nameLen: int32
        _padNameLen: int32
        iov: void*
        iovLen: int64
        control: void*
        controlLen: int64
        flags: int32
    ChengIpMreq =
        multiaddr: uint32
        interface: uint32

var
    cheng_global_scope: ChengMemScope*
    cheng_scope_current: ChengMemScope*

    cheng_mm_retain_total: int64
    cheng_mm_release_total: int64
    cheng_mm_alloc_total: int64
    cheng_mm_free_total: int64
    cheng_mm_live_total: int64

    cheng_block_map_keys: uint64*
    cheng_block_map_vals: ChengMemBlock**
    cheng_block_map_cap: int64
    cheng_block_map_count: int64
    cheng_block_map_tombs: int64
    cheng_errno_code: int32

fn puts_runtime(text: char*): int32 =
    return cheng_puts(text)
fn cheng_strlen_runtime(s: char*): int32 =
    if s == nil:
        return 0
    var n: int32 = 0
    while *(char*(ptr_add(void*(s), n))) != '\0':
        n = n + 1
    return n
fn cheng_memcpy_ffi_runtime(dest: void*, src: void*, n: int64): void* =
    return cheng_memcpy(dest, src, n)
fn cheng_memset_ffi_runtime(dest: void*, val: int32, n: int64): void* =
    return cheng_memset(dest, val, n)
fn cheng_ptr_size_runtime(): int32 =
    return cheng_ptr_size()
fn cheng_ptr_to_u64_runtime(p: void*): uint64 =
    return cheng_ptr_to_u64(p)
fn cheng_seq_get_runtime(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_seq_get(buffer, len, idx, elemSize)
fn cheng_seq_set_runtime(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_seq_set(buffer, len, idx, elemSize)

fn cheng_ptr_size(): int32 =
    return 8

fn cheng_ptr_to_u64(p: void*): uint64 =
    return uint64(p)

fn cheng_align_up(v: int64, a: int64): int64 =
    if a <= 1:
        return v
    let m: int64 = v % a
    if m == 0:
        return v
    return v + (a - m)

fn cheng_sys_is_err(v: int64): bool =
    return v < 0 && v >= -4095

@weak
fn store_int32(p: void*, val: int32) =
    if p == nil:
        return
    let pp: int32* = int32*(p)
    *pp = val

fn load_int32(p: void*): int32 =
    if p == nil:
        return 0
    let pp: int32* = int32*(p)
    return *pp

@weak
fn store_bool(p: void*, val: int8) =
    if p == nil:
        return
    let pp: int8* = int8*(p)
    *pp = val

@weak
fn load_bool(p: void*): int8 =
    if p == nil:
        return 0
    let pp: int8* = int8*(p)
    return *pp

fn cheng_bytes_copy(dst: void*, src: void*, n: int64) =
    if dst == nil || src == nil || n <= 0:
        return
    for i in 0..<n:
        let b: uint8 = *(uint8*(ptr_add(src, int32(i))))
        *(uint8*(ptr_add(dst, int32(i)))) = b

fn cheng_bytes_set(dst: void*, value: int32, n: int64) =
    if dst == nil || n <= 0:
        return
    let b: uint8 = uint8(value & 0xFF)
    for i in 0..<n:
        *(uint8*(ptr_add(dst, int32(i)))) = b

fn cheng_bytes_cmp(a: void*, b: void*, n: int64): int32 =
    if n <= 0:
        return 0
    for i in 0..<n:
        let av: uint8 = *(uint8*(ptr_add(a, int32(i))))
        let bv: uint8 = *(uint8*(ptr_add(b, int32(i))))
        if av < bv:
            return -1
        if av > bv:
            return 1
    return 0

fn cheng_strlen(s: char*): int32 =
    if s == nil:
        return 0
    var n: int32 = 0
    while *(char*(ptr_add(void*(s), n))) != '\0':
        n = n + 1
    return n

fn cheng_strcmp(a: char*, b: char*): int32 =
    if a == b:
        return 0
    var pa: char* = a
    var pb: char* = b
    if pa == nil:
        pa = ""
    if pb == nil:
        pb = ""
    var i: int32 = 0
    while true:
        let ca: uint8 = uint8(int32(*(char*(ptr_add(void*(pa), i)))) & 0xFF)
        let cb: uint8 = uint8(int32(*(char*(ptr_add(void*(pb), i)))) & 0xFF)
        if ca < cb:
            return -1
        if ca > cb:
            return 1
        if ca == 0:
            return 0
        i = i + 1

fn cheng_memcpy(dest: void*, src: void*, n: int64): void* =
    cheng_bytes_copy(dest, src, n)
    return dest

fn cheng_memset(dest: void*, val: int32, n: int64): void* =
    cheng_bytes_set(dest, val, n)
    return dest

fn cheng_memcmp(a: void*, b: void*, n: int64): int32 =
    return cheng_bytes_cmp(a, b, n)

fn cheng_mmap_alloc(total: int64): void* =
    let ret: int64 = cheng_linux_syscall6(cheng_sys_mmap,
                                          0,
                                          total,
                                          cheng_prot_read | cheng_prot_write,
                                          cheng_map_private | cheng_map_anon,
                                          -1,
                                          0)
    if cheng_sys_is_err(ret):
        return nil
    return void*(uint64(ret))

fn cheng_munmap_region(addr: void*, total: int64): int32 =
    if addr == nil || total <= 0:
        return 0
    let ret: int64 = cheng_linux_syscall2(cheng_sys_munmap, int64(uint64(addr)), total)
    return cheng_sys_is_err(ret) ? -1 : 0

fn cheng_raw_alloc(size: int64): void* =
    var n: int64 = size
    if n <= 0:
        n = 1
    let header: int64 = int64(sizeof ChengRawHdr)
    let total: int64 = cheng_align_up(header + n, cheng_page_size)
    let raw: void* = cheng_mmap_alloc(total)
    if raw == nil:
        return nil
    let hdr: ChengRawHdr* = ChengRawHdr*(raw)
    hdr->mapSize = total
    return ptr_add(raw, int32(header))

fn cheng_raw_free(p: void*) =
    if p == nil:
        return
    let header: int32 = int32(sizeof ChengRawHdr)
    let raw: void* = ptr_add(p, -header)
    let hdr: ChengRawHdr* = ChengRawHdr*(raw)
    let total: int64 = hdr->mapSize
    cheng_munmap_region(raw, total)

fn cheng_mem_global(): ChengMemScope* =
    if cheng_global_scope != nil:
        return cheng_global_scope
    let mem: void* = cheng_raw_alloc(int64(sizeof ChengMemScope))
    if mem == nil:
        return nil
    let scope: ChengMemScope* = ChengMemScope*(mem)
    scope->parent = nil
    scope->head = nil
    cheng_global_scope = scope
    return scope

fn cheng_mem_current(): ChengMemScope* =
    if cheng_scope_current == nil:
        cheng_scope_current = cheng_mem_global()
    return cheng_scope_current

fn cheng_ptr_hash(v0: uint64): uint64 =
    var v: uint64 = v0
    v = v ^ (v >> uint64(33))
    v = v * uint64(0xff51afd7ed558ccd)
    v = v ^ (v >> uint64(33))
    v = v * uint64(0xc4ceb9fe1a85ec53)
    v = v ^ (v >> uint64(33))
    return v

fn cheng_ptrmap_init(cap: int64) =
    var n: int64 = 1
    while n < cap:
        n = n << 1
    let keysMem: void* = cheng_raw_alloc(n * int64(sizeof uint64))
    let valsMem: void* = cheng_raw_alloc(n * int64(sizeof VoidPtr))
    if keysMem == nil || valsMem == nil:
        cheng_raw_free(keysMem)
        cheng_raw_free(valsMem)
        cheng_block_map_keys = nil
        cheng_block_map_vals = nil
        cheng_block_map_cap = 0
        cheng_block_map_count = 0
        cheng_block_map_tombs = 0
        return
    cheng_block_map_keys = uint64*(keysMem)
    cheng_block_map_vals = ChengMemBlock**(valsMem)
    cheng_block_map_cap = n
    cheng_block_map_count = 0
    cheng_block_map_tombs = 0

fn cheng_ptrmap_get(key: void*): ChengMemBlock* =
    if key == nil || cheng_block_map_cap == 0:
        return nil
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return nil
    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    while true:
        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
        if cur == 0:
            return nil
        if cur == k:
            return *(ChengMemBlock**(void*(valsBase + (idx * uint64(8)))))
        idx = (idx + 1) & mask

fn cheng_ptrmap_grow() =
    let oldcap: int64 = cheng_block_map_cap
    let oldkeys: uint64* = cheng_block_map_keys
    let oldvals: ChengMemBlock** = cheng_block_map_vals
    let oldcount: int64 = cheng_block_map_count
    let oldtombs: int64 = cheng_block_map_tombs
    let newcap: int64 = oldcap > 0 ? (oldcap * 2) : 1024

    cheng_block_map_keys = nil
    cheng_block_map_vals = nil
    cheng_block_map_cap = 0
    cheng_block_map_count = 0
    cheng_block_map_tombs = 0
    cheng_ptrmap_init(newcap)
    if cheng_block_map_cap == 0:
        cheng_block_map_keys = oldkeys
        cheng_block_map_vals = oldvals
        cheng_block_map_cap = oldcap
        cheng_block_map_count = oldcount
        cheng_block_map_tombs = oldtombs
        return

    if oldkeys != nil && oldcap > 0:
        let newMask: uint64 = uint64(cheng_block_map_cap - 1)
        let keysBase: uint64 = uint64(cheng_block_map_keys)
        let valsBase: uint64 = uint64(cheng_block_map_vals)
        let oldKeysBase: uint64 = uint64(oldkeys)
        let oldValsBase: uint64 = uint64(oldvals)
        for i in 0..<oldcap:
            let k: uint64 = *(uint64*(void*(oldKeysBase + (uint64(i) * uint64(8)))))
            if k > cheng_ptrmap_tomb:
                let v: ChengMemBlock* = *(ChengMemBlock**(void*(oldValsBase + (uint64(i) * uint64(8)))))
                if v != nil:
                    var idx: uint64 = cheng_ptr_hash(k) & newMask
                    while true:
                        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
                        if cur == 0:
                            *(uint64*(void*(keysBase + (idx * uint64(8))))) = k
                            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = v
                            cheng_block_map_count = cheng_block_map_count + 1
                            break
                        idx = (idx + 1) & newMask
        cheng_raw_free(void*(oldkeys))
        cheng_raw_free(void*(oldvals))

fn cheng_ptrmap_put(key: void*, val: ChengMemBlock*) =
    if key == nil:
        return
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return
    if cheng_block_map_cap == 0:
        cheng_ptrmap_init(65536)
        if cheng_block_map_cap == 0:
            return

    if (cheng_block_map_count + cheng_block_map_tombs) * 10 >= cheng_block_map_cap * 7:
        cheng_ptrmap_grow()
        if cheng_block_map_cap == 0:
            return

    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    var firstTomb: int64 = -1
    while true:
        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
        if cur == k:
            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = val
            return
        if cur == cheng_ptrmap_tomb && firstTomb < 0:
            firstTomb = int64(idx)
        if cur == 0:
            var useIdx: uint64 = idx
            if firstTomb >= 0:
                useIdx = uint64(firstTomb)
                cheng_block_map_tombs = cheng_block_map_tombs - 1
            *(uint64*(void*(keysBase + (useIdx * uint64(8))))) = k
            *(ChengMemBlock**(void*(valsBase + (useIdx * uint64(8))))) = val
            cheng_block_map_count = cheng_block_map_count + 1
            return
        idx = (idx + 1) & mask

fn cheng_ptrmap_del(key: void*) =
    if key == nil || cheng_block_map_cap == 0:
        return
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return
    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    while true:
        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
        if cur == 0:
            return
        if cur == k:
            *(uint64*(void*(keysBase + (idx * uint64(8))))) = cheng_ptrmap_tomb
            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = nil
            if cheng_block_map_count > 0:
                cheng_block_map_count = cheng_block_map_count - 1
            cheng_block_map_tombs = cheng_block_map_tombs + 1
            return
        idx = (idx + 1) & mask

fn cheng_mem_link(scope: ChengMemScope*, memBlock: ChengMemBlock*) =
    if scope == nil || memBlock == nil:
        return
    memBlock->scope = scope
    memBlock->prev = nil
    memBlock->next = scope->head
    let head: ChengMemBlock* = scope->head
    if head != nil:
        head->prev = memBlock
    scope->head = memBlock

fn cheng_mem_unlink(memBlock: ChengMemBlock*) =
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil:
        return
    let prev: ChengMemBlock* = memBlock->prev
    let next: ChengMemBlock* = memBlock->next
    if prev != nil:
        prev->next = next
    elif scope->head == memBlock:
        scope->head = next
    if next != nil:
        next->prev = prev
    memBlock->prev = nil
    memBlock->next = nil
    memBlock->scope = nil

fn cheng_mem_find_block_any(p: void*): ChengMemBlock* =
    return cheng_ptrmap_get(p)

fn cheng_malloc(size: int32): void* =
    var n: int32 = size
    if n <= 0:
        n = 1
    let scope: ChengMemScope* = cheng_mem_current()
    let header: int64 = int64(sizeof ChengMemBlock)
    let total: int64 = cheng_align_up(header + int64(n), cheng_page_size)
    let raw: void* = cheng_mmap_alloc(total)
    if raw == nil:
        return nil
    let memBlock: ChengMemBlock* = ChengMemBlock*(raw)
    memBlock->prev = nil
    memBlock->next = nil
    memBlock->scope = nil
    memBlock->size = int64(n)
    memBlock->mapSize = total
    memBlock->rc = 1
    memBlock->_pad = 0
    cheng_mem_link(scope, memBlock)
    let payload: void* = ptr_add(raw, int32(header))
    cheng_ptrmap_put(payload, memBlock)
    cheng_mm_alloc_total = cheng_mm_alloc_total + 1
    cheng_mm_live_total = cheng_mm_live_total + 1
    return payload

fn cheng_free(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    cheng_mem_unlink(memBlock)
    cheng_ptrmap_del(p)
    cheng_munmap_region(void*(memBlock), memBlock->mapSize)
    cheng_mm_free_total = cheng_mm_free_total + 1
    if cheng_mm_live_total > 0:
        cheng_mm_live_total = cheng_mm_live_total - 1

fn cheng_realloc(p: void*, size: int32): void* =
    if p == nil:
        return cheng_malloc(size)
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return nil
    var n: int32 = size
    if n <= 0:
        n = 1
    let out: void* = cheng_malloc(n)
    if out == nil:
        return nil
    let copyN: int64 = memBlock->size < int64(n) ? memBlock->size : int64(n)
    if copyN > 0:
        cheng_bytes_copy(out, p, copyN)
    cheng_free(p)
    return out

fn cheng_mem_scope_push(): void* =
    let mem: void* = cheng_raw_alloc(int64(sizeof ChengMemScope))
    if mem == nil:
        return nil
    let scope: ChengMemScope* = ChengMemScope*(mem)
    scope->parent = cheng_mem_current()
    scope->head = nil
    cheng_scope_current = scope
    return mem

fn cheng_mem_scope_pop() =
    let scope: ChengMemScope* = cheng_mem_current()
    if scope == nil || scope == cheng_global_scope:
        return
    var cur: ChengMemBlock* = scope->head
    while cur != nil:
        let next: ChengMemBlock* = cur->next
        let payload: void* = ptr_add(void*(cur), int32(sizeof ChengMemBlock))
        cheng_ptrmap_del(payload)
        cheng_munmap_region(void*(cur), cur->mapSize)
        cheng_mm_free_total = cheng_mm_free_total + 1
        if cheng_mm_live_total > 0:
            cheng_mm_live_total = cheng_mm_live_total - 1
        cur = next
    cheng_scope_current = scope->parent != nil ? scope->parent : cheng_global_scope
    cheng_raw_free(void*(scope))

fn cheng_mem_scope_escape(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil || scope == cheng_global_scope:
        return
    let target: ChengMemScope* = scope->parent != nil ? scope->parent : cheng_global_scope
    if target == scope:
        return
    cheng_mem_unlink(memBlock)
    cheng_mem_link(target, memBlock)

fn cheng_mem_scope_escape_global(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil || scope == cheng_global_scope:
        return
    cheng_mem_unlink(memBlock)
    cheng_mem_link(cheng_mem_global(), memBlock)

fn cheng_mem_retain(p: void*) =
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    memBlock->rc = memBlock->rc + 1
    cheng_mm_retain_total = cheng_mm_retain_total + 1

fn cheng_mem_release(p: void*) =
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    if memBlock->rc > 0:
        memBlock->rc = memBlock->rc - 1
    cheng_mm_release_total = cheng_mm_release_total + 1
    if memBlock->rc <= 0:
        cheng_mem_unlink(memBlock)
        cheng_ptrmap_del(p)
        cheng_munmap_region(void*(memBlock), memBlock->mapSize)
        cheng_mm_free_total = cheng_mm_free_total + 1
        if cheng_mm_live_total > 0:
            cheng_mm_live_total = cheng_mm_live_total - 1

fn cheng_mem_refcount(p: void*): int32 =
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return 0
    return memBlock->rc

fn cheng_mem_retain_atomic(p: void*) =
    cheng_mem_retain(p)

fn cheng_mem_release_atomic(p: void*) =
    cheng_mem_release(p)

fn cheng_mem_refcount_atomic(p: void*): int32 =
    return cheng_mem_refcount(p)

fn cheng_atomic_cas_i32(p: int32*, expect: int32, desired: int32): int32 =
    if p == nil:
        return 0
    if *p == expect:
        *p = desired
        return 1
    return 0

fn cheng_atomic_store_i32(p: int32*, val: int32) =
    if p != nil:
        *p = val

fn cheng_atomic_load_i32(p: int32*): int32 =
    if p == nil:
        return 0
    return *p

fn cheng_mm_retain_count(): int64 = cheng_mm_retain_total
fn cheng_mm_release_count(): int64 = cheng_mm_release_total
fn cheng_mm_alloc_count(): int64 = cheng_mm_alloc_total
fn cheng_mm_free_count(): int64 = cheng_mm_free_total
fn cheng_mm_live_count(): int64 = cheng_mm_live_total
fn cheng_mm_diag_reset() =
    cheng_mm_retain_total = 0
    cheng_mm_release_total = 0

fn cheng_write_all(fd: int32, data: void*, len: int64): int32 =
    if data == nil || len <= 0:
        return 0
    var off: int64 = 0
    while off < len:
        let n: int64 = cheng_linux_syscall3(cheng_sys_write,
                                            int64(fd),
                                            int64(uint64(ptr_add(data, int32(off)))),
                                            len - off)
        if n == -4:
            continue
        if n <= 0:
            return -1
        off = off + n
    return 0

fn puts(text: char*): int32 =
    var s: char* = text
    if s == nil:
        s = "(null)"
    let n: int64 = int64(cheng_strlen_runtime(s))
    if cheng_write_all(1, void*(s), n) != 0:
        return -1
    var nl: char = '\n'
    if cheng_write_all(1, void*(&nl), 1) != 0:
        return -1
    return 0

fn cheng_puts(text: char*): int32 =
    var s: char* = text
    if s == nil:
        s = "(null)"
    let n: int64 = int64(cheng_strlen_runtime(s))
    if cheng_write_all(1, void*(s), n) != 0:
        return -1
    var nl: char = '\n'
    if cheng_write_all(1, void*(&nl), 1) != 0:
        return -1
    return 0

fn cheng_exit(code: int32) =
    cheng_linux_syscall1(cheng_sys_exit_group, int64(code))
    cheng_linux_syscall1(cheng_sys_exit, int64(code))
    while true:
        0

fn cheng_bounds_check(len: int32, idx: int32) =
    if idx < 0 || idx >= len:
        cheng_puts("cheng: bounds check failed")
        cheng_exit(1)

fn cheng_index_ptr(base: void*, len: int32, idx: int32, elemSize: int32): void* =
    cheng_bounds_check(len, idx)
    if base == nil || elemSize <= 0:
        return base
    let off: int64 = int64(idx) * int64(elemSize)
    return ptr_add(base, int32(off))

fn cheng_seq_get(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_index_ptr(buffer, len, idx, elemSize)

fn cheng_seq_set(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_index_ptr(buffer, len, idx, elemSize)

@weak
fn paramCount(): int32 =
    return 0

@weak
fn paramStr(i: int32): str =
    if i < 0:
        return ""
    return ""

fn __cheng_next_cap(curCap: int32, need: int32): int32 =
    if need <= 0:
        return need
    var cap: int32 = curCap
    if cap < 4:
        cap = 4
    while cap < need:
        let doubled: int32 = cap * 2
        if doubled <= 0:
            return need
        cap = doubled
    return cap

@weak
fn reserve(seq: void*, newCap: int32) =
    if seq == nil:
        return
    if newCap < 0:
        return
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seq)
    if seqHdr->buffer != nil && newCap <= seqHdr->cap:
        return
    if newCap == 0:
        return
    let targetCap: int32 = __cheng_next_cap(seqHdr->cap, newCap)
    if targetCap <= 0:
        return
    let newBuf: void* = cheng_realloc(seqHdr->buffer, targetCap)
    if newBuf == nil:
        return
    seqHdr->buffer = newBuf
    seqHdr->cap = targetCap

# Compatibility alias for stage0/seed outputs that still reference
# the legacy monomorphized reserve symbol name.
@weak
fn reserve_ptr_void(seq: void*, newCap: int32) =
    reserve(seq, newCap)

@weak
fn setLen(seq: void*, newLen: int32) =
    if seq == nil:
        return
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seq)
    var target: int32 = newLen
    if target < 0:
        target = 0
    if target > seqHdr->cap:
        reserve(seqHdr, target)
    seqHdr->len = target

fn cheng_seq_set_grow(seqPtr: void*, idx: int32, elemSize: int32): void* =
    if seqPtr == nil || elemSize <= 0:
        return cheng_index_ptr(nil, 0, idx, elemSize)
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seqPtr)
    if idx < 0:
        return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)
    let needLen: int32 = idx + 1
    if needLen > seqHdr->cap || seqHdr->buffer == nil:
        var newCap: int32 = seqHdr->cap
        if newCap < 4:
            newCap = 4
        while newCap < needLen:
            let doubled: int32 = newCap * 2
            if doubled <= 0:
                newCap = needLen
                break
            newCap = doubled
        let oldCap: int32 = seqHdr->cap
        let bytes: int64 = int64(newCap) * int64(elemSize)
        let newBuf: void* = cheng_realloc(seqHdr->buffer, int32(bytes))
        if newBuf == nil:
            return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)
        if newCap > oldCap:
            let off: int64 = int64(oldCap) * int64(elemSize)
            let zeroBytes: int64 = (int64(newCap) - int64(oldCap)) * int64(elemSize)
            cheng_bytes_set(ptr_add(newBuf, int32(off)), 0, zeroBytes)
        seqHdr->buffer = newBuf
        seqHdr->cap = newCap
    if needLen > seqHdr->len:
        seqHdr->len = needLen
    return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)

fn cheng_slice_get(ptr: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_index_ptr(ptr, len, idx, elemSize)

fn cheng_slice_set(ptr: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_index_ptr(ptr, len, idx, elemSize)

 

fn cheng_spawn(fn_ptr: void*, ctx: void*) =
    fn_ptr
    ctx

fn cheng_sched_pending(): int32 = 0
fn cheng_sched_run_once(): int32 = 0
fn cheng_sched_run() =
    0

fn cheng_async_pending_i32(): void* = nil
fn cheng_async_ready_i32(value: int32): void* =
    value
    return nil
fn cheng_async_set_i32(state: void*, value: int32) =
    state
    value
fn cheng_await_i32(state: void*): int32 =
    state
    return 0

fn cheng_async_pending_void(): void* = nil
fn cheng_async_ready_void(): void* = nil
fn cheng_async_set_void(state: void*) =
    state
fn cheng_await_void(state: void*) =
    state

fn cheng_chan_i32_new(cap: int32): void* =
    cap
    return nil
fn cheng_chan_i32_send(chPtr: void*, value: int32): int32 =
    chPtr
    value
    return 0
fn cheng_chan_i32_recv(chPtr: void*, out: int32*): int32 =
    chPtr
    out
    return 0

fn schedPending(): int32 =
    return cheng_sched_pending()

fn schedRunOnce(): int32 =
    return cheng_sched_run_once()

fn schedRun() =
    cheng_sched_run()

fn asyncPendingI32(): void* =
    return cheng_async_pending_i32()

fn asyncReadyI32(value: int32): void* =
    return cheng_async_ready_i32(value)

fn asyncSetI32(state: void*, value: int32) =
    cheng_async_set_i32(state, value)

fn awaitI32(state: void*): int32 =
    return cheng_await_i32(state)

fn asyncPendingVoid(): void* =
    return cheng_async_pending_void()

fn asyncReadyVoid(): void* =
    return cheng_async_ready_void()

fn asyncSetVoid(state: void*) =
    cheng_async_set_void(state)

fn awaitVoid(state: void*) =
    cheng_await_void(state)

fn chanI32New(cap: int32): void* =
    return cheng_chan_i32_new(cap)

@thread_boundary
fn chanI32Send(ch: void*, value: int32): int32 =
    return cheng_chan_i32_send(ch, value)

@thread_boundary
fn chanI32Recv(ch: void*, out: int32*): int32 =
    return cheng_chan_i32_recv(ch, out)

fn get_stdin(): void* = nil
fn get_stdout(): void* = nil
fn get_stderr(): void* = nil
fn cheng_fseek(stream: void*, offset: int64, whence: int32): int32 =
    stream
    offset
    whence
    return -1
fn cheng_ftell(stream: void*): int64 =
    stream
    return -1

fn cheng_file_exists(path: char*): int32 =
    path
    return 0
fn cheng_dir_exists(path: char*): int32 =
    path
    return 0
fn cheng_file_mtime(path: char*): int64 =
    path
    return 0
fn cheng_file_size(path: char*): int64 =
    path
    return 0
fn cheng_mkdir1(path: char*): int32 =
    path
    return -1
fn cheng_getcwd(): char* =
    return ""
fn cheng_epoch_time(): int64 =
    return 0
fn cheng_monotime_ns(): int64 =
    return 0
fn cheng_list_dir(path: char*): char* =
    path
    return ""
fn cheng_read_file(path: char*): char* =
    path
    return ""
fn cheng_write_file(path: char*, content: char*): int32 =
    path
    content
    return -1
fn cheng_exec_cmd_ex(command: char*, workingDir: char*, mergeStderr: int32, exitCode: int64*): char* =
    command
    workingDir
    mergeStderr
    if exitCode != nil:
        *exitCode = -1
    return ""
fn chengQ_execQ_cmdQ_ex_0(command: char*, workingDir: char*, mergeStderr: int32, exitCode: int64*): char* =
    return cheng_exec_cmd_ex(command, workingDir, mergeStderr, exitCode)

fn cheng_pty_is_supported(): int32 = 0
fn cheng_pty_spawn(command: char*, workingDir: char*, outMasterFd: int32*, outPid: int64*): int32 =
    command
    workingDir
    if outMasterFd != nil:
        *outMasterFd = -1
    if outPid != nil:
        *outPid = -1
    return 0
fn cheng_pipe_spawn(command: char*, workingDir: char*, outReadFd: int32*, outWriteFd: int32*, outPid: int64*): int32 =
    command
    workingDir
    if outReadFd != nil:
        *outReadFd = -1
    if outWriteFd != nil:
        *outWriteFd = -1
    if outPid != nil:
        *outPid = -1
    return 0
fn cheng_pty_read(fd: int32, maxBytes: int32, outEof: int32*): char* =
    fd
    maxBytes
    if outEof != nil:
        *outEof = 1
    return ""
fn cheng_fd_read(fd: int32, maxBytes: int32, outEof: int32*): char* =
    fd
    maxBytes
    if outEof != nil:
        *outEof = 1
    return ""
fn cheng_fd_read_wait(fd: int32, maxBytes: int32, timeoutMs: int32, outEof: int32*): char* =
    fd
    maxBytes
    timeoutMs
    if outEof != nil:
        *outEof = 1
    return ""
fn cheng_pty_write(fd: int32, data: char*, len: int32): int32 =
    fd
    data
    len
    return 0
fn cheng_pty_close(fd: int32): int32 =
    let ret: int64 = cheng_linux_syscall1(cheng_sys_close, int64(fd))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0
fn cheng_pty_wait(pid: int64, outExitCode: int32*): int32 =
    pid
    if outExitCode != nil:
        *outExitCode = -1
    return 0

fn cheng_normalize_bind_sockaddr_linux(addr: void*, len: int32, needFree: bool*): void* =
    if needFree != nil:
        *needFree = false
    if addr == nil || len != cheng_sockaddr_in_len:
        return addr
    let b0: uint8 = *(uint8*(addr))
    let b1: uint8 = *(uint8*(ptr_add(addr, 1)))
    if b0 == uint8(cheng_af_inet) && b1 == 0:
        return addr
    if b0 != uint8(cheng_sockaddr_in_len) || b1 != uint8(cheng_af_inet):
        return addr
    let normalized: void* = alloc(cheng_sockaddr_in_len)
    if normalized == nil:
        return addr
    cheng_bytes_copy(normalized, addr, int64(cheng_sockaddr_in_len))
    *(uint8*(normalized)) = uint8(cheng_af_inet)
    *(uint8*(ptr_add(normalized, 1))) = uint8(0)
    if needFree != nil:
        *needFree = true
    return normalized
fn cheng_tcp_listener(port: int32, outPort: int32*): int32 =
    let fd: int32 = socket(cheng_af_inet, cheng_sock_stream, cheng_ipproto_ip)
    if fd < 0:
        return -1
    let sockOptVal: int32 = 1
    # Best effort socket options; ignore failures and keep listener usable.
    setsockopt(fd, cheng_sol_socket, cheng_so_reuseaddr, void*(&sockOptVal), int32(sizeof int32))
    setsockopt(fd, cheng_sol_socket, cheng_so_reuseport, void*(&sockOptVal), int32(sizeof int32))

    let addr: void* = alloc(cheng_sockaddr_in_len)
    if addr == nil:
        cheng_errno_code = 1
        close(fd)
        return -1
    cheng_bytes_set(addr, 0, cheng_sockaddr_in_len)
    *(uint8*(addr)) = uint8(cheng_af_inet)
    *(uint8*(ptr_add(addr, 1))) = uint8(0)
    *(uint8*(ptr_add(addr, 2))) = uint8((port >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 3))) = uint8(port & 0xFF)
    *(uint8*(ptr_add(addr, 4))) = uint8((cheng_inaddr_loopback >> 24) & 0xFF)
    *(uint8*(ptr_add(addr, 5))) = uint8((cheng_inaddr_loopback >> 16) & 0xFF)
    *(uint8*(ptr_add(addr, 6))) = uint8((cheng_inaddr_loopback >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 7))) = uint8(cheng_inaddr_loopback & 0xFF)

    let bindRes: int32 = bind(fd, addr, cheng_sockaddr_in_len)
    if bindRes < 0:
        # no-libc profile does not depend on libc getenv, keep fallback deterministic.
        let allowAny: bool = false
        if !allowAny:
            close(fd)
            dealloc(addr)
            return -1
        *(uint8*(ptr_add(addr, 4))) = uint8(0)
        *(uint8*(ptr_add(addr, 5))) = uint8(0)
        *(uint8*(ptr_add(addr, 6))) = uint8(0)
        *(uint8*(ptr_add(addr, 7))) = uint8(0)
        if bind(fd, addr, cheng_sockaddr_in_len) < 0:
            close(fd)
            dealloc(addr)
            return -1

    let listenRes: int32 = listen(fd, 128)
    if listenRes != 0:
        close(fd)
        dealloc(addr)
        return -1

    if outPort != nil:
        let name: void* = alloc(cheng_sockaddr_in_len)
        if name == nil:
            close(fd)
            cheng_errno_code = 1
            dealloc(addr)
            return -1
        let namelen: int32* = int32*(alloc(4))
        if namelen == nil:
            close(fd)
            dealloc(name)
            dealloc(addr)
            cheng_errno_code = 1
            return -1
        *namelen = cheng_sockaddr_in_len
        if getsockname(fd, name, namelen) != 0:
            close(fd)
            dealloc(name)
            dealloc(namelen)
            dealloc(addr)
            return -1
        let hiPortByte: int32 = int32(*(uint8*(ptr_add(name, 2))))
        let loPortByte: int32 = int32(*(uint8*(ptr_add(name, 3))))
        *outPort = (hiPortByte << 8) | loPortByte
        dealloc(name)
        dealloc(namelen)
    cheng_errno_code = 0
    dealloc(addr)
    return fd
fn cheng_errno(): int32 =
    return cheng_errno_code
fn cheng_strerror(err: int32): char* =
    if err == 0:
        return "Success"
    if err == 1:
        return "Operation not permitted"
    if err == 2:
        return "No such file or directory"
    if err == 9:
        return "Bad file descriptor"
    if err == 11:
        return "Resource temporarily unavailable"
    if err == 12:
        return "Out of memory"
    if err == 13:
        return "Permission denied"
    if err == 22:
        return "Invalid argument"
    if err == 35:
        return "Operation would block"
    if err == 95:
        return "Operation not supported"
    if err == 97:
        return "Address family not supported by protocol"
    if err == 98:
        return "Address already in use"
    if err == 99:
        return "Cannot assign requested address"
    if err == 111:
        return "Connection refused"
    if err == 104:
        return "Connection reset by peer"
    if err == 125:
        return "Operation canceled"
    if err == 113:
        return "No route to host"
    if err == 115:
        return "Operation now in progress"
    if err == 116:
        return "Operation already in progress"
    if err == 32:
        return "Broken pipe"
    return "unknown error"

fn close(fd: int32): int32 =
    let ret: int64 = cheng_linux_syscall1(cheng_sys_close, int64(fd))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn socket(domain: int32, typ: int32, protocol: int32): int32 =
    let ret: int64 = cheng_linux_syscall3(cheng_sys_socket, int64(domain), int64(typ), int64(protocol))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn socketpair(domain: int32, typ: int32, protocol: int32, sv: int32*): int32 =
    let ret: int64 = cheng_linux_syscall4(cheng_sys_socketpair, int64(domain), int64(typ), int64(protocol), uint64(sv))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn bind(fd: int32, addr: void*, len: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || len != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var bindAddrNeedsFree: bool = false
    let bindAddr: void* = cheng_normalize_bind_sockaddr_linux(addr, len, &bindAddrNeedsFree)
    let ret: int64 = cheng_linux_syscall3(cheng_sys_bind, int64(fd), uint64(bindAddr), int64(len))
    if bindAddrNeedsFree:
        dealloc(bindAddr)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn sendto(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if buf == nil && len > 0:
        cheng_errno_code = cheng_efault
        return -1
    if addr == nil:
        if addrlen != 0:
            cheng_errno_code = cheng_einval
            return -1
        let retNoAddr: int64 = cheng_linux_syscall6(cheng_sys_sendto, int64(fd), uint64(buf), int64(len), int64(flags), 0, 0)
        if cheng_sys_is_err(retNoAddr):
            cheng_errno_code = int32(-retNoAddr)
            return -1
        cheng_errno_code = 0
        return int32(retNoAddr)
    if addrlen != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var sendAddrNeedsFree: bool = false
    let sendAddr: void* = cheng_normalize_bind_sockaddr_linux(addr, addrlen, &sendAddrNeedsFree)
    let ret: int64 = cheng_linux_syscall6(cheng_sys_sendto, int64(fd), uint64(buf), int64(len), int64(flags), uint64(sendAddr), int64(addrlen))
    if sendAddrNeedsFree:
        dealloc(sendAddr)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn send(fd: int32, buf: void*, len: int32, flags: int32): int32 =
    let ret: int64 = cheng_linux_syscall4(cheng_sys_send, int64(fd), uint64(buf), int64(len), int64(flags))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn sendmsg(fd: int32, msg: void*, flags: int32): int32 =
    let ret: int64 = cheng_linux_syscall6(cheng_sys_sendmsg, int64(fd), uint64(msg), int64(flags), 0, 0, 0)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn recvfrom(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if buf == nil && len > 0:
        cheng_errno_code = cheng_efault
        return -1
    let addrLenArg: int64 = if addrlen == nil: 0 else: uint64(addrlen)
    let ret: int64 = cheng_linux_syscall6(cheng_sys_recvfrom, int64(fd), uint64(buf), int64(len), int64(flags), uint64(addr), addrLenArg)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn recv(fd: int32, buf: void*, len: int32, flags: int32): int32 =
    let ret: int64 = cheng_linux_syscall4(cheng_sys_recv, int64(fd), uint64(buf), int64(len), int64(flags))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn recvmsg(fd: int32, msg: void*, flags: int32): int32 =
    let ret: int64 = cheng_linux_syscall6(cheng_sys_recvmsg, int64(fd), uint64(msg), int64(flags), 0, 0, 0)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn getsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32*): int32 =
    let ret: int64 = cheng_linux_syscall5(cheng_sys_getsockopt, int64(fd), int64(level), int64(optname), uint64(optval), uint64(optlen))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn setsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32): int32 =
    let ret: int64 = cheng_linux_syscall5(cheng_sys_setsockopt, int64(fd), int64(level), int64(optname), uint64(optval), int64(optlen))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn listen(fd: int32, backlog: int32): int32 =
    let ret: int64 = cheng_linux_syscall2(cheng_sys_listen, int64(fd), int64(backlog))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn getsockname(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || addrlen == nil:
        cheng_errno_code = cheng_efault
        return -1
    let addrLenArg: int64 = if addrlen == nil: 0 else: uint64(addrlen)
    let ret: int64 = cheng_linux_syscall3(cheng_sys_getsockname, int64(fd), uint64(addr), addrLenArg)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn getpeername(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || addrlen == nil:
        cheng_errno_code = cheng_efault
        return -1
    let addrLenArg: int64 = if addrlen == nil: 0 else: uint64(addrlen)
    let ret: int64 = cheng_linux_syscall3(cheng_sys_getpeername, int64(fd), uint64(addr), addrLenArg)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn connect(fd: int32, addr: void*, len: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || len != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var connectAddrNeedsFree: bool = false
    let connectAddr: void* = cheng_normalize_bind_sockaddr_linux(addr, len, &connectAddrNeedsFree)
    let ret: int64 = cheng_linux_syscall3(cheng_sys_connect, int64(fd), uint64(connectAddr), int64(len))
    if connectAddrNeedsFree:
        dealloc(connectAddr)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn accept(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    let addrLenArg: int64 = if addrlen == nil: 0 else: uint64(addrlen)
    let ret: int64 = cheng_linux_syscall3(cheng_sys_accept, int64(fd), uint64(addr), addrLenArg)
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return int32(ret)

fn shutdown(fd: int32, how: int32): int32 =
    let ret: int64 = cheng_linux_syscall2(cheng_sys_shutdown, int64(fd), int64(how))
    if cheng_sys_is_err(ret):
        cheng_errno_code = int32(-ret)
        return -1
    cheng_errno_code = 0
    return 0

fn __addr(value: int64): int64 = value
fn _addr(value: int64): int64 = value
