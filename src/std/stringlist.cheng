# stringlist.cheng - fixed-size string list helpers
#
# API 对齐 pkg://cheng/libp2p 的 utils/stringlist，便于机械替换 import。

import std/result
import std/strings

const
    maxStringList = 32

type
    StringList =
        count: int32
        items: str[maxStringList]

fn initStringList(): StringList =
    var out: StringList
    out.count = 0
    return out

fn stringListCount(list: StringList): int32 =
    list.count

fn stringListIsEmpty(list: StringList): bool =
    list.count <= 0

fn stringListContains(list: StringList, item: str): bool =
    if len(item) <= 0:
        return false
    for i in 0..<list.count:
        if (list.items[i] == item):
            return true
    return false

fn stringListAdd(list: var StringList, item: str): Result[bool] =
    if len(item) <= 0:
        return Ok[bool](false)
    if stringListContains(list, item):
        return Ok[bool](true)
    if list.count >= maxStringList:
        return Err[bool]("stringlist: full")
    list.items[list.count] = sliceBytes(item, 0, len(item))
    list.count = list.count + 1
    return Ok[bool](true)

fn stringListFromLines(text: str): Result[StringList] =
    var list: StringList = initStringList()
    if len(text) <= 0:
        return Ok[StringList](list)
    var i: int32 = 0
    var start: int32 = 0
    let total: int32 = len(text)
    let __for_start_i_1 = i
    for __for_i_1 in __for_start_i_1..total:
        i = __for_i_1
        if i == total || text[i] == '\n':
            let segLen: int32 = i - start
            if segLen > 0:
                let item: str = sliceBytes(text, start, segLen)
                let addRes: Result[bool] = stringListAdd(list, item)
                if IsErr(addRes):
                    return Err[StringList](Error(addRes))
            start = i + 1
        i = i + 1
    return Ok[StringList](list)

fn stringListToLines(list: StringList): str =
    if list.count <= 0:
        return ""
    var out: str = ""
    for i in 0..<list.count:
        if len(out) == 0:
            out = list.items[i]
        else:
            out = out + "\n"
            out = out + list.items[i]
    return out

fn stringListSlice(list: StringList, offset: int32, limit: int32): StringList =
    var out: StringList = initStringList()
    if limit <= 0:
        return out
    let start: int32 = if offset < 0: 0 else: offset
    if start >= list.count:
        return out
    var i: int32 = start
    var remaining: int32 = limit
    let __for_start_i_2 = i
    for __for_i_2 in __for_start_i_2..<list.count:
        i = __for_i_2
        if ! (i < list.count && remaining > 0):
            break
        out.items[out.count] = list.items[i]
        out.count = out.count + 1
        i = i + 1
        remaining = remaining - 1
    return out

fn stringListLimit(list: StringList, limit: int32): StringList =
    return stringListSlice(list, 0, limit)

fn stringListOffset(list: StringList, offset: int32, limit: int32): StringList =
    return stringListSlice(list, offset, limit)

fn stringListPage(list: StringList, page: int32, size: int32): StringList =
    if size <= 0:
        return initStringList()
    var offset: int32 = 0
    if page > 1:
        offset = (page - 1) * size
    return stringListSlice(list, offset, size)
