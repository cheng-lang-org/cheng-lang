# System module
import std/strings
import std/seqs
import std/tables
import std/option
import std/result
type
    cstring = char*
    # Language-level string keeps value semantics; ABI bridge still uses cstring.
    str = char*

type
    CatchableError =
        msg: str
type
    IOError =
        msg: str
type
    ValueError =
        msg: str
@importc("mul_0")
fn mul_0(a, b: int32): int32
@importc("div_0")
fn div_0(a, b: int32): int32
@importc("mod_0")
fn mod_0(a, b: int32): int32
@importc("shl_0")
fn shl_0(a, b: int32): int32
@importc("shr_0")
fn shr_0(a, b: int32): int32
@importc("bitand_0")
fn bitand_0(a, b: int32): int32
@importc("bitor_0")
fn bitor_0(a, b: int32): int32
@importc("xor_0")
fn xor_0(a, b: int32): int32
@importc("bitnot_0")
fn bitnot_0(a: int32): int32
@importc("not_0")
fn not_0(a: bool): bool
@importc("puts")
fn puts(s: cstring): int32
fn c_puts(s: cstring): int32 =
    return puts s
fn echo(msg: cstring) =
    c_puts(msg)
@importc("exit")
fn exit(code: int32)
fn panic(msg: str) =
    c_puts(cstring(msg))
    exit(1)
fn panicErr(err: result.ErrorInfo) =
    c_puts(cstring(result.ErrorFormat(err)))
    exit(1)
fn assert(cond: bool, msg: str) =
    if ! cond:
        panic(msg)
@importc("cheng_malloc")
fn malloc(size: int32): void*
@importc("cheng_free")
fn free(p: void*)
@importc("cheng_realloc")
fn realloc(p: void*, size: int32): void*
@importc("cheng_mem_retain")
fn memRetain(p: void*)
@importc("cheng_mem_release")
fn memRelease(p: void*)
@importc("cheng_mem_scope_escape")
fn memScopeEscape(p: void*)
@importc("cheng_mem_refcount")
fn memRefCount(p: void*): int32
@importc("cheng_mem_retain_atomic")
fn memRetainAtomic(p: void*)
@importc("cheng_mem_release_atomic")
fn memReleaseAtomic(p: void*)
@importc("cheng_mem_refcount_atomic")
fn memRefCountAtomic(p: void*): int32
@importc("cheng_mm_retain_count")
fn memRetainCount(): int64
@importc("cheng_mm_release_count")
fn memReleaseCount(): int64
@importc("cheng_mm_alloc_count")
fn memAllocCount(): int64
@importc("cheng_mm_free_count")
fn memFreeCount(): int64
@importc("cheng_mm_live_count")
fn memLiveCount(): int64
@importc("cheng_mm_diag_reset")
fn memDiagReset()
@importc("cheng_atomic_cas_i32")
fn atomicCasI32(p: int32*, expect: int32, desired: int32): int32
@importc("cheng_atomic_store_i32")
fn atomicStoreI32(p: int32*, val: int32)
@importc("cheng_atomic_load_i32")
fn atomicLoadI32(p: int32*): int32
fn alloc(size: int32): void* =
    return malloc size
fn dealloc(p: void*) =
    free p
@importc("cheng_strlen")
fn cheng_strlen(s: str): int32
fn c_strlen(s: str): int32 =
    return cheng_strlen(s)
@importc("cheng_memcpy")
fn cheng_memcpy(dest: void*, src: void*, n: int64): void*
@importc("ptr_add")
fn ptr_add(p: void*, offset: int32): void*
fn cheng_ptr_size(): int32 =
    return sizeof(void*)
fn ptrSize(): int32 =
    return cheng_ptr_size()
fn cheng_ptr_to_u64(p: void*): uint64 =
    return uint64(p)
fn ptrToU64(p: void*): uint64 =
    return cheng_ptr_to_u64(p)
@importc("cheng_seq_get")
fn cheng_seq_get(buffer: void*, len: int32, idx: int32, elemSize: int32): void*

@importc("cheng_seq_set")
fn cheng_seq_set(buffer: void*, len: int32, idx: int32, elemSize: int32): void*

fn seqElemPtr(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    if idx < 0 || idx >= len:
        panic "seq index out of bounds"
    var offset64: int64 = int64(idx) * int64(elemSize)
    var offset32: int32 = int32(offset64)
    return ptr_add(buffer, offset32)

fn `[]`(seqInst: T[], i: int32): T =
    var p: void* = seqElemPtr(seqInst.buffer, seqInst.len, i, sizeof T)
    var pt: T* = T*(p)
    return *pt
fn `[]=`(seqInst: var T[], i: int32, val: T) =
    var p: void* = seqElemPtr(seqInst.buffer, seqInst.len, i, sizeof T)
    var pt: T* = T*(p)
    *pt = val
fn `[]`(seqInst: T[]*, i: int32): T =
    if seqInst == nil:
        panic "cheng: nil seq pointer"
    var p: void* = seqElemPtr(seqInst->buffer, seqInst->len, i, sizeof T)
    var pt: T* = T*(p)
    return *pt
fn `[]=`(seqInst: T[]*, i: int32, val: T) =
    if seqInst == nil:
        panic "cheng: nil seq pointer"
    var p: void* = seqElemPtr(seqInst->buffer, seqInst->len, i, sizeof T)
    var pt: T* = T*(p)
    *pt = val
fn `[]`(seqInst: ptr[], i: int32): ptr =
    var p: void* = seqElemPtr(seqInst.buffer, seqInst.len, i, sizeof ptr)
    return ptr(load_ptr(p))
fn `[]=`(seqInst: var ptr[], i: int32, val: ptr) =
    var p: void* = seqElemPtr(seqInst.buffer, seqInst.len, i, sizeof ptr)
    store_ptr(p, void*(val))
fn `[]`(seqInst: ptr[]*, i: int32): ptr =
    if seqInst == nil:
        panic "cheng: nil seq pointer"
    var p: void* = seqElemPtr(seqInst->buffer, seqInst->len, i, sizeof ptr)
    return ptr(load_ptr(p))
fn `[]=`(seqInst: ptr[]*, i: int32, val: ptr) =
    if seqInst == nil:
        panic "cheng: nil seq pointer"
    var p: void* = seqElemPtr(seqInst->buffer, seqInst->len, i, sizeof ptr)
    store_ptr(p, void*(val))
@importc("store_ptr")
fn store_ptr(p: void*, val: void*)
@importc("load_ptr")
fn load_ptr(p: void*): void*
@importc("cheng_memset")
fn cheng_memset(dest: void*, val: int32, n: int64): void*
fn dotdot(a, b: int32): int32 =
    return 0
fn dotdotless(a, b: int32): int32 =
    return 0
fn store(p: void*, val: T) =
    var pT: T* = T*(p)
    *pT = val
fn load(p: void*): T =
    var pT: T* = T*(p)
    return *pT
fn copyMem(dest, src: void*, size: int) =
    0
    cheng_memcpy(dest, src, int64(size))
fn setMem(dest: void*, val: int32, size: int) =
    0
    cheng_memset(dest, val, int64(size))
fn zeroMem(dest: void*, size: int) =
    cheng_memset(dest, 0, int64(size))
@importc("cheng_memcmp")
fn cmpMem(a, b: void*, size: int64): int32
@importc("cheng_strcmp")
fn cheng_strcmp(a, b: cstring): int32
fn c_strcmp(a, b: str): int32 =
    return cheng_strcmp(cstring(a), cstring(b))
fn c_strcmp(a, b: cstring): int32 =
    return cheng_strcmp(a, b)
@importc("cheng_bits_to_f32")
fn bitsToF32(bits: int32): float64
@importc("cheng_f32_to_bits")
fn f32ToBits(value: float64): int32
fn int(x: T): int32 =
    int32(x)
fn int8(x: T): int8 =
    int8(x)
fn int16(x: T): int16 =
    int16(x)
fn int32(x: T): int32 =
    int32(x)
fn int64(x: T): int64 =
    int64(x)
fn float64(x: T): float64 =
    float64(x)
fn float(x: T): float64 =
    float64(x)
fn uint8(x: T): uint8 =
    uint8(x)
fn uint16(x: T): uint16 =
    uint16(x)
fn uint32(x: T): uint32 =
    uint32(x)
fn uint64(x: T): uint64 =
    uint64(x)
fn char(x: T): char =
    char(x)
fn chr(x: int32): char =
    char(x)
fn ord(c: char): int32 =
    int32(c)
fn toString(x: str): str =
    return x
fn toString(x: bool): str =
    if x:
        return "true"
    return "false"
fn toString(x: char): str =
    return charToStr(x)
fn defined(x: bool): bool =
    x
fn newException(t: typedesc[T], message: str): T =
    t
    var e: T
    e.msg = message
    return e
fn repr(x: T): str =
    x
    return "<repr>"
fn abs(x: T): T =
    if x < default[T]:
        return default[T] - x
    else:
        return x
fn max(a: T, b: T): T =
    if a >= b:
        return a
    else:
        return b
fn min(a: T, b: T): T =
    if a <= b:
        return a
    else:
        return b
fn clamp(x: T, lo: T, hi: T): T =
    if x < lo:
        return lo
    elif x > hi:
        return hi
    else:
        return x
fn cmp(a: str, b: str): int32 =
    return c_strcmp(a, b)
fn cmpInt(a: int, b: int): int32 =
    if a < b:
        return -1
    elif a > b:
        return 1
    else:
        return 0
fn cmpFloat(a: float64, b: float64): int32 =
    if a < b:
        return -1
    elif a > b:
        return 1
    else:
        return 0
fn cmpGeneric(a: T, b: T): int32 =
    if a < b:
        return -1
    elif a > b:
        return 1
    else:
        return 0
fn swap(a: var T, b: var T) =
    let tmp: T = *T*(&a)
    *T*(&a) = *T*(&b)
    *T*(&b) = tmp
fn inc(x: var T, delta: T) =
    x = x + delta
fn inc(x: var T) =
    inc(x, T(1))
fn dec(x: var T, delta: T) =
    x = x - delta
fn dec(x: var T) =
    dec(x, T(1))
# Minimal str concat (for `+` builtin semantics; avoid extra modules).
fn __cheng_concat_str(a: str, b: str): str =
    let l1: int32 = c_strlen a
    let l2: int32 = c_strlen b
    let size: int32 = l1 + l2 + 1
    let p: void* = alloc size
    if l1 > 0:
        copyMem(p, a, l1)
    if l2 > 0:
        let p2: void* = ptr_add(p, l1)
        copyMem(p2, b, l2)
    let p_end: void* = ptr_add(p, l1 + l2)
    setMem(p_end, 0, 1)
    return str(p)
fn __cheng_set_range_mask(start: int32, stop: int32, exclusive: bool): uint64 =
    var s: int32 = start
    var e: int32 = stop
    if exclusive:
        e = e - 1
    if s < 0:
        s = 0
    if e < s:
        return uint64(0)
    if e > 63:
        e = 63
    var mask: uint64 = uint64(0)
    for i in s..e:
        mask = mask |(uint64(1) << uint64(i))
    return mask
fn setHas(s: set[T], value: T): bool =
    let idx64 = int64(value)
    let idx = uint64(idx64)
    let mask = uint64(1) << idx
    let bits = uint64(s)
    return (bits & mask) != 0
fn newString(len: int32): str =
    if len <= 0:
        return ""
    let size: int32 = len + 1
    let p: void* = alloc size
    setMem(p, 0, size)
    return str(p)
fn newStringOfCap(len: int32): str =
    return newString len
fn new(x: var ref T) =
    let size64: int64 = sizeof T
    let size: int32 = int32(size64)
    let p: void* = alloc size
    if p != nil:
        zeroMem(p, size)
        x = ref(T(p))
fn new(): ref T =
    var r: ref T
    new r
    return r
