import std/seqs
# Minimal Tables: linear-probing hash table (str key)

type
    Table[V] =
        keys: str[]
        vals: V[]
        states: uint8[] # 0=empty, 1=used
        len: int32

type
    Table_string = Table[str]

fn __cheng_tables_hashStr(s: str): int32 =
    var h: int32 = 0
    if s == nil:
        return 0
    let n: int32 = len s
    for i in 0..<n:
        let code: int32 = int32(s[i])
        h = h + code
        h = h + (h << 10)
        h = h ^ (h >> 6)
    h = h + (h << 3)
    h = h ^ (h >> 11)
    h = h + (h << 15)
    return h

fn __cheng_tables_hashStrHrt(s: str): int32 =
    return __cheng_tables_hashStr(s)

fn __cheng_tables_roundUpPow2(x0: int32): int32 =
    var x: int32 = x0
    if x <= 1:
        return 1
    x = x - 1
    x = x | (x >> 1)
    x = x | (x >> 2)
    x = x | (x >> 4)
    x = x | (x >> 8)
    x = x | (x >> 16)
    x = x + 1
    return x

fn __cheng_tables_initCap(initialCap: int32): int32 =
    var cap: int32 = initialCap
    if cap < 8:
        cap = 8
    cap = __cheng_tables_roundUpPow2(cap)
    return cap

fn __cheng_tables_findSlot(t: Table[V], key: str, allowInsert: bool): int32 =
    let cap: int32 = t.keys.len
    if cap <= 0 || key == nil:
        return -1
    var probe: int32 = (__cheng_tables_hashStr(key) & 0x7fffffff) % cap
    var scanned: int32 = 0
    let __for_start_scanned_1 = scanned
    for __for_scanned_1 in __for_start_scanned_1..<cap:
        scanned = __for_scanned_1
        let st: uint8 = t.states[probe]
        if st == uint8(0):
            if allowInsert:
                return probe
            return -1
        if st == uint8(1) && (t.keys[probe] == key):
            return probe
        probe = probe + 1
        if probe >= cap:
            probe = 0
        scanned = scanned + 1
    return -1

fn __cheng_tables_findSlotMut(t: var Table[V], key: str, allowInsert: bool): int32 =
    if key == nil || t.keys.len <= 0:
        return -1
    let cap: int32 = t.keys.len
    var probe: int32 = (__cheng_tables_hashStr(key) & 0x7fffffff) % cap
    var scanned: int32 = 0
    let __for_start_scanned_2 = scanned
    for __for_scanned_2 in __for_start_scanned_2..<cap:
        scanned = __for_scanned_2
        let st: uint8 = t.states[probe]
        if st == uint8(0):
            if allowInsert:
                return probe
            return -1
        if st == uint8(1) && (t.keys[probe] == key):
            return probe
        probe = probe + 1
        if probe >= cap:
            probe = 0
        scanned = scanned + 1
    return -1

fn __cheng_tables_grow(t: Table[V]*) =
    if t == nil:
        return
    let oldCap: int32 = t->keys.len
    var oldKeys: str[oldCap]
    var oldVals: V[oldCap]
    var oldStates: uint8[oldCap]
    oldKeys.len = oldCap
    oldVals.len = oldCap
    oldStates.len = oldCap
    for i in 0..<oldCap:
        oldKeys[i] = t->keys[i]
        oldVals[i] = t->vals[i]
        oldStates[i] = t->states[i]

    var growCap: int32 = oldCap * 2
    if growCap < 8:
        growCap = 8
    let newCap: int32 = __cheng_tables_initCap(growCap)

    var keys: str[newCap]
    var vals: V[newCap]
    var states: uint8[newCap]
    keys.len = newCap
    vals.len = newCap
    states.len = newCap
    var nextTable: Table[V] = Table[V](keys: keys, vals: vals, states: states, len: 0)

    for i in 0..<oldCap:
        if oldStates[i] == uint8(1):
            let key: str = oldKeys[i]
            let slot: int32 = __cheng_tables_findSlotMut[V](nextTable, key, true)
            if slot >= 0:
                nextTable.keys[slot] = key
                nextTable.vals[slot] = oldVals[i]
                nextTable.states[slot] = uint8(1)
                nextTable.len = nextTable.len + 1

    t->keys = nextTable.keys
    t->vals = nextTable.vals
    t->states = nextTable.states
    t->len = nextTable.len

fn TableInit(initialCap: int32 = 64): Table[V] =
    let cap: int32 = __cheng_tables_initCap(initialCap)
    var keys: str[cap]
    var vals: V[cap]
    var states: uint8[cap]
    keys.len = cap
    vals.len = cap
    states.len = cap
    return Table[V](keys: keys, vals: vals, states: states, len: 0)

fn TableLen(t: Table[V]): int32 =
    return t.len

fn TableHas(t: var Table[V], key: str): bool =
    let slot: int32 = __cheng_tables_findSlot[V](t, key, false)
    return slot >= 0

fn TableGet(t: Table[V], key: str): V =
    let slot: int32 = __cheng_tables_findSlot[V](t, key, false)
    if slot < 0:
        return default[V]
    return t.vals[slot]

fn `[]`(t: Table[V], key: str): V =
    return TableGet[V](t, key)

fn `$`(t: Table[V]): str =
    return "<Table len=" + $(t.len) + ">"

fn TableNext(t: Table[V], cursor: int32, key: var str, val: var V, nextCursor: var int32): bool =
    let cap: int32 = t.keys.len
    if cap <= 0:
        nextCursor = 0
        return false
    var i: int32 = cursor
    if i < 0:
        i = 0
    let __for_start_i_3 = i
    for __for_i_3 in __for_start_i_3..<cap:
        i = __for_i_3
        if t.states[i] == uint8(1):
            key = t.keys[i]
            val = t.vals[i]
            nextCursor = i + 1
            return true
        i = i + 1
    nextCursor = cap
    return false

fn TablePut(t: var Table[V], key: str, val: V) =
    if key == nil:
        return
    if t.keys.len <= 0:
        t = TableInit[V](64)
    if (t.len + 1) * 10 >= t.keys.len * 7:
        __cheng_tables_grow[V](&t)
    let slot: int32 = __cheng_tables_findSlotMut[V](t, key, true)
    if slot < 0:
        return
    if t.states[slot] != uint8(1):
        t.len = t.len + 1
        t.states[slot] = uint8(1)
    t.keys[slot] = key
    t.vals[slot] = val

fn `[]=`(t: var Table[V], key: str, val: V) =
    TablePut[V](t, key, val)

fn arcRetainTable(t: Table[V]) =
    arcRetainSeq[str](t.keys)
    arcRetainSeq[V](t.vals)
    arcRetainSeq[uint8](t.states)

fn arcReleaseTable(t: Table[V]) =
    arcReleaseSeq[uint8](t.states)
    arcReleaseSeq[V](t.vals)
    arcReleaseSeq[str](t.keys)
