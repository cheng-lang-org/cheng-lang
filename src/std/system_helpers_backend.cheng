# Cheng backend runtime helpers (pure Cheng implementation).
# This file is intended to be compiled as a runtime .o and linked into
# backend-emitted executables to avoid compiling `system_helpers.c`.

@importc("malloc")
fn c_malloc(size: int64): void*
@importc("calloc")
fn c_calloc(nmemb: int64, size: int64): void*
@importc("realloc")
fn c_realloc(p: void*, size: int64): void*
@importc("free")
fn c_free(p: void*)

@importc("puts")
fn c_puts_runtime(text: char*): int32
@importc("exit")
fn c_exit(code: int32)
@importc("memcpy")
fn c_memcpy(dest: void*, src: void*, n: int64): void*
@importc("memset")
fn c_memset(dest: void*, val: int32, n: int64): void*
@importc("memcmp")
fn c_memcmp(a: void*, b: void*, n: int64): int32
@importc("getenv")
fn c_getenv(name: char*): char*

@importc("fopen")
fn libc_fopen(filename: char*, mode: char*): void*
@importc("fclose")
fn libc_fclose(f: void*): int32
@importc("fread")
fn libc_fread(ptr: void*, size: int64, n: int64, stream: void*): int64
@importc("fwrite")
fn libc_fwrite(ptr: void*, size: int64, n: int64, stream: void*): int64
@importc("fflush")
fn libc_fflush(stream: void*): int32
@importc("fgetc")
fn libc_fgetc(stream: void*): int32
@importc("fdopen")
fn libc_fdopen(fd: int32, mode: char*): void*
@importc("fseeko")
fn libc_fseeko(stream: void*, offset: int64, whence: int32): int32
@importc("ftello")
fn libc_ftello(stream: void*): int64

@importc("socket")
fn libc_socket(domain: int32, typ: int32, protocol: int32): int32
@importc("bind")
fn libc_bind(fd: int32, addr: void*, len: int32): int32
@importc("sendto")
fn libc_sendto(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32): int32
@importc("send")
fn libc_send(fd: int32, buf: void*, len: int32, flags: int32): int32
@importc("recvfrom")
fn libc_recvfrom(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32*): int32
@importc("recv")
fn libc_recv(fd: int32, buf: void*, len: int32, flags: int32): int32
@importc("sendmsg")
fn libc_sendmsg(fd: int32, msg: void*, flags: int32): int32
@importc("recvmsg")
fn libc_recvmsg(fd: int32, msg: void*, flags: int32): int32
@importc("getsockname")
fn libc_getsockname(fd: int32, addr: void*, addrlen: int32*): int32
@importc("getpeername")
fn libc_getpeername(fd: int32, addr: void*, addrlen: int32*): int32
@importc("listen")
fn libc_listen(fd: int32, backlog: int32): int32
@importc("connect")
fn libc_connect(fd: int32, addr: void*, len: int32): int32
@importc("accept")
fn libc_accept(fd: int32, addr: void*, addrlen: int32*): int32
@importc("getsockopt")
fn libc_getsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32*): int32
@importc("setsockopt")
fn libc_setsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32): int32
@importc("socketpair")
fn libc_socketpair(domain: int32, typ: int32, protocol: int32, sv: int32*): int32
@importc("close")
fn libc_close(fd: int32): int32
@importc("shutdown")
fn libc_shutdown(fd: int32, how: int32): int32
@importc("strerror")
fn libc_strerror(err: int32): char*
@importc("__error")
fn libc_errno_ptr(): int32*
fn puts_runtime(text: char*): int32 =
    return c_puts_runtime(text)
fn cheng_strlen_runtime(s: char*): int32 =
    return cheng_strlen(s == nil ? "" : s)
fn cheng_memcpy_ffi_runtime(dest: void*, src: void*, n: int64): void* =
    return c_memcpy(dest, src, n)
fn cheng_memset_ffi_runtime(dest: void*, val: int32, n: int64): void* =
    return c_memset(dest, val, n)
fn cheng_ptr_size_runtime(): int32 =
    return sizeof(void*)
fn cheng_ptr_to_u64_runtime(p: void*): uint64 =
    return uint64(p)
fn cheng_seq_get_runtime(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_seq_get(buffer, len, idx, elemSize)
fn cheng_seq_set_runtime(buffer: void*, len: int32, idx: int32, elemSize: int32): void* =
    return cheng_seq_set(buffer, len, idx, elemSize)

@importc("mkdir")
fn libc_mkdir(path: char*, mode: int32): int32
@importc("getcwd")
fn libc_getcwd(buf: char*, size: int64): char*
@importc("opendir")
fn libc_opendir(path: char*): void*
@importc("readdir")
fn libc_readdir(dir: void*): void*
@importc("closedir")
fn libc_closedir(dir: void*): int32

@importc("popen")
fn libc_popen(command: char*, mode: char*): void*
@importc("pclose")
fn libc_pclose(stream: void*): int32

@importc("time")
fn libc_time(out: void*): int64
@importc("clock_gettime")
fn libc_clock_gettime(clockId: int32, out: void*): int32

@importc("stat")
fn libc_stat(path: char*, out: void*): int32

# Float bits intrinsics (emitted as AArch64 FP instructions by the backend).
@importc("cheng_f64_add_bits")
fn cheng_f64_add_bits(a_bits: int64, b_bits: int64): int64
@importc("cheng_f64_mul_bits")
fn cheng_f64_mul_bits(a_bits: int64, b_bits: int64): int64
@importc("cheng_f64_div_bits")
fn cheng_f64_div_bits(a_bits: int64, b_bits: int64): int64
@importc("cheng_f64_neg_bits")
fn cheng_f64_neg_bits(a_bits: int64): int64
@importc("cheng_i64_to_f64_bits")
fn cheng_i64_to_f64_bits(x: int64): int64

const
    cheng_ptrmap_tomb: uint64 = 1
    cheng_ffi_handle_slot_mod: uint64 = 4294967296
    cheng_ffi_handle_err_invalid: int32 = -1
    cheng_ffi_handle_max_generation: uint32 = uint32(4294967295)
    cheng_af_inet: int32 = 2
    cheng_af_inet6: int32 = 30
    cheng_sock_stream: int32 = 1
    cheng_sock_dgram: int32 = 2
    cheng_ipproto_ip: int32 = 0
    cheng_ipproto_udp: int32 = 17
    cheng_sol_socket: int32 = 65535
    cheng_sol_udp: int32 = 17
    cheng_so_reuseaddr: int32 = 4
    cheng_so_reuseport: int32 = 512
    cheng_so_broadcast: int32 = 32
    cheng_so_rcvtimeo: int32 = 4102
    cheng_so_sndtimeo: int32 = 4101
    cheng_ip_ttl: int32 = 4
    cheng_ip_multicast_if: int32 = 9
    cheng_ip_multicast_ttl: int32 = 10
    cheng_ip_multicast_loop: int32 = 11
    cheng_ip_add_membership: int32 = 12
    cheng_ip_drop_membership: int32 = 13
    cheng_msg_dontwait: int32 = 128
    cheng_msg_waitall: int32 = 64
    cheng_msg_waitforone: int32 = 0
    cheng_msg_eor: int32 = 8
    cheng_msg_more: int32 = 32768
    cheng_msg_peek: int32 = 2
    cheng_msg_oob: int32 = 1
    cheng_msg_dont_route: int32 = 4
    cheng_msg_nosignal: int32 = 524288
    cheng_inaddr_loopback: int32 = 2130706433
    cheng_inaddr_any: int32 = 0
    cheng_msg_cmsg_space: int32 = 0
    cheng_sockaddr_in_len: int32 = 16
    cheng_ebadf: int32 = 9
    cheng_einval: int32 = 22
    cheng_efault: int32 = 14

type
    VoidPtr = void*
    ChengSeqHeader =
        len: int32
        cap: int32
        buffer: void*
    ChengMemScope =
        parent: ChengMemScope*
        head: ChengMemBlock*
    ChengMemBlock =
        prev: ChengMemBlock*
        next: ChengMemBlock*
        scope: ChengMemScope*
        size: int64
        rc: int32
        _pad: int32
    ChengFfiHandleSlot =
        ptr: void*
        generation: uint32
    ChengIov =
        base: void*
        len: int64
    ChengMsghdr =
        name: void*
        nameLen: int32
        _padNameLen: int32
        iov: void*
        iovLen: int64
        control: void*
        controlLen: int64
        flags: int32
    ChengIpMreq =
        multiaddr: uint32
        interface: uint32

var
    cheng_global_scope: ChengMemScope*
    cheng_scope_current: ChengMemScope*
    cheng_mm_retain_total: int64
    cheng_mm_release_total: int64
    cheng_errno_code: int32
    cheng_mm_alloc_total: int64
    cheng_mm_free_total: int64
    cheng_mm_live_total: int64
    # 2 = unknown; 0 = false; 1 = true
    cheng_mm_disabled: int32 = 2
    cheng_mm_atomic: int32 = 2

    cheng_block_map_keys: uint64*
    cheng_block_map_vals: ChengMemBlock**
    cheng_block_map_cap: int64
    cheng_block_map_count: int64
    cheng_block_map_tombs: int64

    cheng_ffi_handle_slots: ChengFfiHandleSlot*
    cheng_ffi_handle_slots_len: int32
    cheng_ffi_handle_slots_cap: int32

fn cheng_mem_global(): ChengMemScope* =
    if cheng_global_scope != nil:
        return cheng_global_scope
    let mem: void* = c_calloc(1, int64(sizeof ChengMemScope))
    if mem == nil:
        return nil
    let scope: ChengMemScope* = ChengMemScope*(mem)
    scope->parent = nil
    scope->head = nil
    cheng_global_scope = scope
    return scope

fn cheng_strIsEmpty(s: char*): bool =
    if s == nil:
        return true
    return *s == '\0'

fn cheng_cstrEq(a: char*, b: char*): bool =
    if a == b:
        return true
    if a == nil || b == nil:
        return false
    var pa: char* = a
    var pb: char* = b
    while true:
        let ca: char = *pa
        let cb: char = *pb
        if ca != cb:
            return false
        if ca == '\0':
            return true
        pa = pa + 1
        pb = pb + 1

fn cheng_mm_is_disabled(): bool =
    if cheng_mm_disabled != 2:
        return cheng_mm_disabled != 0
    let env: char* = c_getenv("MM")
    if cheng_strIsEmpty(env):
        cheng_mm_disabled = 0
        return false
    if *env == '0':
        cheng_mm_disabled = 1
        return true
    if cheng_cstrEq(env, "off") || cheng_cstrEq(env, "none") ||
       cheng_cstrEq(env, "false") || cheng_cstrEq(env, "no"):
        cheng_mm_disabled = 1
        return true
    cheng_mm_disabled = 0
    return false

fn cheng_mm_atomic_enabled(): bool =
    if cheng_mm_atomic != 2:
        return cheng_mm_atomic != 0
    let env: char* = c_getenv("MM_ATOMIC")
    if cheng_strIsEmpty(env):
        cheng_mm_atomic = 1
        return true
    if cheng_cstrEq(env, "0") || cheng_cstrEq(env, "false") || cheng_cstrEq(env, "no"):
        cheng_mm_atomic = 0
        return false
    cheng_mm_atomic = 1
    return true

fn cheng_ptr_hash(v0: uint64): uint64 =
    var v: uint64 = v0
    # Fast pointer hash: ignore alignment bits, then mix with one multiply.
    v = v >> uint64(3)
    v = v ^ (v >> uint64(33))
    v = v * uint64(0xff51afd7ed558ccd)
    v = v ^ (v >> uint64(33))
    return v

fn cheng_ptrmap_init(cap: int64) =
    var n: int64 = 1
    while n < cap:
        n = n << 1
    let keysMem: void* = c_calloc(n, int64(sizeof uint64))
    let valsMem: void* = c_calloc(n, int64(sizeof VoidPtr))
    if keysMem == nil || valsMem == nil:
        c_free(keysMem)
        c_free(valsMem)
        cheng_block_map_keys = nil
        cheng_block_map_vals = nil
        cheng_block_map_cap = 0
        cheng_block_map_count = 0
        cheng_block_map_tombs = 0
        return
    cheng_block_map_keys = uint64*(keysMem)
    cheng_block_map_vals = ChengMemBlock**(valsMem)
    cheng_block_map_cap = n
    cheng_block_map_count = 0
    cheng_block_map_tombs = 0

fn cheng_ptrmap_get(key: void*): ChengMemBlock* =
    if key == nil || cheng_block_map_cap == 0:
        return nil
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return nil
    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    while true:
        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
        if cur == 0:
            return nil
        if cur == k:
            return *(ChengMemBlock**(void*(valsBase + (idx * uint64(8)))))
        idx = (idx + 1) & mask
    return nil

fn cheng_ptrmap_grow() =
    let oldcap: int64 = cheng_block_map_cap
    let oldkeys: uint64* = cheng_block_map_keys
    let oldvals: ChengMemBlock** = cheng_block_map_vals
    let oldcount: int64 = cheng_block_map_count
    let oldtombs: int64 = cheng_block_map_tombs
    let newcap: int64 = oldcap > 0 ? (oldcap * 2) : 1024

    cheng_block_map_keys = nil
    cheng_block_map_vals = nil
    cheng_block_map_cap = 0
    cheng_block_map_count = 0
    cheng_block_map_tombs = 0
    cheng_ptrmap_init newcap
    if cheng_block_map_cap == 0:
        # Restore old map (best-effort) if growth failed.
        cheng_block_map_keys = oldkeys
        cheng_block_map_vals = oldvals
        cheng_block_map_cap = oldcap
        cheng_block_map_count = oldcount
        cheng_block_map_tombs = oldtombs
        return

    if oldkeys != nil && oldcap > 0:
        let newMask: uint64 = uint64(cheng_block_map_cap - 1)
        let keysBase: uint64 = uint64(cheng_block_map_keys)
        let valsBase: uint64 = uint64(cheng_block_map_vals)
        let oldKeysBase: uint64 = uint64(oldkeys)
        let oldValsBase: uint64 = uint64(oldvals)
        for i in 0..<oldcap:
            let k: uint64 = *(uint64*(void*(oldKeysBase + (uint64(i) * uint64(8)))))
            if k > cheng_ptrmap_tomb:
                let v: ChengMemBlock* = *(ChengMemBlock**(void*(oldValsBase + (uint64(i) * uint64(8)))))
                if v != nil:
                    var idx: uint64 = cheng_ptr_hash(k) & newMask
                    while true:
                        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
                        if cur == 0:
                            *(uint64*(void*(keysBase + (idx * uint64(8))))) = k
                            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = v
                            cheng_block_map_count = cheng_block_map_count + 1
                            break
                        idx = (idx + 1) & newMask
        c_free oldkeys
        c_free oldvals

fn cheng_ptrmap_put(key: void*, val: ChengMemBlock*) =
    if key == nil:
        return
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return
    if cheng_block_map_cap == 0:
        cheng_ptrmap_init 65536
        if cheng_block_map_cap == 0:
            return

    # Grow if (count + tombs) / cap >= 0.7
    if (cheng_block_map_count + cheng_block_map_tombs) * 10 >= cheng_block_map_cap * 7:
        cheng_ptrmap_grow()
        if cheng_block_map_cap == 0:
            return

    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    var firstTomb: int64 = -1
    while true:
        let curp: void* = void*(keysBase + (idx * uint64(8)))
        let cur: uint64 = *(uint64*(curp))
        if cur == k:
            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = val
            return
        if cur == cheng_ptrmap_tomb && firstTomb < 0:
            firstTomb = int64(idx)
        if cur == 0:
            var useIdx: uint64 = idx
            if firstTomb >= 0:
                useIdx = uint64(firstTomb)
                cheng_block_map_tombs = cheng_block_map_tombs - 1
            *(uint64*(void*(keysBase + (useIdx * uint64(8))))) = k
            *(ChengMemBlock**(void*(valsBase + (useIdx * uint64(8))))) = val
            cheng_block_map_count = cheng_block_map_count + 1
            return
        idx = (idx + 1) & mask

fn cheng_ptrmap_del(key: void*) =
    if key == nil || cheng_block_map_cap == 0:
        return
    let k: uint64 = uint64(key)
    if k == 0 || k == cheng_ptrmap_tomb:
        return
    let mask: uint64 = uint64(cheng_block_map_cap - 1)
    let keysBase: uint64 = uint64(cheng_block_map_keys)
    let valsBase: uint64 = uint64(cheng_block_map_vals)
    var idx: uint64 = cheng_ptr_hash(k) & mask
    while true:
        let cur: uint64 = *(uint64*(void*(keysBase + (idx * uint64(8)))))
        if cur == 0:
            return
        if cur == k:
            *(uint64*(void*(keysBase + (idx * uint64(8))))) = cheng_ptrmap_tomb
            *(ChengMemBlock**(void*(valsBase + (idx * uint64(8))))) = nil
            if cheng_block_map_count > 0:
                cheng_block_map_count = cheng_block_map_count - 1
            cheng_block_map_tombs = cheng_block_map_tombs + 1
            return
        idx = (idx + 1) & mask

fn cheng_mem_current(): ChengMemScope* =
    if cheng_scope_current == nil:
        cheng_scope_current = cheng_mem_global()
    return cheng_scope_current

fn cheng_mem_link(scope: ChengMemScope*, memBlock: ChengMemBlock*) =
    if scope == nil || memBlock == nil:
        return
    memBlock->scope = scope
    memBlock->prev = nil
    memBlock->next = scope->head
    let head: ChengMemBlock* = scope->head
    if head != nil:
        head->prev = memBlock
    scope->head = memBlock

fn cheng_mem_unlink(memBlock: ChengMemBlock*) =
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil:
        return
    let prev: ChengMemBlock* = memBlock->prev
    let next: ChengMemBlock* = memBlock->next
    if prev != nil:
        prev->next = next
    elif scope->head == memBlock:
        scope->head = next
    if next != nil:
        next->prev = prev
    memBlock->prev = nil
    memBlock->next = nil
    memBlock->scope = nil

fn cheng_mem_find_block_any(p: void*): ChengMemBlock* =
    return cheng_ptrmap_get p

fn store_int32(p: void*, val: int32) =
    if p == nil:
        return
    let pp: int32* = int32*(p)
    *pp = val

fn load_int32(p: void*): int32 =
    if p == nil:
        return 0
    let pp: int32* = int32*(p)
    return *pp

@weak
fn store_bool(p: void*, val: int8) =
    if p == nil:
        return
    var tmp: int8 = val
    c_memcpy(p, void*(&tmp), 1)

@weak
fn load_bool(p: void*): int8 =
    if p == nil:
        return 0
    var tmp: int8 = 0
    c_memcpy(void*(&tmp), p, 1)
    return tmp

fn cheng_puts(text: char*): int32 =
    if text == nil:
        return c_puts_runtime ""
    return c_puts_runtime text

fn cheng_exit(code: int32) =
    c_exit code

fn cheng_bounds_check(len: int32, idx: int32) =
    if idx < 0 || idx >= len:
        cheng_puts "cheng: bounds check failed"
        cheng_exit 1

fn cheng_index_ptr(base: void*, len: int32, idx: int32, elemSize: int32): void* =
    cheng_bounds_check(len, idx)
    if base == nil || elemSize <= 0:
        return base
    let off: int64 = int64(idx) * int64(elemSize)
    return ptr_add(base, int32(off))

# Keep bootstrap cmdline stubs under non-exported names to avoid colliding
# with std/cmdline symbols in whole-program self-link mode.
@weak
fn cheng_paramCountWeakStub(): int32 =
    return 0

@weak
fn cheng_paramStrWeakStub(i: int32): str =
    if i < 0:
        return ""
    return ""

fn __cheng_next_cap(curCap: int32, need: int32): int32 =
    if need <= 0:
        return need
    var cap: int32 = curCap
    if cap < 4:
        cap = 4
    while cap < need:
        let doubled: int32 = cap * 2
        if doubled <= 0:
            return need
        cap = doubled
    return cap

@weak
fn reserve(seq: void*, newCap: int32) =
    if seq == nil:
        return
    if newCap < 0:
        return
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seq)
    if seqHdr->buffer != nil && newCap <= seqHdr->cap:
        return
    if newCap == 0:
        return
    let targetCap: int32 = __cheng_next_cap(seqHdr->cap, newCap)
    if targetCap <= 0:
        return
    let newBuf: void* = c_realloc(seqHdr->buffer, int64(targetCap))
    if newBuf == nil:
        return
    seqHdr->buffer = newBuf
    seqHdr->cap = targetCap

# Compatibility alias for stage0/seed outputs that still reference
# the legacy monomorphized reserve symbol name.
@weak
fn reserve_ptr_void(seq: void*, newCap: int32) =
    reserve(seq, newCap)

@weak
fn setLen(seq: void*, newLen: int32) =
    if seq == nil:
        return
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seq)
    var target: int32 = newLen
    if target < 0:
        target = 0
    if target > seqHdr->cap:
        reserve(seqHdr, target)
    seqHdr->len = target

fn cheng_seq_set_grow(seqPtr: void*, idx: int32, elemSize: int32): void* =
    if seqPtr == nil || elemSize <= 0:
        return cheng_index_ptr(nil, 0, idx, elemSize)
    let seqHdr: ChengSeqHeader* = ChengSeqHeader*(seqPtr)
    if idx < 0:
        return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)
    let needLen: int32 = idx + 1
    if needLen > seqHdr->cap || seqHdr->buffer == nil:
        var newCap: int32 = seqHdr->cap
        if newCap < 4:
            newCap = 4
        while newCap < needLen:
            let doubled: int32 = newCap * 2
            if doubled <= 0:
                newCap = needLen
                break
            newCap = doubled
        let oldCap: int32 = seqHdr->cap
        let bytes: int64 = int64(newCap) * int64(elemSize)
        let newBuf: void* = c_realloc(seqHdr->buffer, bytes)
        if newBuf == nil:
            return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)
        if newCap > oldCap:
            let off: int64 = int64(oldCap) * int64(elemSize)
            let zeroBytes: int64 = (int64(newCap) - int64(oldCap)) * int64(elemSize)
            c_memset(ptr_add(newBuf, int32(off)), 0, zeroBytes)
        seqHdr->buffer = newBuf
        seqHdr->cap = newCap
    if needLen > seqHdr->len:
        seqHdr->len = needLen
    return cheng_index_ptr(seqHdr->buffer, seqHdr->len, idx, elemSize)

fn cheng_malloc(size: int32): void* =
    var n: int32 = size
    if n <= 0:
        n = 1
    let scope: ChengMemScope* = cheng_mem_current()
    let header: int64 = int64(sizeof ChengMemBlock)
    let total: int64 = header + int64(n)
    let raw: void* = c_malloc total
    if raw == nil:
        return nil
    let memBlock: ChengMemBlock* = ChengMemBlock*(raw)
    memBlock->prev = nil
    memBlock->next = nil
    memBlock->scope = nil
    memBlock->size = int64(n)
    memBlock->rc = 1
    memBlock->_pad = 0
    cheng_mem_link(scope, memBlock)
    let payload: void* = ptr_add(raw, int32(header))
    cheng_ptrmap_put(payload, memBlock)
    cheng_mm_alloc_total = cheng_mm_alloc_total + 1
    cheng_mm_live_total = cheng_mm_live_total + 1
    return payload

fn cheng_free(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    cheng_mem_unlink(memBlock)
    cheng_ptrmap_del(p)
    c_free memBlock
    cheng_mm_free_total = cheng_mm_free_total + 1
    if cheng_mm_live_total > 0:
        cheng_mm_live_total = cheng_mm_live_total - 1

fn cheng_realloc(p: void*, size: int32): void* =
    if p == nil:
        return cheng_malloc(size)
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return nil
    var n: int32 = size
    if n <= 0:
        n = 1
    let header: int64 = int64(sizeof ChengMemBlock)
    let total: int64 = header + int64(n)
    # Copy-on-write: `cheng_realloc` is used heavily by `seq` growth. When the
    # buffer is shared (rc>1), in-place realloc would invalidate aliases and can
    # corrupt the heap. Allocate a fresh block and keep the old one intact.
    if memBlock->rc > 1:
        let rawNew: void* = c_malloc total
        if rawNew == nil:
            return nil
        let newBlock: ChengMemBlock* = ChengMemBlock*(rawNew)
        newBlock->prev = nil
        newBlock->next = nil
        newBlock->scope = nil
        newBlock->size = int64(n)
        newBlock->rc = 1
        newBlock->_pad = 0
        var scope: ChengMemScope* = memBlock->scope
        if scope == nil:
            scope = cheng_mem_current()
        cheng_mem_link(scope, newBlock)
        let payloadNew: void* = ptr_add(rawNew, int32(header))
        cheng_ptrmap_put(payloadNew, newBlock)
        var copyBytes: int64 = memBlock->size
        if copyBytes > int64(n):
            copyBytes = int64(n)
        if copyBytes > 0:
            c_memcpy(payloadNew, p, copyBytes)
        # Drop this reference from the old buffer (others keep it alive).
        cheng_mem_release(p)
        cheng_mm_alloc_total = cheng_mm_alloc_total + 1
        cheng_mm_live_total = cheng_mm_live_total + 1
        return payloadNew
    let resizedRaw: void* = c_realloc(memBlock, total)
    if resizedRaw == nil:
        return nil
    let resized: ChengMemBlock* = ChengMemBlock*(resizedRaw)
    resized->size = int64(n)
    if resized != memBlock:
        let scope: ChengMemScope* = resized->scope
        if scope != nil:
            let prev: ChengMemBlock* = resized->prev
            let next: ChengMemBlock* = resized->next
            if prev != nil:
                prev->next = resized
            elif scope->head == memBlock:
                scope->head = resized
            if next != nil:
                next->prev = resized
        cheng_ptrmap_del(p)
        let payloadNew: void* = ptr_add(resizedRaw, int32(header))
        cheng_ptrmap_put(payloadNew, resized)
        return payloadNew
    return p

fn cheng_mem_scope_push(): void* =
    let mem: void* = c_malloc(int64(sizeof ChengMemScope))
    if mem == nil:
        return nil
    let scope: ChengMemScope* = ChengMemScope*(mem)
    scope->parent = cheng_mem_current()
    scope->head = nil
    cheng_scope_current = scope
    return mem

fn cheng_mem_scope_pop() =
    let scope: ChengMemScope* = cheng_mem_current()
    if scope == nil || scope == cheng_global_scope:
        return
    var cur: ChengMemBlock* = scope->head
    let header: int32 = int32(sizeof ChengMemBlock)
    while cur != nil:
        let next: ChengMemBlock* = cur->next
        let payload: void* = ptr_add(void*(cur), header)
        cheng_ptrmap_del(payload)
        c_free cur
        cheng_mm_free_total = cheng_mm_free_total + 1
        if cheng_mm_live_total > 0:
            cheng_mm_live_total = cheng_mm_live_total - 1
        cur = next
    cheng_scope_current = scope->parent != nil ? scope->parent : cheng_global_scope
    c_free scope

fn cheng_mem_scope_escape(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil || scope == cheng_global_scope:
        return
    let target: ChengMemScope* = scope->parent != nil ? scope->parent : cheng_global_scope
    if target == scope:
        return
    cheng_mem_unlink(memBlock)
    cheng_mem_link(target, memBlock)

fn cheng_mem_scope_escape_global(p: void*) =
    if p == nil:
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    let scope: ChengMemScope* = memBlock->scope
    if scope == nil || scope == cheng_global_scope:
        return
    cheng_mem_unlink(memBlock)
    cheng_mem_link(cheng_mem_global(), memBlock)

fn cheng_mem_retain(p: void*) =
    if cheng_mm_is_disabled():
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    if cheng_mm_atomic_enabled():
        # Atomic mode is a best-effort stub for now.
        memBlock->rc = memBlock->rc + 1
    else:
        memBlock->rc = memBlock->rc + 1
    cheng_mm_retain_total = cheng_mm_retain_total + 1

fn cheng_mem_release(p: void*) =
    if cheng_mm_is_disabled():
        return
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return
    if memBlock->rc > 0:
        memBlock->rc = memBlock->rc - 1
    cheng_mm_release_total = cheng_mm_release_total + 1
    if memBlock->rc <= 0:
        cheng_mem_unlink(memBlock)
        cheng_ptrmap_del(p)
        c_free memBlock
        cheng_mm_free_total = cheng_mm_free_total + 1
        if cheng_mm_live_total > 0:
            cheng_mm_live_total = cheng_mm_live_total - 1

fn cheng_mem_refcount(p: void*): int32 =
    if cheng_mm_is_disabled():
        return 0
    let memBlock: ChengMemBlock* = cheng_mem_find_block_any(p)
    if memBlock == nil:
        return 0
    return memBlock->rc

fn cheng_mem_retain_atomic(p: void*) =
    cheng_mem_retain p

fn cheng_mem_release_atomic(p: void*) =
    cheng_mem_release p

fn cheng_mem_refcount_atomic(p: void*): int32 =
    return cheng_mem_refcount p

fn memRetain(p: void*) =
    cheng_mem_retain p

fn memRelease(p: void*) =
    cheng_mem_release p

fn memRefcount(p: void*): int32 =
    return cheng_mem_refcount p

fn memScopeEscape(p: void*) =
    cheng_mem_scope_escape p

fn memScopeEscapeGlobal(p: void*) =
    cheng_mem_scope_escape_global p

fn memRetainAtomic(p: void*) =
    cheng_mem_retain_atomic p

fn memReleaseAtomic(p: void*) =
    cheng_mem_release_atomic p

fn memRefcountAtomic(p: void*): int32 =
    return cheng_mem_refcount_atomic p

fn cheng_mm_retain_count(): int64 = cheng_mm_retain_total
fn cheng_mm_release_count(): int64 = cheng_mm_release_total
fn cheng_mm_alloc_count(): int64 = cheng_mm_alloc_total
fn cheng_mm_free_count(): int64 = cheng_mm_free_total
fn cheng_mm_live_count(): int64 = cheng_mm_live_total
fn cheng_mm_diag_reset() =
    cheng_mm_retain_total = 0
    cheng_mm_release_total = 0

fn cheng_atomic_cas_i32(p: int32*, expect: int32, desired: int32): int32 =
    if p == nil:
        return 0
    if *p == expect:
        *p = desired
        return 1
    return 0

fn cheng_atomic_store_i32(p: int32*, val: int32) =
    if p == nil:
        return
    *p = val

fn cheng_atomic_load_i32(p: int32*): int32 =
    if p == nil:
        return 0
    return *p

fn cheng_memcmp(a: void*, b: void*, n: int64): int32 =
    return c_memcmp(a, b, n)

fn cheng_u64MaskLoBits(n: int32): uint64 =
    if n <= 0:
        return uint64(0)
    if n >= 64:
        return uint64(0) - uint64(1)
    return (uint64(1) << uint64(n)) - uint64(1)

fn cheng_u64RoundShiftRight(v: uint64, shift: int32): uint64 =
    if shift <= 0:
        if shift == 0:
            return v
        let leftShift: int32 = -shift
        if leftShift >= 64:
            return uint64(0)
        return v << uint64(leftShift)
    if shift >= 64:
        return uint64(0)
    let base: uint64 = v >> uint64(shift)
    let half: uint64 = uint64(1) << uint64(shift - 1)
    let lowMask: uint64 = cheng_u64MaskLoBits(shift)
    let low: uint64 = v & lowMask
    if low > half:
        return base + uint64(1)
    if low == half && (base & uint64(1)) == uint64(1):
        return base + uint64(1)
    return base

fn cheng_f32_bits_to_f64_bits(bits: int32): int64 =
    let ubits: uint64 = uint64(uint32(bits))
    let sign: uint64 = (ubits >> uint64(31)) & uint64(1)
    let exp32: int32 = int32((ubits >> uint64(23)) & uint64(0xff))
    let frac32: uint64 = ubits & uint64(0x7fffff)
    if exp32 == 255:
        let frac64NaN: uint64 = frac32 << uint64(29)
        return int64((sign << uint64(63)) | (uint64(0x7ff) << uint64(52)) | frac64NaN)
    if exp32 == 0:
        if frac32 == 0:
            return int64(sign << uint64(63))
        var mant: uint64 = frac32
        var exp: int32 = -126
        while (mant & uint64(0x800000)) == 0:
            mant = mant << uint64(1)
            exp = exp - 1
        mant = mant & uint64(0x7fffff)
        let exp64Sub: uint64 = uint64(exp + 1023)
        let frac64Sub: uint64 = mant << uint64(29)
        return int64((sign << uint64(63)) | (exp64Sub << uint64(52)) | frac64Sub)
    let exp64: uint64 = uint64(exp32 - 127 + 1023)
    let frac64: uint64 = frac32 << uint64(29)
    return int64((sign << uint64(63)) | (exp64 << uint64(52)) | frac64)

fn cheng_f64_bits_to_f32_bits(bits: int64): int32 =
    let ubits: uint64 = uint64(bits)
    let sign: uint64 = (ubits >> uint64(63)) & uint64(1)
    let exp64: int32 = int32((ubits >> uint64(52)) & uint64(0x7ff))
    let frac64: uint64 = ubits & uint64(0x000fffffffffffff)
    let signOut: uint64 = sign << uint64(31)

    if exp64 == int32(0x7ff):
        if frac64 == 0:
            return int32(signOut | (uint64(0xff) << uint64(23)))
        var fracNaN: uint64 = frac64 >> uint64(29)
        if fracNaN == 0:
            fracNaN = uint64(1)
        return int32(signOut | (uint64(0xff) << uint64(23)) | (fracNaN & uint64(0x7fffff)))

    var exp: int32 = 0
    var mant: uint64 = frac64
    if exp64 == 0:
        if mant == 0:
            return int32(signOut)
        exp = -1022
        while (mant & (uint64(1) << uint64(52))) == 0:
            mant = mant << uint64(1)
            exp = exp - 1
        mant = mant & uint64(0x000fffffffffffff)
    else:
        exp = exp64 - 1023

    var exp32: int32 = exp + 127
    let sig53: uint64 = (uint64(1) << uint64(52)) | mant

    if exp32 >= 255:
        return int32(signOut | (uint64(0xff) << uint64(23)))

    if exp32 <= 0:
        if exp32 < -23:
            return int32(signOut)
        let shiftSub: int32 = (1 - exp32) + 29
        let fracSub: uint64 = cheng_u64RoundShiftRight(sig53, shiftSub)
        if fracSub >= (uint64(1) << uint64(23)):
            return int32(signOut | (uint64(1) << uint64(23)))
        return int32(signOut | (fracSub & uint64(0x7fffff)))

    var sig24: uint64 = cheng_u64RoundShiftRight(sig53, 29)
    if sig24 >= (uint64(1) << uint64(24)):
        sig24 = sig24 >> uint64(1)
        exp32 = exp32 + 1
        if exp32 >= 255:
            return int32(signOut | (uint64(0xff) << uint64(23)))

    let fracOut: uint64 = sig24 & uint64(0x7fffff)
    return int32(signOut | (uint64(exp32) << uint64(23)) | fracOut)

fn cheng_bits_to_f32(bits: int32): float64 =
    return cheng_bits_to_f64(cheng_f32_bits_to_f64_bits(bits))

fn cheng_f32_to_bits(value: float64): int32 =
    return cheng_f64_bits_to_f32_bits(cheng_f64_to_bits(value))

fn cheng_bits_to_f64(bits: int64): float64 =
    var v64: float64
    *int64*(&v64) = bits
    return v64

fn cheng_f64_to_bits(value: float64): int64 =
    var v64: float64 = value
    return *int64*(&v64)

fn cheng_u64Clz(x0: uint64): int32 =
    if x0 == 0:
        return 64
    var x: uint64 = x0
    var n: int32 = 0
    while (x & (uint64(1) << uint64(63))) == 0:
        x = x << uint64(1)
        n = n + 1
    return n

fn cheng_u64_to_f64_bits(x: uint64): int64 =
    if x == 0:
        return 0
    let msb: int32 = 63 - cheng_u64Clz(x)
    var expBits: uint64 = uint64(msb + 1023)
    var sig: uint64 = 0
    if msb <= 52:
        sig = x << uint64(52 - msb)
    else:
        let shift: int32 = msb - 52
        let base: uint64 = x >> uint64(shift)
        let remMask: uint64 = cheng_u64MaskLoBits(shift)
        let rem: uint64 = x & remMask
        var rounded: uint64 = base
        if shift > 0:
            let half: uint64 = uint64(1) << uint64(shift - 1)
            if rem > half || (rem == half && (base & uint64(1)) == uint64(1)):
                rounded = rounded + uint64(1)
        if rounded >= (uint64(1) << uint64(53)):
            rounded = rounded >> uint64(1)
            expBits = expBits + uint64(1)
        sig = rounded
    let frac: uint64 = sig & uint64(0x000fffffffffffff)
    return int64((expBits << uint64(52)) | frac)

fn cheng_f64_bits_to_i64(bits: int64): int64 =
    let ubits: uint64 = uint64(bits)
    let sign: uint64 = (ubits >> uint64(63)) & uint64(1)
    let expRaw: int32 = int32((ubits >> uint64(52)) & uint64(0x7ff))
    let frac: uint64 = ubits & uint64(0x000fffffffffffff)
    let minIu: uint64 = uint64(1) << uint64(63)
    let maxIu: uint64 = minIu - uint64(1)

    if expRaw == int32(0x7ff):
        return sign == 0 ? int64(maxIu) : int64(minIu)
    if expRaw == 0:
        return 0

    let exp: int32 = expRaw - 1023
    if exp < 0:
        return 0
    if sign == 0 && exp > 62:
        return int64(maxIu)
    if sign != 0 && exp > 63:
        return int64(minIu)

    let sig: uint64 = (uint64(1) << uint64(52)) | frac
    var mag: uint64 = 0
    if exp >= 52:
        mag = sig << uint64(exp - 52)
    else:
        mag = sig >> uint64(52 - exp)

    if sign == 0:
        if mag > maxIu:
            return int64(maxIu)
        return int64(mag)

    if mag >= minIu:
        return int64(minIu)
    return int64(uint64(0) - mag)

fn cheng_f64_bits_to_u64(bits: int64): uint64 =
    let ubits: uint64 = uint64(bits)
    let sign: uint64 = (ubits >> uint64(63)) & uint64(1)
    let expRaw: int32 = int32((ubits >> uint64(52)) & uint64(0x7ff))
    let frac: uint64 = ubits & uint64(0x000fffffffffffff)

    if expRaw == int32(0x7ff):
        return uint64(0)
    if sign != 0:
        return uint64(0)
    if expRaw == 0:
        return uint64(0)

    let exp: int32 = expRaw - 1023
    if exp < 0:
        return uint64(0)
    if exp > 63:
        return uint64(0) - uint64(1)

    let sig: uint64 = (uint64(1) << uint64(52)) | frac
    if exp >= 52:
        return sig << uint64(exp - 52)
    return sig >> uint64(52 - exp)

fn cheng_f32_bits_to_i64(bits: int32): int64 =
    return cheng_f64_bits_to_i64(cheng_f32_bits_to_f64_bits(bits))

fn cheng_f32_bits_to_u64(bits: int32): uint64 =
    return cheng_f64_bits_to_u64(cheng_f32_bits_to_f64_bits(bits))

fn cheng_jpeg_decode(data: void*, len: int32, out_w: void*, out_h: void*): void* =
    if out_w != nil:
        *int32*(out_w) = 0
    if out_h != nil:
        *int32*(out_h) = 0
    if data == nil || len <= 0:
        return nil
    return nil

fn cheng_jpeg_free(p: void*) =
    if p == nil:
        return

@importc("__cheng_call_indirect_void")
fn __cheng_call_indirect_void(fn_ptr: void*, ctx: void*)

@importc("__cheng_call_indirect_i32")
fn __cheng_call_indirect_i32(fn_ptr: void*, ctx: int64, a: int32, b: int32): int32

type
    ChengTask =
        fn_ptr: void*
        ctx: void*
        next: ChengTask*

var
    cheng_sched_head: ChengTask*
    cheng_sched_tail: ChengTask*
    cheng_sched_count: int32

fn cheng_spawn(fn_ptr: void*, ctx: void*) =
    if fn_ptr == nil:
        return
    let mem: void* = c_malloc(int64(sizeof ChengTask))
    if mem == nil:
        __cheng_call_indirect_void(fn_ptr, ctx)
        return
    let task: ChengTask* = ChengTask*(mem)
    task->fn_ptr = fn_ptr
    task->ctx = ctx
    task->next = nil
    let tail: ChengTask* = cheng_sched_tail
    if tail != nil:
        tail->next = task
    else:
        cheng_sched_head = task
    cheng_sched_tail = task
    cheng_sched_count = cheng_sched_count + 1

fn cheng_sched_pending(): int32 =
    return cheng_sched_count

fn cheng_sched_run_once(): int32 =
    let task: ChengTask* = cheng_sched_head
    if task == nil:
        return 0
    cheng_sched_head = task->next
    if cheng_sched_head == nil:
        cheng_sched_tail = nil
    if cheng_sched_count > 0:
        cheng_sched_count = cheng_sched_count - 1
    let fn_ptr: void* = task->fn_ptr
    let ctx: void* = task->ctx
    c_free task
    if fn_ptr != nil:
        __cheng_call_indirect_void(fn_ptr, ctx)
    return 1

fn cheng_sched_run() =
    while cheng_sched_run_once() != 0:
        0

type
    ChengAwaitI32 =
        status: int32
        value: int32
    ChengAwaitVoid =
        status: int32

fn cheng_async_make_i32(ready: int32, value: int32): void* =
    let mem: void* = c_malloc(int64(sizeof ChengAwaitI32))
    if mem == nil:
        return nil
    let st: ChengAwaitI32* = ChengAwaitI32*(mem)
    st->status = ready
    st->value = value
    return mem

fn cheng_async_make_void(ready: int32): void* =
    let mem: void* = c_malloc(int64(sizeof ChengAwaitVoid))
    if mem == nil:
        return nil
    let st: ChengAwaitVoid* = ChengAwaitVoid*(mem)
    st->status = ready
    return mem

fn cheng_async_pending_i32(): void* =
    return cheng_async_make_i32(0, 0)

fn cheng_async_ready_i32(value: int32): void* =
    return cheng_async_make_i32(1, value)

fn cheng_async_set_i32(state: void*, value: int32) =
    if state == nil:
        return
    let st: ChengAwaitI32* = ChengAwaitI32*(state)
    st->value = value
    st->status = 1

fn cheng_await_i32(state: void*): int32 =
    if state == nil:
        return 0
    let st: ChengAwaitI32* = ChengAwaitI32*(state)
    while st->status == 0:
        if cheng_sched_run_once() == 0:
            continue
    return st->value

fn cheng_async_pending_void(): void* =
    return cheng_async_make_void 0

fn cheng_async_ready_void(): void* =
    return cheng_async_make_void 1

fn cheng_async_set_void(state: void*) =
    if state == nil:
        return
    let st: ChengAwaitVoid* = ChengAwaitVoid*(state)
    st->status = 1

fn cheng_await_void(state: void*) =
    if state == nil:
        return
    let st: ChengAwaitVoid* = ChengAwaitVoid*(state)
    while st->status == 0:
        if cheng_sched_run_once() == 0:
            continue

type
    ChengChanI32 =
        cap: int32
        count: int32
        head: int32
        tail: int32
        buffer: int32*

fn cheng_chan_i32_new(cap: int32): void* =
    var c: int32 = cap
    if c <= 0:
        c = 1
    let mem: void* = c_malloc(int64(sizeof ChengChanI32))
    if mem == nil:
        return nil
    let ch: ChengChanI32* = ChengChanI32*(mem)
    ch->cap = c
    ch->count = 0
    ch->head = 0
    ch->tail = 0
    let bufBytes: int64 = int64(c) * int64(sizeof int32)
    let buf: void* = c_malloc bufBytes
    if buf == nil:
        c_free mem
        return nil
    ch->buffer = int32*(buf)
    return mem

fn cheng_chan_i32_send(chPtr: void*, value: int32): int32 =
    if chPtr == nil:
        return 0
    let ch: ChengChanI32* = ChengChanI32*(chPtr)
    while ch->count >= ch->cap:
        if cheng_sched_run_once() == 0:
            return 0
    *(int32*(ptr_add(void*(ch->buffer), int32(ch->tail * 4)))) = value
    ch->tail = (ch->tail + 1) % ch->cap
    ch->count = ch->count + 1
    return 1

fn cheng_chan_i32_recv(chPtr: void*, out: int32*): int32 =
    if chPtr == nil || out == nil:
        return 0
    let ch: ChengChanI32* = ChengChanI32*(chPtr)
    while ch->count == 0:
        if cheng_sched_run_once() == 0:
            return 0
    *out = *(int32*(ptr_add(void*(ch->buffer), int32(ch->head * 4))))
    ch->head = (ch->head + 1) % ch->cap
    ch->count = ch->count - 1
    return 1

fn schedPending(): int32 =
    return cheng_sched_pending()

fn schedRunOnce(): int32 =
    return cheng_sched_run_once()

fn schedRun() =
    cheng_sched_run()

fn asyncPendingI32(): void* =
    return cheng_async_pending_i32()

fn asyncReadyI32(value: int32): void* =
    return cheng_async_ready_i32(value)

fn asyncSetI32(state: void*, value: int32) =
    cheng_async_set_i32(state, value)

fn awaitI32(state: void*): int32 =
    return cheng_await_i32(state)

fn asyncPendingVoid(): void* =
    return cheng_async_pending_void()

fn asyncReadyVoid(): void* =
    return cheng_async_ready_void()

fn asyncSetVoid(state: void*) =
    cheng_async_set_void(state)

fn awaitVoid(state: void*) =
    cheng_await_void(state)

fn chanI32New(cap: int32): void* =
    return cheng_chan_i32_new(cap)

@thread_boundary
fn chanI32Send(ch: void*, value: int32): int32 =
    return cheng_chan_i32_send(ch, value)

@thread_boundary
fn chanI32Recv(ch: void*, out: int32*): int32 =
    return cheng_chan_i32_recv(ch, out)

fn cheng_ffi_handle_slot_at(idx: int32): ChengFfiHandleSlot* =
    return ChengFfiHandleSlot*(ptr_add(void*(cheng_ffi_handle_slots), idx * int32(sizeof ChengFfiHandleSlot)))

fn cheng_ffi_handle_ensure_capacity(minCap: int32): bool =
    if minCap <= cheng_ffi_handle_slots_cap:
        return true
    var newCap: int32 = cheng_ffi_handle_slots_cap
    if newCap < 16:
        newCap = 16
    while newCap < minCap:
        if newCap > 1073741823:
            return false
        newCap = newCap * 2
    let bytes: int64 = int64(newCap) * int64(sizeof ChengFfiHandleSlot)
    let mem: void* = c_realloc(void*(cheng_ffi_handle_slots), bytes)
    if mem == nil:
        return false
    cheng_ffi_handle_slots = ChengFfiHandleSlot*(mem)
    for i in cheng_ffi_handle_slots_cap..<newCap:
        let slot: ChengFfiHandleSlot* = cheng_ffi_handle_slot_at(i)
        slot->ptr = nil
        slot->generation = uint32(1)
    cheng_ffi_handle_slots_cap = newCap
    return true

fn cheng_ffi_handle_decode_index(handle: uint64): int32 =
    if handle == uint64(0):
        return -1
    let low: uint64 = handle % cheng_ffi_handle_slot_mod
    if low == uint64(0):
        return -1
    let idx: int32 = int32(low - uint64(1))
    if idx < 0 || idx >= cheng_ffi_handle_slots_len:
        return -1
    return idx

fn cheng_ffi_handle_decode_generation(handle: uint64): uint32 =
    return uint32(handle / cheng_ffi_handle_slot_mod)

fn cheng_ffi_handle_register_ptr(ptr: void*): uint64 =
    if ptr == nil:
        return uint64(0)
    var idx: int32 = -1
    for i in 0..<cheng_ffi_handle_slots_len:
        let slot: ChengFfiHandleSlot* = cheng_ffi_handle_slot_at(i)
        if slot->ptr == nil:
            idx = i
            break
    if idx < 0:
        idx = cheng_ffi_handle_slots_len
        if !cheng_ffi_handle_ensure_capacity(idx + 1):
            return uint64(0)
        cheng_ffi_handle_slots_len = idx + 1
    let slot: ChengFfiHandleSlot* = cheng_ffi_handle_slot_at(idx)
    slot->ptr = ptr
    if slot->generation == uint32(0):
        slot->generation = uint32(1)
    return uint64(slot->generation) * cheng_ffi_handle_slot_mod + uint64(idx + 1)

fn cheng_ffi_handle_resolve_ptr(handle: uint64): void* =
    let idx: int32 = cheng_ffi_handle_decode_index(handle)
    if idx < 0:
        return nil
    let generation: uint32 = cheng_ffi_handle_decode_generation(handle)
    if generation == uint32(0):
        return nil
    let slot: ChengFfiHandleSlot* = cheng_ffi_handle_slot_at(idx)
    if slot->ptr == nil || slot->generation != generation:
        return nil
    return slot->ptr

fn cheng_ffi_handle_invalidate(handle: uint64): int32 =
    let idx: int32 = cheng_ffi_handle_decode_index(handle)
    if idx < 0:
        return cheng_ffi_handle_err_invalid
    let generation: uint32 = cheng_ffi_handle_decode_generation(handle)
    if generation == uint32(0):
        return cheng_ffi_handle_err_invalid
    let slot: ChengFfiHandleSlot* = cheng_ffi_handle_slot_at(idx)
    if slot->ptr == nil || slot->generation != generation:
        return cheng_ffi_handle_err_invalid
    slot->ptr = nil
    if slot->generation == cheng_ffi_handle_max_generation:
        slot->generation = uint32(1)
    else:
        slot->generation = slot->generation + uint32(1)
    return 0

fn cheng_ffi_handle_new_i32(value: int32): uint64 =
    let mem: void* = c_malloc(int64(sizeof int32))
    if mem == nil:
        return uint64(0)
    let cell: int32* = int32*(mem)
    *cell = value
    let handle: uint64 = cheng_ffi_handle_register_ptr(mem)
    if handle == uint64(0):
        c_free(mem)
    return handle

fn cheng_ffi_handle_get_i32(handle: uint64, outValue: int32*): int32 =
    if outValue == nil:
        return cheng_ffi_handle_err_invalid
    let cell: int32* = int32*(cheng_ffi_handle_resolve_ptr(handle))
    if cell == nil:
        return cheng_ffi_handle_err_invalid
    *outValue = *cell
    return 0

fn cheng_ffi_handle_add_i32(handle: uint64, delta: int32, outValue: int32*): int32 =
    if outValue == nil:
        return cheng_ffi_handle_err_invalid
    let cell: int32* = int32*(cheng_ffi_handle_resolve_ptr(handle))
    if cell == nil:
        return cheng_ffi_handle_err_invalid
    *cell = *cell + delta
    *outValue = *cell
    return 0

fn cheng_ffi_handle_release_i32(handle: uint64): int32 =
    let cell: int32* = int32*(cheng_ffi_handle_resolve_ptr(handle))
    if cell == nil:
        return cheng_ffi_handle_err_invalid
    let rc: int32 = cheng_ffi_handle_invalidate(handle)
    if rc != 0:
        return rc
    c_free(void*(cell))
    return 0

fn cheng_abi_sum9_i64(a, b, c, d, e, f, g, h, i: int64): int64 =
    return a + b + c + d + e + f + g + h + i

fn cheng_abi_sum9_i32(a, b, c, d, e, f, g, h, i: int32): int32 =
    return a + b + c + d + e + f + g + h + i

fn cheng_abi_sum16_i64(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p: int64): int64 =
    return a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p

fn cheng_abi_sum16_i32(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p: int32): int32 =
    return a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p

fn cheng_abi_mix_i32_i64(a: int32, b: int64, c: int32, d: int64): int64 =
    return int64(a) + b + int64(c) + d

fn cheng_abi_store_i32(p: int64, v: int32) =
    if p == 0:
        return
    let pp: int32* = int32*(void*(uint64(p)))
    *pp = v

fn cheng_abi_load_i32(p: int64): int32 =
    if p == 0:
        return 0
    let pp: int32* = int32*(void*(uint64(p)))
    return *pp

fn cheng_abi_call_cb_ctx_i32(fn_ptr: void*, ctx: int64, a: int32, b: int32): int32 =
    if fn_ptr == nil:
        return 0
    return __cheng_call_indirect_i32(fn_ptr, ctx, a, b)

# Darwin/AArch64 varargs shim:
# backend varargs lowering keeps `n` in x0 and writes varargs payload to stack slots.
# `_r*` are ignored register placeholders so `a0..a9` map to stack payload slots.
fn cheng_abi_varargs_sum_i32(n: int32,
                             _r0, _r1, _r2, _r3, _r4, _r5, _r6: int32,
                             a0, a1, a2, a3, a4, a5, a6, a7, a8, a9: int64): int32 =
    if n <= 0:
        return 0
    var sum: int32 = 0
    if n >= 1:
        sum = sum + int32(a0)
    if n >= 2:
        sum = sum + int32(a1)
    if n >= 3:
        sum = sum + int32(a2)
    if n >= 4:
        sum = sum + int32(a3)
    if n >= 5:
        sum = sum + int32(a4)
    if n >= 6:
        sum = sum + int32(a5)
    if n >= 7:
        sum = sum + int32(a6)
    if n >= 8:
        sum = sum + int32(a7)
    if n >= 9:
        sum = sum + int32(a8)
    if n >= 10:
        sum = sum + int32(a9)
    return sum

fn cheng_abi_varargs_sum10_i32_fixed(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9: int32): int32 =
    return a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9

fn cheng_abi_ret_pair_i32_out(outA: int64, outB: int64, a: int32, b: int32) =
    if outA != 0:
        let pa: int32* = int32*(void*(uint64(outA)))
        *pa = a
    if outB != 0:
        let pb: int32* = int32*(void*(uint64(outB)))
        *pb = b

fn cheng_abi_out_pair_i32(outA: int64, outB: int64, a: int32, b: int32) =
    cheng_abi_ret_pair_i32_out(outA, outB, a, b)

# --- Minimal std/os + os.cheng backend runtime (Darwin/POSIX, AArch64) ---

type
    DarwinTimespec =
        tv_sec: int64
        tv_nsec: int64
    DarwinStat =
        st_dev: int32
        st_mode: uint16
        st_nlink: uint16
        st_ino: uint64
        st_uid: uint32
        st_gid: uint32
        st_rdev: int32
        st_atimespec: DarwinTimespec
        st_mtimespec: DarwinTimespec
        st_ctimespec: DarwinTimespec
        st_birthtimespec: DarwinTimespec
        st_size: int64
        st_blocks: int64
        st_blksize: int32
        st_flags: uint32
        st_gen: uint32
        st_lspare: int32
        st_qspare0: int64
        st_qspare1: int64
    DarwinDirent =
        d_ino: uint64
        d_seekoff: uint64
        d_reclen: uint16
        d_namlen: uint16
        d_type: uint8

const
    cheng_dirent_name_off: int32 = 21
    cheng_clock_monotonic: int32 = 6

fn cheng_is_digit(c: char): bool =
    return c >= '0' && c <= '9'

fn cheng_cstr_len(s: char*): int64 =
    if s == nil:
        return 0
    return c_strlen s

fn cheng_strdup(s: char*): char* =
    if s == nil:
        let out0: void* = cheng_malloc(1)
        if out0 != nil:
            *(char*(out0)) = '\0'
        return char*(out0)
    let n64: int64 = c_strlen s
    if n64 < 0:
        return nil
    let n32: int32 = int32(n64)
    let out: void* = cheng_malloc(n32 + 1)
    if out == nil:
        return nil
    if n32 > 0:
        c_memcpy(out, void*(s), int64(n32))
    *(char*(ptr_add(out, n32))) = '\0'
    return char*(out)

fn cheng_parse_f64_bits(s: char*): int64 =
    if s == nil:
        return 0
    var i: int32 = 0
    # Skip leading spaces (best-effort).
    while true:
        let c: char = *(char*(ptr_add(void*(s), i)))
        if c == ' ' || c == '\t' || c == '\n' || c == '\r':
            i = i + 1
            continue
        break
    var neg: bool = false
    let c0: char = *(char*(ptr_add(void*(s), i)))
    if c0 == '-':
        neg = true
        i = i + 1
    elif c0 == '+':
        i = i + 1

    let zeroBits: int64 = cheng_i64_to_f64_bits(0)
    let oneBits: int64 = cheng_i64_to_f64_bits(1)
    let tenBits: int64 = cheng_i64_to_f64_bits(10)

    var intBits: int64 = zeroBits
    var anyDigit: bool = false
    while true:
        let ch: char = *(char*(ptr_add(void*(s), i)))
        if !cheng_is_digit(ch):
            break
        anyDigit = true
        let d: int32 = int32(ch) - int32('0')
        let dBits: int64 = cheng_i64_to_f64_bits(int64(d))
        intBits = cheng_f64_add_bits(cheng_f64_mul_bits(intBits, tenBits), dBits)
        i = i + 1

    var fracBits: int64 = zeroBits
    var scaleBits: int64 = oneBits
    var anyFrac: bool = false
    let dot: char = *(char*(ptr_add(void*(s), i)))
    if dot == '.':
        i = i + 1
        while true:
            let ch: char = *(char*(ptr_add(void*(s), i)))
            if !cheng_is_digit(ch):
                break
            anyDigit = true
            anyFrac = true
            let d: int32 = int32(ch) - int32('0')
            let dBits: int64 = cheng_i64_to_f64_bits(int64(d))
            fracBits = cheng_f64_add_bits(cheng_f64_mul_bits(fracBits, tenBits), dBits)
            scaleBits = cheng_f64_mul_bits(scaleBits, tenBits)
            i = i + 1

    var outBits: int64 = intBits
    if anyFrac:
        outBits = cheng_f64_add_bits(outBits, cheng_f64_div_bits(fracBits, scaleBits))
    if !anyDigit:
        outBits = zeroBits
    if neg:
        outBits = cheng_f64_neg_bits(outBits)
    return outBits

fn cheng_fopen(filename: char*, mode: char*): void* =
    return libc_fopen(filename, mode)

fn cheng_fclose(f: void*): int32 =
    return libc_fclose(f)

fn cheng_fread(ptr: void*, size: int64, n: int64, stream: void*): int32 =
    let got: int64 = libc_fread(ptr, size, n, stream)
    if got <= 0:
        return int32(got)
    # Clamp to int32 (callers use small reads; keep it simple).
    if got > int64(0x7fffffff):
        return int32(0x7fffffff)
    return int32(got)

fn cheng_fwrite(ptr: void*, size: int64, n: int64, stream: void*): int32 =
    let wrote: int64 = libc_fwrite(ptr, size, n, stream)
    if wrote <= 0:
        return int32(wrote)
    if wrote > int64(0x7fffffff):
        return int32(0x7fffffff)
    return int32(wrote)

fn cheng_fseek(stream: void*, offset: int64, whence: int32): int32 =
    return libc_fseeko(stream, offset, whence)

fn cheng_ftell(stream: void*): int64 =
    return libc_ftello(stream)

fn cheng_fflush(stream: void*): int32 =
    return libc_fflush(stream)

fn cheng_fgetc(stream: void*): int32 =
    return libc_fgetc(stream)

var
    cheng_stdio_in: void*
    cheng_stdio_out: void*
    cheng_stdio_err: void*

fn get_stdin(): void* =
    if cheng_stdio_in != nil:
        return cheng_stdio_in
    cheng_stdio_in = libc_fdopen(0, "r")
    return cheng_stdio_in

fn get_stdout(): void* =
    if cheng_stdio_out != nil:
        return cheng_stdio_out
    cheng_stdio_out = libc_fdopen(1, "w")
    return cheng_stdio_out

fn get_stderr(): void* =
    if cheng_stdio_err != nil:
        return cheng_stdio_err
    cheng_stdio_err = libc_fdopen(2, "w")
    return cheng_stdio_err

fn cheng_iometer_call(hook: void*, op: int32, bytes: int64) =
    hook
    op
    bytes

fn cheng_file_exists(path: char*): int32 =
    if path == nil || *path == '\0':
        return 0
    let f: void* = libc_fopen(path, "rb")
    if f != nil:
        libc_fclose(f)
        return 1
    return 0

fn cheng_dir_exists(path: char*): int32 =
    if path == nil || *path == '\0':
        return 0
    let d: void* = libc_opendir(path)
    if d != nil:
        libc_closedir(d)
        return 1
    return 0

fn cheng_file_mtime(path: char*): int64 =
    if path == nil || *path == '\0':
        return 0
    var st: DarwinStat
    if libc_stat(path, void*(&st)) != 0:
        return 0
    return st.st_mtimespec.tv_sec

fn cheng_file_size(path: char*): int64 =
    if path == nil || *path == '\0':
        return 0
    var st: DarwinStat
    if libc_stat(path, void*(&st)) != 0:
        return 0
    return st.st_size

fn cheng_epoch_time(): int64 =
    # Return seconds since epoch as f64-bits (soft float representation).
    let secs: int64 = libc_time(nil)
    return cheng_i64_to_f64_bits(secs)

fn cheng_monotime_ns(): int64 =
    var ts: DarwinTimespec
    if libc_clock_gettime(cheng_clock_monotonic, void*(&ts)) != 0:
        return 0
    return ts.tv_sec * 1000000000 + ts.tv_nsec

fn cheng_mkdir1(path: char*): int32 =
    if path == nil || *path == '\0':
        return -1
    return libc_mkdir(path, 493) # 0755

var
    cheng_getcwd_buf: void*

fn cheng_getcwd(): char* =
    if cheng_getcwd_buf == nil:
        cheng_getcwd_buf = c_malloc(4096)
        if cheng_getcwd_buf == nil:
            return ""
        c_memset(cheng_getcwd_buf, 0, 4096)
    let res: char* = libc_getcwd(char*(cheng_getcwd_buf), 4096)
    if res == nil:
        *(char*(cheng_getcwd_buf)) = '\0'
        return ""
    *(char*(ptr_add(cheng_getcwd_buf, 4095))) = '\0'
    return char*(cheng_getcwd_buf)

fn cheng_list_dir(path: char*): char* =
    if path == nil || *path == '\0':
        return cheng_strdup("")
    let d: void* = libc_opendir(path)
    if d == nil:
        return cheng_strdup("")
    var cap: int32 = 256
    var lenOut: int32 = 0
    var out: void* = cheng_malloc(cap)
    if out == nil:
        libc_closedir(d)
        return nil
    *(char*(out)) = '\0'
    while true:
        let entRaw: void* = libc_readdir(d)
        if entRaw == nil:
            break
        let ent: DarwinDirent* = DarwinDirent*(entRaw)
        let nameLenU16: uint16 = ent->d_namlen
        var nameLen: int32 = int32(nameLenU16)
        if nameLen <= 0:
            continue
        let namePtr: char* = char*(ptr_add(entRaw, cheng_dirent_name_off))
        # Skip "." and ".."
        if nameLen == 1 && *namePtr == '.':
            continue
        if nameLen == 2 && *namePtr == '.' && *(char*(ptr_add(void*(namePtr), 1))) == '.':
            continue
        # Ensure space: name + '\n' + '\0'
        var need: int32 = lenOut + nameLen + 2
        if need > cap:
            var newCap: int32 = cap
            if newCap <= 0:
                newCap = 256
            while newCap < need:
                newCap = newCap * 2
            let next: void* = cheng_realloc(out, newCap)
            if next == nil:
                break
            out = next
            cap = newCap
        c_memcpy(ptr_add(out, lenOut), void*(namePtr), int64(nameLen))
        lenOut = lenOut + nameLen
        *(char*(ptr_add(out, lenOut))) = '\n'
        lenOut = lenOut + 1
        *(char*(ptr_add(out, lenOut))) = '\0'
    libc_closedir(d)
    return char*(out)

fn cheng_exec_cmd_ex(command: char*, workingDir: char*, mergeStderr: int32, exitCode: int64*): char* =
    if exitCode != nil:
        *exitCode = -1
    if command == nil || *command == '\0':
        return cheng_strdup("")

    # Build shell command (best-effort): optional `cd "<wd>" &&` and optional `2>&1`.
    let cmdLen: int64 = cheng_cstr_len(command)
    let wdLen: int64 = cheng_cstr_len(workingDir)
    let hasWd: bool = wdLen > 0
    let hasMerge: bool = mergeStderr != 0
    var extra: int64 = 0
    if hasWd:
        extra = extra + int64(6) + wdLen + int64(5) # cd " + wd + " && 
    if hasMerge:
        extra = extra + int64(5) # 2>&1
    let totalLen: int64 = cmdLen + extra
    var full: char* = command
    var tmp: void* = nil
    if extra > 0:
        tmp = c_malloc(totalLen + 1)
        if tmp == nil:
            return cheng_strdup("")
        var pos: int64 = 0
        if hasWd:
            c_memcpy(ptr_add(tmp, int32(pos)), void*("cd \""), 4)
            pos = pos + 4
            c_memcpy(ptr_add(tmp, int32(pos)), void*(workingDir), wdLen)
            pos = pos + wdLen
            c_memcpy(ptr_add(tmp, int32(pos)), void*("\" && "), 5)
            pos = pos + 5
        c_memcpy(ptr_add(tmp, int32(pos)), void*(command), cmdLen)
        pos = pos + cmdLen
        if hasMerge:
            c_memcpy(ptr_add(tmp, int32(pos)), void*(" 2>&1"), 5)
            pos = pos + 5
        *(char*(ptr_add(tmp, int32(pos)))) = '\0'
        full = char*(tmp)

    let pipe: void* = libc_popen(full, "r")
    if tmp != nil:
        c_free tmp
    if pipe == nil:
        return cheng_strdup("")

    var outCap: int32 = 256
    var outLen: int32 = 0
    var out: void* = cheng_malloc(outCap)
    if out == nil:
        libc_pclose(pipe)
        return nil
    *(char*(out)) = '\0'
    while true:
        let avail: int32 = outCap - outLen - 1
        if avail < 4096:
            var needCap: int32 = outLen + 4096 + 1
            var newCap: int32 = outCap
            while newCap < needCap:
                newCap = newCap * 2
            let next: void* = cheng_realloc(out, newCap)
            if next == nil:
                break
            out = next
            outCap = newCap
            continue
        let dst: void* = ptr_add(out, outLen)
        let got: int64 = libc_fread(dst, 1, 4096, pipe)
        if got <= 0:
            break
        outLen = outLen + int32(got)
        *(char*(ptr_add(out, outLen))) = '\0'
        if got < 4096:
            break
    let status: int32 = libc_pclose(pipe)
    if exitCode != nil:
        if status < 0:
            *exitCode = -1
        else:
            # wait status -> exit code (best-effort)
            *exitCode = int64((status >> 8) & 0xff)
    return char*(out)

fn chengQ_execQ_cmdQ_ex_0(command: char*, workingDir: char*, mergeStderr: int32, exitCode: int64*): char* =
    return cheng_exec_cmd_ex(command, workingDir, mergeStderr, exitCode)

fn cheng_pty_is_supported(): int32 = 0
fn cheng_pty_spawn(command: char*, workingDir: char*, outMasterFd: int32*, outPid: int64*): int32 =
    command
    workingDir
    if outMasterFd != nil:
        *outMasterFd = -1
    if outPid != nil:
        *outPid = -1
    return 0
fn cheng_pipe_spawn(command: char*, workingDir: char*, outReadFd: int32*, outWriteFd: int32*, outPid: int64*): int32 =
    command
    workingDir
    if outReadFd != nil:
        *outReadFd = -1
    if outWriteFd != nil:
        *outWriteFd = -1
    if outPid != nil:
        *outPid = -1
    return 0
fn cheng_pty_read(fd: int32, maxBytes: int32, outEof: int32*): char* =
    fd
    maxBytes
    if outEof != nil:
        *outEof = 1
    return cheng_strdup("")
fn cheng_fd_read(fd: int32, maxBytes: int32, outEof: int32*): char* =
    fd
    maxBytes
    if outEof != nil:
        *outEof = 1
    return cheng_strdup("")
fn cheng_fd_read_wait(fd: int32, maxBytes: int32, timeoutMs: int32, outEof: int32*): char* =
    fd
    maxBytes
    timeoutMs
    if outEof != nil:
        *outEof = 1
    return cheng_strdup("")
fn cheng_pty_write(fd: int32, data: char*, len: int32): int32 =
    fd
    data
    len
    return 0
fn cheng_pty_close(fd: int32): int32 =
    fd
    return 0
fn cheng_pty_wait(pid: int64, outExitCode: int32*): int32 =
    pid
    if outExitCode != nil:
        *outExitCode = -1
    return 0

fn cheng_set_sockaddr_linux_inet(addr: void*, port: int32, inaddr: int32) =
    cheng_bytes_set(addr, 0, cheng_sockaddr_in_len)
    *(uint8*(addr)) = uint8(cheng_af_inet)
    *(uint8*(ptr_add(addr, 1))) = uint8(0)
    *(uint8*(ptr_add(addr, 2))) = uint8((port >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 3))) = uint8(port & 0xFF)
    *(uint8*(ptr_add(addr, 4))) = uint8((inaddr >> 24) & 0xFF)
    *(uint8*(ptr_add(addr, 5))) = uint8((inaddr >> 16) & 0xFF)
    *(uint8*(ptr_add(addr, 6))) = uint8((inaddr >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 7))) = uint8(inaddr & 0xFF)

fn cheng_set_sockaddr_darwin_inet(addr: void*, port: int32, inaddr: int32) =
    cheng_bytes_set(addr, 0, cheng_sockaddr_in_len)
    *(uint8*(addr)) = uint8(cheng_sockaddr_in_len)
    *(uint8*(ptr_add(addr, 1))) = uint8(cheng_af_inet)
    *(uint8*(ptr_add(addr, 2))) = uint8((port >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 3))) = uint8(port & 0xFF)
    *(uint8*(ptr_add(addr, 4))) = uint8((inaddr >> 24) & 0xFF)
    *(uint8*(ptr_add(addr, 5))) = uint8((inaddr >> 16) & 0xFF)
    *(uint8*(ptr_add(addr, 6))) = uint8((inaddr >> 8) & 0xFF)
    *(uint8*(ptr_add(addr, 7))) = uint8(inaddr & 0xFF)

fn cheng_bind_ipv4_listener(fd: int32, addr: void*, port: int32, inaddr: int32): bool =
    cheng_set_sockaddr_linux_inet(addr, port, inaddr)
    if bind(fd, addr, cheng_sockaddr_in_len) == 0:
        return true
    cheng_set_sockaddr_darwin_inet(addr, port, inaddr)
    if bind(fd, addr, cheng_sockaddr_in_len) == 0:
        return true
    return false

# Network/login helpers.
fn cheng_tcp_listener(port: int32, outPort: int32*): int32 =
    let fd: int32 = socket(cheng_af_inet, cheng_sock_stream, 0)
    if fd < 0:
        return -1

    let sockOptVal: int32 = 1
    setsockopt(fd, cheng_sol_socket, cheng_so_reuseaddr, void*(&sockOptVal), int32(sizeof int32))
    setsockopt(fd, cheng_sol_socket, cheng_so_reuseport, void*(&sockOptVal), int32(sizeof int32))

    let addr: void* = alloc(cheng_sockaddr_in_len)
    if addr == nil:
        cheng_errno_code = 1
        close(fd)
        return -1
    let allowAny: bool = !cheng_strIsEmpty(c_getenv("CODEX_LOGIN_ALLOW_ANY"))

    let bindRes: bool = cheng_bind_ipv4_listener(fd, addr, port, cheng_inaddr_loopback)
    if !bindRes:
        if !allowAny:
            close(fd)
            dealloc(addr)
            return -1
        if !cheng_bind_ipv4_listener(fd, addr, port, 0):
            close(fd)
            dealloc(addr)
            return -1

    if listen(fd, 64) != 0:
        close(fd)
        dealloc(addr)
        return -1

    if outPort != nil:
        let name: void* = alloc(cheng_sockaddr_in_len)
        if name == nil:
            close(fd)
            cheng_errno_code = 1
            dealloc(addr)
            return -1
        let namelen: int32* = int32*(alloc(4))
        if namelen == nil:
            close(fd)
            dealloc(name)
            dealloc(addr)
            cheng_errno_code = 1
            return -1
        *namelen = cheng_sockaddr_in_len
        if getsockname(fd, name, namelen) != 0:
            close(fd)
            dealloc(name)
            dealloc(namelen)
            dealloc(addr)
            return -1
        let hiPortByte: int32 = int32(*(uint8*(ptr_add(name, 2))))
        let loPortByte: int32 = int32(*(uint8*(ptr_add(name, 3))))
        *outPort = (hiPortByte << 8) | loPortByte
        dealloc(name)
        dealloc(namelen)
    dealloc(addr)
    cheng_errno_code = 0
    return fd

fn cheng_errno(): int32 =
    return cheng_errno_code

fn cheng_get_errno_code(): int32 =
    let errnoPtr: int32* = libc_errno_ptr()
    if errnoPtr == nil:
        return 1
    return *errnoPtr

fn cheng_strerror(err: int32): char* =
    if err == 0:
        return libc_strerror(0)
    if err == 1:
        return "Operation not permitted"
    if err == 11:
        return "Resource temporarily unavailable"
    if err == 35:
        return "Resource temporarily unavailable"
    if err == 95:
        return "Operation not supported"
    if err == 22:
        return "Invalid argument"
    if err == 32:
        return "Broken pipe"
    if err == 97:
        return "Address family not supported by protocol"
    if err == 98:
        return "Address already in use"
    if err == 99:
        return "Cannot assign requested address"
    if err == 111:
        return "Connection refused"
    return libc_strerror(err)

fn close(fd: int32): int32 =
    let ret: int32 = libc_close(fd)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn socket(domain: int32, typ: int32, protocol: int32): int32 =
    let ret: int32 = libc_socket(domain, typ, protocol)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn cheng_normalize_bind_sockaddr_darwin(addr: void*, len: int32, needFree: bool*): void* =
    if needFree != nil:
        *needFree = false
    if addr == nil || len != cheng_sockaddr_in_len:
        return addr
    let b0: uint8 = *(uint8*(addr))
    let b1: uint8 = *(uint8*(ptr_add(addr, 1)))
    if b0 != uint8(cheng_af_inet) || b1 != uint8(0):
        return addr
    let normalized: void* = alloc(cheng_sockaddr_in_len)
    if normalized == nil:
        return addr
    cheng_bytes_copy(normalized, addr, int64(cheng_sockaddr_in_len))
    *(uint8*(normalized)) = uint8(cheng_sockaddr_in_len)
    *(uint8*(ptr_add(normalized, 1))) = uint8(cheng_af_inet)
    if needFree != nil:
        *needFree = true
    return normalized

fn bind(fd: int32, addr: void*, len: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || len != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var bindAddrNeedsFree: bool = false
    let bindAddr: void* = cheng_normalize_bind_sockaddr_darwin(addr, len, &bindAddrNeedsFree)
    let ret: int32 = libc_bind(fd, bindAddr, len)
    if bindAddrNeedsFree:
        dealloc(bindAddr)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn sendto(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if buf == nil && len > 0:
        cheng_errno_code = cheng_efault
        return -1
    if addr == nil:
        if addrlen != 0:
            cheng_errno_code = cheng_einval
            return -1
        let retNoAddr: int32 = libc_sendto(fd, buf, len, flags, nil, 0)
        if retNoAddr < 0:
            cheng_errno_code = cheng_get_errno_code()
            return -1
        cheng_errno_code = 0
        return retNoAddr
    if addrlen != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var sendAddrNeedsFree: bool = false
    let sendAddr: void* = cheng_normalize_bind_sockaddr_darwin(addr, addrlen, &sendAddrNeedsFree)
    let ret: int32 = libc_sendto(fd, buf, len, flags, sendAddr, addrlen)
    if sendAddrNeedsFree:
        dealloc(sendAddr)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn send(fd: int32, buf: void*, len: int32, flags: int32): int32 =
    let ret: int32 = libc_send(fd, buf, len, flags)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn sendmsg(fd: int32, msg: void*, flags: int32): int32 =
    let ret: int32 = libc_sendmsg(fd, msg, flags)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn recvfrom(fd: int32, buf: void*, len: int32, flags: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if buf == nil && len > 0:
        cheng_errno_code = cheng_efault
        return -1
    let ret: int32 = libc_recvfrom(fd, buf, len, flags, addr, addrlen)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn recv(fd: int32, buf: void*, len: int32, flags: int32): int32 =
    let ret: int32 = libc_recv(fd, buf, len, flags)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn recvmsg(fd: int32, msg: void*, flags: int32): int32 =
    let ret: int32 = libc_recvmsg(fd, msg, flags)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn getsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32*): int32 =
    let ret: int32 = libc_getsockopt(fd, level, optname, optval, optlen)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn socketpair(domain: int32, typ: int32, protocol: int32, sv: int32*): int32 =
    let ret: int32 = libc_socketpair(domain, typ, protocol, sv)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn setsockopt(fd: int32, level: int32, optname: int32, optval: void*, optlen: int32): int32 =
    let ret: int32 = libc_setsockopt(fd, level, optname, optval, optlen)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn listen(fd: int32, backlog: int32): int32 =
    let ret: int32 = libc_listen(fd, backlog)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn getsockname(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || addrlen == nil:
        cheng_errno_code = cheng_efault
        return -1
    let ret: int32 = libc_getsockname(fd, addr, addrlen)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn getpeername(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || addrlen == nil:
        cheng_errno_code = cheng_efault
        return -1
    let ret: int32 = libc_getpeername(fd, addr, addrlen)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn connect(fd: int32, addr: void*, len: int32): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    if addr == nil || len != cheng_sockaddr_in_len:
        cheng_errno_code = cheng_einval
        return -1
    var connectAddrNeedsFree: bool = false
    let connectAddr: void* = cheng_normalize_bind_sockaddr_darwin(addr, len, &connectAddrNeedsFree)
    let ret: int32 = libc_connect(fd, connectAddr, len)
    if connectAddrNeedsFree:
        dealloc(connectAddr)
    if ret != 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

fn accept(fd: int32, addr: void*, addrlen: int32*): int32 =
    if fd < 0:
        cheng_errno_code = cheng_ebadf
        return -1
    let ret: int32 = libc_accept(fd, addr, addrlen)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return ret

fn shutdown(fd: int32, how: int32): int32 =
    let ret: int32 = libc_shutdown(fd, how)
    if ret < 0:
        cheng_errno_code = cheng_get_errno_code()
        return -1
    cheng_errno_code = 0
    return 0

# Windows RNG API shim (used by some upstream libs); stubbed on non-Windows.
fn SystemFunction036(buf: void*, len: int32): int32 =
    buf
    len
    return 0

# Backend fallback for `__addr`: identity on pointer-sized values.
fn __addr(value: int64): int64 = value
fn _addr(value: int64): int64 = value
