# std/strutils (minimal, pure Cheng)
import std/strings
import std/seqs
import std/system

type
    FloatFormatMode = enum
        ffDefault, ffDecimal

fn isStripDefaultChar(ch: char): bool =
    return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'

fn sliceStr(s: str, start: int32, stop: int32): str =
    if s == nil:
        return ""
    var s0: int32 = start
    var e: int32 = stop
    if s0 < 0:
        s0 = 0
    let n: int32 = len s
    if e < s0 || s0 >= n:
        return ""
    if e >= n:
        e = n - 1
    let count: int32 = e - s0 + 1
    let p: void* = alloc(count + 1)
    let src: void* = ptr_add(void*(s), s0)
    copyMem(p, src, count)
    setMem(ptr_add(p, count), 0, 1)
    return str(p)

fn startsWith(s: str, prefix: str): bool =
    if len prefix > len s:
        return false
    for i in 0..<len prefix:
        if s[i] != prefix[i]:
            return false
    return true

fn contains(s: str, sub: str): bool =
    if len sub == 0:
        return true
    if len sub > len s:
        return false
    var i: int32 = 0
    let n: int32 = len s
    let m: int32 = len sub
    while i + m <= n:
        var j: int32 = 0
        var matched: bool = true
        let __for_start_j_1 = j
        for __for_j_1 in __for_start_j_1..<m:
            j = __for_j_1
            if s[i + j] != sub[j]:
                matched = false
                break
            j = j + 1
        if matched:
            return true
        i = i + 1
    return false

fn toLowerAscii(s: str): str =
    var out: str = ""
    for i in 0..<len s:
        var ch = s[i]
        if ch >= 'A' && ch <= 'Z':
            let oc: int32 = int32(ch) + 32
            ch = chr oc
        out = out + charToStr ch
    return out

fn toUpperAscii(s: str): str =
    var out: str = ""
    for i in 0..<len s:
        var ch = s[i]
        if ch >= 'a' && ch <= 'z':
            let oc: int32 = int32(ch) - 32
            ch = chr oc
        out = out + charToStr ch
    return out

fn setHasChar(chars: set[char], value: char): bool =
    let ordValue = int32(value)
    let idx64 = int64(ordValue)
    let idx = uint64(idx64)
    let mask = (uint64(1)) << idx
    let bits = uint64(chars)
    return (bits & mask) != 0

fn strip(s: str, chars: set[char]): str =
    if len s == 0:
        return s
    var start = 0
    var stop = len s - 1
    let __for_start_start_2 = start
    for __for_start_2 in __for_start_start_2..stop:
        start = __for_start_2
        if ! (start <= stop && setHasChar(chars, s[start])):
            break
        start = start + 1
    let __for_start_stop_3 = stop
    for __for_stop_3 in 0..(__for_start_stop_3 - (start)):
        stop = __for_start_stop_3 - __for_stop_3
        if ! (stop >= start && setHasChar(chars, s[stop])):
            break
        stop = stop - 1
    if stop < start:
        return ""
    if start == 0 && stop == len s - 1:
        return s
    return sliceStr(s, start, stop)

fn strip(s: str): str =
    if len s == 0:
        return s
    var start = 0
    var stop = len s - 1
    let __for_start_start_4 = start
    for __for_start_4 in __for_start_start_4..stop:
        start = __for_start_4
        if ! (start <= stop && isStripDefaultChar(s[start])):
            break
        start = start + 1
    let __for_start_stop_5 = stop
    for __for_stop_5 in 0..(__for_start_stop_5 - (start)):
        stop = __for_start_stop_5 - __for_stop_5
        if ! (stop >= start && isStripDefaultChar(s[stop])):
            break
        stop = stop - 1
    if stop < start:
        return ""
    if start == 0 && stop == len s - 1:
        return s
    return sliceStr(s, start, stop)

fn split(s: str, sep: char): str[] =
    var out: str[]
    var start = 0
    for i in 0..<len s:
        if s[i] == sep:
            if i > start:
                out.add sliceStr(s, start, i - 1)
            else:
                out.add ""
            start = i + 1
    if start <= len s - 1:
        out.add sliceStr(s, start, len s - 1)
    elif start == len s:
        out.add ""
    return out

fn splitWhitespace(s: str): str[] =
    var out: str[]
    var i = 0
    let __for_guard_start_i_1 = i
    for __for_guard_i_1 in __for_guard_start_i_1..<len s:
        if ! (i < len s):
            break
        let __for_start_i_6 = i
        for __for_i_6 in __for_start_i_6..<len s:
            i = __for_i_6
            if ! (i < len s && isStripDefaultChar(s[i])):
                break
            i = i + 1
        if i >= len s:
            break
        var start = i
        let __for_start_i_7 = i
        for __for_i_7 in __for_start_i_7..<len s:
            i = __for_i_7
            if ! (i < len s && ! isStripDefaultChar(s[i])):
                break
            i = i + 1
        if i > start:
            out.add sliceStr(s, start, i - 1)
    return out

fn join(parts: str[], sep: str): str =
    var out: str = ""
    for i in 0..<parts.len:
        if i > 0:
            out = out + sep
        out = out + parts[i]
    return out

fn replace(s: str, oldSub: str, newSub: str): str =
    if len oldSub == 0:
        return s
    if len s == 0:
        return s
    var out: str = ""
    var i: int32 = 0
    let n: int32 = len s
    let m: int32 = len oldSub
    let __for_guard_start_i_2 = i
    for __for_guard_i_2 in __for_guard_start_i_2..<n:
        if ! (i < n):
            break
        var matched: bool = false
        if i + m <= n:
            matched = true
            for j in 0..<m:
                if s[i + j] != oldSub[j]:
                    matched = false
                    break
        if matched:
            out = out + newSub
            i = i + m
        else:
            out = out + charToStr(s[i])
            i = i + 1
    return out

fn countLines(s: str): int =
    if len s == 0:
        return 0
    var count = 1
    for i in 0..<len s:
        if s[i] == '\n':
            count = count + 1
    return count

fn parseInt(s: str): int =
    if len s == 0:
        return 0
    var i = 0
    var sign = 1
    if s[0] == '+':
        i = 1
    elif s[0] == '-':
        sign = -1
        i = 1
    var val = 0
    var hadDigit = false
    let __for_start_i_8 = i
    for __for_i_8 in __for_start_i_8..<len s:
        i = __for_i_8
        let ch = s[i]
        if ch < '0' || ch > '9':
            break
        hadDigit = true
        val = val * 10 +(int32(ch) - int32('0'))
        i = i + 1
    if ! hadDigit:
        return 0
    return sign * val

fn formatFloatImpl(value: float64, mode: FloatFormatMode, precision: int): str =
    mode
    precision
    return intToStr int(value)

fn formatFloat(value: float64): str =
    return formatFloatImpl(value, ffDefault, 2)
fn formatFloat(value: float64, mode: FloatFormatMode): str =
    return formatFloatImpl(value, mode, 2)
fn formatFloat(value: float64, mode: FloatFormatMode, precision: int): str =
    return formatFloatImpl(value, mode, precision)
