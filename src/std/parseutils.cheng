# std/parseutils (minimal, pure Cheng)
import std/strings
type
    BiggestFloat = float64
fn parseBiggestFloat(s: str, out: var BiggestFloat): int =
    if len s == 0:
        out = 0.0
        return 0
        var i = 0
        var sign = 1.0
        let c0 = s[0]
        if c0 == '+':
            i = 1 el
            if c0 == '-':
                sign = - 1.0
                i = 1
                if i >= len s:
                    out = 0.0
                    return 0
                    var intPart = 0.0
                    var hadDigit = false
                    let __for_guard_start_i_1 = i
                    for __for_guard_i_1 in __for_guard_start_i_1..<len s:
                        if ! (i < len s):
                            break
                        let ch = s[i]
                        if ch >= '0' && ch <= '9':
                            hadDigit = true
                            intPart = intPart * 10.0 + float64(int32(ch) - int32('0'))
                            i = i + 1
                        else:
                            break
                            var fracPart = 0.0
                            var fracFactor = 0.1
                            if i < len s && s[i] == '.':
                                i = i + 1
                                let __for_guard_start_i_2 = i
                                for __for_guard_i_2 in __for_guard_start_i_2..<len s:
                                    if ! (i < len s):
                                        break
                                    let ch = s[i]
                                    if ch >= '0' && ch <= '9':
                                        hadDigit = true
                                        fracPart = fracPart + float64(int32(ch) - int32('0')) * fracFactor
                                        fracFactor = fracFactor * 0.1
                                        i = i + 1
                                    else:
                                        break
                                        if ! hadDigit:
                                            out = 0.0
                                            return 0 # exponent: minimal `e[+-]?\d+`
                                            if i < len s &&(s[i] == 'e' || s[i] == 'E'):
                                                i = i + 1
                                                var expSign = 1
                                                if i < len s && s[i] == '+':
                                                    i = i + 1 el
                                                    if i < len s && s[i] == '-':
                                                        expSign = - 1
                                                        i = i + 1
                                                        var expVal = 0
                                                        var expDigits = 0
                                                        let __for_guard_start_i_3 = i
                                                        for __for_guard_i_3 in __for_guard_start_i_3..<len s:
                                                            if ! (i < len s):
                                                                break
                                                            let ch = s[i]
                                                            if ch >= '0' && ch <= '9':
                                                                expDigits = expDigits + 1
                                                                expVal = expVal * 10 +(int32(ch) - int32('0'))
                                                                i = i + 1
                                                            else:
                                                                break
                                                                if expDigits == 0:
                                                                    out = 0.0
                                                                    return 0
                                                                    var pow10 = 1.0
                                                                    var j = 0
                                                                    let __for_start_j_1 = j
                                                                    for __for_j_1 in __for_start_j_1..<expVal:
                                                                        j = __for_j_1
                                                                        pow10 = pow10 * 10.0
                                                                        j = j + 1
                                                                        if expSign < 0:
                                                                            pow10 = 1.0 / pow10 out = sign *(intPart + fracPart) * pow10
                                                                            return
                                                                            i out = sign *(intPart + fracPart) i
