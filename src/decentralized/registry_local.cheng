import std/os
import std/times
import std/strutils as strutil
import cheng/runtime/json_ast as json
import cheng/decentralized/json_parse as jparse
import cheng/decentralized/cid as dcid
import cheng/decentralized/file_bytes as fbytes
import cheng/decentralized/ast_simhash as simhash
import cheng/libp2p/utils/bytes as bytes
import cheng/libp2p/utils/result as result
import std/strings

type
    PackageSnapshot =
        packageId: str
        authorId: str
        channel: str
        epoch: int32
        cidText: str
        format: str
        astSimhash64: str
        originalityScore: float64
        pubKeyText: str
        sigText: str
        createdTs: str

fn isChannelSupported(ch: str): bool =
    if ch == nil:
        return false
    if ch == "edge" || ch == "stable" || ch == "lts":
        return true
    return false

fn snapshotTs(): str =
    return times.now().format("unix")

fn snapshotPayload(s: PackageSnapshot): str =
    var out = s.packageId + "|" + s.authorId + "|" + s.channel + "|" +
        intToStr(s.epoch) + "|" + s.cidText
    if s.format != nil && len(s.format) > 0:
        out = out + "|" + s.format
    if s.astSimhash64 != nil && len(s.astSimhash64) > 0:
        out = out + "|" + s.astSimhash64
    if s.originalityScore > 0:
        out = out + "|" + $ s.originalityScore
    return out

fn normalizeSnapshotFormat(fmt: str): str =
    if fmt == nil || len(fmt) == 0:
        return ""
    return strutil.toLowerAscii(strutil.strip(fmt))

fn isSnapshotFormatSupported(fmt: str): bool =
    if fmt == nil || len(fmt) == 0:
        return true
    if fmt == "tar" || fmt == "source":
        return true
    return false

fn generateKeyPairText(): result.Result[tuple[pub: str, priv: str]] =
    let ts = snapshotTs()
    return result.Ok[tuple[pub: str, priv: str]](("local-pub-" + ts, "local-priv-" + ts))

fn signSnapshot(s: PackageSnapshot, privText: str): result.Result[PackageSnapshot] =
    if privText == nil || len(privText) == 0:
        return result.Err[PackageSnapshot]("registry: missing private key")
    let payloadBytes = bytes.bytesFromString(snapshotPayload(s) + "|" + privText)
    let payloadCidRes: result.Result[dcid.Cid] = dcid.cidFromBytes(payloadBytes)
    if result.IsErr(payloadCidRes):
        return result.Err[PackageSnapshot](result.Error(payloadCidRes))
    var out: PackageSnapshot = s
    out.pubKeyText = "local:" + s.authorId
    out.sigText = "local:" + dcid.cidText(result.Value(payloadCidRes))
    return result.Ok[PackageSnapshot](out)

fn verifySnapshot(s: PackageSnapshot): bool =
    if s.packageId == nil || len(s.packageId) == 0:
        return false
    if s.channel == nil || len(s.channel) == 0:
        return false
    if s.cidText == nil || len(s.cidText) == 0:
        return false
    if ! isChannelSupported(s.channel):
        return false
    let normFormat = normalizeSnapshotFormat(s.format)
    if ! isSnapshotFormatSupported(normFormat):
        return false
    let simRes: result.Result[str] = simhash.normalizeSimhash64(s.astSimhash64)
    if result.IsErr(simRes):
        return false
    if s.originalityScore <= 0.0 || s.originalityScore > 1.0:
        return false
    if s.pubKeyText == nil || len(s.pubKeyText) == 0:
        return false
    if s.sigText == nil || len(s.sigText) == 0:
        return false
    return true

fn snapshotToJson(s: PackageSnapshot): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("publish")
    node["package_id"] = json.newJString(s.packageId)
    node["author_id"] = json.newJString(s.authorId)
    node["channel"] = json.newJString(s.channel)
    node["epoch"] = json.newJInt(s.epoch)
    node["cid"] = json.newJString(s.cidText)
    if s.format != nil && len(s.format) > 0:
        node["format"] = json.newJString(s.format)
    if s.astSimhash64 != nil && len(s.astSimhash64) > 0:
        node["ast_simhash64"] = json.newJString(s.astSimhash64)
    if s.originalityScore > 0:
        node["originality_score"] = json.newJFloat(s.originalityScore)
    if s.pubKeyText != nil && len(s.pubKeyText) > 0:
        node["pub_key"] = json.newJString(s.pubKeyText)
    if s.sigText != nil && len(s.sigText) > 0:
        node["signature"] = json.newJString(s.sigText)
    if s.createdTs != nil && len(s.createdTs) > 0:
        node["created_ts"] = json.newJString(s.createdTs)
    node

fn parseSnapshot(node: json.JsonNode): PackageSnapshot =
    var s: PackageSnapshot
    s.packageId = jparse.getStringField(node, "package_id", "")
    s.authorId = jparse.getStringField(node, "author_id", "")
    s.channel = jparse.getStringField(node, "channel", "")
    s.epoch = int32(jparse.getIntField(node, "epoch", 0))
    s.cidText = jparse.getStringField(node, "cid", "")
    s.format = normalizeSnapshotFormat(jparse.getStringField(node, "format", ""))
    s.astSimhash64 = jparse.getStringField(node, "ast_simhash64", "")
    s.originalityScore = jparse.getFloatField(node, "originality_score", 0.0)
    s.pubKeyText = jparse.getStringField(node, "pub_key", "")
    s.sigText = jparse.getStringField(node, "signature", "")
    s.createdTs = jparse.getStringField(node, "created_ts", "")
    s

fn ensureParent(path: str) =
    let dir = os.parentDir(path)
    if dir == nil || len(dir) == 0:
        return
    if os.dirExists(dir):
        return
    os.createDir(dir)

@importc("cheng_fopen")
fn c_fopen_registry(filename, mode: cstring): os.File

fn openAppend(path: str): os.File =
    return c_fopen_registry(path, "a")

fn appendLine(path: str, line: str): bool =
    let f = openAppend(path)
    if f == nil:
        return false
    os.writeLine(f, line)
    os.close(f)
    return true

fn findSimhashCollision(registryPath: str, candidateRaw: str): result.Result[bool] =
    let candRes: result.Result[str] = simhash.normalizeSimhash64(candidateRaw)
    if result.IsErr(candRes):
        return result.Err[bool]("registry: invalid ast_simhash64")
    let candidate: str = result.Value(candRes)
    if ! os.fileExists(registryPath):
        return result.Ok[bool](false)
    let content = os.readFile(registryPath)
    if content == nil || len(content) == 0:
        return result.Ok[bool](false)
    let lines = strutil.split(content, '\n')
    for i in 0..<lines.len:
        let line = strutil.strip(lines[i])
        if line == nil || len(line) == 0:
            continue
        let parsed: jparse.ParseResult = jparse.parseJsonSafe(line)
        if ! parsed.ok:
            continue
        let node: json.JsonNode = parsed.value
        let kind = jparse.getStringField(node, "type", "")
        if kind != "publish":
            continue
        let existingHash = jparse.getStringField(node, "ast_simhash64", "")
        if existingHash == nil || len(existingHash) == 0:
            continue
        let dist = simhash.hammingDistanceHex64(candidate, existingHash)
        if dist <= 6:
            return result.Err[bool](
                "registry: originality guard blocked (simhash distance <= 6, approx similarity >= 90%)"
            )
    return result.Ok[bool](false)

fn fingerprintSourceDirAstSimhash64(root: str): result.Result[str] =
    return simhash.computeAstSimhash64ForDir(root)

fn publishSnapshot(registryPath: str, s: PackageSnapshot, privText: str): result.Result[PackageSnapshot] =
    if ! isChannelSupported(s.channel):
        return result.Err[PackageSnapshot]("registry: invalid channel")
    let normFormat = normalizeSnapshotFormat(s.format)
    if ! isSnapshotFormatSupported(normFormat):
        return result.Err[PackageSnapshot]("registry: invalid format")
    if s.packageId == nil || len(s.packageId) == 0:
        return result.Err[PackageSnapshot]("registry: missing package_id")
    if s.authorId == nil || len(s.authorId) == 0:
        return result.Err[PackageSnapshot]("registry: missing author_id")
    if s.cidText == nil || len(s.cidText) == 0:
        return result.Err[PackageSnapshot]("registry: missing cid")
    let cidRes: result.Result[dcid.Cid] = dcid.parseCidText(s.cidText)
    if result.IsErr(cidRes):
        return result.Err[PackageSnapshot](result.Error(cidRes))
    var out: PackageSnapshot = s
    out.format = normFormat
    let hashRes: result.Result[str] = simhash.normalizeSimhash64(out.astSimhash64)
    if result.IsErr(hashRes):
        return result.Err[PackageSnapshot]("registry: missing or invalid ast_simhash64")
    out.astSimhash64 = result.Value(hashRes)
    if out.originalityScore <= 0.0:
        out.originalityScore = 1.0
    if out.originalityScore > 1.0:
        out.originalityScore = 1.0
    let guardRes: result.Result[bool] = findSimhashCollision(registryPath, out.astSimhash64)
    if result.IsErr(guardRes):
        return result.Err[PackageSnapshot](result.Error(guardRes))
    if out.createdTs == nil || len(out.createdTs) == 0:
        out.createdTs = snapshotTs()
    let signedRes: result.Result[PackageSnapshot] = signSnapshot(out, privText)
    if result.IsErr(signedRes):
        return result.Err[PackageSnapshot](result.Error(signedRes))
    out = result.Value(signedRes)
    let node = snapshotToJson(out)
    let line = json.pretty(node)
    ensureParent(registryPath)
    if ! appendLine(registryPath, line):
        return result.Err[PackageSnapshot]("registry: write failed")
    return result.Ok[PackageSnapshot](out)

fn resolveSnapshot(registryPath: str, packageId: str, channel: str): result.Result[PackageSnapshot] =
    if registryPath == nil || len(registryPath) == 0:
        return result.Err[PackageSnapshot]("registry: missing path")
    if ! os.fileExists(registryPath):
        return result.Err[PackageSnapshot]("registry: missing file")
    let content = os.readFile(registryPath)
    if content == nil || len(content) == 0:
        return result.Err[PackageSnapshot]("registry: empty")
    let lines = strutil.split(content, '\n')
    var best: PackageSnapshot
    var hasBest: bool = false
    for i in 0..<lines.len:
        let line = strutil.strip(lines[i])
        if line == nil || len(line) == 0:
            continue
        let parsed: jparse.ParseResult = jparse.parseJsonSafe(line)
        if ! parsed.ok:
            continue
        let node: json.JsonNode = parsed.value
        let kind = jparse.getStringField(node, "type", "")
        if kind != "publish":
            continue
        let snap = parseSnapshot(node)
        if snap.packageId != packageId || snap.channel != channel:
            continue
        if ! verifySnapshot(snap):
            continue
        if ! hasBest || snap.epoch >= best.epoch:
            best = snap
            hasBest = true
    if ! hasBest:
        return result.Err[PackageSnapshot]("registry: not found")
    return result.Ok[PackageSnapshot](best)

fn buildSnapshotFromFile(packageId: str, authorId: str, channel: str, epoch: int32, path: str): result.Result[PackageSnapshot] =
    let dataRes: result.Result[bytes.Bytes] = fbytes.readFileBytes(path)
    if result.IsErr(dataRes):
        return result.Err[PackageSnapshot](result.Error(dataRes))
    let cidRes: result.Result[dcid.Cid] = dcid.cidFromBytes(result.Value(dataRes))
    if result.IsErr(cidRes):
        return result.Err[PackageSnapshot](result.Error(cidRes))
    var s: PackageSnapshot
    s.packageId = packageId
    s.authorId = authorId
    s.channel = channel
    s.epoch = epoch
    s.cidText = dcid.cidText(result.Value(cidRes))
    s.format = "tar"
    if s.cidText == nil || len(s.cidText) == 0:
        return result.Err[PackageSnapshot]("registry: cid encode failed")
    return result.Ok[PackageSnapshot](s)
