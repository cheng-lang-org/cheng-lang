import std/os
import runtime/json_ast as json
import std/strings
import decentralized/lease as dlease
import decentralized/metering as dmeter
import decentralized/audit as daudit
import decentralized/audit_sampling as dsample
import decentralized/exec_request as dexec
import decentralized/exec_receipt as dreceipt
import decentralized/fraud_report as dfraud
import decentralized/storage_proof as dproof

@importc("cheng_fopen")
fn c_fopen_ledger(filename, mode: cstring): os.File

fn openAppend(path: str): os.File =
    return c_fopen_ledger(path, "a")

fn appendLine(path: str, line: str): bool =
    let f = openAppend(path)
    if f == nil:
        return false
    os.writeLine(f, line)
    os.close(f)
    return true

fn ensureParent(path: str) =
    let dir = os.parentDir(path)
    if dir == nil || len(dir) == 0:
        return
    if os.dirExists(dir):
        return
    os.createDir(dir)

fn leaseToJson(lease: dlease.Lease, cost: dlease.LeaseCost, mode: str): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("lease")
    if mode != nil && len(mode) > 0:
        node["mode"] = json.newJString(mode)
    node["lease_id"] = json.newJString(lease.leaseId)
    node["package_id"] = json.newJString(lease.packageId)
    node["author_id"] = json.newJString(lease.authorId)
    node["provider_id"] = json.newJString(lease.providerId)
    node["bytes"] = json.newJInt(lease.bytes)
    node["duration_days"] = json.newJInt(lease.durationDays)
    node["replicas"] = json.newJInt(lease.replicas)
    node["price_per_gb_month"] = json.newJFloat(lease.pricePerGbMonth)
    node["royalty_rate"] = json.newJFloat(lease.royaltyRate)
    node["treasury_rate"] = json.newJFloat(lease.treasuryRate)
    node["start_ts"] = json.newJString(lease.startTs)
    node["storage_cost"] = json.newJFloat(cost.storageCost)
    node["royalty"] = json.newJFloat(cost.royalty)
    node["treasury"] = json.newJFloat(cost.treasury)
    node["provider"] = json.newJFloat(cost.provider)
    node

fn computeToJson(usage: dmeter.ComputeUsage, cost: dmeter.ComputeCost, mode: str): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("compute")
    if mode != nil && len(mode) > 0:
        node["mode"] = json.newJString(mode)
    node["usage_id"] = json.newJString(usage.usageId)
    node["task_id"] = json.newJString(usage.taskId)
    node["package_id"] = json.newJString(usage.packageId)
    node["author_id"] = json.newJString(usage.authorId)
    node["executor_id"] = json.newJString(usage.executorId)
    node["cpu_ms"] = json.newJInt(usage.cpuMs)
    node["mem_bytes"] = json.newJInt(usage.memBytes)
    node["io_bytes"] = json.newJInt(usage.ioBytes)
    node["gpu_ms"] = json.newJInt(usage.gpuMs)
    node["gpu_mem_bytes"] = json.newJInt(usage.gpuMemBytes)
    node["gpu_count"] = json.newJInt(int64(usage.gpuCount))
    if usage.gpuType != nil && len(usage.gpuType) > 0:
        node["gpu_type"] = json.newJString(usage.gpuType)
    if usage.workloadKind != nil && len(usage.workloadKind) > 0:
        node["workload_kind"] = json.newJString(usage.workloadKind)
    node["price_cpu_ms"] = json.newJFloat(usage.priceCpuMs)
    node["price_mem_gb"] = json.newJFloat(usage.priceMemGb)
    node["price_io_gb"] = json.newJFloat(usage.priceIoGb)
    node["price_gpu_ms"] = json.newJFloat(usage.priceGpuMs)
    node["price_gpu_mem_gb"] = json.newJFloat(usage.priceGpuMemGb)
    node["royalty_rate"] = json.newJFloat(usage.royaltyRate)
    node["treasury_rate"] = json.newJFloat(usage.treasuryRate)
    node["epoch"] = json.newJInt(usage.epoch)
    node["start_ts"] = json.newJString(usage.startTs)
    node["total"] = json.newJFloat(cost.total)
    node["royalty"] = json.newJFloat(cost.royalty)
    node["treasury"] = json.newJFloat(cost.treasury)
    node["executor"] = json.newJFloat(cost.executor)
    node

fn auditToJson(ev: daudit.AuditEvent): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("audit")
    node["audit_id"] = json.newJString(ev.auditId)
    node["task_id"] = json.newJString(ev.taskId)
    node["executor_id"] = json.newJString(ev.executorId)
    node["auditor_id"] = json.newJString(ev.auditorId)
    node["result_cid"] = json.newJString(ev.resultCid)
    node["status"] = json.newJString(ev.status)
    node["penalty"] = json.newJFloat(ev.penalty)
    node["epoch"] = json.newJInt(ev.epoch)
    node["note"] = json.newJString(ev.note)
    node["ts"] = json.newJString(ev.ts)
    node

fn auditSampleToJson(ev: dsample.AuditSample): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("audit_sample")
    node["sample_id"] = json.newJString(ev.sampleId)
    node["receipt_id"] = json.newJString(ev.receiptId)
    node["request_id"] = json.newJString(ev.requestId)
    node["task_id"] = json.newJString(ev.taskId)
    node["executor_id"] = json.newJString(ev.executorId)
    node["result_cid"] = json.newJString(ev.resultCid)
    node["status"] = json.newJString(ev.status)
    node["auditor_id"] = json.newJString(ev.auditorId)
    node["epoch"] = json.newJInt(ev.epoch)
    node["rate_bps"] = json.newJInt(ev.rateBps)
    node["base_rate_bps"] = json.newJInt(ev.baseRateBps)
    node["high_risk_rate_bps"] = json.newJInt(ev.highRiskRateBps)
    node["risk_level"] = json.newJString(ev.riskLevel)
    node["risk_reason"] = json.newJString(ev.riskReason)
    node["seed"] = json.newJString(ev.seed)
    node["ts"] = json.newJString(ev.ts)
    node

fn fraudReportToJson(ev: dfraud.FraudReport): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("fraud_report")
    node["report_id"] = json.newJString(ev.reportId)
    node["task_id"] = json.newJString(ev.taskId)
    node["request_id"] = json.newJString(ev.requestId)
    node["receipt_id"] = json.newJString(ev.receiptId)
    node["executor_id"] = json.newJString(ev.executorId)
    node["reporter_id"] = json.newJString(ev.reporterId)
    node["reason"] = json.newJString(ev.reason)
    node["evidence_cid"] = json.newJString(ev.evidenceCid)
    node["severity"] = json.newJString(ev.severity)
    node["epoch"] = json.newJInt(ev.epoch)
    node["ts"] = json.newJString(ev.ts)
    node

fn storageProofToJson(ev: dproof.StorageProof): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("storage_proof")
    node["proof_id"] = json.newJString(ev.proofId)
    node["provider_id"] = json.newJString(ev.providerId)
    if ev.packageId != nil && len(ev.packageId) > 0:
        node["package_id"] = json.newJString(ev.packageId)
    node["cid"] = json.newJString(ev.cidText)
    node["bytes"] = json.newJInt(ev.bytes)
    node["status"] = json.newJString(ev.status)
    if ev.proofHash != nil && len(ev.proofHash) > 0:
        node["proof_hash"] = json.newJString(ev.proofHash)
    node["epoch"] = json.newJInt(ev.epoch)
    if ev.note != nil && len(ev.note) > 0:
        node["note"] = json.newJString(ev.note)
    node["ts"] = json.newJString(ev.ts)
    node

fn execRequestToJson(req: dexec.ExecRequest, mode: str): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("exec_request")
    if mode != nil && len(mode) > 0:
        node["mode"] = json.newJString(mode)
    node["request_id"] = json.newJString(req.requestId)
    node["task_id"] = json.newJString(req.taskId)
    node["package_id"] = json.newJString(req.packageId)
    node["author_id"] = json.newJString(req.authorId)
    node["requester_id"] = json.newJString(req.requesterId)
    if req.executorId != nil && len(req.executorId) > 0:
        node["executor_id"] = json.newJString(req.executorId)
    node["input_cid"] = json.newJString(req.inputCid)
    node["code_cid"] = json.newJString(req.codeCid)
    node["args_cid"] = json.newJString(req.argsCid)
    node["max_cpu_ms"] = json.newJInt(req.maxCpuMs)
    node["max_mem_bytes"] = json.newJInt(req.maxMemBytes)
    node["max_io_bytes"] = json.newJInt(req.maxIoBytes)
    node["max_gpu_ms"] = json.newJInt(req.maxGpuMs)
    node["max_gpu_mem_bytes"] = json.newJInt(req.maxGpuMemBytes)
    node["max_gpu_count"] = json.newJInt(int64(req.maxGpuCount))
    if req.gpuType != nil && len(req.gpuType) > 0:
        node["gpu_type"] = json.newJString(req.gpuType)
    if req.workloadKind != nil && len(req.workloadKind) > 0:
        node["workload_kind"] = json.newJString(req.workloadKind)
    node["price_cpu_ms"] = json.newJFloat(req.priceCpuMs)
    node["price_mem_gb"] = json.newJFloat(req.priceMemGb)
    node["price_io_gb"] = json.newJFloat(req.priceIoGb)
    node["price_gpu_ms"] = json.newJFloat(req.priceGpuMs)
    node["price_gpu_mem_gb"] = json.newJFloat(req.priceGpuMemGb)
    node["expected_cost_nano"] = json.newJInt(req.expectedCostNano)
    node["selected_fraud_score"] = json.newJFloat(req.selectedFraudScore)
    node["selected_bandwidth_out_bytes"] = json.newJInt(req.selectedBandwidthOutBytes)
    if req.selectionSource != nil && len(req.selectionSource) > 0:
        node["selection_source"] = json.newJString(req.selectionSource)
    node["epoch"] = json.newJInt(req.epoch)
    node["ts"] = json.newJString(req.ts)
    node["signature"] = json.newJString(req.signature)
    node

fn execReceiptToJson(rec: dreceipt.ExecReceipt, mode: str): json.JsonNode =
    let node = json.newJObject()
    node["type"] = json.newJString("exec_receipt")
    if mode != nil && len(mode) > 0:
        node["mode"] = json.newJString(mode)
    node["receipt_id"] = json.newJString(rec.receiptId)
    node["request_id"] = json.newJString(rec.requestId)
    node["task_id"] = json.newJString(rec.taskId)
    node["executor_id"] = json.newJString(rec.executorId)
    node["result_cid"] = json.newJString(rec.resultCid)
    node["usage_id"] = json.newJString(rec.usageId)
    node["status"] = json.newJString(rec.status)
    node["error"] = json.newJString(rec.error)
    node["proof_cid"] = json.newJString(rec.proofCid)
    node["epoch"] = json.newJInt(rec.epoch)
    node["ts"] = json.newJString(rec.ts)
    node["signature"] = json.newJString(rec.signature)
    node

fn escapeJsonString(value: str): str =
    if value == nil:
        return ""
    var out: str = ""
    for i in 0..<len(value):
        let ch = value[i]
        if ch == '\\':
            out = out + "\\\\"
        elif ch == '"':
            out = out + "\\\""
        elif ch == '\n':
            out = out + "\\n"
        elif ch == '\r':
            out = out + "\\r"
        elif ch == '\t':
            out = out + "\\t"
        else:
            out = out + charToStr(ch)
    return out

fn quoteJsonString(value: str): str =
    return "\"" + escapeJsonString(value) + "\""

fn jsonPushSep(out: str): str =
    if out != nil && out[1] != '\0':
        return out + ","
    return out

fn jsonAddStrField(out: str, key: str, value: str): str =
    var next = jsonPushSep(out)
    next = next + "\""
    next = next + key
    next = next + "\":"
    next = next + quoteJsonString(value)
    return next

fn jsonAddIntField(out: str, key: str, value: int64): str =
    var next = jsonPushSep(out)
    next = next + "\""
    next = next + key
    next = next + "\":"
    next = next + $ value
    return next

fn jsonAddInt32Field(out: str, key: str, value: int32): str =
    return jsonAddIntField(out, key, int64(value))

fn jsonAddFloatField(out: str, key: str, value: float64): str =
    var next = jsonPushSep(out)
    next = next + "\""
    next = next + key
    next = next + "\":"
    next = next + $ value
    return next

fn leaseToJsonLine(lease: dlease.Lease, cost: dlease.LeaseCost, mode: str): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "lease")
    if mode != nil && len(mode) > 0:
        out = jsonAddStrField(out, "mode", mode)
    out = jsonAddStrField(out, "lease_id", lease.leaseId)
    out = jsonAddStrField(out, "package_id", lease.packageId)
    out = jsonAddStrField(out, "author_id", lease.authorId)
    out = jsonAddStrField(out, "provider_id", lease.providerId)
    out = jsonAddIntField(out, "bytes", lease.bytes)
    out = jsonAddInt32Field(out, "duration_days", lease.durationDays)
    out = jsonAddInt32Field(out, "replicas", lease.replicas)
    out = jsonAddFloatField(out, "price_per_gb_month", lease.pricePerGbMonth)
    out = jsonAddFloatField(out, "royalty_rate", lease.royaltyRate)
    out = jsonAddFloatField(out, "treasury_rate", lease.treasuryRate)
    out = jsonAddStrField(out, "start_ts", lease.startTs)
    out = jsonAddFloatField(out, "storage_cost", cost.storageCost)
    out = jsonAddFloatField(out, "royalty", cost.royalty)
    out = jsonAddFloatField(out, "treasury", cost.treasury)
    out = jsonAddFloatField(out, "provider", cost.provider)
    out = out + "}"
    return out

fn computeToJsonLine(usage: dmeter.ComputeUsage, cost: dmeter.ComputeCost, mode: str): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "compute")
    if mode != nil && len(mode) > 0:
        out = jsonAddStrField(out, "mode", mode)
    out = jsonAddStrField(out, "usage_id", usage.usageId)
    out = jsonAddStrField(out, "task_id", usage.taskId)
    out = jsonAddStrField(out, "package_id", usage.packageId)
    out = jsonAddStrField(out, "author_id", usage.authorId)
    out = jsonAddStrField(out, "executor_id", usage.executorId)
    out = jsonAddIntField(out, "cpu_ms", usage.cpuMs)
    out = jsonAddIntField(out, "mem_bytes", usage.memBytes)
    out = jsonAddIntField(out, "io_bytes", usage.ioBytes)
    out = jsonAddIntField(out, "gpu_ms", usage.gpuMs)
    out = jsonAddIntField(out, "gpu_mem_bytes", usage.gpuMemBytes)
    out = jsonAddInt32Field(out, "gpu_count", usage.gpuCount)
    if usage.gpuType != nil && len(usage.gpuType) > 0:
        out = jsonAddStrField(out, "gpu_type", usage.gpuType)
    if usage.workloadKind != nil && len(usage.workloadKind) > 0:
        out = jsonAddStrField(out, "workload_kind", usage.workloadKind)
    out = jsonAddFloatField(out, "price_cpu_ms", usage.priceCpuMs)
    out = jsonAddFloatField(out, "price_mem_gb", usage.priceMemGb)
    out = jsonAddFloatField(out, "price_io_gb", usage.priceIoGb)
    out = jsonAddFloatField(out, "price_gpu_ms", usage.priceGpuMs)
    out = jsonAddFloatField(out, "price_gpu_mem_gb", usage.priceGpuMemGb)
    out = jsonAddFloatField(out, "royalty_rate", usage.royaltyRate)
    out = jsonAddFloatField(out, "treasury_rate", usage.treasuryRate)
    out = jsonAddInt32Field(out, "epoch", usage.epoch)
    out = jsonAddStrField(out, "start_ts", usage.startTs)
    out = jsonAddFloatField(out, "total", cost.total)
    out = jsonAddFloatField(out, "royalty", cost.royalty)
    out = jsonAddFloatField(out, "treasury", cost.treasury)
    out = jsonAddFloatField(out, "executor", cost.executor)
    out = out + "}"
    return out

fn auditToJsonLine(ev: daudit.AuditEvent): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "audit")
    out = jsonAddStrField(out, "audit_id", ev.auditId)
    out = jsonAddStrField(out, "task_id", ev.taskId)
    out = jsonAddStrField(out, "executor_id", ev.executorId)
    out = jsonAddStrField(out, "auditor_id", ev.auditorId)
    out = jsonAddStrField(out, "result_cid", ev.resultCid)
    out = jsonAddStrField(out, "status", ev.status)
    out = jsonAddFloatField(out, "penalty", ev.penalty)
    out = jsonAddInt32Field(out, "epoch", ev.epoch)
    out = jsonAddStrField(out, "note", ev.note)
    out = jsonAddStrField(out, "ts", ev.ts)
    out = out + "}"
    return out

fn auditSampleToJsonLine(ev: dsample.AuditSample): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "audit_sample")
    out = jsonAddStrField(out, "sample_id", ev.sampleId)
    out = jsonAddStrField(out, "receipt_id", ev.receiptId)
    out = jsonAddStrField(out, "request_id", ev.requestId)
    out = jsonAddStrField(out, "task_id", ev.taskId)
    out = jsonAddStrField(out, "executor_id", ev.executorId)
    out = jsonAddStrField(out, "result_cid", ev.resultCid)
    out = jsonAddStrField(out, "status", ev.status)
    out = jsonAddStrField(out, "auditor_id", ev.auditorId)
    out = jsonAddInt32Field(out, "epoch", ev.epoch)
    out = jsonAddInt32Field(out, "rate_bps", ev.rateBps)
    out = jsonAddInt32Field(out, "base_rate_bps", ev.baseRateBps)
    out = jsonAddInt32Field(out, "high_risk_rate_bps", ev.highRiskRateBps)
    out = jsonAddStrField(out, "risk_level", ev.riskLevel)
    out = jsonAddStrField(out, "risk_reason", ev.riskReason)
    out = jsonAddStrField(out, "seed", ev.seed)
    out = jsonAddStrField(out, "ts", ev.ts)
    out = out + "}"
    return out

fn fraudReportToJsonLine(ev: dfraud.FraudReport): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "fraud_report")
    out = jsonAddStrField(out, "report_id", ev.reportId)
    out = jsonAddStrField(out, "task_id", ev.taskId)
    out = jsonAddStrField(out, "request_id", ev.requestId)
    out = jsonAddStrField(out, "receipt_id", ev.receiptId)
    out = jsonAddStrField(out, "executor_id", ev.executorId)
    out = jsonAddStrField(out, "reporter_id", ev.reporterId)
    out = jsonAddStrField(out, "reason", ev.reason)
    out = jsonAddStrField(out, "evidence_cid", ev.evidenceCid)
    out = jsonAddStrField(out, "severity", ev.severity)
    out = jsonAddInt32Field(out, "epoch", ev.epoch)
    out = jsonAddStrField(out, "ts", ev.ts)
    out = out + "}"
    return out

fn storageProofToJsonLine(ev: dproof.StorageProof): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "storage_proof")
    out = jsonAddStrField(out, "proof_id", ev.proofId)
    out = jsonAddStrField(out, "provider_id", ev.providerId)
    if ev.packageId != nil && len(ev.packageId) > 0:
        out = jsonAddStrField(out, "package_id", ev.packageId)
    out = jsonAddStrField(out, "cid", ev.cidText)
    out = jsonAddIntField(out, "bytes", ev.bytes)
    out = jsonAddStrField(out, "status", ev.status)
    if ev.proofHash != nil && len(ev.proofHash) > 0:
        out = jsonAddStrField(out, "proof_hash", ev.proofHash)
    out = jsonAddInt32Field(out, "epoch", ev.epoch)
    if ev.note != nil && len(ev.note) > 0:
        out = jsonAddStrField(out, "note", ev.note)
    out = jsonAddStrField(out, "ts", ev.ts)
    out = out + "}"
    return out

fn execRequestToJsonLine(req: dexec.ExecRequest, mode: str): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "exec_request")
    if mode != nil && len(mode) > 0:
        out = jsonAddStrField(out, "mode", mode)
    out = jsonAddStrField(out, "request_id", req.requestId)
    out = jsonAddStrField(out, "task_id", req.taskId)
    out = jsonAddStrField(out, "package_id", req.packageId)
    out = jsonAddStrField(out, "author_id", req.authorId)
    out = jsonAddStrField(out, "requester_id", req.requesterId)
    if req.executorId != nil && len(req.executorId) > 0:
        out = jsonAddStrField(out, "executor_id", req.executorId)
    out = jsonAddStrField(out, "input_cid", req.inputCid)
    out = jsonAddStrField(out, "code_cid", req.codeCid)
    out = jsonAddStrField(out, "args_cid", req.argsCid)
    out = jsonAddIntField(out, "max_cpu_ms", req.maxCpuMs)
    out = jsonAddIntField(out, "max_mem_bytes", req.maxMemBytes)
    out = jsonAddIntField(out, "max_io_bytes", req.maxIoBytes)
    out = jsonAddIntField(out, "max_gpu_ms", req.maxGpuMs)
    out = jsonAddIntField(out, "max_gpu_mem_bytes", req.maxGpuMemBytes)
    out = jsonAddInt32Field(out, "max_gpu_count", req.maxGpuCount)
    if req.gpuType != nil && len(req.gpuType) > 0:
        out = jsonAddStrField(out, "gpu_type", req.gpuType)
    if req.workloadKind != nil && len(req.workloadKind) > 0:
        out = jsonAddStrField(out, "workload_kind", req.workloadKind)
    out = jsonAddFloatField(out, "price_cpu_ms", req.priceCpuMs)
    out = jsonAddFloatField(out, "price_mem_gb", req.priceMemGb)
    out = jsonAddFloatField(out, "price_io_gb", req.priceIoGb)
    out = jsonAddFloatField(out, "price_gpu_ms", req.priceGpuMs)
    out = jsonAddFloatField(out, "price_gpu_mem_gb", req.priceGpuMemGb)
    out = jsonAddIntField(out, "expected_cost_nano", req.expectedCostNano)
    out = jsonAddFloatField(out, "selected_fraud_score", req.selectedFraudScore)
    out = jsonAddIntField(out, "selected_bandwidth_out_bytes", req.selectedBandwidthOutBytes)
    if req.selectionSource != nil && len(req.selectionSource) > 0:
        out = jsonAddStrField(out, "selection_source", req.selectionSource)
    out = jsonAddInt32Field(out, "epoch", req.epoch)
    out = jsonAddStrField(out, "ts", req.ts)
    out = jsonAddStrField(out, "signature", req.signature)
    out = out + "}"
    return out

fn execReceiptToJsonLine(rec: dreceipt.ExecReceipt, mode: str): str =
    var out: str = "{"
    out = jsonAddStrField(out, "type", "exec_receipt")
    if mode != nil && len(mode) > 0:
        out = jsonAddStrField(out, "mode", mode)
    out = jsonAddStrField(out, "receipt_id", rec.receiptId)
    out = jsonAddStrField(out, "request_id", rec.requestId)
    out = jsonAddStrField(out, "task_id", rec.taskId)
    out = jsonAddStrField(out, "executor_id", rec.executorId)
    out = jsonAddStrField(out, "result_cid", rec.resultCid)
    out = jsonAddStrField(out, "usage_id", rec.usageId)
    out = jsonAddStrField(out, "status", rec.status)
    out = jsonAddStrField(out, "error", rec.error)
    out = jsonAddStrField(out, "proof_cid", rec.proofCid)
    out = jsonAddInt32Field(out, "epoch", rec.epoch)
    out = jsonAddStrField(out, "ts", rec.ts)
    out = jsonAddStrField(out, "signature", rec.signature)
    out = out + "}"
    return out

fn appendLeaseEventWithMode(ledgerPath: str, lease: dlease.Lease, cost: dlease.LeaseCost, mode: str): bool =
    ensureParent(ledgerPath)
    let line = leaseToJsonLine(lease, cost, mode)
    return appendLine(ledgerPath, line)

fn appendLeaseEvent(ledgerPath: str, lease: dlease.Lease, cost: dlease.LeaseCost): bool =
    return appendLeaseEventWithMode(ledgerPath, lease, cost, "")

fn appendComputeEventWithMode(
    ledgerPath: str,
    usage: dmeter.ComputeUsage,
    cost: dmeter.ComputeCost,
    mode: str
): bool =
    ensureParent(ledgerPath)
    let line = computeToJsonLine(usage, cost, mode)
    return appendLine(ledgerPath, line)

fn appendComputeEvent(ledgerPath: str, usage: dmeter.ComputeUsage, cost: dmeter.ComputeCost): bool =
    return appendComputeEventWithMode(ledgerPath, usage, cost, "")

fn appendAuditEvent(ledgerPath: str, ev: daudit.AuditEvent): bool =
    ensureParent(ledgerPath)
    let line = auditToJsonLine(ev)
    return appendLine(ledgerPath, line)

fn appendAuditSampleEvent(ledgerPath: str, ev: dsample.AuditSample): bool =
    ensureParent(ledgerPath)
    let line = auditSampleToJsonLine(ev)
    return appendLine(ledgerPath, line)

fn appendFraudReportEvent(ledgerPath: str, ev: dfraud.FraudReport): bool =
    ensureParent(ledgerPath)
    let line = fraudReportToJsonLine(ev)
    return appendLine(ledgerPath, line)

fn appendStorageProofEvent(ledgerPath: str, ev: dproof.StorageProof): bool =
    ensureParent(ledgerPath)
    let line = storageProofToJsonLine(ev)
    return appendLine(ledgerPath, line)

fn appendExecRequestEventWithMode(ledgerPath: str, req: dexec.ExecRequest, mode: str): bool =
    ensureParent(ledgerPath)
    let line = execRequestToJsonLine(req, mode)
    return appendLine(ledgerPath, line)

fn appendExecRequestEvent(ledgerPath: str, req: dexec.ExecRequest): bool =
    return appendExecRequestEventWithMode(ledgerPath, req, "")

fn appendExecReceiptEventWithMode(ledgerPath: str, rec: dreceipt.ExecReceipt, mode: str): bool =
    ensureParent(ledgerPath)
    let line = execReceiptToJsonLine(rec, mode)
    return appendLine(ledgerPath, line)

fn appendExecReceiptEvent(ledgerPath: str, rec: dreceipt.ExecReceipt): bool =
    return appendExecReceiptEventWithMode(ledgerPath, rec, "")
