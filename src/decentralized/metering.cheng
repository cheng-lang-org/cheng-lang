import std/times
import std/strings
import std/strutils as strutil

const
    BytesPerGb = 1024.0 * 1024.0 * 1024.0
    WorkloadTrainAlpha = 1.35
    WorkloadInferAlpha = 0.85
    WorkloadOtherAlpha = 1.0

type
    ComputeUsage =
        usageId: str
        taskId: str
        packageId: str
        authorId: str
        executorId: str
        cpuMs: int64
        memBytes: int64
        ioBytes: int64
        gpuMs: int64
        gpuMemBytes: int64
        gpuCount: int32
        gpuType: str
        workloadKind: str
        priceCpuMs: float64
        priceMemGb: float64
        priceIoGb: float64
        priceGpuMs: float64
        priceGpuMemGb: float64
        royaltyRate: float64
        treasuryRate: float64
        epoch: int32
        startTs: str

    ComputeCost =
        total: float64
        royalty: float64
        treasury: float64
        executor: float64

fn usageStartTs(): str =
    return times.now().format("unix")

fn buildUsageId(usage: ComputeUsage): str =
    let payload = usage.taskId + "|" + usage.packageId + "|" + usage.authorId + "|" +
        usage.executorId + "|" + intToStr(int32(usage.cpuMs)) + "|" +
        intToStr(int32(usage.memBytes)) + "|" + intToStr(int32(usage.ioBytes)) + "|" +
        intToStr(int32(usage.gpuMs)) + "|" + intToStr(int32(usage.gpuMemBytes)) + "|" +
        intToStr(usage.gpuCount) + "|" + usage.gpuType + "|" + usage.workloadKind + "|" +
        intToStr(usage.epoch) + "|" + usage.startTs
    return "usage-" + intToStr(int32(len(payload)))

fn computeUsageCost(usage: ComputeUsage): ComputeCost =
    var cost: ComputeCost
    let cpuCost: float64 = float64(usage.cpuMs) * usage.priceCpuMs
    let memCost: float64 = (float64(usage.memBytes) / (1024.0 * 1024.0 * 1024.0)) * usage.priceMemGb
    let ioCost: float64 = (float64(usage.ioBytes) / (1024.0 * 1024.0 * 1024.0)) * usage.priceIoGb
    let gpuCoreCost: float64 = float64(usage.gpuMs) * usage.priceGpuMs
    let gpuMemCost: float64 = (float64(usage.gpuMemBytes) / (1024.0 * 1024.0 * 1024.0)) * usage.priceGpuMemGb
    let gpuAlphaCost: float64 = (gpuCoreCost + gpuMemCost) * workloadAlpha(usage.workloadKind)
    cost.total = cpuCost + memCost + ioCost + gpuAlphaCost
    cost.royalty = cost.total * usage.royaltyRate
    cost.treasury = cost.total * usage.treasuryRate
    cost.executor = cost.total - cost.royalty - cost.treasury
    return cost

fn workloadAlpha(workloadKindRaw: str): float64 =
    let workloadKind = strutil.toLowerAscii(strutil.strip(workloadKindRaw))
    if workloadKind == "train":
        return WorkloadTrainAlpha
    if workloadKind == "infer":
        return WorkloadInferAlpha
    return WorkloadOtherAlpha

fn normalizeUsage(usage: ComputeUsage): ComputeUsage =
    var out = usage
    if len(out.workloadKind) == 0:
        out.workloadKind = "other"
    else:
        out.workloadKind = strutil.toLowerAscii(strutil.strip(out.workloadKind))
        if out.workloadKind != "train" && out.workloadKind != "infer" && out.workloadKind != "other":
            out.workloadKind = "other"
    if len(out.startTs) == 0:
        out.startTs = usageStartTs()
    if len(out.usageId) == 0:
        out.usageId = buildUsageId(out)
    return out
